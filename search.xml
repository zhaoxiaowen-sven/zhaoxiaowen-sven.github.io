<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/10/24/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/05/14/Notes/Algorithm/ALG_01_%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="ALG-01-理论"><a href="#ALG-01-理论" class="headerlink" title="ALG_01_理论"></a>ALG_01_理论</h1><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h2 id="LeetCode顺序"><a href="#LeetCode顺序" class="headerlink" title="LeetCode顺序"></a>LeetCode顺序</h2><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ol>
<li><p>移除元素是虚节点的用处</p>
</li>
<li><p>链表操作</p>
</li>
<li><p>反转列表</p>
</li>
<li><p>删除链表倒数的第n个节点:</p>
</li>
</ol>
<p>​         主要走的次数</p>
<ol start="5">
<li>142</li>
</ol>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2>]]></content>
  </entry>
  <entry>
    <title>NET_01_HTTP</title>
    <url>/2021/07/04/Notes/Android/NET_01_HTTP/</url>
    <content><![CDATA[<h1 id="NET-01-HTTP"><a href="#NET-01-HTTP" class="headerlink" title="NET_01_HTTP"></a>NET_01_HTTP</h1><h2 id="一、HTTP协议"><a href="#一、HTTP协议" class="headerlink" title="一、HTTP协议"></a>一、HTTP协议</h2><h3 id="1-1、请求方式"><a href="#1-1、请求方式" class="headerlink" title="1.1、请求方式"></a>1.1、请求方式</h3><h3 id="1-2、请求"><a href="#1-2、请求" class="headerlink" title="1.2、请求"></a>1.2、请求</h3><img src="/pics/image-20210704204122974.png" alt="image-20210704204122974" style="zoom:50%;" />

<h3 id="1-3、响应"><a href="#1-3、响应" class="headerlink" title="1.3、响应"></a>1.3、响应</h3><h4 id="1-3-1、状态码"><a href="#1-3-1、状态码" class="headerlink" title="1.3.1、状态码"></a>1.3.1、状态码</h4><img src="/pics/image-20210704192743868.png" alt="image-20210704192743868" style="zoom:50%;" />

<h4 id="1-3-2、响应头"><a href="#1-3-2、响应头" class="headerlink" title="1.3.2、响应头"></a>1.3.2、响应头</h4><img src="/pics/image-20210704204247914.png" alt="image-20210704204247914" style="zoom:50%;" />



<img src="/pics/image-20210704220713953.png" alt="image-20210704220713953" style="zoom:50%;" />



<h2 id="二、TCP"><a href="#二、TCP" class="headerlink" title="二、TCP"></a>二、TCP</h2><h3 id="2-1、什么是连接？"><a href="#2-1、什么是连接？" class="headerlink" title="2.1、什么是连接？"></a>2.1、什么是连接？</h3><p><strong>RFC 793 传输控制协议</strong></p>
<ul>
<li>防止连接时候混乱的问题，比如过期的连接，过期是由发送方来判断。</li>
<li>弱网下，数据包丢失，顺序混乱，通过序列号，保证</li>
</ul>
<img src="/pics/image-20210704191205796.png" alt="image-20210704191205796" style="zoom:40%;" />



<img src="/pics/image-20210704191406391.png" alt="image-20210704191205796" style="zoom:40%;" />

<h3 id="2-2、TCP报文首部详解"><a href="#2-2、TCP报文首部详解" class="headerlink" title="2.2、TCP报文首部详解"></a>2.2、TCP报文首部详解</h3><img src="/pics/image-20210704224113783.png" alt="image-20210704224113783" style="zoom:50%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Source Port Number：源端口</span><br><span class="line">　　之所以占据16个bit位，是因为2的16次方正好可以标识65535个端口号</span><br><span class="line">Destination Port Number：目标端口</span><br><span class="line">Sequence Number：请求时附带的随机序列号</span><br><span class="line">Acknowledgement Number：应答时附带的序列号</span><br><span class="line">　　在对方请求时附带的序列号的基础上加1</span><br><span class="line">Header Length：报文首部的长度</span><br><span class="line">　　4个bits表示首部最长的长度为2个4次方，也就是可以标识15段，一段为4个字节，则最长长度为60个字节</span><br><span class="line">Reserved：报文的标识位，占据6bit，可表示6个flag　　URG：报文段中发送的数据是否包含紧急数据，值为1时表示有紧急数据（后面的紧急字段只有当URG值为1时才生效）</span><br><span class="line">　　ACK：表示是否前面的确认号字段是否有效，ACK=1，表示有效（TCP规定，连接建立后，ACK必须为1）</span><br><span class="line">　　PSH：告诉对方收到该报文段收是否应该立即把数据推送给上层，如果为1，则表示对方应该立即把数据提交给上层，而不是缓存起来</span><br><span class="line">　　RST：与主机的连接出现了严重错误（如主机奔溃），必须释放连接，然后再重新建立连接（或者说上次发送的数据有问题，主机拒绝响应）</span><br><span class="line">　　SYN：在建立连接时使用，用来同步序号</span><br><span class="line">　　　　当SYN为1，ACK为0时，表示这是一个请求连接的报文段</span><br><span class="line">　　　　当SYN为1，ACK为1时，表示对方同意建立连接</span><br><span class="line">　　　　SYN为1，说明这是一个请求建立连接或同意建立连接的报文，只有在前两次握手中SYN才置1</span><br><span class="line">　　FIN：标记数据是否发送完毕，如果FIN=1，将相当于告诉对方，自己的数据已经发送完毕，对方可以释放连接了</span><br><span class="line">Windows Size：滑动窗口的大小</span><br><span class="line">　　用以告知对方自己接受缓冲区的大小，以协商出一个合适的传输速率</span><br><span class="line">TCP Checksum：TCP的校验和，提供额外的可靠性</span><br><span class="line">Urgent Pointer：标记进制数据在字段中的位置</span><br><span class="line">Options：可选部分（这部分的最大长度为40Bytes）</span><br><span class="line">Data：数据部分</span><br></pre></td></tr></table></figure>

<h3 id="2-3、三次握手"><a href="#2-3、三次握手" class="headerlink" title="2.3、三次握手"></a>2.3、三次握手</h3><img src="/pics/image-20210704192333642.png" alt="image-20210704192333642" style="zoom:50%;" />

 

<img src="/pics/image-20210704190328897.png" alt="image-20210704190328897" style="zoom:30%;" />



<p><code>SEQ</code> ：序列号</p>
<p><code>ack</code> ：确认号，一般等于SEQ + 1</p>
<p><code>SYN</code> ：同步位，SYN = 1 表示进行网络请求</p>
<p><code>ACK</code>： 确认标记位</p>
<p><code>FIN</code>：结束标记位</p>
<h3 id="2-4、四次挥手"><a href="#2-4、四次挥手" class="headerlink" title="2.4、四次挥手"></a>2.4、四次挥手</h3><img src="/pics/image-20210705000512218.png" alt="image-20210705000512218" style="zoom:30%;" />

<h3 id="2-5、流量控制"><a href="#2-5、流量控制" class="headerlink" title="2.5、流量控制"></a>2.5、流量控制</h3><p>滑动窗口（接收窗口）：接受方当前可用的缓存大小。</p>
<h3 id="2-6、拥塞控制"><a href="#2-6、拥塞控制" class="headerlink" title="2.6、拥塞控制"></a>2.6、拥塞控制</h3><p>控制发送方的发送速率。</p>
<h2 id="三、DNS-过程"><a href="#三、DNS-过程" class="headerlink" title="三、DNS 过程"></a>三、DNS 过程</h2><img src="/pics/image-20210704182114232.png" alt="image-20210704190328897" style="zoom:30%;" />

<p>流量控制和</p>
]]></content>
      <tags>
        <tag>Http</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2020/12/07/Notes/SoftGrowth/%E9%9D%9E%E6%9A%B4%E5%8A%9B%E6%B2%9F%E9%80%9A/</url>
    <content><![CDATA[<h1 id="非暴力沟通"><a href="#非暴力沟通" class="headerlink" title="非暴力沟通"></a>非暴力沟通</h1><h2 id="一、非暴力沟通模式"><a href="#一、非暴力沟通模式" class="headerlink" title="一、非暴力沟通模式"></a>一、非暴力沟通模式</h2><h2 id="1、诚实的表达自己，而不批评指责"><a href="#1、诚实的表达自己，而不批评指责" class="headerlink" title="1、诚实的表达自己，而不批评指责"></a>1、诚实的表达自己，而不批评指责</h2><h4 id="（1）观察"><a href="#（1）观察" class="headerlink" title="（1）观察"></a>（1）观察</h4><p> 我所观察（看、听、回忆、想）到的有助于（或无助于）我的福祉的具体行为：</p>
<p>“当我看、听、回忆、想到、听到 …”  </p>
<h4 id="（2）感受"><a href="#（2）感受" class="headerlink" title="（2）感受"></a>（2）感受</h4><p>对于这些行为，我有什么感受（情感而非思想）：</p>
<p>“我感到 …”</p>
<h4 id="（3-需要"><a href="#（3-需要" class="headerlink" title="（3)  需要"></a>（3)  需要</h4><p>什么样的需要或者价值（而非偏好或某种具体的行为）导致我那样的感受：</p>
<p>“因为我需要/看重…”</p>
<h4 id="（4）请求"><a href="#（4）请求" class="headerlink" title="（4）请求"></a>（4）请求</h4><p>清楚的请求（而非命令）那些能丰富我生命的具体行为，</p>
<p>“你是否愿意 …?”</p>
<h3 id="2、关切的倾听他人、而不解读为批评或指责"><a href="#2、关切的倾听他人、而不解读为批评或指责" class="headerlink" title="2、关切的倾听他人、而不解读为批评或指责"></a>2、关切的倾听他人、而不解读为批评或指责</h3><h4 id="（1）观察-1"><a href="#（1）观察-1" class="headerlink" title="（1）观察"></a>（1）观察</h4><p>你所观察（看、听、回忆、想）到的有助于（或无助于）我的福祉的具体行为：</p>
<p>“当你看、听、回忆、想到、听到 …”  </p>
<h4 id="（2）感受-1"><a href="#（2）感受-1" class="headerlink" title="（2）感受"></a>（2）感受</h4><p>对于这些行为，你有什么感受（情感而非思想）：</p>
<p>“你感到 …吗？”</p>
<h4 id="（3）需要"><a href="#（3）需要" class="headerlink" title="（3）需要"></a>（3）需要</h4><p>什么样的需要或者价值（而非偏好或某种具体的行为）导致你那样的感受：</p>
<p>“因为你需要/看重…”</p>
<h4 id="（4）需要"><a href="#（4）需要" class="headerlink" title="（4）需要"></a>（4）需要</h4><p>关注倾听那些能丰富你生命的具体请求，而不解读为命令：</p>
<p>“所以，你想..“</p>
<h2 id="二、培育对自己的爱"><a href="#二、培育对自己的爱" class="headerlink" title="二、培育对自己的爱"></a>二、培育对自己的爱</h2><h3 id="非暴力最重要的应用在于培育对自己的爱"><a href="#非暴力最重要的应用在于培育对自己的爱" class="headerlink" title="非暴力最重要的应用在于培育对自己的爱"></a>非暴力最重要的应用在于培育对自己的爱</h3><ol>
<li>评价自己的行为时，专注于尚未满足的需要，不要依赖羞愧，内疚或沮丧的心理来寻求改变的而让爱主导我们的学习和成长。</li>
<li>根据自己的需要和价值观来选择生活。我们的行为不再是为了履行职责、获得回报、逃避惩罚或避免内心愧疚和羞愧。</li>
<li>用选择做代替不得不，我们的生活将变得充满和谐和快乐。</li>
</ol>
<h2 id="三、充分表达愤怒"><a href="#三、充分表达愤怒" class="headerlink" title="三、充分表达愤怒"></a>三、充分表达愤怒</h2><h3 id="（1）停下来，什么都不做"><a href="#（1）停下来，什么都不做" class="headerlink" title="（1）停下来，什么都不做"></a>（1）停下来，什么都不做</h3><h3 id="（2）想一想什么使我们生气了"><a href="#（2）想一想什么使我们生气了" class="headerlink" title="（2）想一想什么使我们生气了"></a>（2）想一想什么使我们生气了</h3><h3 id="（3）体会自己的需要"><a href="#（3）体会自己的需要" class="headerlink" title="（3）体会自己的需要"></a>（3）体会自己的需要</h3><h3 id="（4）表达自己的感受和需要"><a href="#（4）表达自己的感受和需要" class="headerlink" title="（4）表达自己的感受和需要"></a>（4）表达自己的感受和需要</h3><p>在第三和第四步之间，需要先倾听他人。在得到倾听和理解之后，他们就可以静下心来体会我们的感受和需要了。</p>
<h2 id="四、表达感激"><a href="#四、表达感激" class="headerlink" title="四、表达感激"></a>四、表达感激</h2><h4 id="（1）对方做了什么事情使我们的生活得到了改善"><a href="#（1）对方做了什么事情使我们的生活得到了改善" class="headerlink" title="（1）对方做了什么事情使我们的生活得到了改善;"></a>（1）对方做了什么事情使我们的生活得到了改善;</h4><h4 id="（2）我们有哪些需要得到了满足"><a href="#（2）我们有哪些需要得到了满足" class="headerlink" title="（2）我们有哪些需要得到了满足;"></a>（2）我们有哪些需要得到了满足;</h4><h4 id="（3）我们的心情怎么样？"><a href="#（3）我们的心情怎么样？" class="headerlink" title="（3）我们的心情怎么样？"></a>（3）我们的心情怎么样？</h4>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/02/22/Notes/Android/FourComponents/BroadcastReceiver%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="BroadcastReceiver-基础知识"><a href="#BroadcastReceiver-基础知识" class="headerlink" title="BroadcastReceiver 基础知识"></a>BroadcastReceiver 基础知识</h1><p>BroadcastReceiver 四大组件之一，主要用于监听手机状态的变以及不同组件和应用间的通信。</p>
<h2 id="一-注册广播"><a href="#一-注册广播" class="headerlink" title="一.注册广播"></a>一.注册广播</h2><h3 id="1-静态注册："><a href="#1-静态注册：" class="headerlink" title="1.静态注册："></a>1.静态注册：</h3><ol>
<li><p>在AndroidMainfest中添加receiver</p>
<pre><code> &lt;receiver android:name=&quot;.MyReceiver&quot;&gt;
     &lt;intent-filter&gt;
         &lt;action android:name=&quot;android.intent.action.myreceiver&quot; /&gt;
     &lt;/intent-filter&gt;
 &lt;/receiver&gt;
</code></pre>
</li>
<li><p>创建类继承BroadcastReceiver的，并且复写onReceive()方法</p>
<pre><code> public class MyReceiver extends BroadcastReceiver &#123;
     @Override
     public void onReceive(Context context, Intent intent) &#123;
         Log.i(TAG, &quot;receive action &quot;);
     &#125;
 &#125;
</code></pre>
</li>
</ol>
<h3 id="2-动态注册"><a href="#2-动态注册" class="headerlink" title="2. 动态注册"></a>2. 动态注册</h3><ol>
<li><p>创建广播类和实例</p>
</li>
<li><p>创建intentFilter并且添加需要接收的action</p>
</li>
<li><p>调用registerReceiver方法注册</p>
</li>
<li><p>可以通过unregisterReceiver取消</p>
<pre><code> public class MainActivity extends Activity &#123;
     private BroadcastReceiver mBroadcastReceiver;
 
     @Override
     protected void onCreate(Bundle savedInstanceState) &#123;
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_main);
 
         mBroadcastReceiver = new MyBroadcastReceiver();
         IntentFilter intentFilter = new IntentFilter();
         intentFilter.addAction(&quot;MyIntent&quot;);
         registerReceiver(mBroadcastReceiver, intentFilter);
     &#125;
     @Override
     protected void onDestroy() &#123;
         super.onDestroy();
         unregisterReceiver(mBroadcastReceiver);
     &#125;
 &#125;
</code></pre>
</li>
</ol>
<p>###Tips：</p>
<ol>
<li>action的注册和解注册成对出现在context对应的生命周期中，例如onCreate和onDestroy，以及onResume和onPause</li>
<li>同一个receiver可以同时接收动态注册和静态注册的广播</li>
<li>动态广播在应用没有启动时，是无法接收到的，即使加了Intent.FLAG_INCLUDE_STOPPED_PACKAGES（测试失败）</li>
</ol>
<h2 id="二、广播的类型"><a href="#二、广播的类型" class="headerlink" title="二、广播的类型"></a>二、广播的类型</h2><p>###1. 系统广播<br>   系统广播，当手机状态发生变化时，都会发出相应的系统广播。如：网络状态，解锁等。注意：有些系统广播必须态注册才有效：SCREEN_ON，SCREEN_OFF<br>###2. 普通广播<br>   自定义的广播，通常用于应用内或应用间通信。<br>###3. 有序广播</p>
<ol>
<li>多个具当前已经注册且有效的BroadcastReceiver接收有序广播时，是按照先后顺序接收的，先后顺序判定标准为：将当前系统中所有有效的动态注册和静态注册的BroadcastReceiver按照priority属性值从大到小排序，对于具有相同的priority的动态广播和静态广播，动态广播会排在前面。<pre><code> &lt;receiver android:name=&quot;.OrderedReceiver1&quot;&gt;
     &lt;intent-filter android:priority=&quot;100&quot;&gt;
         &lt;action android:name=&quot;com.sven.action.my.receiver.orderd.receiver&quot; /&gt;
     &lt;/intent-filter&gt;
 &lt;/receiver&gt;
 &lt;receiver android:name=&quot;.OrderedReceiver2&quot;&gt;
     &lt;intent-filter android:priority=&quot;1000&quot;&gt;
         &lt;action android:name=&quot;com.sven.action.my.receiver.orderd.receiver&quot; /&gt;
     &lt;/intent-filter&gt;
 &lt;/receiver&gt;
</code></pre>
</li>
</ol>
<p> 当然动态注册时也可以设置优先级：</p>
<pre><code>    intentFilter.setPriority(1000);
</code></pre>
<ol start="2">
<li><p>先接收的BroadcastReceiver可以对此有序广播进行截断，使后面的BroadcastReceiver不再接收到此广播，</p>
<pre><code> public class OrderedReceiver2 extends BroadcastReceiver &#123;
     private static final String TAG = &quot;OrderedReceiver2&quot;;
     @Override
     public void onReceive(Context context, Intent intent) &#123;
         Log.i(TAG, &quot;action = &quot;+intent.getAction());
         abortBroadcast();
     &#125;
 &#125;
</code></pre>
</li>
<li><p>receiver之间的通信<br>优先接收到Broadcast的Receiver可通过setResultExtras(Bundle)方法将处理结果存入Broadcast中，下一个Receiver 可通过getResultExtras(true)方法获取上一个 Receiver传来的数据。</p>
<pre><code> //修改
 public class OrderedReceiver2 extends BroadcastReceiver &#123;
     private static final String TAG = &quot;OrderedReceiver2&quot;;
     @Override
     public void onReceive(Context context, Intent intent) &#123;
         Log.i(TAG, &quot;action = &quot;+intent.getAction());
         Bundle b = new Bundle();
         b.putInt(&quot;value&quot;, 101);
         setResultExtras(b);
     &#125;
 &#125;
 
 //接收    
 public class OrderedReceiver1 extends BroadcastReceiver &#123;
     private static final String TAG = &quot;OrderedReceiver1&quot;;
     @Override
     public void onReceive(Context context, Intent intent) &#123;
         Log.i(TAG, &quot;action = &quot;+intent.getAction());
         Bundle b = getResultExtras(true);
         Log.i(TAG,&quot;value = &quot;+b.get(&quot;value&quot;));
     &#125;
 &#125;
</code></pre>
</li>
</ol>
<p>##三、广播和权限</p>
<h3 id="1-谁有权限接收-和安装的顺序有关-需要先装发送者"><a href="#1-谁有权限接收-和安装的顺序有关-需要先装发送者" class="headerlink" title="1. 谁有权限接收 (和安装的顺序有关 需要先装发送者)"></a>1. 谁有权限接收 (和安装的顺序有关 需要先装发送者)</h3><ol>
<li>发送者的manifest声明权限<pre><code> &lt;permission android:name=&quot;com.sven.permission.my.receiver.RECEIVE&quot;/&gt;
</code></pre>
</li>
<li>发送时添加权限<pre><code> public void sendBroadcast(View view) &#123;
     sendBroadcast(new Intent(&quot;com.sven.action.my.receiver&quot;),
             &quot;com.sven.permission.my.receiver.RECEIVE&quot;);
 &#125;
</code></pre>
</li>
<li>接收app的manifest要添加对应的权限<pre><code> &lt;uses-permission android:name=&quot;com.sven.permission.my.receiver.RECEIVE&quot;/&gt;
</code></pre>
</li>
</ol>
<h3 id="2-谁有权限发送-（和安装顺序有关，先安装接收者）"><a href="#2-谁有权限发送-（和安装顺序有关，先安装接收者）" class="headerlink" title="2. 谁有权限发送 （和安装顺序有关，先安装接收者）"></a>2. 谁有权限发送 （和安装顺序有关，先安装接收者）</h3><ol>
<li><p>接收者的manifest文件中声明权限</p>
<pre><code>    &lt;permission android:name=&quot;com.sven.permission.my.receiver.SEND&quot;/&gt;
</code></pre>
</li>
<li><p>接收者的receiver节点中添加</p>
<pre><code>     &lt;receiver
         android:name=&quot;.MyReceiverWithPermission&quot;
         android:permission=&quot;com.sven.permission.my.receiver.SEND&quot;&gt;
         &lt;intent-filter&gt;
         ....
         &lt;/intent-filter&gt;
     &lt;/receiver&gt;
</code></pre>
</li>
<li><p>发送者的manifest文件中使用</p>
<pre><code> &lt;uses-permission android:name=&quot;com.sven.permission.my.receiver.SEND&quot;/&gt;
</code></pre>
</li>
</ol>
<h3 id="Tips："><a href="#Tips：" class="headerlink" title="Tips："></a>Tips：</h3><p>自定义的权限最好在2个app中同时声明，（测试出现了比较奇怪的情况，声明权限的app，必须先安装，否则还是会报权限问题），使用系统权限不会不存在以上问题</p>
<h3 id="四、安全高效地使用广播的一些原则："><a href="#四、安全高效地使用广播的一些原则：" class="headerlink" title="四、安全高效地使用广播的一些原则："></a>四、安全高效地使用广播的一些原则：</h3><ol>
<li><p>如果不需要发送到应用外，同一个应用内的广播尽量使用LocalBroadcastManager</p>
</li>
<li><p>尽量使用动态注册的广播，而且有些系统广播，比如说 CONNECTIVITY_ACTION 在7.0之后只能通过动态注册接收</p>
</li>
<li><p>发送广播时明确广播的接受者：<br> (1)发送时添加权限<br> (2)通过setPackage 指定应用<br> (3)使用LocalBroadcastManager</p>
</li>
<li><p>广播的命名尽量保证唯一</p>
</li>
<li><p>注册一个广播时，限制广播的接收者：</p>
<p> (1)添加一个权限, mainfest 中指定，动态注册可以使用该接口添加权限</p>
<pre><code> public abstract Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler);
</code></pre>
<p> (2)仅仅只是应用内使用时，可以使用设置 android:exported=”false”。这样就不会接收应用外的广播了<br> (3)使用LocalBroadcastManager</p>
</li>
<li><p>onReceive方法运行在主线程中，所以不能执行耗时任务</p>
</li>
<li><p>不要通过广播启动activity，可以使用通知替代</p>
</li>
</ol>
<p>五、onReceive<br>系统执行onReceive方法时，receiver会被当成前台进程，不会被杀，但是当onReceive()方法返回后，会被当成一个低优先级的程序，很容易被系统杀掉，在onReceive执行耗时异步任务时，最好通过goAsync防止执行过程中被系统杀掉。<br>onReceive 的context是Application的context？？？</p>
<pre><code>public class MyBroadcastReceiver extends BroadcastReceiver &#123;
    private static final String TAG = &quot;MyBroadcastReceiver&quot;;
    @Override
    public void onReceive(final Context context, final Intent intent) &#123;
        final PendingResult pendingResult = goAsync();
        AsyncTask&lt;String, Integer, String&gt; asyncTask = new AsyncTask&lt;String, Integer, String&gt;() &#123;
            @Override
            protected String doInBackground(String... params) &#123;
                StringBuilder sb = new StringBuilder();
                sb.append(&quot;Action: &quot; + intent.getAction() + &quot;\n&quot;);
                sb.append(&quot;URI: &quot; + intent.toUri(Intent.URI_INTENT_SCHEME).toString() + &quot;\n&quot;);
                Log.d(TAG, log);
                // Must call finish() so the BroadcastReceiver can be recycled.
                pendingResult.finish();
                return data;
            &#125;
        &#125;;
        asyncTask.execute(); 
&#125;
</code></pre>
<p>}<br>###Tips:<br>可以在通过一下这种方法让onReceive执行在handlerThread中。</p>
<pre><code>private Handler handler; // Handler for the separate Thread
HandlerThread handlerThread = new HandlerThread(&quot;MyNewThread&quot;);
handlerThread.start();
// Now get the Looper from the HandlerThread so that we can create a Handler that is  attached to the HandlerThread
// NOTE: This call will block until the HandlerThread gets control and initializes its Looper
Looper looper = handlerThread.getLooper();
// Create a handler for the service
handler = new Handler(looper);
// Register the broadcast receiver to run on the separate Thread
registerReceiver (myReceiver, intentFilter, broadcastPermission, handler);
</code></pre>
<p><a href="https://stackoverflow.com/questions/10682241/register-a-broadcast-receiver-from-a-service-in-a-new-thread">https://stackoverflow.com/questions/10682241/register-a-broadcast-receiver-from-a-service-in-a-new-thread</a></p>
<h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><ol>
<li>有哪些静态广播可以启动进程，是否有其他要求？</li>
<li>上文提到的发送及接收时permission的问题？</li>
<li>BroadcastReceiver 耗时任务通过开启service执行和异步执行各有什么应用场景？</li>
</ol>
<p>参考资料：<br><a href="https://developer.android.com/guide/components/broadcasts.html#security_considerations_and_best_practices">https://developer.android.com/guide/components/broadcasts.html#security_considerations_and_best_practices</a><br><a href="http://www.cnblogs.com/lwbqqyumidi/p/4168017.html">http://www.cnblogs.com/lwbqqyumidi/p/4168017.html</a></p>
<p>Demo：<br><a href="http://download.csdn.net/detail/time_traveller14/9892205">http://download.csdn.net/detail/time_traveller14/9892205</a><br><a href="http://download.csdn.net/detail/time_traveller14/9892207">http://download.csdn.net/detail/time_traveller14/9892207</a></p>
]]></content>
  </entry>
  <entry>
    <title>NET_01_HTTP</title>
    <url>/2021/02/22/Notes/Android/FourComponents/Android%20Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="Android-Activity生命周期和启动模式理解"><a href="#Android-Activity生命周期和启动模式理解" class="headerlink" title="Android Activity生命周期和启动模式理解"></a>Android Activity生命周期和启动模式理解</h1><h1 id="一、生命周期"><a href="#一、生命周期" class="headerlink" title="一、生命周期"></a>一、生命周期</h1><h2 id="1-正常情况下生命周期分析"><a href="#1-正常情况下生命周期分析" class="headerlink" title="1.正常情况下生命周期分析"></a>1.正常情况下生命周期分析</h2><p><img src="https://leanote.com/api/file/getImage?fileId=594635f1ab64413c78001121" alt="Activity的生命周期"><br>完整生命周期：onCreate -&gt; onDestroy<br>可见生命周期：onStart -&gt; onStop<br>前台生命周期: onResume -&gt; onPause</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="2-常见生命周期的区别"><a href="#2-常见生命周期的区别" class="headerlink" title="2.常见生命周期的区别"></a>2.常见生命周期的区别</h2><h3 id="1-onCreate-和-onStart"><a href="#1-onCreate-和-onStart" class="headerlink" title="1. onCreate 和 onStart"></a>1. onCreate 和 onStart</h3><p>（1）可见与不可见的区别。前者不可见，后者可见。<br>（2）onCreate方法只在Activity创建时执行一次，而onStart方法在Activity的切换以及按Home键返回桌面再切回应用的过程中被多次调用。</p>
<h3 id="2-onStart-和-onRestart"><a href="#2-onStart-和-onRestart" class="headerlink" title="2.onStart 和 onRestart"></a>2.onStart 和 onRestart</h3><p>如果一个activity第一次创建，那么只会走onStart，如果是切换应用或者桌面，那么就会走onRestart<br>If it’s destroyed onCreate(.) &gt;  onStart(.) &gt; onResume(.) is called(variables are lost, redraw).<br>If it’s stopped onRestart(.) &gt; onStart(.) &gt; onResume(.) is called(variables are not lost, redraw)</p>
<h3 id="3-onStart-和-onResume"><a href="#3-onStart-和-onResume" class="headerlink" title="3.onStart 和 onResume"></a>3.onStart 和 onResume</h3><p>onStart activity 可见，不在前台<br>onResume activity 可见，前台且可与用户交互<br>这2个的主要区别就是Activity此时是否可以与用户交互</p>
<h3 id="4-onPause-和-onStop"><a href="#4-onPause-和-onStop" class="headerlink" title="4.onPause 和 onStop"></a>4.onPause 和 onStop</h3><p>这2个状态通常是配对执行的，<br>有一种情况是特殊的，新启动的Activity是一个透明的界面，那么第一个Activity执行onPause后，onStop是不会调用的</p>
<pre><code>&lt;activity android:name=&quot;.SecondActivity&quot;
    android:theme=&quot;@style/Theme.AppCompat.Dialog&quot; /&gt;
</code></pre>
<h3 id="5-onStop-amp-onDestroy"><a href="#5-onStop-amp-onDestroy" class="headerlink" title="5.onStop &amp; onDestroy"></a>5.onStop &amp; onDestroy</h3><p>onStop阶段Activity还没有被销毁，对象还在内存中，此时可以通过切换Activity再次回到该Activity，而onDestroy阶段Activity被销毁</p>
<h3 id="tips："><a href="#tips：" class="headerlink" title="tips："></a>tips：</h3><p>不同的生命周期适合不同的资源初始化或者释放工作，实践和工作中多总结。<a href="http://www.jianshu.com/p/fb44584daee3">http://www.jianshu.com/p/fb44584daee3</a></p>
<h2 id="3-常见操作的生命周期"><a href="#3-常见操作的生命周期" class="headerlink" title="3.常见操作的生命周期"></a>3.常见操作的生命周期</h2><h3 id="1-Launcher点击启动"><a href="#1-Launcher点击启动" class="headerlink" title="1.Launcher点击启动"></a>1.Launcher点击启动</h3><pre><code>01-16 10:57:22.429 26845-26845/? I/ActivityLife: onCreate...
01-16 10:57:22.429 26845-26845/? I/ActivityLife: onStart...
01-16 10:57:22.429 26845-26845/? I/ActivityLife: onResume...
</code></pre>
<h3 id="2-back键退出"><a href="#2-back键退出" class="headerlink" title="2.back键退出"></a>2.back键退出</h3><pre><code>01-16 10:58:58.139 26845-26845/? I/ActivityLife: onPause...
01-16 10:58:58.459 26845-26845/? I/ActivityLife: onStop...
01-16 10:58:58.459 26845-26845/? I/ActivityLife: onDestroy...
</code></pre>
<h3 id="3-HOME键退出然后再次点击启动"><a href="#3-HOME键退出然后再次点击启动" class="headerlink" title="3.HOME键退出然后再次点击启动"></a>3.HOME键退出然后再次点击启动</h3><pre><code>01-16 10:59:49.019 26845-26845/? I/ActivityLife: onPause...
01-16 10:59:49.309 26845-26845/? I/ActivityLife: onStop...
01-16 11:00:06.519 26845-26845/? I/ActivityLife: onRestart...
01-16 11:00:06.519 26845-26845/? I/ActivityLife: onStart...
01-16 11:00:06.519 26845-26845/? I/ActivityLife: onResume...
</code></pre>
<h3 id="4-锁屏解锁"><a href="#4-锁屏解锁" class="headerlink" title="4.锁屏解锁"></a>4.锁屏解锁</h3><pre><code>01-16 11:02:33.739 26845-26845/? I/ActivityLife: onPause...
01-16 11:02:33.779 26845-26845/? I/ActivityLife: onStop...
01-16 11:02:35.509 26845-26845/? I/ActivityLife: onRestart...
01-16 11:02:35.529 26845-26845/? I/ActivityLife: onStart...
01-16 11:02:35.529 26845-26845/? I/ActivityLife: onResume...
</code></pre>
<h1 id="2-异常情况下的生命周期分析"><a href="#2-异常情况下的生命周期分析" class="headerlink" title="2.异常情况下的生命周期分析"></a>2.异常情况下的生命周期分析</h1><h2 id="1-触发情况："><a href="#1-触发情况：" class="headerlink" title="1.触发情况："></a>1.触发情况：</h2><p>1.系统资源相关的配置发生变化导致Activity被杀死和重建<br>2.系统内存资源不足，lmk</p>
<h2 id="2-执行的特殊生命周期："><a href="#2-执行的特殊生命周期：" class="headerlink" title="2.执行的特殊生命周期："></a>2.执行的特殊生命周期：</h2><pre><code>onSaveInstanceState &amp; onRestoreInstanceState
</code></pre>
<p>1.onSaveInstanceState 通常在onStop之前，用于保存Activity数据<br>2.onRestoreInstanceState 通常在onStart之后，恢复Activity数据 </p>
<h3 id="tips：-1"><a href="#tips：-1" class="headerlink" title="tips："></a>tips：</h3><p>在onCreate和onRestoreInstanceState中都有一个参数savedInstanceState，二者的区别是：onRestoreInstanceState的参数是一定有值的，我们不用额外的判断它是否为空，但是onCreate不行，onCreate如果正常启动的话，savedInstanceState的值是null</p>
<h2 id="3-典型示例，系统配置变化，屏幕旋转"><a href="#3-典型示例，系统配置变化，屏幕旋转" class="headerlink" title="3.典型示例，系统配置变化，屏幕旋转"></a>3.典型示例，系统配置变化，屏幕旋转</h2><pre><code>public class MainActivity extends AppCompatActivity &#123;

    private static final String TAG = &quot;ActivityLife&quot;;

    private static final String EDIT_TAG = &quot;edit_tag&quot;;
    private EditText editText;

    @Override
    protected void onSaveInstanceState(Bundle outState) &#123;
        Log.i(TAG, &quot;onSaveInstanceState...&quot;);
        super.onSaveInstanceState(outState);
        String s = editText.getText().toString();
        outState.putString(EDIT_TAG,s);
    &#125;

    @Override
    protected void onRestoreInstanceState(Bundle savedInstanceState) &#123;
        super.onRestoreInstanceState(savedInstanceState);
        Log.i(TAG, &quot;onRestoreInstanceState...&quot;);
        //onCreate 或者这里恢复数据均可
        editText.setText(savedInstanceState.getString(EDIT_TAG));
    &#125;

    @Override
    protected void onCreate(Bundle savedInstanceState) &#123;
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Log.i(TAG, &quot;onCreate...&quot;);
        editText = (EditText) findViewById(R.id.edit_content);
        if (savedInstanceState != null)&#123;
            Log.i(TAG, &quot;onCreate savedInstanceState is not null&quot;);
            editText.setText(savedInstanceState.getString(EDIT_TAG));
        &#125;
    &#125;
&#125;
</code></pre>
<p>从Lanucher启动并且旋转一次屏幕，生命周期如下：</p>
<pre><code>01-16 11:59:30.459 29726-29726/? I/ActivityLife: onCreate...
01-16 11:59:30.459 29726-29726/? I/ActivityLife: onStart...
01-16 11:59:30.459 29726-29726/? I/ActivityLife: onResume...
01-16 11:59:38.609 29726-29726/? I/ActivityLife: onPause...
01-16 11:59:38.609 29726-29726/? I/ActivityLife: onSaveInstanceState...
01-16 11:59:38.619 29726-29726/? I/ActivityLife: onStop...
01-16 11:59:38.619 29726-29726/? I/ActivityLife: onDestroy...
01-16 11:59:38.669 29726-29726/? I/ActivityLife: onCreate...
01-16 11:59:38.669 29726-29726/? I/ActivityLife: onCreate savedInstanceState is not null
01-16 11:59:38.669 29726-29726/? I/ActivityLife: onStart...
01-16 11:59:38.669 29726-29726/? I/ActivityLife: onRestoreInstanceState...
01-16 11:59:38.669 29726-29726/? I/ActivityLife: onResume...
</code></pre>
<h2 id="4-onConfigurationChanged"><a href="#4-onConfigurationChanged" class="headerlink" title="4.onConfigurationChanged"></a>4.onConfigurationChanged</h2><p>当系统配置发生变化，如果不希望Activity重新创建，可以在AndroidManifest文件中给Activity加上属性，以屏幕旋转为例</p>
<pre><code>android:configChanges=&quot;orientation|screenSize&quot;
</code></pre>
<p>注意：从 Android 3.2（API 级别 13）开始，当设备在纵向和横向之间切换时，“屏幕尺寸”也会发生变化。因此，在开发针对 API 级别 13 或更高版本（正如 minSdkVersion 和 targetSdkVersion 属性中所声明）的应用时，若要避免由于设备方向改变而导致运行时重启，则除了 “orientation” 值以外，您还必须添加 “screenSize” 值。 也就是说，您必须声明 android:configChanges=”orientation|screenSize”。</p>
<h3 id="configChanges相关属性"><a href="#configChanges相关属性" class="headerlink" title="configChanges相关属性"></a>configChanges相关属性</h3><p><img src="https://leanote.com/api/file/getImage?fileId=59464bb1ab64413e9800127c" alt="config_changes"></p>
<h1 id="二、Activity的启动模式"><a href="#二、Activity的启动模式" class="headerlink" title="二、Activity的启动模式"></a>二、Activity的启动模式</h1><h2 id="1-Activity的四种启动模式"><a href="#1-Activity的四种启动模式" class="headerlink" title="1.Activity的四种启动模式"></a>1.Activity的四种启动模式</h2><p>standard:标准模式，每次启动一个Activity都会重新创建一个新的实例，不管这个实例是否已经存在<br>singleTop:栈顶复用模式，如果新的Activity已经位于任务栈的栈顶，那么此Activity就不会被重新创建,同时他的onNewIntent方法会被回调<br>singleTask:栈内复用模式，如果一个Activity在一个任务栈内存在，那么多次启动这个Activity都不会重新创建实例，它的onNewIntent方法也会被回调<br>singleInstance：单实例模式，具有此种模式的Activity只能单独的位于一个任务栈中</p>
<p>standard 和 singleTop都比较好理解，下面主要分析下singleTask和singleInstance的特点。会用到的调试命令：</p>
<pre><code>adb shell dumpsys activity | grep com.example.sven.activitydemo
</code></pre>
<h2 id="2-singleTask的特点"><a href="#2-singleTask的特点" class="headerlink" title="2.singleTask的特点"></a>2.singleTask的特点</h2><p>​    </p>
<h3 id="1-singleTask-和-taskAffinity"><a href="#1-singleTask-和-taskAffinity" class="headerlink" title="1.singleTask 和 taskAffinity"></a>1.singleTask 和 taskAffinity</h3><p><strong>1.launchMode=singleTask 的应用启动时是否会创建新的任务和taskAffinity属性有关</strong></p>
<p>设置了”singleTask”启动模式的Activity，它在启动的时候，会先在系统中查找属性值affinity等于它的属值taskAffinity的任务存在；如果存在这样的任务，它就会在这个任务中启动，否则就会在新任务中启动。因此如果我们想要设置了”singleTask”启动模式的Activity在新的任务中启动，就要为它设置一个唯一的taskAffinity属性值。</p>
<p>示例：A应用中，A0（表示启动界面，A1跳转的第二个界面，依次类推）A0-A1<br>(1)设置SecondActivity launchMode=”singleTask”，但不指定taskAffinity</p>
<pre><code>TaskRecord&#123;576dbde #53 A=com.example.sven.activitydemo U=0 sz=2&#125;
    Run #5: ActivityRecord&#123;dc04be8 u0 com.example.sven.activitydemo/.SecondActivity t53&#125;
    Run #4: ActivityRecord&#123;bebf9d2 u0 com.example.sven.activitydemo/.MainActivity t53&#125;
</code></pre>
<p>可以看到，虽然设置了singleTask的lanuchModel，但是MainActivity和SecondActivity还是在同一个任务栈中</p>
<p>(2)设置SecondActivity launchMode=”singleTask” ，同时指定taskAffinity = “com.example.sven.activitydemo.second”</p>
<pre><code>TaskRecord&#123;705495 #55 A=com.example.sven.activitydemo.second U=0 sz=1&#125;
    Run #5: ActivityRecord&#123;5a9b163 u0 com.example.sven.activitydemo/.SecondActivity t55&#125;
TaskRecord&#123;9d799aa #54 A=com.example.sven.activitydemo U=0 sz=1&#125;
    Run #4: ActivityRecord&#123;5e9adf5 u0 com.example.sven.activitydemo/.MainActivity t54&#125;
</code></pre>
<p>可以看到，设置了taskAffinity后，新的Activity就运行在新的任务栈里了</p>
<h3 id="tips：-2"><a href="#tips：-2" class="headerlink" title="tips："></a>tips：</h3><p>默认情况下，所有Activity的所需任务栈名均为包名，所以说如果将上面的taskAffinity属性设置为包名，SecondActivity也是不会在新的任务栈中启动的</p>
<p><strong>2.在同一个任务栈中具有唯一性</strong><br>    如果设置了”singleTask”启动模式的Activity不是在新的任务中启动时，它会在已有的任务中查看是否已经存在对应的Activity实例，如果存在，就会把位于这个Activity实例上面的Activity全部结束掉，最终这个Activity实例位于任务的堆栈顶端中。<br>示例：<br>MainActity SecondActivty ThirdActivty（以上3个Activity用A、B、C代表）在2种条件下执行如下过程 A -&gt; B -&gt;C -&gt; A -&gt;B</p>
<p>(1) SecondActivty launchMode=”singleTask”，taskAffinity=包名，最终栈中的结果如下</p>
<pre><code>TaskRecord&#123;8d620aa #62 A=com.example.sven.activitydemo U=0 sz=2&#125;
    Run #5: ActivityRecord&#123;ab051c1 u0 com.example.sven.activitydemo/.SecondActivity t62&#125;
    Run #4: ActivityRecord&#123;56fcc63 u0 com.example.sven.activitydemo/.MainActivity t62&#125;
</code></pre>
<p>(2) 设置SecondActivty 指定 taskAffinity = “com.example.sven.activitydemo.second”</p>
<pre><code>  TaskRecord&#123;4e4a3bc #61 A=com.example.sven.activitydemo.second U=0 sz=1&#125;
    Run #5: ActivityRecord&#123;f48dc2b u0 com.example.sven.activitydemo/.SecondActivity t61&#125;
  TaskRecord&#123;ea52f45 #60 A=com.example.sven.activitydemo U=0 sz=1&#125;
    Run #4: ActivityRecord&#123;9e4ab1 u0 com.example.sven.activitydemo/.MainActivity t60&#125;
</code></pre>
<p>   可以看到在2种情况下， 不论是否设定taskAffinity，在SecondActivity栈顶的实例都被清掉了</p>
<p><strong>3.任务（Task）不仅可以跨应用（Application），还可以跨进程（Process）</strong></p>
<p>示例：<br>    2个应用中A,B中，2个ActivityA1,B1的singleTask的Activity的taskAffinity设置为相同，执行如下过程 A0-&gt;A1，B0-&gt;B1</p>
<pre><code>android:launchMode=&quot;singleTask&quot;
android:taskAffinity=&quot;com.example.sven.activitydemo.second&quot;

TaskRecord&#123;a412e6e #71 A=com.example.sven.activitydemo.second U=0 sz=2&#125;
    Run #5: ActivityRecord&#123;12bc505 u0 com.example.sven.activitydemo2/.SecondActivityCopy t71&#125;
  TaskRecord&#123;fa790f #72 A=com.example.sven.activitydemo2 U=0 sz=1&#125;
    Run #4: ActivityRecord&#123;2610bd9 u0 com.example.sven.activitydemo2/.MainActivityCopy t72&#125;
  TaskRecord&#123;a412e6e #71 A=com.example.sven.activitydemo.second U=0 sz=2&#125;
    Run #3: ActivityRecord&#123;ca0064a u0 com.example.sven.activitydemo/.SecondActivity t71&#125;
  TaskRecord&#123;c224d9c #70 A=com.example.sven.activitydemo U=0 sz=1&#125;
    Run #2: ActivityRecord&#123;4257b8e u0 com.example.sven.activitydemo/.MainActivity t70&#125;
</code></pre>
<p>可以看到相同taskAffinity的Run#5和Run#3是在同一个任务栈a412e6e中的。</p>
<h3 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h3><p>Application，Task和Process的区别与联系<br>application翻译成中文时一般称为“应用”或“应用程序”，在android中，总体来说一个应用就是一组组件的集合。<br>task是在程序运行时，只针对activity的概念。说白了，task是一组相互关联的activity的集合，它是存在于framework层的一个概念，控制界面的跳转和返回。这个task存在于一个称为backstack的数据结构中，也就是说，framework是以栈的形式管理用户开启的activity。这个栈的基本行为是，当用户在多个activity之间跳转时，执行压栈操作，当用户按返回键时，执行出栈操作。<br>process一般翻译成进程，进程是操作系统内核中的一个概念，表示直接受内核调度的执行单位。在应用程序的角度看，我们用java编写的应用程序，运行在dalvik虚拟机中，可以认为一个运行中的dalvik虚拟机实例占有一个进程，所以，在默认情况下，一个应用程序的所有组件运行在同一个进程中。但是这种情况也有例外，即，应用程序中的不同组件可以运行在不同的进程中。只需要在manifest中用process属性指定组件所运行的进程的名字。如下所示：</p>
<pre><code> &lt;activity
        android:name=&quot;.SecondActivityCopy&quot;
       android:process=&quot;:remote&quot;
        android:allowTaskReparenting=&quot;true&quot; /&gt;
</code></pre>
<p><strong>4.allowTaskReparenting</strong><br>    一个应用A启动另一个应用B的B1（standard模式）Activity，如果这个Activity的allowTaskReparenting属性为true的话，那么B启动后B1直接会转移到B的任务栈中。现象就是A启动B1，在启动B时，显示的就是B1，而不是B0</p>
<pre><code>A -&gt; B1：

TaskRecord&#123;fc84b0d #46 A=com.example.sven.activitydemo2 U=0 sz=1&#125;
    Run #1: ActivityRecord&#123;8ebbcf3 u0 com.example.sven.activitydemo2/.SecondActivityCopy t46&#125;
  TaskRecord&#123;137b068 #45 A=com.example.sven.activitydemo U=0 sz=1&#125;
    Run #0: ActivityRecord&#123;b7827ad u0 com.example.sven.activitydemo/.MainActivity t45&#125;
</code></pre>
<p>​<br>​<br>​    启动B<br>​    TaskRecord{fc84b0d #46 A=com.example.sven.activitydemo2 U=0 sz=1}<br>​        Run #1: ActivityRecord{8ebbcf3 u0 com.example.sven.activitydemo2/.SecondActivityCopy t46}<br>​      TaskRecord{137b068 #45 A=com.example.sven.activitydemo U=0 sz=1}<br>​        Run #0: ActivityRecord{b7827ad u0 com.example.sven.activitydemo/.MainActivity t45}</p>
<h2 id="4-SingleInstance的特点"><a href="#4-SingleInstance的特点" class="headerlink" title="4.SingleInstance的特点"></a>4.SingleInstance的特点</h2><p><strong>1.singleInstance模式启动的Activity具有全局唯一性</strong><br>    整个系统中只会存在一个这样的实例，如果在启动这样的Activity时，已经存在了一个实例，那么会把它所在的任务调度到前台，重用这个实例。</p>
<p>示例：<br>2 个应用A，B，设置**B1 launchMode=”singleInstance”**， 执行如下过程，先B -&gt; B1， 再A0 -&gt;B1</p>
<pre><code>TaskRecord&#123;9b9bb06 #108 A=com.example.sven.activitydemo2 U=0 sz=1&#125;
    Run #3: ActivityRecord&#123;5520232 u0 com.example.sven.activitydemo2/.SecondActivityCopy t108&#125;
TaskRecord&#123;7b4a5c7 #107 A=com.example.sven.activitydemo2 U=0 sz=1&#125;
    Run #2: ActivityRecord&#123;6cf92f7 u0 com.example.sven.activitydemo2/.MainActivityCopy t107&#125;

TaskRecord&#123;9b9bb06 #108 A=com.example.sven.activitydemo2 U=0 sz=1&#125;
    Run #4: ActivityRecord&#123;5520232 u0 com.example.sven.activitydemo2/.SecondActivityCopy t108&#125;
TaskRecord&#123;3cccdb5 #109 A=com.example.sven.activitydemo U=0 sz=1&#125;
    Run #3: ActivityRecord&#123;facfdb u0 com.example.sven.activitydemo/.MainActivity t109&#125;
TaskRecord&#123;7b4a5c7 #107 A=com.example.sven.activitydemo2 U=0 sz=1&#125;
    Run #2: ActivityRecord&#123;6cf92f7 u0 com.example.sven.activitydemo2/.MainActivityCopy t107&#125;
</code></pre>
<p>可以看到 2 个过程中B1 的Taskrecord没有发生变化</p>
<p><strong>2.singleInstance模式启动的Activity具有独占性</strong><br>它会独自占用一个任务，被它开启的任何activity都会运行在其他任务中，但是否能够开启一个新任务，要看当前系统中是不是已经有了一个和要开启的Activity的taskAffinity属性相同的任务。<br>示例：<br>   B0-&gt;B1 B1-&gt;A3（B0和B1又因为上个原则，所以是在不同的任务栈中）</p>
<pre><code>  TaskRecord&#123;94de3cf #69 A=com.example.sven.activitydemo U=0 sz=1&#125;
    Run #2: ActivityRecord&#123;89ba288 u0 com.example.sven.activitydemo/.ThirdActivity t69&#125;
  TaskRecord&#123;2ad415c #68 A=com.example.sven.activitydemo2 U=0 sz=1&#125;
    Run #1: ActivityRecord&#123;73d6ca u0 com.example.sven.activitydemo2/.SecondActivityCopy t68&#125;
  TaskRecord&#123;6d70c65 #67 A=com.example.sven.activitydemo2 U=0 sz=1&#125;
    Run #0: ActivityRecord&#123;3941c44 u0 com.example.sven.activitydemo2/.MainActivityCopy t67&#125;
</code></pre>
<p>先启动A0（A3和A0是运行在同一个栈中）  B0-&gt;B1 B1-&gt;A3</p>
<pre><code>TaskRecord&#123;5db49f9 #71 A=com.example.sven.activitydemo U=0 sz=2&#125;
  Run #3: ActivityRecord&#123;dfea174 u0 com.example.sven.activitydemo/.ThirdActivity t71&#125;
TaskRecord&#123;e7e8d3e #73 A=com.example.sven.activitydemo2 U=0 sz=1&#125;
  Run #2: ActivityRecord&#123;cb12857 u0 com.example.sven.activitydemo2/.SecondActivityCopy t73&#125;
TaskRecord&#123;3f750ec #72 A=com.example.sven.activitydemo2 U=0 sz=1&#125;
  Run #1: ActivityRecord&#123;2efad8b u0 com.example.sven.activitydemo2/.MainActivityCopy t72&#125;
TaskRecord&#123;5db49f9 #71 A=com.example.sven.activitydemo U=0 sz=2&#125;
  Run #0: ActivityRecord&#123;c39fdab u0 com.example.sven.activitydemo/.MainActivity t71&#125;
</code></pre>
<p>可以看到A3（Run #2）会在A0 （Run #5）的任务栈中46bac8a</p>
<h3 id="tips：-3"><a href="#tips：-3" class="headerlink" title="tips："></a>tips：</h3><p>启动时是否开启任务栈，考虑3个点：1.被启动的Activity的launchModel，如果是singleTask要同时考虑它的taskAffinity<br>                                 2.启动Activity的launchmode(singleInstance)<br>                                 3.当前是否有被启动应用的任务栈</p>
<h2 id="4-Activity的flag"><a href="#4-Activity的flag" class="headerlink" title="4.Activity的flag"></a>4.Activity的flag</h2><h3 id="1-Intent-FLAG-ACTIVITY-NEW-TASK"><a href="#1-Intent-FLAG-ACTIVITY-NEW-TASK" class="headerlink" title="1.Intent.FLAG_ACTIVITY_NEW_TASK"></a>1.Intent.FLAG_ACTIVITY_NEW_TASK</h3><p>等价于 launchMode = singleTask</p>
<h3 id="2-Intent-FLAG-ACTIVITY-SINGLE-TOP"><a href="#2-Intent-FLAG-ACTIVITY-SINGLE-TOP" class="headerlink" title="2.Intent.FLAG_ACTIVITY_SINGLE_TOP"></a>2.Intent.FLAG_ACTIVITY_SINGLE_TOP</h3><p>等价于 launchMode = singleTop 设置singleTop 和一起使用taskAffinity ，只有singleTop的效果</p>
<h3 id="3-Intent-FLAG-ACTIVITY-CLEAR-TOP"><a href="#3-Intent-FLAG-ACTIVITY-CLEAR-TOP" class="headerlink" title="3.Intent.FLAG_ACTIVITY_CLEAR_TOP"></a>3.Intent.FLAG_ACTIVITY_CLEAR_TOP</h3><p>检查目标栈中是否有对应的实例，如果有就会将该实例之上的所有栈都清掉<br>    A-&gt;B（正常启动）-&gt;C-&gt;A-&gt;B(clearTop方式启动)<br>    (1) B的launchmode 是standard</p>
<pre><code>TaskRecord&#123;fec37c7 #134 A=com.example.sven.activitydemo U=0 sz=4&#125;
    Run #5: ActivityRecord&#123;91e286b u0 com.example.sven.activitydemo/.MainActivity t134&#125;
    Run #4: ActivityRecord&#123;775d8ae u0 com.example.sven.activitydemo/.ThirdActivity t134&#125;
    Run #3: ActivityRecord&#123;20304d6 u0 com.example.sven.activitydemo/.SecondActivity t134&#125;
    Run #2: ActivityRecord&#123;b049afa u0 com.example.sven.activitydemo/.MainActivity t134&#125;
 
TaskRecord&#123;fec37c7 #134 A=com.example.sven.activitydemo U=0 sz=2&#125;
   Run #3: ActivityRecord&#123;4fdc1db u0 com.example.sven.activitydemo/.SecondActivity t134&#125;
    Run #2: ActivityRecord&#123;b049afa u0 com.example.sven.activitydemo/.MainActivity t134&#125;
</code></pre>
<p>可以看到，如果被启动的SecondActivity的启动模式是standard，那么B会重新创建新的实例并且之前的实例及实例之上的Activity都会出栈，recordid 发生了变化 20304d6 -&gt; 4fdc1db</p>
<pre><code>(2) B的launchmode是singleTask

TaskRecord&#123;249ecaa #135 A=com.example.sven.activitydemo U=0 sz=4&#125;
    Run #5: ActivityRecord&#123;1116cb u0 com.example.sven.activitydemo/.MainActivity t135&#125;
    Run #4: ActivityRecord&#123;92b068e u0 com.example.sven.activitydemo/.ThirdActivity t135&#125;
    Run #3: ActivityRecord&#123;96bd6b6 u0 com.example.sven.activitydemo/.SecondActivity t135&#125;
    Run #2: ActivityRecord&#123;44bf730 u0 com.example.sven.activitydemo/.MainActivity t135&#125;

TaskRecord&#123;249ecaa #135 A=com.example.sven.activitydemo U=0 sz=2&#125;
    Run #3: ActivityRecord&#123;96bd6b6 u0 com.example.sven.activitydemo/.SecondActivity t135&#125;
    Run #2: ActivityRecord&#123;44bf730 u0 com.example.sven.activitydemo/.MainActivity t135&#125;
</code></pre>
<p>可以看到，如果被启动的SecondActivity的启动模式是SingleTask，那么B会清除实例之上的Activity，并且调用onNewIntent方法</p>
<p><strong>总结：主要2个点，清除被启动Activity之上的实例，是否创建新的实例和被启动Activity的lanuchMode有关</strong></p>
<h3 id="4-Intent-FLAG-ACTIVITY-EXCLUDE-FROM-RECENTS"><a href="#4-Intent-FLAG-ACTIVITY-EXCLUDE-FROM-RECENTS" class="headerlink" title="4. Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS"></a>4. Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS</h3><p>具有这个标记的Activity不会出现在历史Activity的记录中，和android:excludeFromRecents作用相同</p>
<h3 id="tips：启动模式有2种设置方法，通过设置Intent的FLAG-和-AndroidManifest-xml-，第一种方式的优先级大于第二种方式"><a href="#tips：启动模式有2种设置方法，通过设置Intent的FLAG-和-AndroidManifest-xml-，第一种方式的优先级大于第二种方式" class="headerlink" title="tips：启动模式有2种设置方法，通过设置Intent的FLAG 和 AndroidManifest.xml ，第一种方式的优先级大于第二种方式"></a>tips：启动模式有2种设置方法，通过设置Intent的FLAG 和 AndroidManifest.xml ，第一种方式的优先级大于第二种方式</h3><h1 id="三、IntentFilter的匹配规则"><a href="#三、IntentFilter的匹配规则" class="headerlink" title="三、IntentFilter的匹配规则"></a>三、IntentFilter的匹配规则</h1><p>Activity的显示调用和隐式调用：<a href="http://blog.csdn.net/xiao__gui/article/details/11392987">http://blog.csdn.net/xiao__gui/article/details/11392987</a></p>
<p>一个activity可以有多个过滤器，每个过滤器均可以有多个action，category和data</p>
<h2 id="1-action的匹配规则"><a href="#1-action的匹配规则" class="headerlink" title="1.action的匹配规则"></a>1.action的匹配规则</h2><p><strong>Intent 中的 action 只要有一个与过滤器（manifest中的intent-filter）的匹配，就可调用这个过滤器所在的组件。</strong></p>
<h2 id="2-category的匹配规则"><a href="#2-category的匹配规则" class="headerlink" title="2.category的匹配规则"></a>2.category的匹配规则</h2><p>category 表示类别，最常见就是这2个</p>
<pre><code>&lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
 &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;
</code></pre>
<p><strong>1. 隐式启动时intent会自动的添加一个默认的category，所以隐式启动时，过滤器中默认的category必须要加</strong></p>
<pre><code> &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;
</code></pre>
<p><strong>2. 隐式启动时，intent中添加的category必须包含在过滤器中</strong></p>
<h2 id="3-data的匹配规则"><a href="#3-data的匹配规则" class="headerlink" title="3.data的匹配规则"></a>3.data的匹配规则</h2><p><strong>data 表示该组件可以支持的数据格式与类型，intent 至少可以匹配过滤器中的一个</strong></p>
<p>主要由两部分组成：1.mimeType 2.URI ，语法如下：</p>
<pre><code>&lt;data android:scheme=&quot;string&quot;
    android:host=&quot;string&quot;
    android:port=&quot;string&quot;
    android:path=&quot;string&quot;
    android:pathPattern=&quot;string&quot;
    android:pathPrefix=&quot;string&quot;
    android:mimeType=&quot;string&quot; /&gt;
</code></pre>
<p>(1) mimeType 指的是支持的数据类型与格式<br>    常见的有：1.text/plain 2.image/jpeg 3.video/* 4.audio/*<br>    / 号前面的是数据类型，后面是具体格式。</p>
<p>(2) URI 格式：</p>
<pre><code>&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;]|[&lt;pathPrefix&gt;]|[pathPattern]
</code></pre>
<p>1.scheme、host、port、path分别表示URI的模式、主机名和端口号和路径</p>
<pre><code>例如：http://www.baidu.com:80/search/info
</code></pre>
<p>2.如果scheme或者host未指定那么URI就无效</p>
<p>3.URI 是有默认值的，content 和 file，这里不是很理解，不过发现这样一种情况：</p>
<p>在intent-filter 中添加任意一种mimeType，不指定URI</p>
<pre><code>&lt;data android:mimeType=&quot;image/jpeg&quot;/&gt;
</code></pre>
<p>intent启动时，设置URI为 content:.* 或 file:.* 均可启动</p>
<pre><code>intent.setDataAndType(Uri.parse(&quot;content://abc&quot;), &quot;image/jpeg&quot;);
</code></pre>
<p>4.data 是有如下2种写法的，效果是一样的</p>
<pre><code>&lt;data android:scheme=&quot;file&quot;
      android:host=&quot;abc&quot;
      android:mimeType=&quot;text/plain&quot;/&gt;

&lt;data android:scheme=&quot;file&quot;/&gt;
&lt;data android:host=&quot;abc&quot;/&gt;
&lt;data android:mimeType=&quot;text/plain&quot;/&gt;
</code></pre>
<p>如果一个intent-filter 中有多个data 并且他们的URI均不同，建议用第一种。</p>
<p>data 的匹配规则这里只列举的常用的一部分，还有些情况类似与如下，也可以匹配到，可以将URI 和MIMETYPE的关系理解为action和category的关系</p>
<pre><code>&lt;data android:scheme=&quot;http&quot; android:host=&quot;abc&quot; android:mimeType=&quot;text/plain&quot;/&gt;
&lt;data android:scheme=&quot;http&quot; android:host=&quot;abc2&quot; android:mimeType=&quot;image/png&quot;/&gt;

intent.setDataAndType(Uri.parse(&quot;http://abc&quot;), &quot;image/png&quot;);
</code></pre>
<p>只能理解为 URI 和MIMETYPE 其实类似于 action 和 category的关系，采用如下的写法更能表现两者的关系，具体大家在实践中多多理解</p>
<pre><code>  &lt;data android:scheme=&quot;file&quot; android:host=&quot;abc&quot; /&gt;
  &lt;data android:scheme=&quot;file&quot; android:host=&quot;abc2&quot; /&gt;
  &lt;data android:mimeType=&quot;text/plain&quot; /&gt;
  &lt;data android:mimeType=&quot;image/png&quot; /&gt;
</code></pre>
<h3 id="tips-1"><a href="#tips-1" class="headerlink" title="tips:"></a>tips:</h3><p>1.如果要为Intent指定完整的data，必须要调用setDataAndType方法，不能先调用setData然后调用setType，因为这两个方法会彼此清除对方的值。<br>2.当我们启动Activity可以通过resolveActivity判断是否有对应的Activity</p>
<pre><code>if(this.getPackageManager().resolveActivity(intent, 0) != null)&#123;
    startActivity(intent);
&#125;
</code></pre>
<p>3.特殊的一组action和category，标记应用启动时打开的Activity，少了任何一个都没有意义</p>
<pre><code>&lt;intent-filter&gt;
    &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
    &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
&lt;/intent-filter&gt;
</code></pre>
<p>4.显示Component调用也是可以跨应用的，需要显示指定Activity属性 android:exported=”true” 或者添加一个intent-Filter，否则会报AndroidRuntime异常，通过Tip 2是不能检查出intent是否正常。</p>
<p>以上这些自己写了个Demo，方便大家调试和学习：</p>
<p><strong>问题：</strong></p>
<ol>
<li>onSaveInstanceState 为何会在跳转到别的Activity、Home键以及锁屏时调用？</li>
<li>category 和 data 的更多用法？</li>
</ol>
<p><strong>参考资料：</strong><br><a href="https://developer.android.com/reference/android/app/Activity.html">https://developer.android.com/reference/android/app/Activity.html</a><br><a href="https://developer.android.com/guide/topics/manifest/activity-element.html?hl=zh-cn#config">https://developer.android.com/guide/topics/manifest/activity-element.html?hl=zh-cn#config</a><br><a href="http://blog.csdn.net/u011240877/article/details/71305797">http://blog.csdn.net/u011240877/article/details/71305797</a><br>《Android 开发艺术之旅》</p>
]]></content>
      <tags>
        <tag>网络</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/02/22/Notes/Android/FourComponents/Android%20Service%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="Android-Service-基础知识"><a href="#Android-Service-基础知识" class="headerlink" title="Android Service 基础知识"></a>Android Service 基础知识</h1><p>Service 作为android 四大组件之一，主要用于再后台处理一些耗时的逻辑或者去执行一些长期运行的任务。</p>
<h1 id="一、startService-和-bindService"><a href="#一、startService-和-bindService" class="headerlink" title="一、startService 和 bindService"></a>一、startService 和 bindService</h1><h2 id="1-生命周期和启动方式："><a href="#1-生命周期和启动方式：" class="headerlink" title="1. 生命周期和启动方式："></a>1. 生命周期和启动方式：</h2><p><img src="https://leanote.com/api/file/getImage?fileId=595288b4ab6441560e001f51" alt="service_lifecircle"><br>1.1 启动<br>通过startService启动服务时，如果是第一次启动，会调用onCreate-&gt;onStartCommand，但是多次启动时不会再调用onCreate，只有onStartCommand会被调用多次。<br>通过bindService绑定服务时，如果服务还未启动，会调用onCreate-&gt;onBind，创建并且绑定服务，多次调用bindService并不会多次调用onBind()，除非是多个客户端来绑定服务。</p>
<p>1.2 销毁<br>如果组件通过调用 startService() 启动服务，则服务将一直运行，直到服务使用 stopSelf()自行停止运行，或由其他组件通过调用 stopService() 停止它为止。无论服务被启动了多少次，只要调用一次stopService，便可终止（不考虑被绑定过的情况）。</p>
<p>如果组件是通过调用 bindService()来创建服务（且未调用onStartCommand()），则服务只会在该组件与其绑定时运行。一旦该服务与所有客户端之间的绑定全部取消，系统便会销毁它。</p>
<h2 id="2-starService和bindService一起使用："><a href="#2-starService和bindService一起使用：" class="headerlink" title="2. starService和bindService一起使用："></a>2. starService和bindService一起使用：</h2><p>如果一个Service又被启动又被绑定，则该Service会一直在后台运行。首先不管如何调用，onCreate始终只会调用一次。startService调用多少次，Service的onStartCommand方法便会调用多少次。Service的终止，需要unbindService和stopService同时调用才行。不管startService与bindService的调用顺序，如果先调用unbindService，此时服务不会自动终止，再调用stopService之后，服务才会终止；如果先调用stopService，此时服务也不会终止，再次调用unbindService或者<strong>之前调用bindService的Context不存在了</strong>（如Activity被finish的时候）之后，服务才会停止。</p>
<h2 id="3-使用场景："><a href="#3-使用场景：" class="headerlink" title="3. 使用场景："></a>3. 使用场景：</h2><p>   startService 主要用于开启服务，例如后台下载和播放音乐<br>   bindService 主要为了使用服务中的一些功能或者与服务进行交互<br>   这2种模式不是完全分离的。你可以可以绑定到一个通过startService()启动的服务。如一个intent想要播放音乐，通过startService启动后台播放音乐的service。然后，也许用户想要操作播放器或者获取当前正在播放的乐曲的信息，一个activity就会通过bindService建立一个到此service的连接. 这种情况下 stopService() 在全部的连接关闭后才会真正停止service。</p>
<h3 id="Tips："><a href="#Tips：" class="headerlink" title="Tips："></a>Tips：</h3><ol>
<li>服务的onCreate和onDestroy在一个生命周期中只会执行一次</li>
<li>service的stopself方法的功能是，当完成所有功能之后，将service停掉</li>
<li>Service中onRebind方法被调用的时机，需要满足2个条件：<br>(1)服务中onUnBind方法返回值为true<br>(2)服务对象被解绑后没有被销毁，之后再次被绑定</li>
</ol>
<h2 id="2-onStartCommand的返回值："><a href="#2-onStartCommand的返回值：" class="headerlink" title="2. onStartCommand的返回值："></a>2. onStartCommand的返回值：</h2><p>请注意，onStartCommand() 方法必须返回整型数。整型数是一个值，用于描述系统应该如何在服务终止的情况下继续运行服务（如上所述，IntentService 的默认实现将为您处理这种情况，不过您可以对其进行修改）。从onStartCommand()返回的值必须是以下常量之一：</p>
<h2 id="1-START-NOT-STICKY"><a href="#1-START-NOT-STICKY" class="headerlink" title="1. START_NOT_STICKY"></a>1. START_NOT_STICKY</h2><p>如果系统在 onStartCommand() 返回后终止服务，则除非有挂起 Intent 要传递，否则系统不会重建服务。这是最安全的选项，可以避免在不必要时以及应用能够轻松重启所有未完成的作业时运行服务。</p>
<h2 id="2-START-STICKY"><a href="#2-START-STICKY" class="headerlink" title="2. START_STICKY"></a>2. START_STICKY</h2><p>如果系统在 onStartCommand() 返回后终止服务，则会重建服务并调用 onStartCommand()，但不会重新传递最后一个 Intent。相反，除非有挂起 Intent 要启动服务（在这种情况下，将传递这些 Intent ），否则系统会通过空 Intent 调用 onStartCommand()。这适用于不执行命令、但无限期运行并等待作业的媒体播放器（或类似服务）。</p>
<h2 id="3-START-REDELIVER-INTENT"><a href="#3-START-REDELIVER-INTENT" class="headerlink" title="3. START_REDELIVER_INTENT"></a>3. START_REDELIVER_INTENT</h2><p>如果系统在 onStartCommand() 返回后终止服务，则会重建服务，并通过传递给服务的最后一个 Intent 调用 onStartCommand()。任何挂起 Intent 均依次传递。这适用于主动执行应该立即恢复的作业（例如下载文件）的服务。</p>
<h1 id="二、前台服务"><a href="#二、前台服务" class="headerlink" title="二、前台服务"></a>二、前台服务</h1><p>Service几乎都是在后台运行的，一直以来它都是默默地做着辛苦的工作。但是Service的系统优先级还是比较低的，当系统出现内存不足情况时，就有可能会回收掉正在后台运行的Service。如果你希望Service可以一直保持运行状态，而不会由于系统内存不足的原因导致被回收，就可以考虑使用前台Service。前台Service和普通Service最大的区别就在于，它会一直有一个正在运行的图标在系统的状态栏显示，下拉状态栏后可以看到更加详细的信息，非常类似于通知的效果。当然有时候你也可能不仅仅是为了防止Service被回收才使用前台Service，有些项目由于特殊的需求会要求必须使用前台Service，比如说墨迹天气。</p>
<pre><code>    Intent intent = new Intent(this, MainActivity.class);
    //需要让Activity运行在新的任务栈中
    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    Notification.Builder builder = new Notification.Builder(this);
    Notification notification = builder.setSmallIcon(R.mipmap.ic_launcher)
            .setContentText(&quot;this is a notify&quot;)
            .setContentTitle(&quot;notify!!!&quot;).setTicker(&quot;notify&quot;)
            .setContentIntent(PendingIntent.
                    getActivity(ServiceB.this, 0, intent, PendingIntent.FLAG_CANCEL_CURRENT))
            .build();
    startForeground(1, notification);
</code></pre>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips:"></a>Tips:</h3><ol>
<li>startForeground让服务变成前台服务并显示通知，这时必须要setSmallIcon，否则会显示默认的通知，不显示自定义通知</li>
<li>如何让服务一直存活 <a href="http://zhoujianghua.com/2015/07/28/black_technology_in_alipay/">http://zhoujianghua.com/2015/07/28/black_technology_in_alipay/</a></li>
</ol>
<h1 id="三、Service-和-Thread"><a href="#三、Service-和-Thread" class="headerlink" title="三、Service 和 Thread"></a>三、Service 和 Thread</h1><p>之所以有不少人会把它们联系起来，主要就是因为Service的后台概念。Thread我们大家都知道，是用于开启一个子线程，在这里去执行一些耗时操作就不会阻塞主线程的运行。而Service我们最初理解的时候，总会觉得它是用来处理一些后台任务的，一些比较耗时的操作也可以放在这里运行，这就会让人产生混淆了。但其实Service其实是运行在主线程里的，所以说service的主进程中不能执行耗时的任务，需要另外启动线程执行，例如IntentService的内部就是使用了HandlerThread的实现。</p>
<h1 id="四、IntentService"><a href="#四、IntentService" class="headerlink" title="四、IntentService"></a>四、IntentService</h1><p>IntentService是Service 的子类，它使用工作线程逐一处理所有启动请求。如果不要求服务同时处理多个请求，这是最好的选择。只需实现 onHandleIntent() 方法即可，该方法会接收每个启动请求的Intent，能够执行后台工作。由于大多数启动服务都不必同时处理多个请求，因此使用 IntentService 类实现服务也许是最好的选择。</p>
<p>IntentService的特点：</p>
<ol>
<li>IntentService 会创建一个线程，来处理所有传给onStartCommand()的Intent请求</li>
<li>创建一个请求队列，用于将 Intent 逐一传递给 onHandleIntent() 实现，不必担心多线程问题</li>
<li>在所有的请求执行完毕后结束Service</li>
<li>提供 onBind() 的默认实现（返回 null）</li>
<li>提供默认的 onStartCommand() 实现，将intent传入等待队列中，然后到onHandleIntent()的实现。所以如果需要重写onStartCommand() 方法一定要调用父类的实现。</li>
</ol>
<h3 id="Tips-1"><a href="#Tips-1" class="headerlink" title="Tips:"></a>Tips:</h3><ol>
<li>IntentService是针对StarteService设计的，由于它默认实现的onBind()方法返回值是null，所以不适合bindService()</li>
<li>多次startService请求执行耗时任务，不会并发执行onHandleIntent()方法，而是一个一个顺序执行。当所有的任务执行完成，IntentService会自动销毁</li>
</ol>
<p>问题：onStartCommand的返回值的具体应用场景？</p>
<p>Demo：</p>
<p>参考资料：<br><a href="https://developer.android.com/guide/components/services.html">https://developer.android.com/guide/components/services.html</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/11952435">http://blog.csdn.net/guolin_blog/article/details/11952435</a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/02/22/Notes/Android/FourComponents/ContentProvider%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="ContentProvider-基础知识"><a href="#ContentProvider-基础知识" class="headerlink" title="ContentProvider 基础知识"></a>ContentProvider 基础知识</h1><p>ContentProvider 用户跨进程访问数据，通常和数据库以及ContentResolver配合使用，可以保证数据的安全性。</p>
<h2 id="一、ContentResolver"><a href="#一、ContentResolver" class="headerlink" title="一、ContentResolver"></a>一、ContentResolver</h2><p>对于每一个应用程序来说，如果想要访问内容提供器中共享的数据，就一定要借助ContentResolver类，可以通过Context中的getContentResolver()方法获取到该类的实例。 ContentResolver中提供了一系列的方法用于对数据进行CRUD操作，其中insert()方法用于添加数据，update()方法用于更新数据，delete()方法用于删除数据，query()方法用于查询数据。有没有似曾相识的感觉？没错，SQLiteDatabase中也是使用的这几个方法来进行 CRUD 操作的，只不过它们在方法参数上稍微有一些区别。不同于SQLiteDatabase，ContentResolver中的增删改查方法都是不接收表名参数的，而是使用一个 Uri参数代替，这个参数被称为内容 URI，下面会详细介绍它的格式定义。在得到了内容URI字符串之后，我们还需要将它解析成Uri对象才可以作为参数传入。 只需要调用 Uri.parse()方法，就可以将内容URI字符串解析成 Uri对象： </p>
<pre><code>Uri uri = Uri.parse(&quot;content://com.example.app.provider/table1&quot;) 
</code></pre>
<p>再调用contentResolver的CURD方法就可完成对应的操作。</p>
<pre><code>Cursor cursor = context.getContentResolver().query(uri, null, null, null, null);
</code></pre>
<h2 id="二、内容-URI"><a href="#二、内容-URI" class="headerlink" title="二、内容 URI"></a>二、内容 URI</h2><p>无论是通过ContentResolver访问数据，还是实现自定义的ContentProvider都需要内容URI才能够通信。URI给内容提供器中的数据建立了唯一标志符，基本格式如下：</p>
<pre><code>content://Authority/Path/Id
</code></pre>
<p>content:// 固定格式<br>Authority：权限，用于对不同的应用程序进行区分，一般为了避免冲突，都会采用包名.provider<br>Path: 路径，用于对同一个程序中的不同表做区分<br>Id: 数据Id，用于区分表中的不同数据<br>URI的格式主要有如下2种：</p>
<pre><code>   content://com.example.app.provider/table 
   content://com.example.app.provider/table1/1 
</code></pre>
<p>以路径结尾表示期望访问该表中所有的数据， 以 id结尾就表示期望访问该表中拥有相应 id的数据。我们可以使用通配符的方式来分别匹 配这两种格式的内容 URI，规则如下。</p>
<ol>
<li><p>*：表示匹配任意长度的任意字符 </p>
</li>
<li><p>#：表示匹配任意长度的数字<br>所以，一个能够匹配任意表的内容 URI格式就可以写成：</p>
<p> content://com.example.app.provider/* </p>
</li>
</ol>
<p>而一个能够匹配 table1表中任意一行数据的内容 URI格式就可以写成</p>
<pre><code>content://com.example.app.provider/table1/#
</code></pre>
<p>我们再借助UriMatcher这个类就可以轻松地实现匹配内容URI的功能。UriMatcher中提供了一个addURI()方法，这个方法接收三个参数，可以分别把权限、路径和一个自定义代码传进去。这样，当调用UriMatcher的match()方法时，就可以将一个 Uri对象传入，返回值是某个能够匹配这个Uri对象所对应的自定义代码，利用这个代码，我们就可以判断出调用方期望访问的是哪张表中的数据了。</p>
<h2 id="三、ContentProvider方法介绍"><a href="#三、ContentProvider方法介绍" class="headerlink" title="三、ContentProvider方法介绍"></a>三、ContentProvider方法介绍</h2><p>通过继承ContentProvider，并且实现抽象方法就可完成自定义的ContentProvider共享数据了。</p>
<h3 id="1-onCreate"><a href="#1-onCreate" class="headerlink" title="1.onCreate()"></a>1.onCreate()</h3><p>初始化内容提供器的时候调用。通常会在这里完成对数据库的创建和升级等操作，返回true表示内容提供器初始化成功，返回false 则表示失败。注意，只有当存在 ContentResolver尝试访问我们程序中的数据时，内容提供器才会被初始化。</p>
<h3 id="2-query"><a href="#2-query" class="headerlink" title="2.query()"></a>2.query()</h3><p>从内容提供器中查询数据。使用uri参数来确定查询哪张表，projection参数用于确定查询哪些列，selection和selectionArgs参数用于约束查询哪些行，sortOrder参数用于对结果进行排序，查询的结果存放在Cursor对象中返回。 </p>
<h3 id="3-insert"><a href="#3-insert" class="headerlink" title="3.insert()"></a>3.insert()</h3><p>向内容提供器中添加一条数据。使用uri参数来确定要添加到的表，待添加的数据保存在values参数中。添加完成后，返回一个用于表示这条新记录的 URI。</p>
<h3 id="4-update"><a href="#4-update" class="headerlink" title="4.update()"></a>4.update()</h3><p>更新内容提供器中已有的数据。使用uri参数来确定更新哪一张表中的数据，新数据保存在values参数中，selection和selectionArgs参数用于约束更新哪些行，受影响的 行数将作为返回值返回。</p>
<h3 id="5-delete"><a href="#5-delete" class="headerlink" title="5.delete()"></a>5.delete()</h3><p>从内容提供器中删除数据。使用uri参数来确定删除哪一张表中的数据，selection和selectionArgs参数用于约束删除哪些行，被删除的行数将作为返回值返回。</p>
<h3 id="6-getType"><a href="#6-getType" class="headerlink" title="6.getType()"></a>6.getType()</h3><p>根据传入的内容 URI来返回相应的 MIME类型。它是所有的内容提供器都必须提供的一个方法，用于获取Uri对象所对应的MIME类型。一个内容URI所对应的MIME字符串主要由三部分组分，Android对这三个部分做了如下格式规定。<br>    1. 必须以vnd开头。<br>    2. 如果内容URI以路径结尾，则后接android.cursor.dir/，如果内容URI以id结尾，则后接android.cursor.item/<br>    3. 最后接上 vnd.authority.path</p>
<p>所以，对于 content://com.example.app.provider/table1这个内容 URI，它所对应的 MIME 类型就可以写成：</p>
<pre><code>vnd.android.cursor.dir/vnd.com.example.app.provider.table1 
</code></pre>
<p>对于 content://com.example.app.provider/table1/1这个内容 URI，它所对应的 MIME类型 就可以写成：</p>
<pre><code> vnd.android.cursor.item/vnd.com.example.app.provider.table1
</code></pre>
<h2 id="四、call-方法"><a href="#四、call-方法" class="headerlink" title="四、call 方法"></a>四、call 方法</h2><p>上面的方法都是访问或修改数据库的，如果需要跨进程访问里一个应用其他数据，例如sharePreference数据，可以通过call方法来调用自定义的函数。</p>
<h3 id="1-provider中复写call-方法，并且添加自定义的方法"><a href="#1-provider中复写call-方法，并且添加自定义的方法" class="headerlink" title="1.provider中复写call 方法，并且添加自定义的方法"></a>1.provider中复写call 方法，并且添加自定义的方法</h3><pre><code>@Override
public Bundle call(@NonNull String method, @Nullable String arg, @Nullable Bundle extras) &#123;
    switch (method)&#123;
        case &quot;getData&quot;:
            return getData();
        default:
            break;
    &#125;
    return null;
&#125;

//自定义函数
public Bundle getData()&#123;
    Bundle b = new Bundle();
    b.putString(&quot;name&quot;,&quot;call getData&quot;);
    return b;
&#125;
</code></pre>
<h3 id="2-查询方传入要调用的provider的自定义方法名和参数"><a href="#2-查询方传入要调用的provider的自定义方法名和参数" class="headerlink" title="2.查询方传入要调用的provider的自定义方法名和参数"></a>2.查询方传入要调用的provider的自定义方法名和参数</h3><pre><code>// uri格式最后一定要带一个 /
Uri uriCall = Uri.parse(&quot;content://&quot; + AUTHORITY + &quot;/&quot;);
Bundle b = getContentResolver().call(uriCall, &quot;getData&quot;, null, null);
Log.i(TAG, &quot;&quot;+b.get(&quot;name&quot;));
</code></pre>
<h2 id="五、MatrixCursor"><a href="#五、MatrixCursor" class="headerlink" title="五、MatrixCursor"></a>五、MatrixCursor</h2><p>ContentProvider的Query方法返回的是一个cursor，如果要对cursor中的数据做处理后再返回给查询的一方，可以通过MatrixCursor 对现有数据封装后返回。</p>
<pre><code>Cursor cursor1 = db.query(&quot;users&quot;, null, &quot;id = ?&quot;, new String[]&#123;&quot;1&quot;&#125;,null, null, null);
MatrixCursor m = new MatrixCursor(new String[]&#123;&quot;c1&quot;, &quot;c2&quot;, &quot;c3&quot;&#125;);
while(cursor1.moveToNext()) &#123;
    String name = cursor1.getString(1);
    int age = cursor1.getInt(2);
    String address = cursor1.getString(3);
    Log.i(TAG, name + &quot;age = &quot;+age + &quot;address = &quot;+address);
    m.addRow(new Object[]&#123;name, age, address&#125;);
&#125;
return m
</code></pre>
<p>Demo：</p>
<p>参考资料：<br>第一行代码——Android 郭霖<br><a href="https://stackoverflow.com/questions/17224766/what-is-getcontentresolver-call-and-how-to-use-it">https://stackoverflow.com/questions/17224766/what-is-getcontentresolver-call-and-how-to-use-it</a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/02/22/Notes/Android/FourComponents/Fragment%E5%AD%A6%E4%B9%A0%E7%90%86%E8%A7%A3%E5%8F%8A%E7%AE%80%E5%8D%95%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>本文主要介绍下Android Fragment的生命周期，相关的API以及和Activity通信的简单实践</p>
<h1 id="一、生命周期："><a href="#一、生命周期：" class="headerlink" title="一、生命周期："></a>一、生命周期：</h1><p><img src="https://leanote.com/api/file/getImage?fileId=5936c722ab64410e79001e16" alt="fragment生命周期"><br>Fragment创建销毁时，fragment和所依赖的activity生命周期的执行顺序，<strong>注意看log的TAG</strong></p>
<h2 id="1-创建时"><a href="#1-创建时" class="headerlink" title="1.创建时"></a>1.创建时</h2><pre><code>01-12 17:57:24.823 28028-28028/? I/ActivityLife: onCreate...
01-12 17:57:24.843 28028-28028/? I/FragmentLife: onAttach...
01-12 17:57:24.843 28028-28028/? I/FragmentLife: onCreate...
01-12 17:57:24.843 28028-28028/? I/FragmentLife: onCreateView...
01-12 17:57:24.843 28028-28028/? I/FragmentLife: onActivityCreated...
01-12 17:57:24.843 28028-28028/? I/ActivityLife: onStart...
01-12 17:57:24.843 28028-28028/? I/FragmentLife: onStart...
01-12 17:57:24.843 28028-28028/? I/ActivityLife: onResume...
01-12 17:57:24.843 28028-28028/? I/FragmentLife: onResume...
</code></pre>
<h2 id="2-销毁时"><a href="#2-销毁时" class="headerlink" title="2.销毁时"></a>2.销毁时</h2><pre><code>01-12 17:57:40.583 28028-28028/? I/FragmentLife: onPause...
01-12 17:57:40.583 28028-28028/? I/ActivityLife: onPause...
01-12 17:57:40.883 28028-28028/? I/FragmentLife: onStop...
01-12 17:57:40.883 28028-28028/? I/ActivityLife: onStop...
01-12 17:57:40.883 28028-28028/? I/FragmentLife: onDestroyView...
01-12 17:57:40.883 28028-28028/? I/FragmentLife: onDestroy...
01-12 17:57:40.883 28028-28028/? I/FragmentLife: onDetach...
01-12 17:57:40.883 28028-28028/? I/ActivityLife: onDestroy...
</code></pre>
<h1 id="二、Activity中，Fragment的2种加载方法"><a href="#二、Activity中，Fragment的2种加载方法" class="headerlink" title="二、Activity中，Fragment的2种加载方法"></a>二、Activity中，Fragment的2种加载方法</h1><h2 id="1-静态加载"><a href="#1-静态加载" class="headerlink" title="1.静态加载"></a>1.静态加载</h2><h3 id="（1）创建Fragment类和布局文件-fragment1-xml"><a href="#（1）创建Fragment类和布局文件-fragment1-xml" class="headerlink" title="（1）创建Fragment类和布局文件(fragment1.xml)"></a>（1）创建Fragment类和布局文件(fragment1.xml)</h3><pre><code>public class Fragment1 extends Fragment &#123;
    @Override
    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) &#123;
       return inflater.inflate(R.layout.fragment1, container, false);
    &#125;
&#125;

&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:background=&quot;#00ff00&quot; &gt;
    &lt;TextView
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;This is fragment 1&quot;
        android:textColor=&quot;#000000&quot;
        android:textSize=&quot;25sp&quot; /&gt;
&lt;/LinearLayout&gt; 
</code></pre>
<h3 id="（2）在activity布局文件（activity-main-xml）中添加fragment布局"><a href="#（2）在activity布局文件（activity-main-xml）中添加fragment布局" class="headerlink" title="（2）在activity布局文件（activity_main.xml）中添加fragment布局"></a>（2）在activity布局文件（activity_main.xml）中添加fragment布局</h3><pre><code>...
&lt;fragment
android:id=&quot;@+id/fragment1&quot;
android:name=&quot;com.example.sven.fragementdemo.Fragment1&quot;
android:layout_width=&quot;0dip&quot;
android:layout_height=&quot;match_parent&quot;
android:layout_weight=&quot;1&quot; /&gt;
...
</code></pre>
<h2 id="2-动态加载"><a href="#2-动态加载" class="headerlink" title="2.动态加载"></a>2.动态加载</h2><h3 id="1-在activity布局文件中添加FragmentLayout节点"><a href="#1-在activity布局文件中添加FragmentLayout节点" class="headerlink" title="(1) 在activity布局文件中添加FragmentLayout节点"></a>(1) 在activity布局文件中添加FragmentLayout节点</h3><pre><code>...
  &lt;FrameLayout
        android:id=&quot;@+id/fragment_container&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;&gt;
    &lt;/FrameLayout&gt;
...
</code></pre>
<h3 id="2-java代码中动态加载"><a href="#2-java代码中动态加载" class="headerlink" title="(2) java代码中动态加载"></a>(2) java代码中动态加载</h3><pre><code>...
  1.获取fragmentManager
FragmentManager fragmentManager = getFragmentManager();
  2.获取FragmentTransaction
FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();
  3.创建需要的Fragment
Fragment fragment = new Fragment1();
  4.动态添加fragment
    将创建的fragment添加到Activity布局文件中定义的占位符中（FrameLayout）
fragmentTransaction.add(R.id.fragment_container,fragment).commit();
...
</code></pre>
<h1 id="三、FragmentTransaction方法解析结合Fragment的生命周期"><a href="#三、FragmentTransaction方法解析结合Fragment的生命周期" class="headerlink" title="三、FragmentTransaction方法解析结合Fragment的生命周期"></a>三、FragmentTransaction方法解析结合Fragment的生命周期</h1><p>对Fragment的操作主要是通过调用FragmentTransaction类的方法进行的，FragmentTransaction的对象通常是通过getFragmentManager().beginTransaction()获取的</p>
<h2 id="1-add-amp-remove-replace"><a href="#1-add-amp-remove-replace" class="headerlink" title="1.add &amp; remove / replace"></a>1.add &amp; remove / replace</h2><h3 id="1-add-往Activity中添加一个Fragment，对应的fragment的生命周期如下："><a href="#1-add-往Activity中添加一个Fragment，对应的fragment的生命周期如下：" class="headerlink" title="(1) add 往Activity中添加一个Fragment，对应的fragment的生命周期如下："></a>(1) add 往Activity中添加一个Fragment，对应的fragment的生命周期如下：</h3><pre><code>06-13 12:01:43.406 1986-1986/? I/Fragment3: onAttach
06-13 12:01:43.406 1986-1986/? I/Fragment3: onCreate
06-13 12:01:43.406 1986-1986/? I/Fragment3: onCreateView
06-13 12:01:43.406 1986-1986/? I/Fragment3: onActivityCreated
06-13 12:01:43.406 1986-1986/? I/Fragment3: onStart
06-13 12:01:43.406 1986-1986/? I/Fragment3: onResume  
</code></pre>
<h3 id="2-remove-从Activity中移除一个Fragment，和add配对使用，通常是直接用replace"><a href="#2-remove-从Activity中移除一个Fragment，和add配对使用，通常是直接用replace" class="headerlink" title="(2) remove 从Activity中移除一个Fragment，和add配对使用，通常是直接用replace"></a>(2) remove 从Activity中移除一个Fragment，和add配对使用，通常是直接用replace</h3><pre><code>06-13 12:07:54.046 8765-8765/com.example.sven.fragementdemo I/Fragment3: onPause
06-13 12:07:54.046 8765-8765/com.example.sven.fragementdemo I/Fragment3: onStop
06-13 12:07:54.046 8765-8765/com.example.sven.fragementdemo I/Fragment3: onDestroyView
06-13 12:07:54.046 8765-8765/com.example.sven.fragementdemo I/Fragment3: onDestroy
06-13 12:07:54.046 8765-8765/com.example.sven.fragementdemo I/Fragment3: onDetach
</code></pre>
<h3 id="3-replace-使用另一个fragment替换当前的，先remove掉当前的再add新的，参考add和remove的过程"><a href="#3-replace-使用另一个fragment替换当前的，先remove掉当前的再add新的，参考add和remove的过程" class="headerlink" title="(3) replace 使用另一个fragment替换当前的，先remove掉当前的再add新的，参考add和remove的过程"></a>(3) replace 使用另一个fragment替换当前的，先remove掉当前的再add新的，参考add和remove的过程</h3><h2 id="2-attach-amp-detach"><a href="#2-attach-amp-detach" class="headerlink" title="2.attach &amp; detach"></a>2.attach &amp; detach</h2><h3 id="1-attach-重建view视图，添加到UI上并显示，和detach配合使用，显示一个被detach的fragment"><a href="#1-attach-重建view视图，添加到UI上并显示，和detach配合使用，显示一个被detach的fragment" class="headerlink" title="(1) attach 重建view视图，添加到UI上并显示，和detach配合使用，显示一个被detach的fragment"></a>(1) attach 重建view视图，添加到UI上并显示，和detach配合使用，显示一个被detach的fragment</h3><pre><code>06-13 11:57:46.376 29992-29992/com.example.sven.fragementdemo I/Fragment3: onCreateView
06-13 11:57:46.376 29992-29992/com.example.sven.fragementdemo I/Fragment3: onActivityCreated
06-13 11:57:46.376 29992-29992/com.example.sven.fragementdemo I/Fragment3: onStart
06-13 11:57:46.376 29992-29992/com.example.sven.fragementdemo I/Fragment3: onResume
</code></pre>
<h3 id="2-detach-会将view从UI中移除-和remove-不同-此时fragment的状态依然由FragmentManager维护，fragment的实例还存在，但是视图被销毁了"><a href="#2-detach-会将view从UI中移除-和remove-不同-此时fragment的状态依然由FragmentManager维护，fragment的实例还存在，但是视图被销毁了" class="headerlink" title="(2) detach 会将view从UI中移除,和remove()不同,此时fragment的状态依然由FragmentManager维护，fragment的实例还存在，但是视图被销毁了"></a>(2) detach 会将view从UI中移除,和remove()不同,此时fragment的状态依然由FragmentManager维护，fragment的实例还存在，但是视图被销毁了</h3><pre><code>06-13 11:58:13.486 29992-29992/com.example.sven.fragementdemo I/Fragment3: onPause
06-13 11:58:13.486 29992-29992/com.example.sven.fragementdemo I/Fragment3: onStop
06-13 11:58:13.486 29992-29992/com.example.sven.fragementdemo I/Fragment3: onDestroyView
</code></pre>
<h2 id="3-hide-amp-show"><a href="#3-hide-amp-show" class="headerlink" title="3.hide &amp; show"></a>3.hide &amp; show</h2><p>不涉及fragment生命周期，调试过程中没有看到想象中onPause、onStop、onResume函数的调用过程，hide时fragment的视图和实例都不会被销毁，只是视图可见与不可见的变化。账号登陆界面应该用的比较多，能够保存用户的输入，和detach区别就是detach不能够的保存界面的信息（例如EditText的输入），每次detach，attch时界面都会重绘</p>
<h2 id="4-commit"><a href="#4-commit" class="headerlink" title="4.commit"></a>4.commit</h2><p>提交对fragment的一系列操作。注意每一次对fragment的操作都要开一次事务，commit一次。commit和FragmentManager.beginTransaction()要配对使用。（很像数据库，暂时没深入研究）</p>
<h2 id="5-addToBackStack-String"><a href="#5-addToBackStack-String" class="headerlink" title="5.addToBackStack(String)"></a>5.addToBackStack(String)</h2><p>把当前事务的变化情况添加到回退栈,下节详细讲下</p>
<h2 id="tips："><a href="#tips：" class="headerlink" title="tips："></a>tips：</h2><h3 id="1-以上这些方法通常是在Activity中使用，依附于同一个Activity的多个fragment的各种切换"><a href="#1-以上这些方法通常是在Activity中使用，依附于同一个Activity的多个fragment的各种切换" class="headerlink" title="1.以上这些方法通常是在Activity中使用，依附于同一个Activity的多个fragment的各种切换"></a>1.以上这些方法通常是在Activity中使用，依附于同一个Activity的多个fragment的各种切换</h3><h3 id="2-fragment真正的实例其实是要通过FragmentTransaction-add，只有在add时才会执行onCreate，new的时候拿到只是一个引用-并没有执行生命周期函数"><a href="#2-fragment真正的实例其实是要通过FragmentTransaction-add，只有在add时才会执行onCreate，new的时候拿到只是一个引用-并没有执行生命周期函数" class="headerlink" title="2.fragment真正的实例其实是要通过FragmentTransaction.add，只有在add时才会执行onCreate，new的时候拿到只是一个引用 并没有执行生命周期函数"></a>2.fragment真正的实例其实是要通过FragmentTransaction.add，只有在add时才会执行onCreate，new的时候拿到只是一个引用 并没有执行生命周期函数</h3><h3 id="3-使用attach-detach-或者-hide-show-都需要new出对象，并且执行add"><a href="#3-使用attach-detach-或者-hide-show-都需要new出对象，并且执行add" class="headerlink" title="3.使用attach/detach 或者 hide/show 都需要new出对象，并且执行add"></a>3.使用attach/detach 或者 hide/show 都需要new出对象，并且执行add</h3><h3 id="4-add-remove-replace-hide-show后都要commit其效果才会在屏幕上显示出来"><a href="#4-add-remove-replace-hide-show后都要commit其效果才会在屏幕上显示出来" class="headerlink" title="4.add/remove/replace/hide/show后都要commit其效果才会在屏幕上显示出来"></a>4.add/remove/replace/hide/show后都要commit其效果才会在屏幕上显示出来</h3><h1 id="四、Fragment的回退栈"><a href="#四、Fragment的回退栈" class="headerlink" title="四、Fragment的回退栈"></a>四、Fragment的回退栈</h1><p>Fragment回退栈是用来保存每一次Fragment事务发生的变化，如果你将Fragment任务添加到回退栈，当点击back键时，将看到上一次的保存的Fragment，一旦Fragment完全从后退栈中弹出，用户再次点击后退键，则退出当前Activity，如果被移除的Fragment没有添加到回退栈，例如执行remove或者replace时，这个Fragment实例将会被销毁</p>
<p>理解以下3种情况 在同一个Actity中，fragment1 跳转到fragment2，然后按back退出时的不同情况</p>
<pre><code>public void jump2fragment2()&#123;
    FragmentTransaction fragmentTransaction = getFragmentManager().beginTransaction();
    fragment之间跳转时
    1.只采用replace 实例会被销毁 back键一次
    fragmentTransaction.replace(R.id.fragment_container,new Fragment2());
    fragmentTransaction.addToBackStack(null);

    2.把当前事务的变化情况添加到回退栈,视图会被销毁但是实例还在(back 2次)
    fragmentTransaction.replace(R.id.fragment_container,new Fragment2());
    fragmentTransaction.addToBackStack(null);

    3.采用hide方式 实例不会被销毁,视图也不会被销毁(back 2次)
    fragmentTransaction.hide(this);
    fragmentTransaction.add(R.id.fragment_container, new Fragment2());
    fragmentTransaction.addToBackStack(null);
    fragmentTransaction.commit();
&#125;
</code></pre>
<h1 id="五、Fragment与Activity之间的通信"><a href="#五、Fragment与Activity之间的通信" class="headerlink" title="五、Fragment与Activity之间的通信"></a>五、Fragment与Activity之间的通信</h1><h2 id="1-一般Fragment依附于Activity存在，因此与Activity之间的通信可以归纳为以下3点："><a href="#1-一般Fragment依附于Activity存在，因此与Activity之间的通信可以归纳为以下3点：" class="headerlink" title="1.一般Fragment依附于Activity存在，因此与Activity之间的通信可以归纳为以下3点："></a>1.一般Fragment依附于Activity存在，因此与Activity之间的通信可以归纳为以下3点：</h2><h3 id="（1）Fragment中可以通过getActivity得到当前绑定的Activity的实例，然后进行操作"><a href="#（1）Fragment中可以通过getActivity得到当前绑定的Activity的实例，然后进行操作" class="headerlink" title="（1）Fragment中可以通过getActivity得到当前绑定的Activity的实例，然后进行操作"></a>（1）Fragment中可以通过getActivity得到当前绑定的Activity的实例，然后进行操作</h3><p>例如你在想在某个fragment中通过activity拿到fragment1的数据可以这样做</p>
<pre><code>public void getfragment1text() &#123;
    getActivity().findViewById(R.id.fragment1_text)
&#125;
</code></pre>
<h3 id="2-如果你Activity中包含自己管理的Fragment的引用，可以通过引用直接访问所有的Fragment的public方法"><a href="#2-如果你Activity中包含自己管理的Fragment的引用，可以通过引用直接访问所有的Fragment的public方法" class="headerlink" title="(2) 如果你Activity中包含自己管理的Fragment的引用，可以通过引用直接访问所有的Fragment的public方法"></a>(2) 如果你Activity中包含自己管理的Fragment的引用，可以通过引用直接访问所有的Fragment的public方法</h3><h3 id="3-如果Activity中未保存任何Fragment的引用，那么没关系，每个Fragment都有一个唯一的TAG或者ID-可以通过getFragmentManager-findFragmentByTag-或者findFragmentById-获得任何Fragment实例，然后进行操作-fragment的id其实是无法设置的，add或replace时设置的id是其实要插入fragment所在ViewGroup的id，tag可以在add或replace时设置。https-stackoverflow-com-questions-9363072-android-set-fragment-id"><a href="#3-如果Activity中未保存任何Fragment的引用，那么没关系，每个Fragment都有一个唯一的TAG或者ID-可以通过getFragmentManager-findFragmentByTag-或者findFragmentById-获得任何Fragment实例，然后进行操作-fragment的id其实是无法设置的，add或replace时设置的id是其实要插入fragment所在ViewGroup的id，tag可以在add或replace时设置。https-stackoverflow-com-questions-9363072-android-set-fragment-id" class="headerlink" title="(3) 如果Activity中未保存任何Fragment的引用，那么没关系，每个Fragment都有一个唯一的TAG或者ID,可以通过getFragmentManager.findFragmentByTag()或者findFragmentById()获得任何Fragment实例，然后进行操作 fragment的id其实是无法设置的，add或replace时设置的id是其实要插入fragment所在ViewGroup的id，tag可以在add或replace时设置。https://stackoverflow.com/questions/9363072/android-set-fragment-id"></a>(3) 如果Activity中未保存任何Fragment的引用，那么没关系，每个Fragment都有一个唯一的TAG或者ID,可以通过getFragmentManager.findFragmentByTag()或者findFragmentById()获得任何Fragment实例，然后进行操作 fragment的id其实是无法设置的，add或replace时设置的id是其实要插入fragment所在ViewGroup的id，tag可以在add或replace时设置。<a href="https://stackoverflow.com/questions/9363072/android-set-fragment-id">https://stackoverflow.com/questions/9363072/android-set-fragment-id</a></h3><pre><code>public class MainActivity extends AppCompatActivity &#123;
    private static final String TAG = &quot;ActivityLife&quot;;
    private Fragment1 fragment = new Fragment1();
    @Override
    protected void onCreate(Bundle savedInstanceState) &#123;
        super.onCreate(savedInstanceState);
        printLog(&quot;onCreate...&quot;);
        setContentView(R.layout.activity_main);

        // 1.获取fragmentManager
        FragmentManager fragmentManager = getFragmentManager();
        // 2.获取FragmentTransaction
        FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();
        // 3.创建需要的Fragment
        // Fragment fragment = new Fragment1();
        // 4.动态添加fragment
        // 将创建的fragment添加到Activity布局文件中定义的占位符中（FrameLayout）
        fragmentTransaction.add(R.id.fragment_container, fragment, &quot;fragment1&quot;).commit();
    &#125;

    public void getFragmentMessage(View view)&#123;
        //1.针对第2种情况
        fragment.printSth();
        //2.针对第3种情况
        Fragment fragment = getFragmentManager().findFragmentByTag(&quot;fragment1&quot;);
        printLog(fragment.toString());
        fragment.onResume();
    &#125;
&#125;

public class Fragment1 extends Fragment &#123;
    ...
    public void printSth() &#123;
        Log.i(TAG,&quot;fragment3 printSth&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="（4）更复杂的用法参考："><a href="#（4）更复杂的用法参考：" class="headerlink" title="（4）更复杂的用法参考："></a>（4）更复杂的用法参考：</h3><p><a href="http://blog.csdn.net/lmj623565791/article/details/37992017">http://blog.csdn.net/lmj623565791/article/details/37992017</a></p>
<h2 id="2-应用场景主要就是通过Activity去管理多个Fragment的状态"><a href="#2-应用场景主要就是通过Activity去管理多个Fragment的状态" class="headerlink" title="2.应用场景主要就是通过Activity去管理多个Fragment的状态"></a>2.应用场景主要就是通过Activity去管理多个Fragment的状态</h2><h2 id="思路如下："><a href="#思路如下：" class="headerlink" title="思路如下："></a>思路如下：</h2><h3 id="1-让各个Fragment注册一个监听接口，让Activity去implements这个监听接口"><a href="#1-让各个Fragment注册一个监听接口，让Activity去implements这个监听接口" class="headerlink" title="(1) 让各个Fragment注册一个监听接口，让Activity去implements这个监听接口"></a>(1) 让各个Fragment注册一个监听接口，让Activity去implements这个监听接口</h3><h3 id="2-在Activity中new出各个Fragment的对象，获取引用"><a href="#2-在Activity中new出各个Fragment的对象，获取引用" class="headerlink" title="(2) 在Activity中new出各个Fragment的对象，获取引用"></a>(2) 在Activity中new出各个Fragment的对象，获取引用</h3><h3 id="3-将Fragment中的事件通过listener传递到Activity中，在Fragment中通过getActivity去调用监听方法"><a href="#3-将Fragment中的事件通过listener传递到Activity中，在Fragment中通过getActivity去调用监听方法" class="headerlink" title="(3) 将Fragment中的事件通过listener传递到Activity中，在Fragment中通过getActivity去调用监听方法"></a>(3) 将Fragment中的事件通过listener传递到Activity中，在Fragment中通过getActivity去调用监听方法</h3><h2 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h2><h3 id="Fragment中的按钮的事件响应时不能通过在配置文件中加onClick属性找到的，必须注册onClickListenr-有2种方式"><a href="#Fragment中的按钮的事件响应时不能通过在配置文件中加onClick属性找到的，必须注册onClickListenr-有2种方式" class="headerlink" title="Fragment中的按钮的事件响应时不能通过在配置文件中加onClick属性找到的，必须注册onClickListenr(有2种方式)"></a>Fragment中的按钮的事件响应时不能通过在配置文件中加onClick属性找到的，必须注册onClickListenr(有2种方式)</h3><p>原因参考：<a href="http://blog.csdn.net/Zafir6453/article/details/51383915">http://blog.csdn.net/Zafir6453/article/details/51383915</a></p>
<h2 id="3-以上这些自己写了个Demo，方便大家调试和学习"><a href="#3-以上这些自己写了个Demo，方便大家调试和学习" class="headerlink" title="3.以上这些自己写了个Demo，方便大家调试和学习"></a>3.以上这些自己写了个Demo，方便大家调试和学习</h2><p><a href="http://download.csdn.net/detail/time_traveller14/9870932">http://download.csdn.net/detail/time_traveller14/9870932</a></p>
<h3 id="1-生命周期，回退栈，参考fragment1-fragment2-MainActivity"><a href="#1-生命周期，回退栈，参考fragment1-fragment2-MainActivity" class="headerlink" title="1.生命周期，回退栈，参考fragment1,fragment2,MainActivity"></a>1.生命周期，回退栈，参考fragment1,fragment2,MainActivity</h3><h3 id="2-FragmentTransaction及和Activity通信（fragment中不同的按钮事件响应）-参考fragment3-fragment4-Main2Activity"><a href="#2-FragmentTransaction及和Activity通信（fragment中不同的按钮事件响应）-参考fragment3-fragment4-Main2Activity" class="headerlink" title="2.FragmentTransaction及和Activity通信（fragment中不同的按钮事件响应） 参考fragment3,fragment4, Main2Activity"></a>2.FragmentTransaction及和Activity通信（fragment中不同的按钮事件响应） 参考fragment3,fragment4, Main2Activity</h3><h1 id="六-还未理解问题："><a href="#六-还未理解问题：" class="headerlink" title="六.还未理解问题："></a>六.还未理解问题：</h1><h3 id="1-回退栈的使用场景，有了hide和detach为何还要加这个，仅仅是为了多按一次back键？"><a href="#1-回退栈的使用场景，有了hide和detach为何还要加这个，仅仅是为了多按一次back键？" class="headerlink" title="1.回退栈的使用场景，有了hide和detach为何还要加这个，仅仅是为了多按一次back键？"></a>1.回退栈的使用场景，有了hide和detach为何还要加这个，仅仅是为了多按一次back键？</h3><h3 id="2-hide和show为何没有onPause和onResume的过程，hide为何不执行onPause，onStop呢？"><a href="#2-hide和show为何没有onPause和onResume的过程，hide为何不执行onPause，onStop呢？" class="headerlink" title="2.hide和show为何没有onPause和onResume的过程，hide为何不执行onPause，onStop呢？"></a>2.hide和show为何没有onPause和onResume的过程，hide为何不执行onPause，onStop呢？</h3><h3 id="3-remove-的真正含义销毁还是出栈，看许多资料解释是销毁掉，但为何remove掉，commit完fragment-null，还能够通过tag获取到，但是去寻找fragment的视图元素会报错？"><a href="#3-remove-的真正含义销毁还是出栈，看许多资料解释是销毁掉，但为何remove掉，commit完fragment-null，还能够通过tag获取到，但是去寻找fragment的视图元素会报错？" class="headerlink" title="3.remove 的真正含义销毁还是出栈，看许多资料解释是销毁掉，但为何remove掉，commit完fragment!=null，还能够通过tag获取到，但是去寻找fragment的视图元素会报错？"></a>3.remove 的真正含义销毁还是出栈，看许多资料解释是销毁掉，但为何remove掉，commit完fragment!=null，还能够通过tag获取到，但是去寻找fragment的视图元素会报错？</h3><h3 id="4-屏幕旋转时，已经判断了onSavedInstance-null，为何还会继续，log中-onCreate-onCreateView会执行，要结合activity？"><a href="#4-屏幕旋转时，已经判断了onSavedInstance-null，为何还会继续，log中-onCreate-onCreateView会执行，要结合activity？" class="headerlink" title="4.屏幕旋转时，已经判断了onSavedInstance==null，为何还会继续，log中 onCreate onCreateView会执行，要结合activity？"></a>4.屏幕旋转时，已经判断了onSavedInstance==null，为何还会继续，log中 onCreate onCreateView会执行，要结合activity？</h3><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a href="https://developer.android.com/guide/components/fragments.html">https://developer.android.com/guide/components/fragments.html</a><br>郭霖大神 <a href="http://blog.csdn.net/guolin_blog/article/details/8881711">http://blog.csdn.net/guolin_blog/article/details/8881711</a><br>鸿洋大神 <a href="http://blog.csdn.net/lmj623565791/article/details/37970961">http://blog.csdn.net/lmj623565791/article/details/37970961</a></p>
<h3 id="自己的第一篇技术博客，请大家多多指教，最后不理解的问题，欢迎讨论！"><a href="#自己的第一篇技术博客，请大家多多指教，最后不理解的问题，欢迎讨论！" class="headerlink" title="自己的第一篇技术博客，请大家多多指教，最后不理解的问题，欢迎讨论！"></a>自己的第一篇技术博客，请大家多多指教，最后不理解的问题，欢迎讨论！</h3>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/02/24/Notes/Android/IPC/2.%20IPC%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="Android中IPC的方式："><a href="#Android中IPC的方式：" class="headerlink" title="Android中IPC的方式："></a>Android中IPC的方式：</h1><pre><code>1.Bundle
2.文件共享：适合在对数据同步要求不高的进程中通信
3.Messenger 和 Message
4.AIDL
5.contentProvider 数据共享,数据库
6.Socket （未学习）
</code></pre>
<h1 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL:"></a>AIDL:</h1><h2 id="1-支持的数据类型："><a href="#1-支持的数据类型：" class="headerlink" title="1.支持的数据类型："></a>1.支持的数据类型：</h2><pre><code>1.基本数据类型（int、long、char、boolean、double等）
2.String和charSequence
3.List只支持ArrayList （CopyOnWriteArrayList支持并发）
4.Map 只支持 HashMap （ConcurrentHashMap 支持并发）
5.Parcelable 实现了Parcelable接口的对象
6.AIDL 接口本身
</code></pre>
<h2 id="2-RemoteCallbackList：监听者的注册与解注册"><a href="#2-RemoteCallbackList：监听者的注册与解注册" class="headerlink" title="2.RemoteCallbackList：监听者的注册与解注册"></a>2.RemoteCallbackList：监听者的注册与解注册</h2><pre><code>private RemoteCallbackList&lt;IOnNewBookArrivedListener&gt; mListenerList = new RemoteCallbackList&lt;IOnNewBookArrivedListener&gt;();
 
mListenerList.register(listener);

mListenerList.unregister(listener);

final int N = mListenerList.beginBroadcast();
for(int i = 0; i &lt;N ;i++)&#123; IOnNewBookArrivedListener l = mListenerList.getBroadcastItem(i); 
if (l != null)&#123; Log.i(TAG, &quot;real onNewBookArrived...&quot;); 
try &#123; l.onNewBookArrived(book); &#125;catch (RemoteException e)&#123; e.printStackTrace(); &#125; &#125; &#125; mListenerList.finishBroadcast(); 
</code></pre>
<h2 id="3-不要在UI线程中调用远程的耗时方法-例如：在onServiceConnected-和-onServiceDisconnected中调用"><a href="#3-不要在UI线程中调用远程的耗时方法-例如：在onServiceConnected-和-onServiceDisconnected中调用" class="headerlink" title="3.不要在UI线程中调用远程的耗时方法 例如：在onServiceConnected 和 onServiceDisconnected中调用"></a>3.不要在UI线程中调用远程的耗时方法 例如：在onServiceConnected 和 onServiceDisconnected中调用</h2><h2 id="4-监听Binder意外死亡的2中方式"><a href="#4-监听Binder意外死亡的2中方式" class="headerlink" title="4.监听Binder意外死亡的2中方式"></a>4.监听Binder意外死亡的2中方式</h2><pre><code>1.onServiceDisconnected 
2.给binder设置DeathRecipient private IBookManager iBookManager; 
privateServiceConnection mServiceConn = new ServiceConnection() &#123; 
    @Override public void onServiceConnected(ComponentName name, IBinderservice) &#123; 
        iBookManager = IBookManager.Stub.asInterface(service); 
        try &#123; service.linkToDeath(mDeathRecipient,0); ... 
    &#125; catch(RemoteException e) &#123; 
        e.printStackTrace(); 
        &#125; 
    &#125; 
    @Override public void onServiceDisconnected(ComponentName name) &#123;
    Log.i(TAG,&quot;onServiceDisconnected ...&quot;); 
        iBookManager = null; Intent intent = new Intent(MainActivity.this,BookManagerService.class); bindService(intent,mServiceConn, Context.BIND_AUTO_CREATE); &#125; 
    &#125;; 
    private IBinder.DeathRecipientmDeathRecipient = new IBinder.DeathRecipient()&#123; 
    @Override 
    public void binderDied() &#123;
        Log.i(TAG,&quot;binderDied ...&quot;);
        if(iBookManager == null) return; 
        iBookManager.asBinder().unlinkToDeath(mDeathRecipient, 0); 
        iBookManager = null; //rebindremote service &#125; 
    &#125;; 
&#125;
</code></pre>
<h2 id="5-连接服务时添加权限验证-1-onBind：验证不通过返回null，无法绑定服务2-onTransact：验证失败返回false，服务端不会执行AIDL中的方法-…"><a href="#5-连接服务时添加权限验证-1-onBind：验证不通过返回null，无法绑定服务2-onTransact：验证失败返回false，服务端不会执行AIDL中的方法-…" class="headerlink" title="5.连接服务时添加权限验证 1.onBind：验证不通过返回null，无法绑定服务2.onTransact：验证失败返回false，服务端不会执行AIDL中的方法 …"></a>5.连接服务时添加权限验证 1.onBind：验证不通过返回null，无法绑定服务2.onTransact：验证失败返回false，服务端不会执行AIDL中的方法 …</h2><p>1.服务端定义权限并且声明服务需要该权限<br>    <permission android:name="com.example.zxw.self.permission"/><br>    <service android:permission="com.example.zxw.self.permission" android:name=".BookManagerService" android:enabled="true" android:exported="true" android:process=":remote">    </p>
<p>2.客户端绑定时：</p>
<pre><code>&lt;uses-permission android:name=&quot;com.example.zxw.self.permission&quot;/&gt;
</code></pre>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>private Binder mBinder = new IBookManager.Stub()&#123;
    ...
    @Override
    public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;
        Log.i(TAG, &quot;onTransact ...&quot;);
            int check = checkCallingOrSelfPermission(&quot;com.example.zxw.self.permission&quot;);
            if(check == PackageManager.PERMISSION_DENIED)&#123;
                return false;
            &#125;
        return super.onTransact(code, data, reply, flags);
    &#125;
&#125;;

@Override
public IBinder onBind(Intent intent) &#123;
    Log.i(TAG,&quot;onBind ...&quot;);
    int check = checkCallingOrSelfPermission(&quot;com.example.zxw.self.permission&quot;);
    Log.i(TAG,&quot;check = &quot;+check);
    if(check == PackageManager.PERMISSION_DENIED)&#123;
        return null;
    &#125;
    return mBinder;
&#125;
</code></pre>
<h3 id="区别：都是无法调用aidl的方法"><a href="#区别：都是无法调用aidl的方法" class="headerlink" title="区别：都是无法调用aidl的方法"></a>区别：都是无法调用aidl的方法</h3><pre><code>      但是onbind 中校验不过根本没有连接
      onTransact 有连接，客户端能监听到连接的断开
</code></pre>
<h2 id="6-onDestroy中解绑"><a href="#6-onDestroy中解绑" class="headerlink" title="6.onDestroy中解绑"></a>6.onDestroy中解绑</h2><pre><code>protected void onDestroy() &#123;
    super.onDestroy();
    Log.i(TAG, &quot;onDestroy&quot;);
    if(iBookManager != null &amp;&amp; iBookManager.asBinder().isBinderAlive())&#123;
        try &#123;
            iBookManager.unregesterListener(mOnNewBookArrivedListener);
        &#125; catch (RemoteException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
    unbindService(mServiceConn);
    iBookManager = null;
&#125;
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>APK签名机制</title>
    <url>/2021/03/20/Notes/Android/Framework/APK%E7%AD%BE%E5%90%8D%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="APK签名机制"><a href="#APK签名机制" class="headerlink" title="APK签名机制"></a>APK签名机制</h1><h1 id="1、什么是apk签名"><a href="#1、什么是apk签名" class="headerlink" title="1、什么是apk签名"></a>1、什么是apk签名</h1><p>android应用在安装过程中会对apk进行签名校验，主要用于验证apk的可靠性、安全性以及唯一性，保证apk是有可信性的发布者发布，防止发布后被篡改；另外在apk升级时除了包名一致，签名也要一致。要了解签名和验签过程需要先了解以下几个基本概念。</p>
<h2 id="1-1、基本概念"><a href="#1-1、基本概念" class="headerlink" title="1.1、基本概念"></a>1.1、基本概念</h2><h3 id="1-1-1、数字摘要"><a href="#1-1-1、数字摘要" class="headerlink" title="1.1.1、数字摘要"></a>1.1.1、数字摘要</h3><p>数字摘要就是采用单向Hash函数将需要加密的明文“摘要”成一串固定长度（128位）的密文这一串密文又称为数字指纹，它有固定的长度，而且不同的明文摘要成密文，其结果总是不同的，而同样的明文其摘要必定一致。常用的数字摘要技术（Digital Digest）也称作为安全HASH编码法（SHA：Secure Hash Algorithm）。对所要传输的数据进行运算生成信息摘要，它并不是一种加密机制，但却能产生信息的数字”指纹”，它的目的是为了确保数据没有被修改或变化，保证信息的完整性不被破坏。</p>
<h3 id="1-1-2、数字签名"><a href="#1-1-2、数字签名" class="headerlink" title="1.1.2、数字签名"></a>1.1.2、数字签名</h3><p>数字签名的作用就是保证信息传输的完整性、发送者的身份认证、防止交易中的抵赖发生。<strong>数字签名技术是将摘要信息用发送者的私钥加密</strong>，与原文一起传送给接收者。接收者只有<strong>用发送者的公钥才能解密被加密的摘要信息然后用HASH函数对收到的原文产生一个摘要信息，与解密的摘要信息对比</strong>。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。</p>
<h3 id="1-1-3、数字证书"><a href="#1-1-3、数字证书" class="headerlink" title="1.1.3、数字证书"></a>1.1.3、数字证书</h3><p>数字证书是由权威公证的第三方认证机构（即CA，Certificate Authority）负责签发和管理的、个人或企业的网络数字身份证明。A的数字签名可以类比为现实世界中的签名，用来证明一个文件或者消息是A签署的，通常是使用A的私钥对消息摘要加密而得到，其他人可以使用A的公钥对数字签名进行验证。但是怎么才能信任A的公钥呢？让A自己证明自己是一件很难的事情，因此就需要第三方来证明，这就是数字证书的意义所在。</p>
<h2 id="1-2、apk签名和验签原理"><a href="#1-2、apk签名和验签原理" class="headerlink" title="1.2、apk签名和验签原理"></a>1.2、apk签名和验签原理</h2><p><img src="/pics/image-20201216113655542.png" alt="image-20201216113655542"></p>
<h3 id="1-2-1、APK签名"><a href="#1-2-1、APK签名" class="headerlink" title="1.2.1、APK签名"></a>1.2.1、APK签名</h3><ol>
<li>计算摘要：使用数字摘要算法计算出apk的摘要；</li>
<li>签名：通过私钥对摘要进行加密，加密后的信息就是签名；</li>
<li>写入签名：将签名信息、证书以及公钥写入到文件中。</li>
</ol>
<h3 id="1-2-2、APK验签"><a href="#1-2-2、APK验签" class="headerlink" title="1.2.2、APK验签"></a>1.2.2、APK验签</h3><ol>
<li>解密签名：通过公钥解密签名信息获得摘要；</li>
<li>计算摘要：使用摘要算法从接收的数据中计算摘要；</li>
<li>比较摘要：比较解密出的摘要和通过文件计算的摘要，若一致，则校验通过。</li>
</ol>
<p>接下来介绍下现有的4种apk签名的方式。</p>
<h1 id="2、v1-签名"><a href="#2、v1-签名" class="headerlink" title="2、v1 签名"></a>2、v1 签名</h1><p>V1签名又称为JAR签名，是对jar包进行签名的一种机制，由于jar包apk本质上都是zip包，所以可以应用到对apk的签名。解压apk后，META-INF目录中存放的就是签名相关的文件。</p>
<h2 id="2-1-v1签名过程"><a href="#2-1-v1签名过程" class="headerlink" title="2.1 v1签名过程"></a>2.1 v1签名过程</h2><p><img src="/pics/image-20201221200634926.png" alt="image-20201221200634926"></p>
<p>MANIFEST.MF、CERT.SF、CERT.RSA是签名过程中生成的文件（<a href="https://android.googlesource.com/platform/build/+/7e447ed/tools/signapk/SignApk.java">apksigner源码</a>），作用如下：</p>
<h3 id="2-1-1、MANIFEST-MF"><a href="#2-1-1、MANIFEST-MF" class="headerlink" title="2.1.1、MANIFEST.MF"></a>2.1.1、MANIFEST.MF</h3><p>对APK中所有文件计算摘要保存到该文件中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Manifest-Version: <span class="number">1.0</span></span><br><span class="line">Created-By: <span class="number">1.8</span><span class="number">.0_212</span> (Oracle Corporation)</span><br><span class="line"></span><br><span class="line">Name: AndroidManifest.xml <span class="comment">//apk各个文件的摘要</span></span><br><span class="line">SHA1-Digest: GpiU1HOPO9rxpTPh43kG1XVG8iw=</span><br><span class="line"></span><br><span class="line">Name: META-INF/BdTuringSdk_cnRelease.kotlin_module</span><br><span class="line">SHA1-Digest: PVHPdoZ9+09Zq0PF+eJz0yRVf10=</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="2-1-2、CERT-SF"><a href="#2-1-2、CERT-SF" class="headerlink" title="2.1.2、CERT.SF"></a>2.1.2、CERT.SF</h3><ul>
<li>SHA1-Digest-Manifest-Main-Attributes：MANIFEST.MF主属性的数据摘要。</li>
<li>SHA1-Digest-Manifest： MANIFEST.MF 文件计算摘要。</li>
<li>SHA1-Digest：MANIFEST.MF 的各个条目摘要。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Signature-Version: <span class="number">1.0</span></span><br><span class="line">SHA1-Digest-Manifest-Main-Attributes: TN5zBsqBLAij6alOeMWe+Ejwd4g= <span class="comment">//主属性记录了MANIFEST.MF文件所有主属性的数据摘要</span></span><br><span class="line">SHA1-Digest-Manifest: PBUX5Kag9TIOJy4jZ57vwuAur1Y= <span class="comment">//整个MANIFEST.MF文件的数据摘要</span></span><br><span class="line">Created-By: <span class="number">1.8</span><span class="number">.0_45</span>-internal (Oracle Corporation)</span><br><span class="line"></span><br><span class="line">Name: res/layout/ac.xml</span><br><span class="line">SHA1-Digest: mYQig54fsd3pTRQTmTwMD2oO5CM= <span class="comment">//MANIFEST.MF 各个条目的摘要</span></span><br></pre></td></tr></table></figure>

<h3 id="2-1-3、CERT-RSA"><a href="#2-1-3、CERT-RSA" class="headerlink" title="2.1.3、CERT.RSA"></a>2.1.3、CERT.RSA</h3><p><strong>对CERT.SF 文件的摘要通过私钥加密生成校验串</strong>, 然后和<strong>数字签名、公钥、数字证书</strong>一同写入 CERT.RSA 中保存。很多文章将校验串描述成签名，这样的理解是不准确的。可以比较2个同一个公司出品的apk的RSA文件，你会发现可能除了结尾部分不太一样外，其他部分基本相同，原因其实就是同一个公司出品的apk，它的签名，证书，公钥通常都是相同的，只有通过私钥加密的CERT.SF的摘要不同。 如下图：</p>
<p><img src="/pics/image-20201217160514944.png" alt="image-20201217160514944"></p>
<h4 id="1、查看证书与公钥"><a href="#1、查看证书与公钥" class="headerlink" title="1、查看证书与公钥"></a>1、查看证书与公钥</h4><p>1、将.rsa 后缀改为.p7b文件，双击直接打开</p>
<p>2、openssl 命令查看证书信息（公钥在证书信息中）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 查看.RSA文件中证书信息</span><br><span class="line">openssl pkcs7 -inform DER -in XXX.RSA -noout -print_certs -text</span><br><span class="line"></span><br><span class="line">// 查看本地证书的公钥和私钥</span><br><span class="line">keytool -list -rfc --keystore test.jks | openssl x509 -inform pem -pubkey</span><br></pre></td></tr></table></figure>

<p>通过一个实例去理解一下这两种方式的区别和联系。</p>
<ol>
<li>使用AS或keytool生成一个.jks签名文件； <a href="https://www.jianshu.com/p/b28a5be05029">Android studio 如何生成jks签名文件</a></li>
<li>使用签名文件对apk进行签名；</li>
<li>通过相关命令查看.jks文件以及解压apk中的.rsa 文件。</li>
</ol>
<p><img src="/pics/image-20201217162850396.png" alt="image-20201217162850396"></p>
<h4 id="2、查看签名"><a href="#2、查看签名" class="headerlink" title="2、查看签名"></a>2、查看签名</h4><p>其实能看到也是签名的摘要，不是真正的签名。</p>
<ol>
<li>将.rsa 后缀改为.p7b文件，双击直接打开</li>
<li>使用keytool的命令查看.RSA文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">keytool -printcert -file xxx.RSA</span><br></pre></td></tr></table></figure>

<p><strong>证书信息：</strong></p>
<p><img src="/pics/image-20201217163225037.png" alt="image-20201217163225037"></p>
<h2 id="2-2、v1验签过程"><a href="#2-2、v1验签过程" class="headerlink" title="2.2、v1验签过程"></a>2.2、<a href="https://android.googlesource.com/platform/frameworks/base/+/android-5.1.1_r38/services/core/java/com/android/server/pm/PackageManagerService.java">v1验签过程</a></h2><ol>
<li><p><strong>首先校验cert.sf文件的签名</strong></p>
<p>计算cert.sf文件的摘要，与通过签名者公钥解密CERT.RSA文件得到的摘要进行对比，如果一致则进入下一步；</p>
</li>
<li><p><strong>校验manifest.mf文件的完整性</strong></p>
<p>计算manifest.mf文件的摘要，与cert.sf主属性中记录的摘要进行对比，如一致则逐一校验mf文件各个条目的完整性；</p>
</li>
<li><p><strong>校验apk中每个文件的完整性</strong></p>
<p>逐一计算apk中每个文件（META-INF目录除外）的摘要，与mf中的记录进行对比，如全部一致，刚校验通过；</p>
</li>
<li><p><strong>校验签名的一致性</strong></p>
<p>如果是升级安装，还需校验证书签名是否与已安装app一致。</p>
</li>
</ol>
<h2 id="2-3、v1签名的劣势"><a href="#2-3、v1签名的劣势" class="headerlink" title="2.3、v1签名的劣势"></a>2.3、v1签名的劣势</h2><ol>
<li><p>签名校验速度慢</p>
<p>校验过程中需要对apk中所有文件进行摘要计算，在apk资源很多、性能较差的机器上签名校验会花费较长时间，导致安装速度慢；</p>
</li>
<li><p>完整性保障不够</p>
<p>META-INF目录用来存放签名，自然此目录本身是不计入签名校验过程的，可以随意在这个目录中添加文件，比如一些快速批量打包方案就选择在这个目录中添加渠道文件。</p>
<p>为了解决这两个问题，Android 7.0推出了全新的签名方案V2，下面介绍下v2签名。</p>
</li>
</ol>
<h1 id="2、v2签名"><a href="#2、v2签名" class="headerlink" title="2、v2签名"></a>2、v2签名</h1><h2 id="2-1、ZIP文件结构"><a href="#2-1、ZIP文件结构" class="headerlink" title="2.1、ZIP文件结构"></a>2.1、ZIP文件结构</h2><p>我们先来了解下v1签名文件的apk结构，也就是zip文件的结构。</p>
<p><img src="/pics/image-20201217175101791.png" alt="image-20201217175101791"></p>
<p>zip文件分为3部分：</p>
<ol>
<li><p><strong>数据区</strong></p>
<p>主要存放压缩的文件数据</p>
</li>
<li><p><strong>中央目录</strong></p>
<p>存放数据区压缩文件的索引</p>
</li>
<li><p><strong>中央目录结尾记录</strong></p>
<p>存放中央目录的文件索引</p>
</li>
</ol>
<p>查找压缩文件中数据可以先中央目录起始偏移量和size即可定位到中央目录，再遍历中央目录条目，根据本地文件头的起始偏移量即可在数据区中找到相应数据。</p>
<h2 id="2-2、v2签名原理"><a href="#2-2、v2签名原理" class="headerlink" title="2.2、v2签名原理"></a>2.2、v2签名原理</h2><p>JAR签名是在apk文件中添加META-INF目录，即需要修改数据区、中央目录，此外，添加文件后会导致中央目录大小和偏移量发生变化，还需要修改中央目录结尾记录。</p>
<p>v2方案为加强数据完整性保证，不在数据区和中央目录中插入数据，选择在 数据区和中央目录之间插入一个APK签名分块，从而保证了原始数据的完整性。</p>
<img src="/pics/image-20201217174414400.png" alt="image-20201217174414400" style="zoom:150%;" />

<p>APK 签名方案 v2 负责保护第 1、3、4 部分的完整性，以及第 2 部分包含的“APK 签名方案 v2 分块”中的 <code>signed data</code> 分块的完整性。第 1、3 和 4 部分的完整性通过其内容的一个或多个摘要来保护，这些摘要存储在 <code>signed data</code> 分块中，而这些分块则通过一个或多个签名来保护。</p>
<h3 id="2-2-1、APK摘要计算"><a href="#2-2-1、APK摘要计算" class="headerlink" title="2.2.1、APK摘要计算"></a>2.2.1、APK摘要计算</h3><p><img src="/pics/image-20201217202801891.png" alt="image-20201217202801891"></p>
<p>第 1、3 和 4 部分的摘要采用以下计算方式：</p>
<ol>
<li>将APK拆分成多个大小为 1 MB大小的连续块，最后一个块可能小于1M。之所以分块，是为了可以通过并行计算摘要以加快计算速度；</li>
<li>计算块的摘要，以字节 0xa5 + 块的长度（字节数） + 块的内容 进行计算；</li>
<li>计算整体摘要，字节 0x5a + 块数 + 块的摘要的连接（按块在 APK 中的顺序）进行计算。</li>
</ol>
<h2 id="2-3、签名过程"><a href="#2-3、签名过程" class="headerlink" title="2.3、签名过程"></a>2.3、签名过程</h2><p>介绍APK签名过程前，需要先了解下使用apk签名块的结构和v2签名块的结构。</p>
<h3 id="2-3-1、APKSigning-Block"><a href="#2-3-1、APKSigning-Block" class="headerlink" title="2.3.1、APKSigning Block"></a>2.3.1、APKSigning Block</h3><p>APK签名分块包含了4部分：分块长度、ID-VALUE序列、分块长度、固定magic值。其中APK 签名方案 <strong>v2分块</strong>存放在ID为<strong>0x7109871a</strong>的ID-VALUE区中。</p>
<p><img src="/pics/image-20201217212653708.png" alt="image-20201217212653708"></p>
<h3 id="2-3-2、v2-Block"><a href="#2-3-2、v2-Block" class="headerlink" title="2.3.2、v2 Block"></a>2.3.2、v2 Block</h3><p>v2分块主要由签名数据，数字签名以及公钥组成，具体结构如下。</p>
<p><img src="/pics/image-20201219104001970.png" alt="image-20201219104001970"></p>
<h3 id="2-3-3、签名过程"><a href="#2-3-3、签名过程" class="headerlink" title="2.3.3、签名过程"></a>2.3.3、签名过程</h3><p>V2签名块的生成可参考<a href="https://android.googlesource.com/platform/build/+/dd910c5/tools/signapk/src/com/android/signapk/ApkSignerV2.java">ApkSignerV2</a>，整体结构和流程如下图所示：</p>
<p><img src="/pics/image-20201219153651713.png" alt="image-20201219153651713"></p>
<h2 id="2-4、v2验签过程"><a href="#2-4、v2验签过程" class="headerlink" title="2.4、v2验签过程"></a>2.4、v2验签过程</h2><p>在 Android 7.0 及更高版本中，可以根据 APK 签名方案 v2+ 或 JAR 签名（v1 方案）验证 APK。更低版本的平台会忽略 v2 签名，仅验证 v1 签名。</p>
<p><img src="/pics/image-20201221204054757.png" alt="image-20201221204054757"></p>
<h3 id="2-4-1、v2签名块定位"><a href="#2-4-1、v2签名块定位" class="headerlink" title="2.4.1、v2签名块定位"></a>2.4.1、v2签名块定位</h3><p>APK签名分块包含了4部分：分块长度、ID-VALUE序列、分块长度、固定magic值。其中APK 签名方案 v2分块存放在ID为0x7109871a的键值对中。</p>
<p>在进行签名校验时，先找到zip中央目录结尾记录，从该记录中找到中央目录起始偏移量，再通过magic值（APK Sig Block 42）即可确定前方可能是APK签名分块，再通过前后两个分块长度字段，即可确定APK签名分块的位置，最后通过ID（0x7109871a）定位APK 签名方案 v2分块位置。</p>
<h3 id="2-4-2、v2-验证过程"><a href="#2-4-2、v2-验证过程" class="headerlink" title="2.4.2、v2 验证过程"></a>2.4.2、v2 验证过程</h3><p><img src="/pics/image-20210319101806758.png" alt="image-20210319101806758"></p>
<h3 id="2-4-3、防回滚保护"><a href="#2-4-3、防回滚保护" class="headerlink" title="2.4.3、防回滚保护"></a>2.4.3、防回滚保护</h3><p><img src="/pics/image-20210319102400692.png" alt="image-20210319102400692"></p>
<h1 id="3、v3签名"><a href="#3、v3签名" class="headerlink" title="3、v3签名"></a>3、<a href="https://source.android.com/security/apksigning/v3.html">v3签名</a></h1><p>v3和v2一样签名块存储在中央目录区之前，v3 签名会存储的ID为<strong>0xf05368c0</strong>，新增了 ID为<strong>0x3ba06f8c</strong> 的proof-of-rotation 结构中用来支持应用替换签名证书。在 Android 9 及更高版本中，可以根据 APK 签名方案 v3、v2 或 v1 验证 APK。较旧的平台会忽略 v3 签名而尝试验证 v2 签名，然后尝试验证 v1 签名。</p>
<p><img src="/pics/image-20201222203051481.png" alt="image-20201222203051481"></p>
<h1 id="4、v4签名"><a href="#4、v4签名" class="headerlink" title="4、v4签名"></a>4、v4签名</h1><p>Android 11 通过 APK 签名方案 v4 支持与流式传输兼容的签名方案（来支持增量安装APK）。v4 签名基于根据 APK 的所有字节计算得出的 Merkle 哈希树。</p>
<p><a href="https://source.android.google.cn/security/apksigning/v4">https://</a><a href="https://source.android.google.cn/security/apksigning/v4">source.android.google.cn/security/apksigning/v4</a> </p>
<h1 id="5、多渠道打包原理"><a href="#5、多渠道打包原理" class="headerlink" title="5、多渠道打包原理"></a>5、多渠道打包原理</h1><p>同一个app，需要上线各种平台，比如：小米，华为，百度等，我们多数称之为渠道，如果发的渠道多，可能有上百个渠道。</p>
<p>针对每个渠道，我们希望可以获取各个渠道的一些独立的统计信息，比如：下载量等。</p>
<p><strong>那么，如何区分各个渠道呢？</strong></p>
<p>Gradle Plugin为我们提供了一个自动化的方案，我们可以利用占位符，然后在build.gradle中去配置多个渠道信息，这样就可以将枯燥重复的任务自动化了。</p>
<p>这样的方式最大的问题，就是效率问题，每个渠道包，都要执行一遍构建流程，打包效率太低，目前市面比较出名的方案有美团<a href="https://tech.meituan.com/2017/01/13/android-apk-v2-signature-scheme.html">Walle</a>，腾讯的<a href="https://github.com/Tencent/VasDolly">VasDolly</a>所谓万变不离其宗，下面就介绍下市面上多渠道打包方案的基本原理。</p>
<h2 id="5-1、v1方案"><a href="#5-1、v1方案" class="headerlink" title="5.1、v1方案"></a>5.1、v1方案</h2><h3 id="5-1-1、EOCD"><a href="#5-1-1、EOCD" class="headerlink" title="5.1.1、EOCD"></a>5.1.1、EOCD</h3><p>我们知道要在apk中定位某个文件的位置必须要先解析出EOCD的结果，根据EOCD的结构推断出中央目录区，再根据中央目录区定位到v2签名块或者文件的情况。下面是EOCD的结构，主要包括几部分：</p>
<ol>
<li>魔数 0x06054B50，标记EOCD</li>
<li>中央目录信息（起始位置，记录数，长度）</li>
<li>注释区长度n（前2个字节）以及注释内容（Comment）</li>
</ol>
<p><img src="/pics/image-20201219155013207.png" alt="image-20201219155013207"></p>
<h3 id="5-1-2、v1方案"><a href="#5-1-2、v1方案" class="headerlink" title="5.1.2、v1方案"></a>5.1.2、v1方案</h3><p>根据之前的V1签名和校验机制可知，v1签名只会检验第一部分的所有压缩文件，而不理会后两部分内容。因此，我们可以向注释区中写入渠道。写入过程如下：</p>
<p><img src="/pics/image-20201222201238671.png" alt="image-20201222201238671"></p>
<p>这里添加魔数的好处是方便从后向前读取数据，定位渠道信息。因此，读取渠道信息包括以下几步：</p>
<ol>
<li>定位到魔数（8字节）</li>
<li>向前读两个字节，确定渠道信息的长度LEN（2字节）</li>
<li>继续向前读LEN字节，就是渠道信息了。</li>
</ol>
<h2 id="5-2、v2方案"><a href="#5-2、v2方案" class="headerlink" title="5.2、v2方案"></a>5.2、v2方案</h2><p>对于v2签名，Android系统只会关注ID为<strong>0x7109871a</strong>的v2签名块，并且忽略其他的ID-Value，同时v2签名只会保护APK本身，不包含签名块。所以可以将渠道写入到ID-Value键值对区。写入过程如下：</p>
<ol>
<li>从apk文件结尾，通过ID <strong>0x06054B50定</strong>位到<strong>EOCD</strong></li>
<li>通过EOCD找到<strong>中央目录结尾起始偏移</strong></li>
<li>定位APKSigning Block，</li>
<li>定位v2block</li>
<li>获取已有的ID-Value Pair</li>
<li><strong>添加包含渠道信息的ID-Value</strong></li>
<li>基于所有的ID-Value生成新的签名</li>
<li>修改EOCD的中央目录的偏移量(修改EOCD的中央目录偏移量，不会导致数据摘要校验失败）</li>
</ol>
<p>读取过程和写入过程基本相同，忽略。</p>
<h2 id="5-3、v3-方案"><a href="#5-3、v3-方案" class="headerlink" title="5.3、v3 方案"></a>5.3、v3 方案</h2><p>v3和v2的方案基本相同，但是v3签名<strong>限制了签名块大小是4096的倍数</strong>（<a href="https://www.cnblogs.com/yrstudy/p/11884996.html">参考</a>）在不写入渠道时读取下APK Singing Block，其大小刚好是4096。若写入渠道后不满足该条件，如果不是的话，就会去生成一个ByteBuffer来填充签名块，其ID为0x42726577。所以写入渠道后，<strong>可以通过修改0x42726577的value的大小保证签名块长度是4096的倍数即可</strong>。源码：</p>
<p><a href="https://android.googlesource.com/platform/tools/apksig/+/master/src/main/java/com/android/apksig/internal/apk/ApkSigningBlockUtils.java">generateApkSigningBlock</a></p>
<p><img src="/pics/image-20201222211918992.png" alt="image-20201222211918992"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/286d2b372334">https://www.jianshu.com/p/286d2b372334</a></p>
<p><a href="https://juejin.cn/post/6844903473310334984">https://juejin.cn/post/6844903473310334984</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/108036144">https://zhuanlan.zhihu.com/p/108036144</a></p>
<p><a href="https://mp.weixin.qq.com/s/709mXKfEzSuLrd0WCqrmbghttps://github.com/Meituan-Dianping/walle">https://mp.weixin.qq.com/s/709mXKfEzSuLrd0WCqrmbghttps://github.com/Meituan-Dianping/walle</a>)</p>
<p><a href="https://www.cnblogs.com/yrstudy/p/11884996.html">https://www.cnblogs.com/yrstudy/p/11884996.html</a></p>
<p><a href="https://source.android.google.cn/security/apksigning/v2?hl=zh-cn">https://source.android.google.cn/security/apksigning/v2?hl=zh-cn</a></p>
]]></content>
      <tags>
        <tag>签名</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/02/24/Notes/Android/Framework/Android%E7%B3%BB%E7%BB%9F%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p><a href="http://参考博客/">http://gityuan.com/2016/06/04/broadcast-receiver/</a><br><a href="http://流程图/">https://rawgit.com/prife/VirtualAppDoc/master/pngs/Broadcast.svg</a></p>
<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>广播(Broadcast)机制用于进程/线程间通信，广播分为广播发送和广播接收两个过程，其中广播接收者BroadcastReceiver便是Android四大组件之一。</p>
<p>BroadcastReceiver分为两类：</p>
<pre><code>静态广播接收者：通过AndroidManifest.xml的标签来申明的BroadcastReceiver。
动态广播接收者：通过AMS.registerReceiver()方式注册的BroadcastReceiver，动态注册更为灵活，可在不需要时通过unregisterReceiver()取消注册。
</code></pre>
<p>从广播发送方式可分为三类：</p>
<pre><code>普通广播：通过Context.sendBroadcast()发送，可并行处理
有序广播：通过Context.sendOrderedBroadcast()发送，串行处理
Sticky广播：通过Context.sendStickyBroadcast()发送
</code></pre>
<h1 id="二、广播的注册过程"><a href="#二、广播的注册过程" class="headerlink" title="二、广播的注册过程"></a>二、广播的注册过程</h1><h1 id="2-1-registerReceiver-BroadcastReceiver-receiver-IntentFilter-filter"><a href="#2-1-registerReceiver-BroadcastReceiver-receiver-IntentFilter-filter" class="headerlink" title="2.1 registerReceiver(BroadcastReceiver receiver, IntentFilter filter)"></a>2.1 registerReceiver(BroadcastReceiver receiver, IntentFilter filter)</h1><h1 id="2-2-ContextWrapper-registerReceiver-receiver-filter"><a href="#2-2-ContextWrapper-registerReceiver-receiver-filter" class="headerlink" title="2.2 ContextWrapper.registerReceiver(receiver,filter)"></a>2.2 ContextWrapper.registerReceiver(receiver,filter)</h1><h1 id="2-3-ContextImpl-registerReceiver-receiver-filter"><a href="#2-3-ContextImpl-registerReceiver-receiver-filter" class="headerlink" title="2.3 ContextImpl.registerReceiver(receiver,filter)"></a>2.3 ContextImpl.registerReceiver(receiver,filter)</h1><pre><code>public Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter,
        String broadcastPermission, Handler scheduler) &#123;
    return registerReceiverInternal(receiver, getUserId(),
            filter, broadcastPermission, scheduler, getOuterContext());
&#125;

private Intent registerReceiverInternal(BroadcastReceiver receiver, int userId,
        IntentFilter filter, String broadcastPermission,
        Handler scheduler, Context context) &#123;
    //rd 的类型是LoadApk.ReceiverDispatcher.InnerReceiver的一个对象
    IIntentReceiver rd = null;
    if (receiver != null) &#123;
        if (mPackageInfo != null &amp;&amp; context != null) &#123;
            if (scheduler == null) &#123;
                scheduler = mMainThread.getHandler();
            &#125;
            rd = mPackageInfo.getReceiverDispatcher(
                receiver, context, scheduler,
                mMainThread.getInstrumentation(), true);
        &#125; else &#123;
            if (scheduler == null) &#123;
                scheduler = mMainThread.getHandler();
            &#125;
            rd = new LoadedApk.ReceiverDispatcher(
                    receiver, context, scheduler, null, true).getIIntentReceiver();
        &#125;
    &#125;
    try &#123;
        //调用到AMS的registerReceiver方法
        return ActivityManagerNative.getDefault().registerReceiver(
                mMainThread.getApplicationThread(), mBasePackageName,
                rd, filter, broadcastPermission, userId);
    &#125; catch (RemoteException e) &#123;
        return null;
    &#125;
&#125;
</code></pre>
<h1 id="step1：-rd-的创建过程"><a href="#step1：-rd-的创建过程" class="headerlink" title="step1： rd 的创建过程"></a>step1： rd 的创建过程</h1><p>ReceiverDispatcher(广播分发者)有一个内部类InnerReceiver，该类继承于IIntentReceiver.Stub。显然，这是一个Binder服务端，广播分发者通过rd.getIIntentReceiver()可获取该Binder服务端对象InnerReceiver，用于Binder IPC通信。</p>
<pre><code>frameworks/base/core/java/android/app/LoadedApk.java

static final class ReceiverDispatcher &#123;

    final static class InnerReceiver extends IIntentReceiver.Stub &#123;
        final WeakReference&lt;LoadedApk.ReceiverDispatcher&gt; mDispatcher;
        final LoadedApk.ReceiverDispatcher mStrongRef;

        InnerReceiver(LoadedApk.ReceiverDispatcher rd, boolean strong) &#123;
            mDispatcher = new WeakReference&lt;LoadedApk.ReceiverDispatcher&gt;(rd);
            mStrongRef = strong ? rd : null;
        &#125;
       ...
    &#125;

    final IIntentReceiver.Stub mIIntentReceiver;
    final BroadcastReceiver mReceiver;
    ...

     ReceiverDispatcher(BroadcastReceiver receiver, Context context,
            Handler activityThread, Instrumentation instrumentation,
            boolean registered) &#123;
        if (activityThread == null) &#123;
            throw new NullPointerException(&quot;Handler must not be null&quot;);
        &#125;

        mIIntentReceiver = new InnerReceiver(this, !registered);
        mReceiver = receiver;
        mContext = context;
        mActivityThread = activityThread;
        mInstrumentation = instrumentation;
        mRegistered = registered;
        mLocation = new IntentReceiverLeaked(null);
        mLocation.fillInStackTrace();
    &#125;
    ...
    IIntentReceiver getIIntentReceiver() &#123;
        return mIIntentReceiver;
    &#125;
</code></pre>
<h1 id="2-4-在AMS中注册"><a href="#2-4-在AMS中注册" class="headerlink" title="2.4 在AMS中注册"></a>2.4 在AMS中注册</h1><p>其中mRegisteredReceivers记录着所有已注册的广播，以receiver IBinder为key, ReceiverList为value为HashMap。另外，这个过程涉及对象ReceiverList，BroadcastFilter，BroadcastRecord的创建。</p>
<p>在BroadcastQueue中有两个广播队列mParallelBroadcasts,mOrderedBroadcasts，数据类型都为ArrayList：</p>
<pre><code>mParallelBroadcasts:并行广播队列，可以立刻执行，而无需等待另一个广播运行完成，该队列只允许动态已注册的广播，从而避免发生同时拉起大量进程来执行广播，前台的和后台的广播分别位于独立的队列。
mOrderedBroadcasts：有序广播队列，同一时间只允许执行一个广播，该队列顶部的广播便是活动广播，其他广播必须等待该广播结束才能运行，也是独立区别前台的和后台的广播。

public Intent registerReceiver(IApplicationThread caller, String callerPackage,
            IIntentReceiver receiver, IntentFilter filter, String permission, int userId) &#123;
        synchronized (this) &#123;
            if (callerApp != null &amp;&amp; (callerApp.thread == null
                    || callerApp.thread.asBinder() != caller.asBinder())) &#123;
                return null;
            &#125;
            //ReceiverList rl保存了相同InnerReceiver注册的广播接收者BroadcastFilter
            //mRegisteredReceivers的 final HashMap&lt;IBinder, ReceiverList&gt; mRegisteredReceivers
            //通过不同的InnerReceiver来区分不同的广播
            ReceiverList rl = mRegisteredReceivers.get(receiver.asBinder());
            if (rl == null) &#123;
                rl = new ReceiverList(this, callerApp, callingPid, callingUid,
                        userId, receiver);
                if (rl.app != null) &#123;
                    rl.app.receivers.add(rl);
                &#125; else &#123;
                    try &#123;
                        receiver.asBinder().linkToDeath(rl, 0);
                    &#125; catch (RemoteException e) &#123;
                        return sticky;
                    &#125;
                    rl.linkedToDeath = true;
                &#125;
                mRegisteredReceivers.put(receiver.asBinder(), rl);
            &#125; 
            //描述正在注册的广播接收者
            BroadcastFilter bf = new BroadcastFilter(filter, rl, callerPackage,
                    permission, callingUid, userId);
            //将注册的广播接收者BroadcastFilter 加入到ReceiverList中
            rl.add(bf);
            if (!bf.debugCheck()) &#123;
                Slog.w(TAG, &quot;==&gt; For Dynamic broadcast&quot;);
            &#125;
            //将广播接收者保存到内部的类成员变量mReceiverResolver中，所以BroadcastReceiver和InnerReceiver是成对存在的
            //final IntentResolver&lt;BroadcastFilter, BroadcastFilter&gt; mReceiverResolver
            mReceiverResolver.addFilter(bf);

            if (allSticky != null) &#123;
                ArrayList receivers = new ArrayList();
                receivers.add(bf);

                final int stickyCount = allSticky.size();
                for (int i = 0; i &lt; stickyCount; i++) &#123;
                    Intent intent = allSticky.get(i);
                    BroadcastQueue queue = broadcastQueueForIntent(intent);
                    BroadcastRecord r = new BroadcastRecord(queue, intent, null,
                            null, -1, -1, null, null, AppOpsManager.OP_NONE, null, receivers,
                            null, 0, null, null, false, true, true, -1);
                    queue.enqueueParallelBroadcastLocked(r);
                    queue.scheduleBroadcastsLocked();
                &#125;
            &#125;

            return sticky;
        &#125;
    &#125;
</code></pre>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>注册广播的过程，主要功能：<br>创建ReceiverList(接收者队列)，并添加到AMS.mRegisteredReceivers(已注册广播队列)；<br>创建BroadcastFilter(广播过滤者)，并添加到AMS.mReceiverResolver(接收者的解析人)；<br>当注册的是Sticky广播，则创建BroadcastRecord，并添加到BroadcastQueue的mParallelBroadcasts(并行广播队列)，注册后调用AMS来尽快处理该广播。</p>
<p>三、广播的发送过程</p>
<h1 id="3-1-sendBroadcast-intent"><a href="#3-1-sendBroadcast-intent" class="headerlink" title="3.1 sendBroadcast(intent)"></a>3.1 sendBroadcast(intent)</h1><h1 id="3-2-ContextWrapper-sendBroadcast-intent"><a href="#3-2-ContextWrapper-sendBroadcast-intent" class="headerlink" title="3.2 ContextWrapper.sendBroadcast(intent)"></a>3.2 ContextWrapper.sendBroadcast(intent)</h1><pre><code>frameworks/base/core/java/android/content/ContextWrapper.java

public void sendBroadcast(Intent intent) &#123;
        mBase.sendBroadcast(intent);
&#125;
</code></pre>
<h1 id="3-3-ContextImpl-sendBroadcast"><a href="#3-3-ContextImpl-sendBroadcast" class="headerlink" title="3.3 ContextImpl.sendBroadcast"></a>3.3 ContextImpl.sendBroadcast</h1><pre><code>frameworks/base/core/java/android/app/ContextImpl.java

public void sendBroadcast(Intent intent) &#123;
        warnIfCallingFromSystemProcess();
        String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
        try &#123;
            intent.prepareToLeaveProcess();
            ActivityManagerNative.getDefault().broadcastIntent(
                    mMainThread.getApplicationThread(), intent, resolvedType, null,
                    Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false,
                    getUserId());
        &#125; catch (RemoteException e) &#123;
            throw new RuntimeException(&quot;Failure from system&quot;, e);
        &#125;
    &#125;
</code></pre>
<h1 id="3-4-ActivityManagerProxy-broadcastIntent"><a href="#3-4-ActivityManagerProxy-broadcastIntent" class="headerlink" title="3.4 ActivityManagerProxy.broadcastIntent"></a>3.4 ActivityManagerProxy.broadcastIntent</h1><pre><code>frameworks/base/core/java/android/app/ActivityManagerNative.java

    public int broadcastIntent(IApplicationThread caller,
        Intent intent, String resolvedType, IIntentReceiver resultTo,
        int resultCode, String resultData, Bundle map,
        String[] requiredPermissions, int appOp, Bundle options, boolean serialized,
        boolean sticky, int userId) throws RemoteException
&#123;
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IActivityManager.descriptor);
    data.writeStrongBinder(caller != null ? caller.asBinder() : null);
    intent.writeToParcel(data, 0);
    data.writeString(resolvedType);
    data.writeStrongBinder(resultTo != null ? resultTo.asBinder() : null);
    data.writeInt(resultCode);
    data.writeString(resultData);
    data.writeBundle(map);
    data.writeStringArray(requiredPermissions);
    data.writeInt(appOp);
    data.writeBundle(options);
    data.writeInt(serialized ? 1 : 0);
    data.writeInt(sticky ? 1 : 0);
    data.writeInt(userId);
    mRemote.transact(BROADCAST_INTENT_TRANSACTION, data, reply, 0);
    reply.readException();
    int res = reply.readInt();
    reply.recycle();
    data.recycle();
    return res;
&#125;
</code></pre>
<h1 id="3-5-ActivityManagerService-broadcastIntent"><a href="#3-5-ActivityManagerService-broadcastIntent" class="headerlink" title="3.5 ActivityManagerService.broadcastIntent"></a>3.5 ActivityManagerService.broadcastIntent</h1><pre><code>frameworks/base/services/java/com/android/server/am/ActivityManagerService.java

public final int broadcastIntent(IApplicationThread caller,
        Intent intent, String resolvedType, IIntentReceiver resultTo,
        int resultCode, String resultData, Bundle resultExtras,
        String[] requiredPermissions, int appOp, Bundle options,
        boolean serialized, boolean sticky, int userId) &#123;
    enforceNotIsolatedCaller(&quot;broadcastIntent&quot;);
    synchronized(this) &#123;
        intent = verifyBroadcastLocked(intent);

        final ProcessRecord callerApp = getRecordForAppLocked(caller);
        final int callingPid = Binder.getCallingPid();
        final int callingUid = Binder.getCallingUid();
        final long origId = Binder.clearCallingIdentity();
        int res = broadcastIntentLocked(callerApp,
                callerApp != null ? callerApp.info.packageName : null,
                intent, resolvedType, resultTo, resultCode, resultData, resultExtras,
                requiredPermissions, appOp, null, serialized, sticky,
                callingPid, callingUid, userId);
        Binder.restoreCallingIdentity(origId);
        return res;
    &#125;
</code></pre>
<h1 id="3-6-ActivityManagerService-broadcastIntentLocked-分解为8个步骤解析"><a href="#3-6-ActivityManagerService-broadcastIntentLocked-分解为8个步骤解析" class="headerlink" title="3.6 ActivityManagerService.broadcastIntentLocked 分解为8个步骤解析"></a>3.6 ActivityManagerService.broadcastIntentLocked 分解为8个步骤解析</h1><h1 id="step1-设置广播flag"><a href="#step1-设置广播flag" class="headerlink" title="step1: 设置广播flag"></a>step1: 设置广播flag</h1><pre><code>添加flag=FLAG_EXCLUDE_STOPPED_PACKAGES，保证已停止app不会收到该广播；
当系统还没有启动完成，则不允许启动新进程，，即只有动态注册receiver才能接受广播
当非USER_ALL广播且当前用户并没有处于Running的情况下，除非是系统升级广播或者关机广播，否则直接返回。

BroadcastReceiver还有其他flag，位于Intent.java常量:
    FLAG_RECEIVER_REGISTERED_ONLY //只允许已注册receiver接收广播
    FLAG_RECEIVER_REPLACE_PENDING //新广播会替代相同广播
    FLAG_RECEIVER_FOREGROUND //只允许前台receiver接收广播
    FLAG_RECEIVER_NO_ABORT //对于有序广播，先接收到的receiver无权抛弃广播
    FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT //Boot完成之前，只允许已注册receiver接收广播
    FLAG_RECEIVER_BOOT_UPGRADE //升级模式下，允许系统准备就绪前可以发送广播

private final int broadcastIntentLocked(ProcessRecord callerApp,
        String callerPackage, Intent intent, String resolvedType,
        IIntentReceiver resultTo, int resultCode, String resultData,
        Bundle resultExtras, String[] requiredPermissions, int appOp, Bundle options,
        boolean ordered, boolean sticky, int callingPid, int callingUid, int userId) &#123;
    intent = new Intent(intent);

    // By default broadcasts do not go to stopped apps.
    intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
    
    // If we have not finished booting, don&#39;t allow this to launch new processes.
    if (!mProcessesReady &amp;&amp; (intent.getFlags()&amp;Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) &#123;
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
    &#125;
    
     // Make sure that the user who is receiving this broadcast is running.
    // If not, we will just skip it. Make an exception for shutdown broadcasts
    // and upgrade steps.

    if (userId != UserHandle.USER_ALL &amp;&amp; !isUserRunningLocked(userId, false)) &#123;
        if ((callingUid != Process.SYSTEM_UID
                || (intent.getFlags() &amp; Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0)
                &amp;&amp; !Intent.ACTION_SHUTDOWN.equals(intent.getAction())) &#123;
            Slog.w(TAG, &quot;Skipping broadcast of &quot; + intent
                    + &quot;: user &quot; + userId + &quot; is stopped&quot;);
            return ActivityManager.BROADCAST_FAILED_USER_STOPPED;
        &#125;
    &#125;
</code></pre>
<h1 id="step2-广播权限验证"><a href="#step2-广播权限验证" class="headerlink" title="step2: 广播权限验证"></a>step2: 广播权限验证</h1><p>对于callingAppId为SYSTEM_UID，PHONE_UID，SHELL_UID，BLUETOOTH_UID，NFC_UID之一或者callingUid == 0时都畅通无阻；<br>否则对于调用者进程为空并且不是persistent进程的情况下：<br>    1.当发送的是受保护广播mProtectedBroadcasts(只允许系统使用)，则抛出异常；<br>    2.当action为ACTION_APPWIDGET_CONFIGURE时，虽然不希望该应用发送这种广播，处于兼容性考虑，限制该广播只允许发送给自己，否则抛出异常。</p>
<pre><code>/*
     * Prevent non-system code (defined here to be non-persistent
     * processes) from sending protected broadcasts.
     */
    int callingAppId = UserHandle.getAppId(callingUid);
    if (callingAppId == Process.SYSTEM_UID || callingAppId == Process.PHONE_UID
        || callingAppId == Process.SHELL_UID || callingAppId == Process.BLUETOOTH_UID
        || callingAppId == Process.NFC_UID || callingUid == 0) &#123;
        // Always okay.
    &#125; else if (callerApp == null || !callerApp.persistent) &#123;
        try &#123;
            if (AppGlobals.getPackageManager().isProtectedBroadcast(
                    intent.getAction())) &#123;
                String msg = &quot;Permission Denial: not allowed to send broadcast &quot;
                        + intent.getAction() + &quot; from pid=&quot;
                        + callingPid + &quot;, uid=&quot; + callingUid;
                Slog.w(TAG, msg);
                throw new SecurityException(msg);
            &#125; else if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(intent.getAction())) &#123;
                // Special case for compatibility: we don&#39;t want apps to send this,
                // but historically it has not been protected and apps may be using it
                // to poke their own app widget.  So, instead of making it protected,
                // just limit it to the caller.
                if (callerApp == null) &#123;
                    String msg = &quot;Permission Denial: not allowed to send broadcast &quot;
                            + intent.getAction() + &quot; from unknown caller.&quot;;
                    Slog.w(TAG, msg);
                    throw new SecurityException(msg);
                &#125; else if (intent.getComponent() != null) &#123;
                    // They are good enough to send to an explicit component...  verify
                    // it is being sent to the calling app.
                    if (!intent.getComponent().getPackageName().equals(
                            callerApp.info.packageName)) &#123;
                        String msg = &quot;Permission Denial: not allowed to send broadcast &quot;
                                + intent.getAction() + &quot; to &quot;
                                + intent.getComponent().getPackageName() + &quot; from &quot;
                                + callerApp.info.packageName;
                        Slog.w(TAG, msg);
                        throw new SecurityException(msg);
                    &#125;
                &#125; else &#123;
                    // Limit broadcast to their own package.
                    intent.setPackage(callerApp.info.packageName);
                &#125;
            &#125;
        &#125; catch (RemoteException e) &#123;
            Slog.w(TAG, &quot;Remote exception&quot;, e);
            return ActivityManager.BROADCAST_SUCCESS;
        &#125;
    &#125;
</code></pre>
<h1 id="step3-处理系统相关广播"><a href="#step3-处理系统相关广播" class="headerlink" title="step3: 处理系统相关广播"></a>step3: 处理系统相关广播</h1><pre><code>这个过程代码较长，主要处于系统相关的广播，如下10个case：
case Intent.ACTION_UID_REMOVED: //uid移除
case Intent.ACTION_PACKAGE_REMOVED: //package移除，
case Intent.ACTION_PACKAGE_CHANGED: //package改变
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE: //外部设备不可用时，强制停止所有波及的应用并清空cache数据
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE: //外部设备可用
case Intent.ACTION_PACKAGE_ADDED: //增加package，处于兼容考虑

case Intent.ACTION_TIMEZONE_CHANGED: //时区改变，通知所有运行中的进程
case Intent.ACTION_TIME_CHANGED: //时间改变，通知所有运行中的进程
case Intent.ACTION_CLEAR_DNS_CACHE: //dns缓存清空
case Proxy.PROXY_CHANGE_ACTION: //网络代理改变

final String action = intent.getAction();
if (action != null) &#123;
    switch (action) &#123;
        case Intent.ACTION_UID_REMOVED:
            mBatteryStatsService.removeUid(uid);
            mAppOpsService.uidRemoved(uid);
            break;
        case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
            String list[] = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
            if (list != null &amp;&amp; list.length &gt; 0) &#123;
                for (int i = 0; i &lt; list.length; i++) &#123;
                    forceStopPackageLocked(list[i], -1, false, true, true,
                            false, false, userId, &quot;storage unmount&quot;);
                &#125;
                mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
                sendPackageBroadcastLocked(
                    IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE, list,userId);
            &#125;
            break;
        case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE
            mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
            break;
        case Intent.ACTION_PACKAGE_REMOVED:
        case Intent.ACTION_PACKAGE_CHANGED:
            Uri data = intent.getData();
            boolean removed = Intent.ACTION_PACKAGE_REMOVED.equals(action);
            boolean fullUninstall = removed &amp;&amp; !intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
            final boolean killProcess = !intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP, false);
            if (killProcess) &#123;
                forceStopPackageLocked(ssp, UserHandle.getAppId(
                        intent.getIntExtra(Intent.EXTRA_UID, -1)),
                        false, true, true, false, fullUninstall, userId,
                        removed ? &quot;pkg removed&quot; : &quot;pkg changed&quot;);
            &#125;
            if (removed) &#123;
                sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REMOVED,new String[] &#123;ssp&#125;, userId);
                if (fullUninstall) &#123;
                    mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID, -1), ssp);
                    removeUriPermissionsForPackageLocked(ssp, userId, true);
                    removeTasksByPackageNameLocked(ssp, userId);
                    mBatteryStatsService.notePackageUninstalled(ssp);
                &#125;
            &#125; else &#123;
                cleanupDisabledPackageComponentsLocked(ssp, userId, killProcess,
                        intent.getStringArrayExtra(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST));
            &#125;
            break;

        case Intent.ACTION_PACKAGE_ADDED:
            Uri data = intent.getData();
            final boolean replacing =intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
            mCompatModePackages.handlePackageAddedLocked(ssp, replacing);
            ApplicationInfo ai = AppGlobals.getPackageManager().getApplicationInfo(ssp, 0, 0);
            break;
        case Intent.ACTION_TIMEZONE_CHANGED:
            mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
            break;
        case Intent.ACTION_TIME_CHANGED:
            final int is24Hour = intent.getBooleanExtra(Intent.EXTRA_TIME_PREF_24_HOUR_FORMAT, false) ? 1: 0;
            mHandler.sendMessage(mHandler.obtainMessage(UPDATE_TIME, is24Hour, 0));
            BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();
            synchronized (stats) &#123;
                stats.noteCurrentTimeChangedLocked();
            &#125;
            break;
        case Intent.ACTION_CLEAR_DNS_CACHE:
            mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
            break;
        case Proxy.PROXY_CHANGE_ACTION:
            ProxyInfo proxy = intent.getParcelableExtra(Proxy.EXTRA_PROXY_INFO);
            mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG, proxy));
            break;
    &#125;
&#125;
</code></pre>
<h1 id="step4：增加sticky广播"><a href="#step4：增加sticky广播" class="headerlink" title="step4：增加sticky广播"></a>step4：增加sticky广播</h1><pre><code>这个过程主要是将sticky广播增加到list，并放入mStickyBroadcasts里面。

if (sticky) &#123;
    if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,
            callingPid, callingUid)
            != PackageManager.PERMISSION_GRANTED) &#123;
        throw new SecurityException(&quot;&quot;);
    &#125;
    if (requiredPermissions != null &amp;&amp; requiredPermissions.length &gt; 0) &#123;
        return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
    &#125;

    if (intent.getComponent() != null) &#123;
       //当sticky广播发送给指定组件，则throw Exception
    &#125;
    if (userId != UserHandle.USER_ALL) &#123;
       //当非USER_ALL广播跟USER_ALL广播出现冲突,则throw Exception
    &#125;

    ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt; stickies = mStickyBroadcasts.get(userId);
    if (stickies == null) &#123;
        stickies = new ArrayMap&lt;&gt;();
        mStickyBroadcasts.put(userId, stickies);
    &#125;
    ArrayList&lt;Intent&gt; list = stickies.get(intent.getAction());
    if (list == null) &#123;
        list = new ArrayList&lt;&gt;();
        stickies.put(intent.getAction(), list);
    &#125;
    final int stickiesCount = list.size();
    int i;
    for (i = 0; i &lt; stickiesCount; i++) &#123;
        if (intent.filterEquals(list.get(i))) &#123;
            //替换已存在的sticky intent
            list.set(i, new Intent(intent));
            break;
        &#125;
    &#125;
    //新的intent追加到list
    if (i &gt;= stickiesCount) &#123;
        list.add(new Intent(intent));
    &#125;
&#125;
</code></pre>
<h1 id="step5：查询receivers和registeredReceivers"><a href="#step5：查询receivers和registeredReceivers" class="headerlink" title="step5：查询receivers和registeredReceivers"></a>step5：查询receivers和registeredReceivers</h1><p>receivers：记录着匹配当前intent的所有静态注册广播接收者；<br>registeredReceivers：记录着匹配当前的所有动态注册的广播接收者。<br>其中，mReceiverResolver是AMS的成员变量，记录着已注册的广播接收者的resolver.</p>
<pre><code>int[] users;
if (userId == UserHandle.USER_ALL) &#123;
    users = mStartedUserArray; //广播给所有已启动用户
&#125; else &#123;
    users = new int[] &#123;userId&#125;; //广播给指定用户
&#125;

List receivers = null;
List&lt;BroadcastFilter&gt; registeredReceivers = null;
//找出所有能接收该广播的receivers
if ((intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) &#123;
    //根据intent查找相应的receivers,查询静态注册的广播
    receivers = collectReceiverComponents(intent, resolvedType, callingUid, users);
&#125;
if (intent.getComponent() == null) &#123;
    if (userId == UserHandle.USER_ALL &amp;&amp; callingUid == Process.SHELL_UID) &#123;
        UserManagerService ums = getUserManagerLocked();
        for (int i = 0; i &lt; users.length; i++) &#123;
            //shell用户是否开启允许debug功能
            if (ums.hasUserRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES, users[i])) &#123;
                continue;
            &#125;
            // 查询动态注册的广播
            List&lt;BroadcastFilter&gt; registeredReceiversForUser =
                    mReceiverResolver.queryIntent(intent,
                            resolvedType, false, users[i]);
            if (registeredReceivers == null) &#123;
                registeredReceivers = registeredReceiversForUser;
            &#125; else if (registeredReceiversForUser != null) &#123;
                registeredReceivers.addAll(registeredReceiversForUser);
            &#125;
        &#125;
    &#125; else &#123;
        // 查询动态注册的广播
        registeredReceivers = mReceiverResolver.queryIntent(intent,
                resolvedType, false, userId);
    &#125;
&#125;

AMS.collectReceiverComponents：

private List&lt;ResolveInfo&gt; collectReceiverComponents(Intent intent, String resolvedType,
    int callingUid, int[] users) &#123;
List&lt;ResolveInfo&gt; receivers = null;
for (int user : users) &#123;
    //调用PKMS.queryIntentReceivers，可获取AndroidManifest.xml声明的接收者信息
    List&lt;ResolveInfo&gt; newReceivers = AppGlobals.getPackageManager()
            .queryIntentReceivers(intent, resolvedType, STOCK_PM_FLAGS, user);
    if (receivers == null) &#123;
        receivers = newReceivers;
    &#125; else if (newReceivers != null) &#123;
        ...
        //将所用户的receiver整合到receivers
    &#125;
 &#125;
return receivers;
&#125;
</code></pre>
<h1 id="step6：处理并行广播"><a href="#step6：处理并行广播" class="headerlink" title="step6：处理并行广播"></a>step6：处理并行广播</h1><p>广播队列中有一个成员变量mParallelBroadcasts，类型为ArrayList，记录着所有的并行广播。</p>
<pre><code>//用于标识是否需要用新intent替换旧的intent。
final boolean replacePending = (intent.getFlags()&amp;Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
//处理并行广播
int NR = registeredReceivers != null ? registeredReceivers.size() : 0;
if (!ordered &amp;&amp; NR &gt; 0) &#123;
    final BroadcastQueue queue = broadcastQueueForIntent(intent);
    //创建BroadcastRecord对象
    BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp,
            callerPackage, callingPid, callingUid, resolvedType, requiredPermissions,
            appOp, brOptions, registeredReceivers, resultTo, resultCode, resultData,
            resultExtras, ordered, sticky, false, userId);

    final boolean replaced = replacePending &amp;&amp; queue.replaceParallelBroadcastLocked(r);
    if (!replaced) &#123;
        //将BroadcastRecord加入到并行广播队列
        queue.enqueueParallelBroadcastLocked(r);
        //处理广播【见小节4.1】
        queue.scheduleBroadcastsLocked();
    &#125;
    registeredReceivers = null;
    NR = 0;
&#125;
</code></pre>
<h1 id="step7：合并registeredReceivers到receivers"><a href="#step7：合并registeredReceivers到receivers" class="headerlink" title="step7：合并registeredReceivers到receivers"></a>step7：合并registeredReceivers到receivers</h1><pre><code>int ir = 0;
if (receivers != null) &#123;
    //防止应用监听该广播，在安装时直接运行。
    String skipPackages[] = null;
    if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction())
            || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction())
            || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) &#123;
        Uri data = intent.getData();
        if (data != null) &#123;
            String pkgName = data.getSchemeSpecificPart();
            if (pkgName != null) &#123;
                skipPackages = new String[] &#123; pkgName &#125;;
            &#125;
        &#125;
    &#125; else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) &#123;
        skipPackages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
    &#125;

    //将skipPackages相关的广播接收者从receivers列表中移除
    if (skipPackages != null &amp;&amp; (skipPackages.length &gt; 0)) &#123;
        for (String skipPackage : skipPackages) &#123;
            if (skipPackage != null) &#123;
                int NT = receivers.size();
                for (int it=0; it&lt;NT; it++) &#123; ResolveInfo curt = (ResolveInfo)receivers.get(it); if (curt.activityInfo.packageName.equals(skipPackage)) &#123; receivers.remove(it); it--; NT--; &#125; &#125; &#125; &#125; &#125; //前面part6有一个处理动态广播的过程，处理完后再执行将动态注册的registeredReceivers合并到receivers int NT = receivers != null ? receivers.size() : 0; int it = 0; ResolveInfo curt = null; BroadcastFilter curr = null; while (it &lt; NT &amp;&amp; ir &lt; NR) &#123; if (curt == null) &#123; curt = (ResolveInfo)receivers.get(it); &#125; if (curr == null) &#123; curr = registeredReceivers.get(ir); &#125; if (curr.getPriority()&gt;= curt.priority) &#123;
            receivers.add(it, curr);
            ir++;
            curr = null;
            it++;
            NT++;
        &#125; else &#123;
            it++;
            curt = null;
        &#125;
    &#125;
&#125;
while (ir &lt; NR) &#123;
    if (receivers == null) &#123;
        receivers = new ArrayList();
    &#125;
    receivers.add(registeredReceivers.get(ir));
    ir++;
&#125;
</code></pre>
<h1 id="step8-处理串行广播"><a href="#step8-处理串行广播" class="headerlink" title="step8: 处理串行广播"></a>step8: 处理串行广播</h1><p>广播队列中有一个成员变量mOrderedBroadcasts，类型为ArrayList，记录着所有的有序广播。</p>
<pre><code>    if ((receivers != null &amp;&amp; receivers.size() &gt; 0)
        || resultTo != null) &#123;
    BroadcastQueue queue = broadcastQueueForIntent(intent);
    //创建BroadcastRecord
    BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp,
            callerPackage, callingPid, callingUid, resolvedType,
            requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode,
            resultData, resultExtras, ordered, sticky, false, userId);

    boolean replaced = replacePending &amp;&amp; queue.replaceOrderedBroadcastLocked(r);
    if (!replaced) &#123;
        //将BroadcastRecord加入到有序广播队列
        queue.enqueueOrderedBroadcastLocked(r);
        //处理广播【见小节4.1】
        queue.scheduleBroadcastsLocked();
    &#125;
&#125;
</code></pre>
<h1 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h1><pre><code>注册广播的小节[2.4]阶段, 会处理Sticky广播;
发送广播的[step 6]阶段, 会处理并行广播;
发送广播的[step 8]阶段, 会处理串行广播;
</code></pre>
<p>上述3个处理过程都是通过调用scheduleBroadcastsLocked()方法来完成的,接下来再来看看这个方法.</p>
<h1 id="四、-处理广播"><a href="#四、-处理广播" class="headerlink" title="四、 处理广播"></a>四、 处理广播</h1><p>在发送广播过程中会执行scheduleBroadcastsLocked方法来处理相关的广播</p>
<pre><code>base/services/core/java/com/android/server/am/BroadcastQueue
</code></pre>
<h1 id="4-1-scheduleBroadcastsLocked"><a href="#4-1-scheduleBroadcastsLocked" class="headerlink" title="4.1 scheduleBroadcastsLocked"></a>4.1 scheduleBroadcastsLocked</h1><pre><code>public void scheduleBroadcastsLocked() &#123;
        if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;Schedule broadcasts [&quot;
                + mQueueName + &quot;]: current=&quot;
                + mBroadcastsScheduled);

        if (mBroadcastsScheduled) &#123;
            return;
        &#125;
        mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this));
        mBroadcastsScheduled = true;
    &#125;
</code></pre>
<h1 id="4-2-handleMessage"><a href="#4-2-handleMessage" class="headerlink" title="4.2 handleMessage"></a>4.2 handleMessage</h1><p>调用到processNextBroadcast</p>
<pre><code>private final class BroadcastHandler extends Handler &#123;
    public BroadcastHandler(Looper looper) &#123;
        super(looper, null, true);
    &#125;

    @Override
    public void handleMessage(Message msg) &#123;
        switch (msg.what) &#123;
            case BROADCAST_INTENT_MSG: &#123;
                if (DEBUG_BROADCAST) Slog.v(
                        TAG_BROADCAST, &quot;Received BROADCAST_INTENT_MSG&quot;);
                processNextBroadcast(true);
            &#125; break;
            ...
            &#125;
</code></pre>
<h1 id="4-3-processNextBroadcast"><a href="#4-3-processNextBroadcast" class="headerlink" title="4.3 processNextBroadcast"></a>4.3 processNextBroadcast</h1><p>此处mService为AMS，整个流程还是比较长的，全程持有AMS锁，所以广播效率低的情况下，直接会严重影响这个手机的性能与流畅度，这里应该考虑细化同步锁的粒度。</p>
<pre><code>final void processNextBroadcast(boolean fromMsg) &#123;
synchronized(mService) &#123;
    //step1: 处理并行广播
    //step2: 处理当前有序广播
    //step3: 获取下条有序广播
    //step4: 处理下条有序广播
    &#125;
&#125;
</code></pre>
<h1 id="step1-处理并行广播"><a href="#step1-处理并行广播" class="headerlink" title="step1: 处理并行广播"></a>step1: 处理并行广播</h1><pre><code>BroadcastRecord r;
mService.updateCpuStats(); //更新CPU统计信息
if (fromMsg)  mBroadcastsScheduled = false;

while (mParallelBroadcasts.size() &gt; 0) &#123;
    r = mParallelBroadcasts.remove(0);
    r.dispatchTime = SystemClock.uptimeMillis();
    r.dispatchClockTime = System.currentTimeMillis();
    final int N = r.receivers.size();
    for (int i=0; i&lt;N; i++) &#123; Object target = r.receivers.get(i); //分发广播给已注册的receiver 【见小节4.3】 deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, false); &#125; addBroadcastToHistoryLocked(r);//将广播添加历史统计 &#125; # step2: 处理当前有序广播 if (mPendingBroadcast != null) &#123; boolean isDead; synchronized (mService.mPidsSelfLocked) &#123; //从mPidsSelfLocked获取正在处理该广播进程，判断该进程是否死亡 ProcessRecord proc = mService.mPidsSelfLocked.get(mPendingBroadcast.curApp.pid); isDead = proc == null || proc.crashing; &#125; if (!isDead) &#123; //正在处理广播的进程保持活跃状态，则继续等待其执行完成 return; &#125; else &#123; mPendingBroadcast.state = BroadcastRecord.IDLE; mPendingBroadcast.nextReceiver = mPendingBroadcastRecvIndex; mPendingBroadcast = null; &#125; &#125; boolean looped = false; do &#123; if (mOrderedBroadcasts.size() == 0) &#123; //所有串行广播处理完成，则调度执行gc mService.scheduleAppGcsLocked(); if (looped) &#123; mService.updateOomAdjLocked(); &#125; return; &#125; r = mOrderedBroadcasts.get(0); boolean forceReceive = false; //获取所有该广播所有的接收者 int numReceivers = (r.receivers != null) ? r.receivers.size() : 0; if (mService.mProcessesReady &amp;&amp; r.dispatchTime&gt; 0) &#123;
        long now = SystemClock.uptimeMillis();
        if ((numReceivers &gt; 0) &amp;&amp;
                (now &gt; r.dispatchTime + (2*mTimeoutPeriod*numReceivers))) &#123;
            //当广播处理时间超时，则强制结束这条广播
            broadcastTimeoutLocked(false);
            forceReceive = true;
            r.state = BroadcastRecord.IDLE;
        &#125;
    &#125;

    if (r.state != BroadcastRecord.IDLE) &#123;
        return;
    &#125;

    if (r.receivers == null || r.nextReceiver &gt;= numReceivers
            || r.resultAbort || forceReceive) &#123;
        if (r.resultTo != null) &#123;
            //处理广播消息消息，调用到onReceive()
            performReceiveLocked(r.callerApp, r.resultTo,
                new Intent(r.intent), r.resultCode,
                r.resultData, r.resultExtras, false, false, r.userId);
            r.resultTo = null;
        &#125;
        //取消BROADCAST_TIMEOUT_MSG消息
        cancelBroadcastTimeoutLocked();

        addBroadcastToHistoryLocked(r);
        mOrderedBroadcasts.remove(0);
        r = null;
        looped = true;
        continue;
    &#125;
&#125; while (r == null);
</code></pre>
<h1 id="step3-获取下条有序广播"><a href="#step3-获取下条有序广播" class="headerlink" title="step3: 获取下条有序广播"></a>step3: 获取下条有序广播</h1><p>mTimeoutPeriod，对于前台广播则为10s，对于后台广播则为60s。广播超时为2<em>mTimeoutPeriod</em>numReceivers，接收者个数numReceivers越多则广播超时总时长越大。</p>
<pre><code>//获取下一个receiver的index
int recIdx = r.nextReceiver++;

r.receiverTime = SystemClock.uptimeMillis();
if (recIdx == 0) &#123;
    r.dispatchTime = r.receiverTime;
    r.dispatchClockTime = System.currentTimeMillis();
&#125;
if (!mPendingBroadcastTimeoutMessage) &#123;
    long timeoutTime = r.receiverTime + mTimeoutPeriod;
    //设置广播超时时间，发送BROADCAST_TIMEOUT_MSG
    setBroadcastTimeoutLocked(timeoutTime);
&#125;

final BroadcastOptions brOptions = r.options;
//获取下一个广播接收者
final Object nextReceiver = r.receivers.get(recIdx);

if (nextReceiver instanceof BroadcastFilter) &#123;
    //对于动态注册的广播接收者，deliverToRegisteredReceiverLocked处理广播
    BroadcastFilter filter = (BroadcastFilter)nextReceiver;
    deliverToRegisteredReceiverLocked(r, filter, r.ordered);
    if (r.receiver == null || !r.ordered) &#123;
        r.state = BroadcastRecord.IDLE;
        scheduleBroadcastsLocked();
    &#125; else &#123;
        ...
    &#125;
    return;
&#125;

//对于静态注册的广播接收者
ResolveInfo info = (ResolveInfo)nextReceiver;
ComponentName component = new ComponentName(
        info.activityInfo.applicationInfo.packageName,
        info.activityInfo.name);
...
//执行各种权限检测，此处省略，当权限不满足时skip=true

if (skip) &#123;
    r.receiver = null;
    r.curFilter = null;
    r.state = BroadcastRecord.IDLE;
    scheduleBroadcastsLocked();
    return;
&#125;

r.state = BroadcastRecord.APP_RECEIVE;
String targetProcess = info.activityInfo.processName;
r.curComponent = component;
final int receiverUid = info.activityInfo.applicationInfo.uid;
if (r.callingUid != Process.SYSTEM_UID &amp;&amp; isSingleton
        &amp;&amp; mService.isValidSingletonCall(r.callingUid, receiverUid)) &#123;
    info.activityInfo = mService.getActivityInfoForUser(info.activityInfo, 0);
&#125;
r.curReceiver = info.activityInfo;
...

//Broadcast正在执行中，stopped状态设置成false
AppGlobals.getPackageManager().setPackageStoppedState(
        r.curComponent.getPackageName(), false, UserHandle.getUserId(r.callingUid));
</code></pre>
<h1 id="step4-处理下条有序广播"><a href="#step4-处理下条有序广播" class="headerlink" title="step4: 处理下条有序广播"></a>step4: 处理下条有序广播</h1><p>如果是动态广播接收者，则调用deliverToRegisteredReceiverLocked处理；<br>如果是静态广播接收者，且对应进程已经创建，则调用processCurBroadcastLocked处理；<br>如果是静态广播接收者，且对应进程尚未创建，则调用startProcessLocked创建进程。</p>
<pre><code>//该receiver所对应的进程已经运行，则直接处理
    ProcessRecord app = mService.getProcessRecordLocked(targetProcess,
            info.activityInfo.applicationInfo.uid, false);
    if (app != null &amp;&amp; app.thread != null) &#123;
        try &#123;
            app.addPackage(info.activityInfo.packageName,
                    info.activityInfo.applicationInfo.versionCode, mService.mProcessStats);
            processCurBroadcastLocked(r, app);
            return;
        &#125; catch (RemoteException e) &#123;
        &#125; catch (RuntimeException e) &#123;
            finishReceiverLocked(r, r.resultCode, r.resultData, r.resultExtras, r.resultAbort, false);
            scheduleBroadcastsLocked();
            r.state = BroadcastRecord.IDLE; //启动receiver失败则重置状态
            return;
        &#125;
    &#125;
    
    //该receiver所对应的进程尚未启动，则创建该进程
    if ((r.curApp=mService.startProcessLocked(targetProcess,
            info.activityInfo.applicationInfo, true,
            r.intent.getFlags() | Intent.FLAG_FROM_BACKGROUND,
            &quot;broadcast&quot;, r.curComponent,
            (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_BOOT_UPGRADE) != 0, false, false))
                    == null) &#123;
        //创建失败，则结束该receiver
        finishReceiverLocked(r, r.resultCode, r.resultData,
                r.resultExtras, r.resultAbort, false);
        scheduleBroadcastsLocked();
        r.state = BroadcastRecord.IDLE;
        return;
    &#125;
    mPendingBroadcast = r;
    mPendingBroadcastRecvIndex = recIdx;
</code></pre>
<h1 id="4-3-deliverToRegisteredReceiverLocked"><a href="#4-3-deliverToRegisteredReceiverLocked" class="headerlink" title="4.3 deliverToRegisteredReceiverLocked"></a>4.3 deliverToRegisteredReceiverLocked</h1><pre><code>private void deliverToRegisteredReceiverLocked(BroadcastRecord r,
        BroadcastFilter filter, boolean ordered) &#123;
        ...
        //检查发送者是否有BroadcastFilter所需权限
        //以及接收者是否有发送者所需的权限等等
        //当权限不满足要求，则skip=true。
    
        if (!skip) &#123;
            //并行广播ordered = false，只有串行广播才进入该分支
            if (ordered) &#123;
                r.receiver = filter.receiverList.receiver.asBinder();
                r.curFilter = filter;
                filter.receiverList.curBroadcast = r;
                r.state = BroadcastRecord.CALL_IN_RECEIVE;
                if (filter.receiverList.app != null) &#123;
                    r.curApp = filter.receiverList.app;
                    filter.receiverList.app.curReceiver = r;
                    mService.updateOomAdjLocked(r.curApp);
                &#125;
            &#125;
            // 处理广播【见小节4.4】
            performReceiveLocked(filter.receiverList.app, filter.receiverList.receiver,
                    new Intent(r.intent), r.resultCode, r.resultData,
                    r.resultExtras, r.ordered, r.initialSticky, r.userId);
            if (ordered) &#123;
                r.state = BroadcastRecord.CALL_DONE_RECEIVE;
            &#125;
            ...
        &#125;
    &#125;
</code></pre>
<h1 id="4-4-performReceiveLocked"><a href="#4-4-performReceiveLocked" class="headerlink" title="4.4 performReceiveLocked"></a>4.4 performReceiveLocked</h1><pre><code>private static void performReceiveLocked(ProcessRecord app, IIntentReceiver receiver,
    Intent intent, int resultCode, String data, Bundle extras,
    boolean ordered, boolean sticky, int sendingUser) throws RemoteException &#123;
//通过binder异步机制，向receiver发送intent
if (app != null) &#123;
    if (app.thread != null) &#123;
        //调用ApplicationThreadProxy类对应的方法 【4.5】
        app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode,
                data, extras, ordered, sticky, sendingUser, app.repProcState);
    &#125; else &#123;
        //应用进程死亡，则Recevier并不存在
        throw new RemoteException(&quot;app.thread must not be null&quot;);
    &#125;
&#125; else &#123;
    //调用者进程为空，则执行该分支
    receiver.performReceive(intent, resultCode, data, extras, ordered,
            sticky, sendingUser);
&#125;
</code></pre>
<p>}</p>
<h1 id="4-5-ATP-scheduleRegisteredReceiver"><a href="#4-5-ATP-scheduleRegisteredReceiver" class="headerlink" title="4.5 ATP.scheduleRegisteredReceiver"></a>4.5 ATP.scheduleRegisteredReceiver</h1><p>ATP位于system_server进程，是Binder Bp端通过Binder驱动向Binder Bn端发送消息, ATP所对应的Bn端位于发送广播调用端所在进程的ApplicationThread，即进入AT.scheduleRegisteredReceiver， 接下来说明该方</p>
<pre><code>public void scheduleRegisteredReceiver(IIntentReceiver receiver, Intent intent,
        int resultCode, String dataStr, Bundle extras, boolean ordered,
        boolean sticky, int sendingUser, int processState) throws RemoteException &#123;
    Parcel data = Parcel.obtain();
    data.writeInterfaceToken(IApplicationThread.descriptor);
    data.writeStrongBinder(receiver.asBinder());
    intent.writeToParcel(data, 0);
    data.writeInt(resultCode);
    data.writeString(dataStr);
    data.writeBundle(extras);
    data.writeInt(ordered ? 1 : 0);
    data.writeInt(sticky ? 1 : 0);
    data.writeInt(sendingUser);
    data.writeInt(processState);

    //command=SCHEDULE_REGISTERED_RECEIVER_TRANSACTION
    mRemote.transact(SCHEDULE_REGISTERED_RECEIVER_TRANSACTION, data, null,
            IBinder.FLAG_ONEWAY);
    data.recycle();
&#125;
</code></pre>
<h1 id="4-6-scheduleRegisteredReceiver"><a href="#4-6-scheduleRegisteredReceiver" class="headerlink" title="4.6 scheduleRegisteredReceiver"></a>4.6 scheduleRegisteredReceiver</h1><p>IPC过程 最终调用到ActivityThread.scheduleRegisteredReceiver,此处receiver是注册广播时创建的，见小节[2.3]，可知该receiver=LoadedApk.ReceiverDispatcher.InnerReceiver。</p>
<pre><code>public void scheduleRegisteredReceiver(IIntentReceiver receiver, Intent intent,
        int resultCode, String dataStr, Bundle extras, boolean ordered,
        boolean sticky, int sendingUser, int processState) throws RemoteException &#123;
    //更新虚拟机进程状态
    updateProcessState(processState, false);
    //【见小节4.7】
    receiver.performReceive(intent, resultCode, dataStr, extras, ordered,
            sticky, sendingUser);
&#125;
</code></pre>
<h1 id="4-7-InnerReceiver-performReceive"><a href="#4-7-InnerReceiver-performReceive" class="headerlink" title="4.7 InnerReceiver.performReceive"></a>4.7 InnerReceiver.performReceive</h1><pre><code>base/core/java/android/app/LoadedApk.java
public void performReceive(Intent intent, int resultCode, String data,
        Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123;
    LoadedApk.ReceiverDispatcher rd = mDispatcher.get();
    if (rd != null) &#123;
        //【4.8】
        rd.performReceive(intent, resultCode, data, extras, ordered, sticky, sendingUser);
    &#125; else &#123;
       ...
    &#125;
&#125;
</code></pre>
<h1 id="4-8-ReceiverDispatcher-performReceive"><a href="#4-8-ReceiverDispatcher-performReceive" class="headerlink" title="4.8 ReceiverDispatcher.performReceive"></a>4.8 ReceiverDispatcher.performReceive</h1><p>其中Args继承于BroadcastReceiver.PendingResult，实现了接口Runnable。这里mActivityThread.post(args) 消息机制，关于Handler消息机制，见Android消息机制1-Handler(Java层)，把消息放入MessageQueue，再调用Args的run()方法。</p>
<pre><code>public void performReceive(Intent intent, int resultCode, String data,
        Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123;
    Args args = new Args(intent, resultCode, data, extras, ordered,
            sticky, sendingUser);
    //通过handler消息机制发送args.
    if (!mActivityThread.post(args)) &#123;
        if (mRegistered &amp;&amp; ordered) &#123;
            IActivityManager mgr = ActivityManagerNative.getDefault();
            args.sendFinished(mgr);
        &#125;
    &#125;
&#125;
</code></pre>
<h1 id="4-9-Args-run"><a href="#4-9-Args-run" class="headerlink" title="4.9 Args.run"></a>4.9 Args.run</h1><p>最终调用BroadcastReceiver具体实现类的onReceive()方法，至此广播的处理过程结束,后续是AMS的一些处理过程</p>
<pre><code>public final class LoadedApk &#123;
  static final class ReceiverDispatcher &#123;
    final class Args extends BroadcastReceiver.PendingResult implements Runnable &#123;
        public void run() &#123;
            final BroadcastReceiver receiver = mReceiver;
            final boolean ordered = mOrdered;

            final IActivityManager mgr = ActivityManagerNative.getDefault();
            final Intent intent = mCurIntent;
            mCurIntent = null;

            if (receiver == null || mForgotten) &#123;
                if (mRegistered &amp;&amp; ordered) &#123;
                    sendFinished(mgr);
                &#125;
                return;
            &#125;

            try &#123;
                //获取mReceiver的类加载器
                ClassLoader cl =  mReceiver.getClass().getClassLoader();
                intent.setExtrasClassLoader(cl);
                setExtrasClassLoader(cl);
                receiver.setPendingResult(this);
                //回调广播onReceive方法
                receiver.onReceive(mContext, intent);
            &#125; catch (Exception e) &#123;
                ...
            &#125;
            //调用到BroadcastReceiver.finishReceiver
            if (receiver.getPendingResult() != null) &#123;
                finish();
            &#125;
        &#125;
      &#125;
    &#125;
</code></pre>
<p>​        </p>
<h1 id="4-10-PendingResult-finish"><a href="#4-10-PendingResult-finish" class="headerlink" title="4.10 PendingResult.finish"></a>4.10 PendingResult.finish</h1><p>此处AMP.finishReceiver，经过binder调用，进入AMS.finishReceiver方法,</p>
<pre><code>base/core/java/android/content/BroadcastReceiver.java

public final void finish() &#123;
    final IActivityManager mgr = ActivityManagerNative.getDefault();
    sendFinished(mgr);
    ...
&#125;

public void sendFinished(IActivityManager am) &#123;
    synchronized (this) &#123;
        try &#123;
            if (mResultExtras != null) &#123;
                mResultExtras.setAllowFds(false);
            &#125;
            if (mOrderedHint) &#123;
                //串行广播
                am.finishReceiver(mToken, mResultCode, mResultData, mResultExtras,
                        mAbortBroadcast, mFlags);
            &#125; else &#123;
                //并行广播
                am.finishReceiver(mToken, 0, null, null, false, mFlags);
            &#125;
        &#125; catch (RemoteException ex) &#123;
        &#125;
    &#125;
&#125;
</code></pre>
<h1 id="4-11-AMS-finishReceiver"><a href="#4-11-AMS-finishReceiver" class="headerlink" title="4.11 AMS.finishReceiver"></a>4.11 AMS.finishReceiver</h1><pre><code>public void finishReceiver(IBinder who, int resultCode, String resultData,
        Bundle resultExtras, boolean resultAbort, int flags) &#123;
    ...
    final long origId = Binder.clearCallingIdentity();
    try &#123;
        boolean doNext = false;
        BroadcastRecord r;

        synchronized(this) &#123;
            BroadcastQueue queue = (flags &amp; Intent.FLAG_RECEIVER_FOREGROUND) != 0
                    ? mFgBroadcastQueue : mBgBroadcastQueue;
            r = queue.getMatchingOrderedReceiver(who);
            if (r != null) &#123;
                doNext = r.queue.finishReceiverLocked(r, resultCode,
                    resultData, resultExtras, resultAbort, true);
            &#125;
        &#125;

        if (doNext) &#123;
            //处理下一条广播
            r.queue.processNextBroadcast(false);
        &#125;
        trimApplications();
    &#125; finally &#123;
        Binder.restoreCallingIdentity(origId);
    &#125;
&#125;
</code></pre>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/02/26/Notes/Android/Framework/Android%20Service%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p> 一、 startService 和 bindService的区别<br>    <img src="https://leanote.com/api/file/getImage?fileId=59341fcbab64415b02001748"></p>
<ul>
<li>执行startService时，Service会经历onCreate-&gt;onStartCommand。当执行stopService时，直接调用onDestroy方法。调用者如果没有stopService，Service会一直在后台运行，下次调用者再起来仍然可以stopService。</li>
<li>执行bindService时，Service会经历onCreate-&gt;onBind。这个时候调用者和Service绑定在一起。调用者调用unbindService方法或者调用者Context不存在了（如Activity被finish了），Service就会调用onUnbind-&gt;onDestroy。这里所谓的绑定在一起就是说两者共存亡了。</li>
<li>多次调用startService，该Service只能被创建一次，即该Service的onCreate方法只会被调用一次。但是每次调用startService，onStartCommand方法都会被调用。Service的onStart方法在API5时被废弃，替代它的是onStartCommand方法。</li>
<li>第一次执行bindService时，onCreate和onBind方法会被调用，但是多次执行bindService时，onCreate和onBind方法并不会被多次调用，即并不会多次创建服务和绑定服务。</li>
</ul>
<p>二、startService的过程<br><a href="http://0.0.0.1/">http://www.jianshu.com/p/c0aadd5bf7a5</a><br><a href="http://0.0.0.2/">http://wujingchao.com/2016/02/10/art-of-android-development-notes-startservice/</a></p>
<p>1.frameworks/base/core/java/android/content/ContextWrapper.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ComponentName <span class="title">startService</span><span class="params">(Intent service)</span> </span>&#123;</span><br><span class="line">        warnIfCallingFromSystemProcess();</span><br><span class="line">        <span class="keyword">return</span> startServiceCommon(service, mUser);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> ComponentName <span class="title">startServiceCommon</span><span class="params">(Intent service, UserHandle user)</span> </span>&#123;</span><br><span class="line">    ComponentName cn = ActivityManagerNative.getDefault().startService(</span><br><span class="line">        mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(</span><br><span class="line">                    getContentResolver()), getOpPackageName(), user.getIdentifier());    </span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.通过ActivityManagerNative.getDefault().startService的ActivityManagerNative-&gt;ActivityManagerService-&gt;ActiveServices.startServiceLocked</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ComponentName <span class="title">startServiceLocked</span><span class="params">(IApplicationThread caller, Intent service, String resolvedType,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid, String callingPackage, <span class="keyword">int</span> userId)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">…</span><br><span class="line"><span class="comment">//PackageManagerService解析出Intent得到要启动的ServiceRecord</span></span><br><span class="line">ServiceLookupResult res =</span><br><span class="line">retrieveServiceLocked(service, resolvedType, callingPackage,</span><br><span class="line">callingPid, callingUid, userId, <span class="keyword">true</span>, callerFg);</span><br><span class="line">    ServiceRecord r = res.record;            </span><br><span class="line">... </span><br><span class="line"><span class="keyword">return</span> startServiceInnerLocked(smap, service, r, callerFg, addToStarting);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ComponentName <span class="title">startServiceInnerLocked</span><span class="params">(ServiceMap smap, Intent service, ServiceRecord r,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">boolean</span> callerFg, <span class="keyword">boolean</span> addToStarting)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">…</span><br><span class="line">String error = bringUpServiceLocked(r, service.getFlags(), callerFg, <span class="keyword">false</span>);</span><br><span class="line">…</span><br><span class="line"><span class="keyword">return</span> r.name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> String <span class="title">bringUpServiceLocked</span><span class="params">(ServiceRecord r,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">int</span> intentFlags, <span class="keyword">boolean</span> execInFg, <span class="keyword">boolean</span> whileRestarting)</span> </span>&#123;</span><br><span class="line"><span class="comment">//如果进程已经存在的情况下就不是处理下面的流程，直接处理onStart的流程</span></span><br><span class="line"><span class="keyword">if</span> (r.app != <span class="keyword">null</span> &amp;&amp; r.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">sendServiceArgsLocked(r, execInFg, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处于restart的状态(在onStartCommand里面处理了服务被杀之后的行为)也不会处理</span></span><br><span class="line"><span class="keyword">if</span> (!whileRestarting &amp;&amp; r.restartDelay &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mRestartingServices.remove(r)) &#123;</span><br><span class="line">clearRestartingIfNeededLocked(r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (r.delayed) &#123;</span><br><span class="line">getServiceMap(r.userId).mDelayedStartList.remove(r);</span><br><span class="line">r.delayed = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//…</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> isolated = (r.serviceInfo.flags&amp;ServiceInfo.FLAG_ISOLATED_PROCESS) != <span class="number">0</span>;</span><br><span class="line"><span class="keyword">final</span> String procName = r.processName;</span><br><span class="line">ProcessRecord app;</span><br><span class="line"><span class="comment">//独立的进程运行isolated为true,</span></span><br><span class="line"><span class="keyword">if</span> (!isolated) &#123;</span><br><span class="line">app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">app.addPackage(r.appInfo.packageName, r.appInfo.versionCode, mAm.mProcessStats);</span><br><span class="line"><span class="comment">//直接启动服务，不用开启新的进程</span></span><br><span class="line">realStartServiceLocked(r, app, execInFg);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">Slog.w(TAG, “Exception when starting service ” + r.shortName, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">app = r.isolatedProc;</span><br><span class="line">&#125;</span><br><span class="line">第一次创建时，走到这里，先创建一个service的进程</span><br><span class="line"><span class="keyword">if</span> (app == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//开启新的进程 </span></span><br><span class="line">    <span class="keyword">if</span> ((app=mAm.startProcessLocked(procName, r.appInfo, <span class="keyword">true</span>, intentFlags,</span><br><span class="line">            <span class="string">&quot;service&quot;</span>, r.name, <span class="keyword">false</span>, isolated, <span class="keyword">false</span>))== <span class="keyword">null</span>) &#123;</span><br><span class="line">        bringDownServiceLocked(r);</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isolated) &#123;</span><br><span class="line">        r.isolatedProc = app;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将ServiceRecord加入即将启动mPendingServices列表里，后面进程启动成功后在启动Service</span></span><br><span class="line"><span class="keyword">if</span> (!mPendingServices.contains(r)) &#123;</span><br><span class="line">    mPendingServices.add(r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果进程已经存在的情况下就不是处理下面的流程，直接调用realStartServiceLocked处理onStart的流程。ActivityManagerService.startProcessLocked开启进程，procName为AndroidManifest中Service标签了process指定的进程名，默认是包名。</p>
<pre><code>final ProcessRecord startProcessLocked(String processName, ApplicationInfo info,
boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName,
boolean allowWhileBooting, boolean isolated, int isolatedUid, boolean keepIfLarge,
String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler) &#123;
    ProcessRecord app;
    if (!isolated) &#123;
    app = getProcessRecordLocked(processName, info.uid, keepIfLarge);
    &#125; else &#123;
        // If this is an isolated process, it can&#39;t re-use an existing process.
        app = null;
    &#125;
    //...
    String hostingNameStr = hostingName != null
            ? hostingName.flattenToShortString() : null;
   //...
   if (app == null) &#123;
        //构建一个新的的ProcessRecord
        app = newProcessRecordLocked(info, processName, isolated, isolatedUid);
        app.crashHandler = crashHandler;
        mProcessNames.put(processName, app.uid, app);
        if (isolated) &#123;
            mIsolatedProcesses.put(app.uid, app);
        &#125;
    &#125; 
    //...
    startProcessLocked(
            app, hostingType, hostingNameStr, abiOverride, entryPoint, entryPointArgs);
    return (app.pid != 0) ? app : null;
&#125;
</code></pre>
<p>构建新的ProcessRecord，startProcessLocked开启进程:</p>
<pre><code>private final void startProcessLocked(ProcessRecord app, String hostingType,
        String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) &#123;
    //...
    try &#123;
        int uid = app.uid;
        int[] gids = null;
        int mountExternal = Zygote.MOUNT_EXTERNAL_NONE;
        if (!app.isolated) &#123;
            //...
        &#125;
        int debugFlags = 0;
        //...
        boolean isActivityProcess = (entryPoint == null);
        if (entryPoint == null) entryPoint = &quot;android.app.ActivityThread&quot;;
        Process.ProcessStartResult startResult = Process.start(entryPoint,
                app.processName, uid, uid, gids, debugFlags, mountExternal,
                app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,
                app.info.dataDir, entryPointArgs);
        //...
&#125;
</code></pre>
<p>调用Process.start开启一个新的进程，新进程的入口点就是android.app.ActivityThread，执行里面的main方法。</p>
<pre><code> public final class ActivityThread &#123;
    final ApplicationThread mAppThread = new ApplicationThread();
    public static void main(String[] args) &#123;
        //...
        Looper.prepareMainLooper();
        ActivityThread thread = new ActivityThread();
        thread.attach(false);
        if (sMainThreadHandler == null) &#123;
            sMainThreadHandler = thread.getHandler();
        &#125;
        Looper.loop();
        throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);
    &#125;
     private void attach(boolean system) &#123;
        //...
        if (!system) &#123;
            //...
            final IActivityManager mgr = ActivityManagerNative.getDefault();
            try &#123;
                mgr.attachApplication(mAppThread);
            &#125; catch (RemoteException ex) &#123;
                // Ignore
            &#125;
            //...
        &#125; 
    &#125;
&#125;
</code></pre>
<p>准备主线程的Looper，调用attachApplication通知ActiviyManangerService主线程准备完毕，然后loop开始消息循环。<br>ApplicationThread通过IPC向ActivityManagerService调用attachApplication，并传递mAppThread给ActivityManagerService，mAppThread是一个Binder对象，用于ActivityManagerService向我们发起调用。注意从这里开始已经是在新进程里面执行了。<br>ApplicationThread对象继承自ApplicationThreadNative.java，在ActivityThread对象被创建时，它也被构造了，我前面已经提到过了，它继承了ApplicationThreadNative类，熟悉进程通信代理机制的朋友就清楚了，ApplicationThread就是一个通信代理存根实现类，我们可以看它的实现方法，都是调用queueOrSendMessage方法，派发消息交给ActivityThread的mH去处理，那么我们很清楚了，ActivityThread代理存根对象，它负责执行来自远程的调用，这些远程的调用大部分来自system_process，所以，system_process很容易通过ApplicationThread的客户端代理对象控制ActivityThread，事实就是如此，后面我们可以很好地看到这一点</p>
<pre><code>    base/core/java/android/app/ActivityManagerNative.java
    
    class ActivityManagerProxy implements IActivityManager&#123;
    public void attachApplication(IApplicationThread app) throws RemoteException
    &#123;
        Parcel data = Parcel.obtain();
        Parcel reply = Parcel.obtain();
        data.writeInterfaceToken(IActivityManager.descriptor);
        data.writeStrongBinder(app.asBinder());
        mRemote.transact(ATTACH_APPLICATION_TRANSACTION, data, reply, 0);
        reply.readException();
        data.recycle();
        reply.recycle();
    &#125;
&#125;
</code></pre>
<p>遂进入到ActivityManagerService:</p>
<pre><code>public final void attachApplication(IApplicationThread thread) &#123;
synchronized (this) &#123;
    int callingPid = Binder.getCallingPid();
    final long origId = Binder.clearCallingIdentity();
    attachApplicationLocked(thread, callingPid);
    Binder.restoreCallingIdentity(origId);
&#125;
</code></pre>
<p>attachApplicationLocked</p>
<pre><code>private final boolean attachApplicationLocked(IApplicationThread thread,
        int pid) &#123;
    ProcessRecord app;
    ...
    final String processName = app.processName;
    ...
    app.makeActive(thread, mProcessStats);
    app.curAdj = app.setAdj = -100;
    app.curSchedGroup = app.setSchedGroup = Process.THREAD_GROUP_DEFAULT;
    app.forcingToForeground = null;
    updateProcessForegroundLocked(app, false, false);
    app.hasShownUi = false;
    app.debugging = false;
    app.cached = false;
    app.killedByAm = false;
    ...
     //使用ApplicationThread发起IPC调用bindApplication -&gt;ActivityThread．bindApplication:
        thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,
                profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,
                app.instrumentationUiAutomationConnection, testMode, enableOpenGlTrace,
                isRestrictedBackupMode || !normalMode, app.persistent,
                new Configuration(mConfiguration), app.compat,
                getCommonServicesLocked(app.isolated),
                mCoreSettingsObserver.getCoreSettingsLocked());
    ...   
        
    boolean badApp = false;
    //...
    // Find any services that should be running in this process...
    if (!badApp) &#123;
        try &#123;
            //接着调用ActivieServices的attachApplicationLocked通知客户端启动Service:
            didSomething |= mServices.attachApplicationLocked(app, processName);
        &#125; catch (Exception e) &#123;
            Slog.wtf(TAG, &quot;Exception thrown starting services in &quot; + app, e);
            badApp = true;
        &#125;
    &#125;
   //...
    return true;
&#125;
</code></pre>
<p>使用ApplicationThread发起IPC调用bindApplication -&gt;ActivityThread.bindApplication:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bindApplication</span><span class="params">(String processName, ApplicationInfo appInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">                List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName,</span></span></span><br><span class="line"><span class="params"><span class="function">                ProfilerInfo profilerInfo, Bundle instrumentationArgs,</span></span></span><br><span class="line"><span class="params"><span class="function">                IInstrumentationWatcher instrumentationWatcher,</span></span></span><br><span class="line"><span class="params"><span class="function">                IUiAutomationConnection instrumentationUiConnection, <span class="keyword">int</span> debugMode,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">boolean</span> enableOpenGlTrace, <span class="keyword">boolean</span> isRestrictedBackupMode, <span class="keyword">boolean</span> persistent,</span></span></span><br><span class="line"><span class="params"><span class="function">                Configuration config, CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services,</span></span></span><br><span class="line"><span class="params"><span class="function">                Bundle coreSettings)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//... init</span></span><br><span class="line">            IPackageManager pm = getPackageManager();</span><br><span class="line">            android.content.pm.PackageInfo pi = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pi = pm.getPackageInfo(appInfo.packageName, <span class="number">0</span>, UserHandle.myUserId());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pi != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">//处理sharedUid的情况</span></span><br><span class="line">               <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">            AppBindData data = <span class="keyword">new</span> AppBindData();</span><br><span class="line">            data.processName = processName;</span><br><span class="line">            data.appInfo = appInfo;</span><br><span class="line">            data.providers = providers;</span><br><span class="line">            data.instrumentationName = instrumentationName;</span><br><span class="line">            data.instrumentationArgs = instrumentationArgs;</span><br><span class="line">            data.instrumentationWatcher = instrumentationWatcher;</span><br><span class="line">            data.instrumentationUiAutomationConnection = instrumentationUiConnection;</span><br><span class="line">            data.debugMode = debugMode;</span><br><span class="line">            data.enableOpenGlTrace = enableOpenGlTrace;</span><br><span class="line">            data.restrictedBackupMode = isRestrictedBackupMode;</span><br><span class="line">            data.persistent = persistent;</span><br><span class="line">            data.config = config;</span><br><span class="line">            data.compatInfo = compatInfo;</span><br><span class="line">            data.initProfilerInfo = profilerInfo;</span><br><span class="line">            sendMessage(H.BIND_APPLICATION, data);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">int</span> what, Object obj)</span> </span>&#123;</span><br><span class="line">        sendMessage(what, obj, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> H mH = <span class="keyword">new</span> H();</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">int</span> what, Object obj, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    Message msg = Message.obtain();</span><br><span class="line">    msg.what = what;</span><br><span class="line">    msg.obj = obj;</span><br><span class="line">    msg.arg1 = arg1;</span><br><span class="line">    msg.arg2 = arg2;</span><br><span class="line">    <span class="keyword">if</span> (async) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mH.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p> 主线程的Looper前面已经在ActivityThread主线程里面初始化了，然后向Handler发消息实现进程切换(因为bindApplication是在客户端Binder线程池里面调用的)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">case</span> BIND_APPLICATION:</span><br><span class="line">                       AppBindData data = (AppBindData)msg.obj;</span><br><span class="line">                       handleBindApplication(data);</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>接着调用ActivityThread的handleBindApplication，主要是然客户端初始化应用程序的一些状态比如时区地域，Instrumentation，LoadedApk等等。</p>
<pre><code>private void handleBindApplication(AppBindData data) &#123;
    mBoundApplication = data;
    mConfiguration = new Configuration(data.config);
    mCompatConfiguration = new Configuration(data.config);
    //...
    TimeZone.setDefault(null);
    //...
    Locale.setDefault(data.config.locale);
    //...
&#125;
</code></pre>
<p>再回到ActivityManagerService中的attachApplicationLocked，接着调用ActivieServices的attachApplicationLocked通知客户端启动Service</p>
<pre><code>    if (!badApp) &#123;
        try &#123;
            didSomething |= mServices.attachApplicationLocked(app, processName);
        &#125; catch (Exception e) &#123;
            Slog.wtf(TAG, &quot;Exception thrown starting services in &quot; + app, e);
            badApp = true;
        &#125;
    &#125;
</code></pre>
<p>attachApplicationLocked，mPendingServices就是前面加入列表的ServiceRecord，过滤要启动的ServiceRecord，调用realStartServiceLocked:   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(ProcessRecord proc, String processName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> didSomething = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// Collect any services that are waiting for this process to come up.</span></span><br><span class="line">    <span class="keyword">if</span> (mPendingServices.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ServiceRecord sr = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mPendingServices.size(); i++) &#123; sr = mPendingServices.get(i); <span class="comment">//过滤我们客户端当前的进程 </span></span><br><span class="line">                                                           <span class="keyword">if</span> (proc != sr.isolatedProc &amp;&amp; (proc.uid != sr.appInfo.uid || !processName.equals(sr.processName))) &#123; <span class="keyword">continue</span>; &#125; mPendingServices.remove(i); i--; proc.addPackage(sr.appInfo.packageName, sr.appInfo.versionCode, mAm.mProcessStats); realStartServiceLocked(sr, proc, sr.createdFromFg); didSomething = <span class="keyword">true</span>; &#125; &#125; <span class="keyword">catch</span> (RemoteException e) &#123; Slog.w(TAG, <span class="string">&quot;Exception in new application when starting service &quot;</span> - sr.shortName, e); <span class="keyword">throw</span> e; &#125; &#125; <span class="keyword">if</span> (mRestartingServices.size()&gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">//处理restart的状态</span></span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> didSomething;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>pendingStarts在放入要执行start操作的列表里面，在执行sendServiceArgsLocked告诉客户端执行onStart:</p>
<pre><code>private final void realStartServiceLocked(ServiceRecord r,
        ProcessRecord app, boolean execInFg) throws RemoteException &#123;
    //..
    r.app = app;
    r.restartTime = r.lastActivity = SystemClock.uptimeMillis();
    app.services.add(r);
    //将Service加入到正在执行的executingServices(ProcessRecord)列表里
    bumpServiceExecutingLocked(r, execInFg, &quot;create&quot;);
    mAm.updateLruProcessLocked(app, false, null);
    mAm.updateOomAdjLocked();
    boolean created = false;
    try &#123;
        //...
        app.thread.scheduleCreateService(r, r.serviceInfo,
                mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),
                app.repProcState);
        //前台进程显示Notification
        r.postNotification();
        created = true;
    &#125; catch (DeadObjectException e) &#123;
      //...
  &#125;
    // If the service is in the started state, and there are no
    // pending arguments, then fake up one so its onStartCommand() will
    // be called.
    if (r.startRequested &amp;&amp; r.callStart &amp;&amp; r.pendingStarts.size() == 0) &#123;
        r.pendingStarts.add(new ServiceRecord.StartItem(r, false, r.makeNextStartId(),
                null, null));
    &#125;
    sendServiceArgsLocked(r, execInFg, true);
    //...
&#125;
</code></pre>
<p> 先看ActivityThread的scheduleCreateService,这里对应的token就是ActivityManagerService创建的ServiceRecord，ServiceInfo是ActivityManagerService为我们解析AndroidManifest的Service标签:</p>
<pre><code>public final void scheduleCreateService(IBinder token,
        ServiceInfo info, CompatibilityInfo compatInfo, int processState) &#123;
    updateProcessState(processState, false);
    CreateServiceData s = new CreateServiceData();
    s.token = token;
    s.info = info;
    s.compatInfo = compatInfo;
    sendMessage(H.CREATE_SERVICE, s);
&#125;
</code></pre>
<p>同样是向Handler发送消息实现进程切换:</p>
<pre><code> private class H extends Handler &#123;
    public void handleMessage(Message msg) &#123;
        //...
         case CREATE_SERVICE:
            handleCreateService((CreateServiceData)msg.obj);
            break;
        //...
    &#125;
&#125;
</code></pre>
<p>执行ActivityThread的handleCreateService，实现创建服务并执行onCreate，调用ActivityManagerService的serviceDoneExecuting，onCreate更新下Service的一些状态</p>
<pre><code> private void handleCreateService(CreateServiceData data) &#123;
    ...
        Service service = null;
        ...
            java.lang.ClassLoader cl = packageInfo.getClassLoader();
            service = (Service) cl.loadClass(data.info.name).newInstance();
            ...
            service.attach(context, this, data.info.name, data.token, app,
                    ActivityManagerNative.getDefault());
            service.onCreate();
            mServices.put(data.token, service);
            ...
            //serviceDoneExecuting的主要工作是当service启动完成，则移除service Timeout消息。
                ActivityManagerNative.getDefault().serviceDoneExecuting(
                        data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);
            ...
    &#125;
</code></pre>
<p>再回到上面的ActivieServices的sendServiceArgsLocked告诉客户端要执行onStartCommand，将要执行的onStart的参数（例如startId）传回客户端:</p>
<pre><code>    private final void sendServiceArgsLocked(ServiceRecord r, boolean execInFg,
        boolean oomAdjusted) &#123;
    //...
    while (r.pendingStarts.size() &gt; 0) &#123;
        try &#123;
            ServiceRecord.StartItem si = r.pendingStarts.remove(0);
            //...
            si.deliveredTime = SystemClock.uptimeMillis();
            r.deliveredStarts.add(si);
            si.deliveryCount++;
            //更新正在执行的状态
            bumpServiceExecutingLocked(r, execInFg, &quot;start&quot;);
            int flags = 0;
            if (si.deliveryCount &gt; 1) &#123;
                flags |= Service.START_FLAG_RETRY;
            &#125;
            if (si.doneExecutingCount &gt; 0) &#123;
                flags |= Service.START_FLAG_REDELIVERY;
            &#125;
            //IPC过程 ApplicationThreadNative -&gt; ActivityThread
            r.app.thread.scheduleServiceArgs(r, si.taskRemoved, si.id, flags, si.intent);
        &#125; catch (RemoteException e) &#123;
            //...
        &#125; 
    &#125;
&#125;
</code></pre>
<p>接着执行ActivityThread里的scheduleServiceArgs:</p>
<pre><code>public final void scheduleServiceArgs(IBinder token, boolean taskRemoved, int startId,
            int flags ,Intent args) &#123;
            ServiceArgsData s = new ServiceArgsData();
            s.token = token;
            s.taskRemoved = taskRemoved;
            s.startId = startId;
            s.flags = flags;
            s.args = args;
            sendMessage(H.SERVICE_ARGS, s);
        &#125;
</code></pre>
<p>同样发送消息给主线程执行handleServiceArgs，mServices为客户端维护的Service列表:</p>
<pre><code>    private void handleServiceArgs(ServiceArgsData data) &#123;
    Service s = mServices.get(data.token);
    ...
            int res;
            if (!data.taskRemoved) &#123;
                res = s.onStartCommand(data.args, data.flags, data.startId);
           ...
           //通知AMSservice的状态
           ActivityManagerNative.getDefault().serviceDoneExecuting(
                    data.token, SERVICE_DONE_EXECUTING_START, data.startId, res);
           
&#125;
</code></pre>
<p>onStartCommand执行完后会返回一个参数，用于控制Service的一些行为，例如进程被杀死之后Service的行为。<br>随后调用serviceDoneExecuting告诉ActivityManagerService，onStart已经执行完了，ActivityManagerService再更新一些状态，就这样Service就运行起来了。</p>
<p>三、bindService的过程分析<br>    这个过程中Service所在的进程是已经别启动了的<br>    <a href="http://0.0.0.1/">http://www.jianshu.com/p/37e0e66979a6</a><br>    <a href="http://0.0.0.2/">http://blog.csdn.net/jelly_fang/article/details/50488915</a><br>    <a href="http://0.0.0.3/">http://www.cnblogs.com/android-blogs/p/5718302.html</a></p>
<p>frameworks\base\core\java\android\app\ContextImpl.java</p>
<pre><code> public boolean bindService(Intent service, ServiceConnection conn,
            int flags) &#123;
        warnIfCallingFromSystemProcess();
        return bindServiceCommon(service, conn, flags, Process.myUserHandle());
    &#125;
    private boolean bindServiceCommon(Intent service, ServiceConnection conn, int flags,
            UserHandle user) &#123;
        IServiceConnection sd;
        ...
        1.onbind最终回调ServiceConnection的onServiceConnected方法
        if (mPackageInfo != null) &#123;
            sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(),
                    mMainThread.getHandler(), flags);
        &#125; 
        ...
        2.AMS中bind过程
        int res = ActivityManagerNative.getDefault().bindService(
                mMainThread.getApplicationThread(), getActivityToken(), service,
                service.resolveTypeIfNeeded(getContentResolver()),
                sd, flags, getOpPackageName(), user.getIdentifier());    
        ...
    &#125;
</code></pre>
<p>分析1过程：<br>sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(),<br>                mMainThread.getHandler(), flags);</p>
<pre><code>frameworks\base\core\java\android\app\LoadedApk.java

public final IServiceConnection getServiceDispatcher(ServiceConnection c,
        Context context, Handler handler, int flags) &#123;
    synchronized (mServices) &#123;
        //创建ServiceDispatcher
        LoadedApk.ServiceDispatcher sd = null;
        ...
        if (sd == null) &#123;
            sd = new ServiceDispatcher(c, context, handler, flags);
            ...
        &#125;
        ...
        //返回的是ServiceDispatcher的内部类InnerConnection
        return sd.getIServiceConnection();
    &#125;
&#125;
</code></pre>
<p>   ServiceDispatcher类中的方法</p>
<pre><code>static final class ServiceDispatcher &#123;
    private final ServiceDispatcher.InnerConnection mIServiceConnection;
    private final ServiceConnection mConnection;
    private final Context mContext;
    private final Handler mActivityThread;
    private final ServiceConnectionLeaked mLocation;
    private final int mFlags;
    ...
    //ServiceDispatcher的内部类
    private static class InnerConnection extends IServiceConnection.Stub &#123;
        final WeakReference&lt;LoadedApk.ServiceDispatcher&gt; mDispatcher;

        InnerConnection(LoadedApk.ServiceDispatcher sd) &#123;
            mDispatcher = new WeakReference&lt;LoadedApk.ServiceDispatcher&gt;(sd);
        &#125;
        //保存当前激活的Serviceconnection的Map
        private final ArrayMap&lt;ComponentName, ServiceDispatcher.ConnectionInfo&gt; mActiveConnections
        = new ArrayMap&lt;ComponentName, ServiceDispatcher.ConnectionInfo&gt;();
        
        public void connected(ComponentName name, IBinder service) throws RemoteException &#123;
            LoadedApk.ServiceDispatcher sd = mDispatcher.get();
            if (sd != null) &#123;
                //调用到了外部类ServiceDispatcher中的connected
                sd.connected(name, service);
            &#125;
        &#125;
    &#125;
    //ServiceDispatcher的connected方法
    public void connected(ComponentName name, IBinder service) &#123;
        if (mActivityThread != null) &#123;
            mActivityThread.post(new RunConnection(name, service, 0));
        &#125; else &#123;
        //调用到ServiceDispatcher的doConnected
            doConnected(name, service);
        &#125;
    &#125;
    
    public void doConnected(ComponentName name, IBinder service) &#123;
        ...
        if (service != null) &#123;
                // A new service is being connected... set it all up.
                mDied = false;
                info = new ConnectionInfo();
                info.binder = service;
                info.deathMonitor = new DeathMonitor(name, service);
                ...
        &#125;   
        ...
        // If there is a new service, it is now connected.
        if (service != null) &#123;
            //调用了 mConnection.onServiceConnected(name, service)这个方法,后面会通过InnerConnection实例来远程回调这个方法。
            //这个mConnection其实就是一开始ServiceDispatcher 的构造函数中传进来的ServiceConnection实例。
            mConnection.onServiceConnected(name, service);
        &#125;
    &#125;
</code></pre>
<p> 分析2过程：<br>    int res = ActivityManagerNative.getDefault().bindService(<br>            mMainThread.getApplicationThread(), getActivityToken(), service,<br>            service.resolveTypeIfNeeded(getContentResolver()),<br>            sd, flags, getOpPackageName(), user.getIdentifier());</p>
<p>   ActivityManagerNative.getDefault() 最终都会调用ActiveServices.bindServiceLocked方法,细致的不去跟踪<br>   frameworks\base\services\core\java\com\android\server\am\ActiveServices.java<br>   s（ServiceRecord ）、b（AppBindRecord ）、c（ConnectionRecord ）、callerApp （ProcessRecord） 这四个类型的一些保存之类的操作，方便以后调用</p>
<pre><code>    int bindServiceLocked(IApplicationThread caller, IBinder token, Intent service,
        String resolvedType, IServiceConnection connection, int flags,
        String callingPackage, int userId) throws TransactionTooLargeException &#123;
    ...
  
    final ProcessRecord callerApp = mAm.getRecordForAppLocked(caller);
    ...
    ServiceLookupResult res =
        retrieveServiceLocked(service, resolvedType, callingPackage,
                Binder.getCallingPid(), Binder.getCallingUid(), userId, true, callerFg);
    if (res == null) &#123;
        return 0;
    &#125;
    if (res.record == null) &#123;
        return -1;
    &#125;
    ServiceRecord s = res.record;
    ...
    try &#123;
        mAm.startAssociationLocked(callerApp.uid, callerApp.processName,
                s.appInfo.uid, s.name, s.processName);
        //获取一个ServiceRecord对象，如果不存在就创建        
        AppBindRecord b = s.retrieveAppBindingLocked(service, callerApp);
        ConnectionRecord c = new ConnectionRecord(b, activity,connection, flags, clientLabel, clientIntent);
        
        //这个binder其实可以简单的看做成IServiceConnection ，后面可以通过它asInterface方法获取binder驱动来远程调用IServiceConnection （其实就是IServiceConnection–&gt;InnerConnection –&gt;ServiceDispatcher ）里面的方法。然后把这个binder放到了s（ServiceRecord ）的connections的集合中,clist就是一个connectionRecord的集合，应为可能不止一个activity或者组件需要绑定这个service。
        IBinder binder = connection.asBinder();
        
        ArrayList&lt;ConnectionRecord&gt; clist = s.connections.get(binder);
        if (clist == null) &#123;
            clist = new ArrayList&lt;ConnectionRecord&gt;();
            s.connections.put(binder, clist);
        &#125;
        clist.add(c);
        ...
        if ((flags&amp;Context.BIND_AUTO_CREATE) != 0) &#123;
            s.lastActivity = SystemClock.uptimeMillis();
            //执行bringUpServiceLocked,bringUpServiceLocked调用到realStartServiceLocked;
            if (bringUpServiceLocked(s, service.getFlags(), callerFg, false) != null) &#123;
                return 0;
            &#125;
        &#125;
</code></pre>
<p>​<br>​            if (s.app != null &amp;&amp; b.intent.received) {<br>​                // Service is already running, so we can immediately<br>​                // publish the connection.<br>​                …<br>​                    //重复bind时会走这里，直接调用requestServiceBindingLocked<br>​                    c.conn.connected(s.name, b.intent.binder);<br>​                …<br>​                // If this is the first app connected back to this binding,<br>​                // and the service had previously asked to be told when<br>​                // rebound, then do so.<br>​                if (b.intent.apps.size() == 1 &amp;&amp; b.intent.doRebind) {<br>​                    requestServiceBindingLocked(s, b.intent, callerFg, true);<br>​                }<br>​            } else if (!b.intent.requested) {<br>​                requestServiceBindingLocked(s, b.intent, callerFg, false);<br>​<br>            }<br>        …<br>        return 1;<br>    }</p>
<p>bringUpServiceLocked</p>
<pre><code> private final String bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean execInFg, boolean whileRestarting) throws TransactionTooLargeException &#123;
        ...
        if (!isolated) &#123;
            app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, false);
            if (DEBUG_MU) Slog.v(TAG_MU, &quot;bringUpServiceLocked: appInfo.uid=&quot; + r.appInfo.uid
                        + &quot; app=&quot; + app);
            if (app != null &amp;&amp; app.thread != null) &#123;
                try &#123;
                    app.addPackage(r.appInfo.packageName, r.appInfo.versionCode, mAm.mProcessStats);
                    realStartServiceLocked(r, app, execInFg);
                    return null;
                &#125; catch (TransactionTooLargeException e) &#123;
                    throw e;
                &#125; catch (RemoteException e) &#123;
                    Slog.w(TAG, &quot;Exception when starting service &quot; + r.shortName, e);
                &#125;
            &#125;
        &#125;
        ...
        return null;
    &#125;
</code></pre>
<p> realStartServiceLocked</p>
<pre><code>private final void realStartServiceLocked(ServiceRecord r,
            ProcessRecord app, boolean execInFg) throws RemoteException &#123;

        r.app = app;
       ...
        //3.调用ActivityThread的scheduleCreateService,创建一个Service
            app.thread.scheduleCreateService(r, r.serviceInfo,
                    mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),
                    app.repProcState);
            r.postNotification();
     ...
        //4. 等待3的service被创建完成bindService
        requestServiceBindingsLocked(r, execInFg);
        updateServiceClientActivitiesLocked(app, null, true);
    &#125;
</code></pre>
<p>分析3过程<br>app.thread.scheduleCreateService(r, r.serviceInfo,<br>                    mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),<br>                    app.repProcState);</p>
<pre><code>//scheduleCreateService 发送一个消息
public final void scheduleCreateService(IBinder token,
            ServiceInfo info, CompatibilityInfo compatInfo, int processState) &#123;
        updateProcessState(processState, false);
        CreateServiceData s = new CreateServiceData();
        s.token = token;
        s.info = info;
        s.compatInfo = compatInfo;

        sendMessage(H.CREATE_SERVICE, s);
&#125;
//handleCreateService
private void handleCreateService(CreateServiceData data) &#123;
...
    初始化一个service ，并执行回调
    Service service = null;
    ...
        java.lang.ClassLoader cl = packageInfo.getClassLoader();
        service = (Service) cl.loadClass(data.info.name).newInstance();
        ...
        service.attach(context, this, data.info.name, data.token, app,
                ActivityManagerNative.getDefault());
        service.onCreate();
        mServices.put(data.token, service);
        ...
        //serviceDoneExecuting的主要工作是当service启动完成，则移除service Timeout消息。
        ActivityManagerNative.getDefault().serviceDoneExecuting(
                    data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);
        ...
&#125;
</code></pre>
<p>分析4过程：<br>requestServiceBindingsLocked(r, execInFg);</p>
<pre><code>private final boolean requestServiceBindingLocked(ServiceRecord r, IntentBindRecord i,
        boolean execInFg, boolean rebind) throws TransactionTooLargeException &#123;
        ...
        //调用ActivityThread的scheduleBindService
        r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,
                    r.app.repProcState);
        ...
&#125;
</code></pre>
<p>接下来的过程类似于 onCreate 的过程scheduleBindService -&gt; handleMessage -&gt; handleBindService 调用到ActiveServices.publishServiceLocked</p>
<pre><code>private void handleBindService(BindServiceData data) &#123;
    Service s = mServices.get(data.token);
    ...
    //类似于之前的过程 最终调用到 ActiveServices 的 publishServiceLocked
        ActivityManagerNative.getDefault().publishService(
                            data.token, data.intent, binder);
    ...
&#125;
</code></pre>
<p>//取出在bindServiceLock中放到ServiceRecord中的ConnectionRecord </p>
<pre><code>void publishServiceLocked(ServiceRecord r, Intent intent, IBinder service) &#123;
    for (int conni=r.connections.size()-1; conni&gt;=0; conni--) &#123;
         ArrayList&lt;ConnectionRecord&gt; clist = r.connections.valueAt(conni);
             for (int i=0; i&lt;clist.size(); i++) &#123; ConnectionRecord c = clist.get(i); ... //回调到onServiceConnected，bindService结束 即是方法ConnectionRecord.ServiceDispatcher.InnerConnection.connected c.conn.connected(r.name, service); ... &#125; &#125; &#125; 四、startService和bindService的流程的区别在于： 4.1在bringUpServiceLocked 中开启新的进程后，绕一圈再调用到realStartServiceLocked ActivityManagerService.startProcessLocked-&gt;ActivityThread.main-&gt;ActivityManagerNative.getDefault().attachApplicationLocked-&gt; 
</code></pre>
<p>ActivityManagerService.attachApplicationLocked-&gt;ActiveServices.attachApplicationLocked-&gt;ActiveServices.realStartServiceLocked<br>4.2当realStartServiceLocked 中执行时，bindService会调用requestServiceBindingsLocked做绑定服务的下一步处理，这里创建的Service并不会回调onStartCommand，在realStartServiceLocked中对start和bind的操作做了区分<br>    //bringUpServiceLocked</p>
<pre><code> private final String bringUpServiceLocked(ServiceRecord r,int intentFlags, boolean execInFg, boolean whileRestarting) &#123;
         if (app == null) &#123;
                if ((app=mAm.startProcessLocked(procName, r.appInfo, true, intentFlags,
                        &quot;service&quot;, r.name, false, isolated, false)) == null) &#123;
                   //...
            &#125;  
        &#125;
</code></pre>
<p>//开启新的进程</p>
<pre><code>public final class ActivityThread &#123;
            public static void main(String[] args) &#123;
                Looper.prepareMainLooper();
                ActivityThread thread = new ActivityThread();
                thread.attach(false);
                Looper.loop();
                throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);
            &#125;
            private void attach(boolean system) &#123;
                ...
                 mgr.attachApplication(mAppThread);
                ...
        &#125;
</code></pre>
<p>   ActivityManagerService.attachApplicationLocked</p>
<pre><code> private final boolean attachApplicationLocked(IApplicationThread thread,
            int pid) &#123;
          //...
            thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,
                    profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,
                    app.instrumentationUiAutomationConnection, testMode, enableOpenGlTrace,
                    isRestrictedBackupMode || !normalMode, app.persistent,
                    new Configuration(mConfiguration), app.compat,
                    getCommonServicesLocked(app.isolated),
                    mCoreSettingsObserver.getCoreSettingsLocked());
        ...
        // Find any services that should be running in this process...
        //这里继续调用到ActiveService.attachApplicationLocked
             didSomething |= mServices.attachApplicationLocked(app, processName);
      //...
        return true;
    &#125;
</code></pre>
<p> ActiveServices.attachApplicationLocked   </p>
<pre><code> boolean attachApplicationLocked(ProcessRecord proc, String processName)
        throws RemoteException &#123;
        ...
        realStartServiceLocked(sr, proc, sr.createdFromFg);
        didSomething = true;
        ...
    return didSomething;
&#125;
</code></pre>
<p>ActiveServices.realStartServiceLocked</p>
<pre><code>    private final void realStartServiceLocked(ServiceRecord r,
        ProcessRecord app, boolean execInFg) throws RemoteException &#123;
    //...
    r.app = app;
    r.restartTime = r.lastActivity = SystemClock.uptimeMillis();
    app.services.add(r);
    bumpServiceExecutingLocked(r, execInFg, &quot;create&quot;);
    mAm.updateLruProcessLocked(app, false, null);
    mAm.updateOomAdjLocked();
    boolean created = false;
    try &#123;
        //通知创建Service并执行onCreate
        app.thread.scheduleCreateService(r, r.serviceInfo,
                mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),
                app.repProcState);
        r.postNotification();
        created = true;
    &#125; catch (DeadObjectException e) &#123;
      //...
    &#125; finally &#123;
        //...
    &#125;
    //bindService 会执行这里,最终回调到方法onServiceConnected
      scheduleBindService -&gt; handleMessage -&gt; handleBindService 调用到ActiveServices.publishServiceLocked
    requestServiceBindingsLocked(r, execInFg);
    updateServiceClientActivitiesLocked(app, null, true);
    //这里不会加入到pendingStarts里面，所以不会执行onStartCommand
    if (r.startRequested &amp;&amp; r.callStart &amp;&amp; r.pendingStarts.size() == 0) &#123;
        r.pendingStarts.add(new ServiceRecord.StartItem(r, false, r.makeNextStartId(),
                null, null));
    &#125;
    //startService 过程继续执行这里
    sendServiceArgsLocked(r, execInFg, true);
    //...
&#125;
</code></pre>
<p>ActiveServices.requestServiceBindingsLocked,bindService 会执行这里,最终回调到方法onServiceConnected<br>          scheduleBindService -&gt; handleMessage -&gt; handleBindService,调用到ActiveServices.publishServiceLocked     </p>
<pre><code>private final void requestServiceBindingsLocked(ServiceRecord r, boolean execInFg)
        throws TransactionTooLargeException &#123;
    for (int i=r.bindings.size()-1; i&gt;=0; i--) &#123;
        IntentBindRecord ibr = r.bindings.valueAt(i);
        if (!requestServiceBindingLocked(r, ibr, execInFg, false)) &#123;
            break;
        &#125;
    &#125;
&#125; 
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>Android Handler消息机制</title>
    <url>/2021/02/27/Notes/Android/Framework/FrameWork_00_Handler%20%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6md/</url>
    <content><![CDATA[<h1 id="Android-Handler消息机制"><a href="#Android-Handler消息机制" class="headerlink" title="Android Handler消息机制"></a>Android Handler消息机制</h1><p>Handler是Android中一种线程间传递消息的机制。主要应用的场景，将子线程中待更新的UI信息传递到主线程。本文将从以下几个方面介绍Handler：</p>
<ol>
<li>Handler的消息发送和分发过程</li>
<li>Looper，Message 以及和Handler的关系</li>
<li>Message组成和类型以及复用机制</li>
<li>IdleHandler等一些不常见的知识</li>
</ol>
<p>下面正式开始，故事从sendMessage开始讲起。</p>
<h1 id="一、消息分发过程"><a href="#一、消息分发过程" class="headerlink" title="一、消息分发过程"></a>一、消息分发过程</h1><h2 id="1-1、从sendMessage开始"><a href="#1-1、从sendMessage开始" class="headerlink" title="1.1、从sendMessage开始"></a>1.1、从sendMessage开始</h2><p>Handler常见的用法如下，主线程中创建Handler，子线程中使用sendMessage发送消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Handler mHandler;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        mHandler = <span class="keyword">new</span> Handler()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//收到消息后，更新 ui</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//发送消息</span></span><br><span class="line">                    mHandler.sendMessage();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了上面这种写法外，常见的写法还有post这种：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mHandler = <span class="keyword">new</span> Handler();</span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//ui操作</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;); </span><br><span class="line">       &#125;</span><br><span class="line">   &#125;).start();</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>以上2种方式最终都是殊途同归，最终调用的都是Handler的<strong>sendMessageAtTime</strong>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    MessageQueue queue = mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="keyword">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">        Log.w(<span class="string">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不同地方在于post 将Runnable赋值给msg.callback，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    Message m = Message.obtain();</span><br><span class="line">    m.callback = r;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后在dispatchMessage处理消息时，post方式msg.callback不为空，会执行handleCalback，最终回调Runnable的run方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// post的执行</span></span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleCalback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// sendMessage的执行</span></span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    message.callback.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>细心的读者可能会问mCallback又是什么呢？其实mCallback就是你在new Handler时可以传的一个参数，如果你像下面这样在Handler.Callback中返回true，就可以拦截消息不让消息在Handler的handler的handleMessage中处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Handler handler1 = <span class="keyword">new</span> Handler(<span class="keyword">new</span> Handler.Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="1-2、发送消息"><a href="#1-2、发送消息" class="headerlink" title="1.2、发送消息"></a>1.2、发送消息</h2><p>sendMessageAtTime后发生了什么？继续分析sendMessageAtTime方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    MessageQueue queue = mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="keyword">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">        Log.w(<span class="string">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(<span class="meta">@NonNull</span> MessageQueue queue, <span class="meta">@NonNull</span> Message msg,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将Handler赋值给msg.target,消息分发的时候会用到</span></span><br><span class="line">        msg.target = <span class="keyword">this</span>;</span><br><span class="line">        msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>经过一系列的调用sendMessageAtTime最终调用到了MessagQueue.enqueueMessage。</p>
<p>enqueueMessage将所有收到的消息按发送时间进行排序，加入到MessageQueue（消息队列）中，MessageQueue更多的细节后面再讲。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Message must have a target.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">&quot; This message is already in use.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">            IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    msg.target + <span class="string">&quot; sending message to a Handler on a dead thread&quot;</span>);</span><br><span class="line">            Log.w(TAG, e.getMessage(), e);</span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        <span class="comment">//1、拿到队列头部消息</span></span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="comment">//2、如果消息不需要延时，或者消息的执行时间比头部消息早，插到队列头部</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span></span><br><span class="line">            <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">            <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="comment">// 3、根据时间，将消息插到队列中合适的位置</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="comment">// 4、唤醒机制</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>22 - 24行：对收到的消息按发送时间进行排序，如果当前消息不需要延时，放到头部；若是延时消息，则根据发送时间放到队列合适位置。</p>
<p><strong>总结一下：sendMessage就是讲消息加到MessageQueue的队列中。</strong></p>
<p>至此，消息的发送过程全部结束了，什么！那消息是怎么分发的呢？我们先给出答案，是通过Looper.loop。</p>
<h2 id="1-3、消息分发"><a href="#1-3、消息分发" class="headerlink" title="1.3、消息分发"></a>1.3、消息分发</h2><p>刚才说了Handler的消息分发是通过Looper.loop，接下来看下代码，上车！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">     <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 1、从Looper中消息队列</span></span><br><span class="line">     <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">         <span class="comment">// 2、从消息队列中取出消息</span></span><br><span class="line">         Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">         <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"><span class="comment">// 省略 ...</span></span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">// 3、调用handler.dispatchMessage</span></span><br><span class="line">             msg.target.dispatchMessage(msg);</span><br><span class="line">             end = (slowDispatchThresholdMs == <span class="number">0</span>) ? <span class="number">0</span> : SystemClock.uptimeMillis();</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                 Trace.traceEnd(traceTag);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     </span><br><span class="line"><span class="comment">//省略 ...</span></span><br><span class="line">         msg.recycleUnchecked();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>主要步骤如下：</p>
<p>6行：从Looper中取出消息队列</p>
<p>9行：开启死循环，然后不断地调用的MessageQueue的next()方法，这个next()方法就是消息队列的出队方法。如果当前MessageQueue中存在待处理的消息，就将这个消息出队，否则就进入一个阻塞状态，一直等到有新的消息入队。</p>
<p>19行：消息分发msg.target的dispatchMessage()方法中，那这里msg.target又是什么呢？其实就是handler，回头看下enqueueMessage。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Handle system messages here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>28行：消息回收过程，这里涉及到Message的回收和复用，后面再讲。</p>
<p><strong>总结一下：Handler通过sendMessage将消息加入到消息队列中，最后在通过Looper.loop从消息队列中逐个取出消息执行。</strong>整体原理如下图所示：</p>
<p><img src="../../pics/image-20210226151751578.png" alt="image-20210226151751578"></p>
<p>好了，Handler的消息分发机制就介绍完了。如果只是想简单了解下Handler机制，到这里就可以了。</p>
<p>就这？当然不！上述介绍过程中涉及到几个概念Looper，MessageQueue，还没详细说呢？我们先来看下Looper。</p>
<h1 id="二、Looper"><a href="#二、Looper" class="headerlink" title="二、Looper"></a>二、Looper</h1><p>通过以上的介绍我们知道Looper是handler中消息分发的核心，那它是怎么来的？我们先来看下Handler的构造函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="meta">@Nullable</span> Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// loop赋值</span></span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()</span><br><span class="line">                    + <span class="string">&quot; that has not called Looper.prepare()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Looper的赋值是通过looper.myLooper()，最终调到了sThreadLocal.get()。这个sThreadLocal又是什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sThreadLocal.get() will return null unless you&#x27;ve called prepare().</span></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br></pre></td></tr></table></figure>

<p>这个sThreadLocal是一个ThreadLocal对象，存的是Looper对象。什么？ThreadLocal也不懂？来来来，先记住个概念，后面再解释：ThreadLocal提供了线程的局部变量，每个线程都可以通过set()和get()来对这个局部变量进行操作，但不会和其他线程的局部变量进行冲突，实现了线程的数据隔离。也就说通<strong>过ThreadLocal可以存取当前线程的Looper对象</strong>。</p>
<p>仔细看sThreadLocal的注释，除非您已调用prepare()，否则sThreadLocal.get()将返回null。那就看下loop.prepare吧。</p>
<h2 id="2-1、loop-prepare"><a href="#2-1、loop-prepare" class="headerlink" title="2.1、loop.prepare"></a>2.1、loop.prepare</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 每个线程只能初始化一次looper</span></span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 注意，这是messageQueue初始化的地方</span></span><br><span class="line">   mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">   mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>10行：新建一个Looper对象并存到sThreadLocal中。</p>
<p>14行：注意这里，handler中的MessageQuee就是Looper初始化时构造出来的。</p>
<p>也就是说，new Hanlder 之前必须要调用 Looper.prepare方法，那为何在主线程中使用是不需要呢？其实Android在程序启动的时候，通过ActivityThread帮我们创建主线程时已经初始化好了，代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line">    <span class="comment">// 1、 主线程Looper.parpare!</span></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">    thread.attach(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">        Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                LogPrinter(Log.DEBUG, <span class="string">&quot;ActivityThread&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2、看这里looper.loop</span></span><br><span class="line">    Looper.loop();</span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3行：调用了 Looper.prepareMainLooper()，再调用到Looper的prepare。</p>
<p>14行：<strong>Looper.looper，开启循环，不停取出消息。主线程中其实先开启循环不停取消息，再才是发送消息。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the current thread as a looper, marking it as an</span></span><br><span class="line"><span class="comment"> * application&#x27;s main looper. See also: &#123;<span class="doctag">@link</span> #prepare()&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@deprecated</span> The main looper for your application is created by the Android environment,</span></span><br><span class="line"><span class="comment"> *   so you should never need to call this function yourself.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The main Looper has already been prepared.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意prepareMainLooper的注释，prepare只能调用一次，ActivityThread中已经调用过了，再调用到这里会报异常（12行）。到这里我们已经搞明白主线程中的looper是怎么来的。刚才遗留了一个问题ThreadLocal是怎么存取Loope，下面就来介绍下ThreadLocal。</p>
<h2 id="2-2、ThreadLocal"><a href="#2-2、ThreadLocal" class="headerlink" title="2.2、ThreadLocal"></a>2.2、ThreadLocal</h2><p>先来看下ThreadLocal的set过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1、获取当前线程</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">// 2、获取当前线程的ThreadMap对象</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 2.1、map不为空存value到map中</span></span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 2.2、map为空则创建map并value存进去</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">                              </span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ThreadLocalMap存储的值是弱引用</span></span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要步骤有2点：</p>
<ol>
<li>获取当前线程的ThreadMap对象 , ThreadMap其实是Thread的一个成员变量，但是是通过ThreadLocal来维护的。Thread.threadLocals为空时先创建。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* ThreadLocal values pertaining to this thread. This map is maintained</span><br><span class="line"> * by the ThreadLocal class. */</span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = null;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>将value值存到ThreadMap中，key是当前threadLocal对象，也就是说一个Thread可以存多个不同ThreadLocal的值，一个ThreadLocal只能存一个值。</li>
</ol>
<p>我们再理解下Looper.myLooper对应的get过程，先获取线程的threadLocals（ThreadMap对象），再通过get（key是当前ThreadLocal对象）获取到looper。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                T result = (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结一下：Looper通过prepare会初始化一个Looper对象，通过ThreadLocal将Thread和Looper对象绑定在一起。Looper.loop会从MessageQueue中不断取出消息，进行分发。</strong></p>
<h1 id="三、MessageQueue"><a href="#三、MessageQueue" class="headerlink" title="三、MessageQueue"></a>三、MessageQueue</h1><p>MessagQueue，顾名思义，消息队列，在Looper的介绍中，我们提到了MessageQueue其实是在Looper构造创建生成的，Handler中的mQueue其实就是Looper.mQueue，Looper和MessageQueue是一一对应的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="meta">@Nullable</span> Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()</span><br><span class="line">                    + <span class="string">&quot; that has not called Looper.prepare()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 看这里</span></span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在前面章节我们讲了sengMessage最终会调用到MessageQueue.enqueueMessage，下面具体分析enqueueMessage的代码。</p>
<h2 id="3-1、消息入队"><a href="#3-1、消息入队" class="headerlink" title="3.1、消息入队"></a>3.1、消息入队</h2><p>关于enqueueMessage消息入队逻辑在1.2节已经介绍过了；除此之外，消息加入队列时，两种情况会唤醒looper.loop，为什么要唤醒，后面再说：</p>
<ol>
<li>（队列为空，消息无需延时或消息执行时间比队列头部消息早) &amp;&amp; (线程处于挂起状态时（mBlocked = true）)</li>
<li>【线程挂起（mBlocked = true）&amp;&amp; 消息循环处于同步屏障状态】，这时如果插入的是一个异步消息，则需要唤醒。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">          <span class="keyword">boolean</span> needWake;</span><br><span class="line">         <span class="comment">//1、队列为空，消息无需延时或消息执行时间比队列头部消息早) &amp;&amp; (线程处于挂起状态时（mBlocked = true）)</span></span><br><span class="line">          <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">              <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">              msg.next = p;</span><br><span class="line">              mMessages = msg;</span><br><span class="line">              needWake = mBlocked;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span></span><br><span class="line">              <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">              <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">              <span class="comment">// 2、线程挂起（mBlocked = true）&amp;&amp; 消息循环处于同步屏障状态】，这时如果插入的是一个异步消息，则需要唤醒。</span></span><br><span class="line">              needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">              Message prev;</span><br><span class="line">              <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                  prev = p;</span><br><span class="line">                  p = p.next;</span><br><span class="line">                  <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                      needWake = <span class="keyword">false</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">              prev.next = msg;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">          <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">              nativeWake(mPtr);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2、消息出队"><a href="#3-2、消息出队" class="headerlink" title="3.2、消息出队"></a>3.2、消息出队</h2><p>在1.3节我们介绍过Looper.Looper负责消息出队，其实是通过Queue.next()取队列中的消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">    <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">    <span class="comment">// which is not supported.</span></span><br><span class="line">    <span class="comment">// 1、通过Looper.quit调用到Message.quit后会执行到这里</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2、nextPollTimeoutMillis = -1 阻塞</span></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">            Message msg = mMessages;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 3、屏障消息</span></span><br><span class="line">                <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// 4、时间没到，设定下次唤醒的时间</span></span><br><span class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Got a message.</span></span><br><span class="line">                    mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">           <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">           <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">          	<span class="comment">// 第一次执行时，确定IdleHandler的数目</span></span><br><span class="line">           <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                   &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">               pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">               mBlocked = <span class="keyword">true</span>;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">               mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">           &#125;</span><br><span class="line">           mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run the idle handlers.</span></span><br><span class="line">        <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">        <span class="comment">// 遍历执行idleHandler</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="comment">// 非keep的执行完后移除掉</span></span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">        <span class="comment">// idleHandler</span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line">        <span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要的步骤：</p>
<ol>
<li><p>判断MessageQueue是不是退出了，如果退出，整个Looper.loop都退出，通常是通过调用Looper.quit退出。</p>
</li>
<li><p>nativePollOnce，我们知道Looper.looper是一个死循环，如果没有消息，还会继续执行吗？显然不可能，在消息队列为空的时候，Looper实际上处于休眠状态，当nextPollTimeoutMillis =-1 时阻塞，CPU进入休眠；对于deleyMessage，nextPollTimeoutMillis&gt;0，时间到了后唤醒。Message Queue共有2种情况唤醒：1.加入消息新消息时唤醒（上一节介绍过） ；2.delayMsg时间到了唤醒。</p>
<p>那么是怎么实现的呢？这里涉及到linux的epoll机制，handler这里就不展开讲了，参考（<a href="https://mp.weixin.qq.com/s/H8mHoYHyTe6oOaUwfYh6_g%EF%BC%89%E3%80%82">https://mp.weixin.qq.com/s/H8mHoYHyTe6oOaUwfYh6_g）。</a></p>
</li>
<li><p>屏障消息和idleHandler相关，后面介绍。</p>
</li>
</ol>
<p><strong>总结一下：MessageQueue负责消息的存取，Looper的looper并不会一直执行，当nativePollOnce的参数nextPollTimeoutMillis=-1时会休眠，唤醒有2种方式一种是队列有新消息入队时；另一种是delayMsg时刻到了。</strong></p>
<h1 id="四、Message"><a href="#四、Message" class="headerlink" title="四、Message"></a>四、Message</h1><p>先看下Message的数据结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> what;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> arg1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> arg2;</span><br><span class="line">    <span class="keyword">public</span> Object obj;</span><br><span class="line">    <span class="keyword">public</span> Messenger replyTo; <span class="comment">// Messager对象</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">long</span> when; <span class="comment">//消息发送时间</span></span><br><span class="line">    <span class="comment">/*package*/</span> <span class="keyword">int</span> flags; <span class="comment">// 标记消息消息类型是否是异步</span></span><br><span class="line">    <span class="comment">/*package*/</span> Handler target; <span class="comment">//指向接收消息的handler</span></span><br><span class="line">    <span class="comment">/*package*/</span> Message next; <span class="comment">//指向下一个消息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Message sPool; <span class="comment">// Message内部复用队列的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Message对象都有一个同类型的next字段，这个next字段指向的就是下一个可用的Message，最后Message的next为空，组成Message链表，sPool 永远指向的是整个链表的第一个元素。</p>
<h2 id="4-1、Message的复用机制"><a href="#4-1、Message的复用机制" class="headerlink" title="4.1、Message的复用机制"></a>4.1、Message的复用机制</h2><p>通常我们获取一个Message都是通过Message的obtain方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// sometimes we store linked lists of these things</span></span><br><span class="line">    <span class="comment">/*package*/</span> Message next;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object sPoolSync = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Message sPool;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sPoolSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * Return a new Message instance from the global pool. Allows us to</span></span><br><span class="line"><span class="comment">      * avoid allocating new objects in many cases.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Message m = sPool;</span><br><span class="line">                sPool = m.next;</span><br><span class="line">                m.next = <span class="keyword">null</span>;</span><br><span class="line">                m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">                sPoolSize--;</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Message();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>17 - 18行，当使用obtain方法获取一个Message对象时，其实获取的就是链表中的第一个元素，同时将sPool在指向下一个Message。</p>
<p>那么这些Message对象是在什么时候被放到链表中的呢，在Message类的说明中有这样一句话：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">While the constructor of Message is public, the best way to getone of these is to call &#123;@link #obtain Message.obtain()&#125; or one of the methods, which will pull them from a pool of recycled objects。</span><br></pre></td></tr></table></figure>

<p>原来在创建Message时不会将Message放入队列而是在recycle时才会加入到队列，让我们先来看下recylce方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isInUse()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (gCheckRecycle) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;This message cannot be recycled because it &quot;</span></span><br><span class="line">                    + <span class="string">&quot;is still in use.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    recycleUnchecked();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recycles a Message that may be in-use.</span></span><br><span class="line"><span class="comment"> * Used internally by the MessageQueue and Looper when disposing of queued Messages.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Mark the message as in use while it remains in the recycled object pool.</span></span><br><span class="line">    <span class="comment">// Clear out all other details.</span></span><br><span class="line">    flags = FLAG_IN_USE;</span><br><span class="line">    what = <span class="number">0</span>;</span><br><span class="line">    arg1 = <span class="number">0</span>;</span><br><span class="line">    arg2 = <span class="number">0</span>;</span><br><span class="line">    obj = <span class="keyword">null</span>;</span><br><span class="line">    replyTo = <span class="keyword">null</span>;</span><br><span class="line">    sendingUid = -<span class="number">1</span>;</span><br><span class="line">    when = <span class="number">0</span>;</span><br><span class="line">    target = <span class="keyword">null</span>;</span><br><span class="line">    callback = <span class="keyword">null</span>;</span><br><span class="line">    data = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">            next = sPool;</span><br><span class="line">            sPool = <span class="keyword">this</span>;</span><br><span class="line">            sPoolSize++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>12- 8行：判断Message是否在被使用中，如果没有，则执行回收操作。</p>
<p>19-35行：回收先清空Message的各字段，并将flag置为FLAG_IN_USE，这个flag在obtain时会被置为0。然后继续判断是否要将该消息放17到回收池中，如果池的大小小于MAX_POOL_SIZE（50），那么就进行链表操作，将这个Message放到链表的表头。</p>
<p>总结一下：Message 通过在内部构建一个链表维护一个被回收的Message对象的对象池，当用户调用obtain函数时优先从池中获取，如果池中没有可以复用的对象则创建一个新的Message对象。这些新创建的Message对象再被使用完之后会被回收到这个对象池中，当下次再调用obtain函数时，他们就会被复用。<br>结合的Looper.loop方法，在使用完一个Message对象后就将会将它回收，避免系统中创建太多Message对象。</p>
<h2 id="4-2、同步消息、屏障消息和异步消息"><a href="#4-2、同步消息、屏障消息和异步消息" class="headerlink" title="4.2、同步消息、屏障消息和异步消息"></a>4.2、同步消息、屏障消息和异步消息</h2><p>在Handler构造函数，如果看到的足够仔细的话</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="meta">@Nullable</span> Callback callback, <span class="keyword">boolean</span> async)</span> </span></span><br></pre></td></tr></table></figure>

<p>我们会发现构造参数里有个async，异步？这个参数代表什么意思？</p>
<p>其实在MessageQueue中消息有三种类型：同步消息，异步消息以及屏障消息。</p>
<h3 id="4-1-1、同步消息"><a href="#4-1-1、同步消息" class="headerlink" title="4.1.1、同步消息"></a>4.1.1、同步消息</h3><p>默认的消息类型，同步消息在MessageQueue里的存和取完全就是按照时间（msg.when）排序的。</p>
<h3 id="4-1-2、异步消息"><a href="#4-1-2、异步消息" class="headerlink" title="4.1.2、异步消息"></a>4.1.2、异步消息</h3><p>异步消息有2种构造方式：</p>
<ol>
<li>handler构造参数指定 async =true</li>
<li>Message构造时，指定setAsynchronous（true）</li>
</ol>
<p>在sendMessage中，我们可以看到这2者的关系</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(<span class="meta">@NonNull</span> MessageQueue queue, <span class="meta">@NonNull</span> Message msg,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    msg.target = <span class="keyword">this</span>;</span><br><span class="line">    msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line">	<span class="comment">// mAsynchronous 就是构造参数中的 async </span></span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若Handler的构造参数中的async设置为true，该Handler所有的消息都会被设置为异步消息。</p>
<h3 id="4-1-3、屏障消息"><a href="#4-1-3、屏障消息" class="headerlink" title="4.1.3、屏障消息"></a>4.1.3、屏障消息</h3><p>屏障(Barrier) 是一种特殊的Message，它最大的特征就是target为null(只有屏障的target可以为null，如果我们自己设置Message的target为null的话会报异常)，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Message must have a target.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且arg1属性被用作屏障的标识符来区别不同的屏障。屏障的作用是用于拦截队列中同步消息，放行异步消息。</p>
<p>那么屏障消息是怎么被添加和删除的呢？ 我们可以看到在MessageQueue里有添加和删除屏障消息的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">(<span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Enqueue a new sync barrier token.</span></span><br><span class="line">    <span class="comment">// We don&#x27;t need to wake the queue because the purpose of a barrier is to stall it.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> token = mNextBarrierToken++;</span><br><span class="line">        <span class="keyword">final</span> Message msg = Message.obtain();</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        msg.arg1 = token;</span><br><span class="line"></span><br><span class="line">        Message prev = <span class="keyword">null</span>;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">         <span class="comment">// 根据时间找到第一个比屏障消息晚的消息，将屏障消息插入到该消息之前；</span></span><br><span class="line">         <span class="comment">// 屏障只会影响到队列中它之后的消息</span></span><br><span class="line">        <span class="keyword">if</span> (when != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.when &lt;= when) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果prev是null,屏障消息插入到消息队列的头部</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeSyncBarrier</span><span class="params">(<span class="keyword">int</span> token)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Remove a sync barrier token from the queue.</span></span><br><span class="line">        <span class="comment">// If the queue is no longer stalled by a barrier then wake it.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            Message prev = <span class="keyword">null</span>;</span><br><span class="line">            Message p = mMessages;</span><br><span class="line">        <span class="comment">// 前面在插入屏障消息后会生成一个token，这个token就是用来删除该屏障消息用的。</span></span><br><span class="line">        <span class="comment">// 所以这里通过判断target和token来找到该屏障消息，从而进行删除操作</span></span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; (p.target != <span class="keyword">null</span> || p.arg1 != token)) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The specified message queue synchronization &quot;</span></span><br><span class="line">                        + <span class="string">&quot; barrier token has not been posted or has already been removed.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> needWake;</span><br><span class="line">            <span class="comment">// 删除屏障消息，原理是链表的删除</span></span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                prev.next = p.next;</span><br><span class="line">                needWake = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mMessages = p.next;</span><br><span class="line">                needWake = mMessages == <span class="keyword">null</span> || mMessages.target != <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p.recycleUnchecked();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the loop is quitting then it is already awake.</span></span><br><span class="line">            <span class="comment">// We can assume mPtr != 0 when mQuitting is false.</span></span><br><span class="line">            <span class="comment">// 屏障消息删除后可再次之前的同步消息</span></span><br><span class="line">            <span class="keyword">if</span> (needWake &amp;&amp; !mQuitting) &#123;</span><br><span class="line">                nativeWake(mPtr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>介绍完屏障消息的插入和删除，那么屏障消息的作用是什么？和同步及异步消息有何关系呢？ 我们可以看到MessageQueue的next方法里有这么一段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前消息是屏障消息时（msg.target==null）, 如果存在屏障消息，那么在它之后进来的消息中，只放行异步消息</span></span><br><span class="line"><span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prevMsg = msg;</span><br><span class="line">        msg = msg.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入屏障消息后，只放行队列中的异步消息，在Android系统里面为了更快响应UI刷新在<strong>ViewRootImpl.scheduleTraversals</strong>也有应用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 1、为主线程的MessageQueue设置了个消息屏障</span></span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        <span class="comment">// 2、这里发送了个异步消息mTraversalRunnable，这个mTraversalRunnable最终会执行doTraversal(),也就是会触发View的绘制流程</span></span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line"> 		</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// postCallback 经过层层调用到这里Choreographer.postCallbackDelayedInternal</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postCallbackDelayedInternal</span><span class="params">(<span class="keyword">int</span> callbackType,</span></span></span><br><span class="line"><span class="params"><span class="function">        Object action, Object token, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">  		<span class="comment">// 省略...</span></span><br><span class="line">        <span class="keyword">if</span> (dueTime &lt;= now) &#123;</span><br><span class="line">            scheduleFrameLocked(now);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">            msg.arg1 = callbackType;</span><br><span class="line">            <span class="comment">// 设置为异步消息</span></span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">            mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>scheduleTraversals时通过设置屏障消息，会把主线程的同步消息先阻塞，优先执行View绘制这个异步消息进行界面绘制。让界面绘制的任务优先执行，避免出现界面卡顿。</p>
<p>另外App层如果发送同步屏障postSyncBarrier需要反射才能使用，Android不建议使用，主线程中滥用的话就是和界面绘制抢资源了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postSyncBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Method method = MessageQueue.class.getDeclaredMethod(<span class="string">&quot;postSyncBarrier&quot;</span>);</span><br><span class="line">  token = (<span class="keyword">int</span>) method.invoke(Looper.getMainLooper().getQueue());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeSyncBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Method method = MessageQueue.class.getDeclaredMethod(<span class="string">&quot;removeSyncBarrier&quot;</span>, <span class="keyword">int</span>.class);</span><br><span class="line">   method.invoke(Looper.getMainLooper().getQueue(), token);&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="五、IdleHandler"><a href="#五、IdleHandler" class="headerlink" title="五、IdleHandler"></a>五、IdleHandler</h1><p>IdleHandler，空闲的处理器（就是说我是在消息队列空闲的时候才会执行的，如果消息队列里有其他非IdleHandler消息在执行，则我先不执行），它其实就是一个接口，我们就认为它是空闲消息吧，只不过它不是存在MessageQueue里，而是以数组的形式保存的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Callback interface for discovering when a thread is going to block</span><br><span class="line"> * waiting for more messages.</span><br><span class="line"> */</span><br><span class="line">public static interface IdleHandler &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Called when the message queue has run out of messages and will now</span><br><span class="line">     * wait for more.  Return true to keep your idle handler active, false</span><br><span class="line">     * to have it removed.  This may be called if there are still messages</span><br><span class="line">     * pending in the queue, but they are all scheduled to be dispatched</span><br><span class="line">     * after the current time.</span><br><span class="line">     */</span><br><span class="line">    boolean queueIdle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MessageQueue有添加和删除IdleHandler的方法，IdleHandler被保存在一个ArrayList里：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;IdleHandler&gt; mIdleHandlers = <span class="keyword">new</span> ArrayList&lt;IdleHandler&gt;();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addIdleHandler</span><span class="params">(<span class="meta">@NonNull</span> IdleHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;Can&#x27;t add a null IdleHandler&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        mIdleHandlers.add(handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeIdleHandler</span><span class="params">(<span class="meta">@NonNull</span> IdleHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        mIdleHandlers.remove(handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，它是怎么实现在消息队列空闲的间隙得到执行的呢？细心的同学应该注意到了，也是在MessageQueue.next()方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">    <span class="comment">// 1、这个参数很重要，控制</span></span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">          	<span class="comment">// 省略...</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">            <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">            <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">            <span class="comment">// 首次for循环 &amp;&amp; 消息队列处于空闲 当前消息队列没有消息或者要执行的消息晚于当前时间</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                <span class="comment">// 赋值</span></span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run the idle handlers.</span></span><br><span class="line">        <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果queueIdle返回true，则该空闲消息不会被自动删除，在下次执行next的时候，如果还出现队列空闲，会再次执行。</span></span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果返回false，则该空闲消息会在执行完后，被自动删除掉。</span></span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">        <span class="comment">// 这里把空闲消息标志置为0，而不置为-1，防止一直执行；一直到下一次调用 MessageQueue.next() 方法.</span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当执行了 IdleHander 之后, 会消耗一段时间, 这时候消息队列里可能已经有消息到达可执行时间, 所以重置 nextPollTimeoutMillis 回去重新检查消息队列.</span></span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下：IdleHandler是在MessageQueuer队列空闲时执行的且只会执行一次，但如果将queueIdle的返回值改为true，会在每一次MessageQueue.next方法执行时在执行一次，也就是说如果队列中有新的消息到达就会再次执行。</p>
<h1 id="六、常见问题"><a href="#六、常见问题" class="headerlink" title="六、常见问题"></a>六、常见问题</h1><h2 id="6-1、子线程中更新UI的方法"><a href="#6-1、子线程中更新UI的方法" class="headerlink" title="6.1、子线程中更新UI的方法"></a>6.1、子线程中更新UI的方法</h2><p>除了Handler的sendMessage和post之外，我们还有以下2种方法可以在子线程中进行UI操作，一句话解释完，请看注释！！！</p>
<h3 id="6-1-1、View的post-方法"><a href="#6-1-1、View的post-方法" class="headerlink" title="6.1.1、View的post()方法"></a>6.1.1、View的post()方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Causes the Runnable to be added to the message queue.</span></span><br><span class="line"><span class="comment"> * The runnable will be run on the user interface thread.&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class="line">    <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> attachInfo.mHandler.post(action);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Postpone the runnable until we know on which thread it needs to run.</span></span><br><span class="line">    <span class="comment">// Assume that the runnable will be successfully placed after attach.</span></span><br><span class="line">    getRunQueue().post(action);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-1-2、Activity的runOnUiThread-方法"><a href="#6-1-2、Activity的runOnUiThread-方法" class="headerlink" title="6.1.2、Activity的runOnUiThread()方法"></a>6.1.2、Activity的runOnUiThread()方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Runs the specified action on the UI thread. If the current thread is the UI</span></span><br><span class="line"><span class="comment">* thread, then the action is executed immediately. If the current thread is</span></span><br><span class="line"><span class="comment">* not the UI thread, the action is posted to the event queue of the UI thread.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> action the action to run on the UI thread</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runOnUiThread</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (Thread.currentThread() != mUiThread) &#123;</span><br><span class="line">           mHandler.post(action);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           action.run();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-2、主线程中Looper-Loop的不会卡死？"><a href="#6-2、主线程中Looper-Loop的不会卡死？" class="headerlink" title="6.2、主线程中Looper.Loop的不会卡死？"></a>6.2、主线程中Looper.Loop的不会卡死？</h2><p>1、Looper.Loop会调用到MessageQueue.next()方法，没有消息时会阻塞在nativePollOnce，此时主线程会释放CPU进入休眠状态，并不会消耗CPU资源。直到有下个消息到达，这里依赖的是Linux pipe/epoll机制。</p>
<p>2、ANR的原理，任务再特定时间内没有执行完。以Service ANR原理为例，首先startService之后，经过一系列的调用，最终会调用到AMS的startService相关方法，发送一个SERVICE_TIMEOUT_MSG的延时消息；紧接着再通过消息机制调用到ActivityThread.H.handleMessag中先执行Service的onCreate，再回到AMS找中，执行serviceDoneExecuting，移除SERVICE_TIMEOUT_MSG消息。也就是说如果onCreate执行时间过长导致SERVICE_TIMEOUT_MSG消息没有被及时移除，就会触发ANR。这里涉及到2个handler，一个ActivityThread，一个是AMS的，ActivityThread的Handler是和应用主线程绑定的；而AMS.MainHandler是SystemServer的ServerThread绑定的，用于处理service、process、provider的超时问题。另外input的超时处理过程并非发生在ActivityManager线程，而是inputDispatcher线程发生的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>Looper 作为消息循环的核心，其内部包含了一个消息队列 MessageQueue ，用于记录所有待处理的消息；Handler通过sendMessage添加消息，通过Looper.loop()不断地从MessageQueue中抽取Message，按分发机制将消息分发给目标处理者，可以看成是消息泵。注意，线程切换就是在这一步完成的。</li>
<li>MessageQueue 则作为一个消息队列，则包含了一系列链接在一起的 Message ；不要被这个Queue的名字给迷惑了，就以为它是一个队列，但其实内部通过单链表的数据结构来维护消息列表，等待Looper的抽取。</li>
<li>Message 则是消息体，内部又包含了一个目标处理器 target ，这个 target 正是最终处理它的 Handler。</li>
<li><strong>Looper和Thread以及MessageQueue是一一对应的</strong>，<strong>而一个Handler只能关联一个Looper，一个Looper可以关联多个Handler</strong>, Handler的messagequeue就是Looper的messagequeue。  </li>
</ul>
<p><strong>参考资料：</strong><br><a href="http://blog.csdn.net/guolin_blog/article/details/9991569">http://blog.csdn.net/guolin_blog/article/details/9991569</a></p>
<p><a href="https://juejin.cn/post/6844904068129751047">https://juejin.cn/post/6844904068129751047</a></p>
<p><a href="https://mp.weixin.qq.com/s/H8mHoYHyTe6oOaUwfYh6_g">https://mp.weixin.qq.com/s/H8mHoYHyTe6oOaUwfYh6_g</a></p>
<p><a href="https://mp.weixin.qq.com/s/71OV_K7YJas7pLtsPY-jeQ">https://mp.weixin.qq.com/s/71OV_K7YJas7pLtsPY-jeQ</a></p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Handler</tag>
      </tags>
  </entry>
  <entry>
    <title>FrameWork_01_Binder</title>
    <url>/2021/05/30/Notes/Android/Framework/FrameWork_01_Binder/</url>
    <content><![CDATA[<h1 id="FrameWork-01-Binder"><a href="#FrameWork-01-Binder" class="headerlink" title="FrameWork_01_Binder"></a>FrameWork_01_Binder</h1><h2 id="什么是Binder？"><a href="#什么是Binder？" class="headerlink" title="什么是Binder？"></a>什么是Binder？</h2><p>对于<code>Binder</code>的定义，在不同场景下其定义不同。</p>
<ol>
<li>从IPC角度来说：<strong>Binder是Android中的一种跨进程通信方式，该通信方式在linux中没有，是Android独有</strong>；</li>
<li>从Android Driver层：<strong>Binder还可以理解为一种虚拟的物理设备，它的设备驱动是/dev/binder</strong>；</li>
<li>从Android Native层：Binder是创建Service Manager以及BpBinder/BBinder模型，搭建与binder驱动的桥梁；</li>
<li>从Android Framework层：Binder是各种Manager（ActivityManager、WindowManager等）和相应xxxManagerService的桥梁；</li>
<li>从Android APP层：Binder是客户端和服务端进行通信的媒介，当bindService的时候，服务端会返回一个包含了服务端业务调用的 Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或者数据，这里的服务包括普通服务和基于AIDL的服务。</li>
</ol>
<h2 id="IPC-基本概念"><a href="#IPC-基本概念" class="headerlink" title="IPC 基本概念"></a>IPC 基本概念</h2><p><img src="/pics/image-20210530173422907.png" alt="image-20210530173422907" style="zoom:35%;" />..</p>
<p>上图展示了传统进程通信的基本概念：</p>
<ul>
<li>进程隔离</li>
<li>进程空间划分</li>
<li>系统调用</li>
</ul>
<h3 id="进程隔离"><a href="#进程隔离" class="headerlink" title="进程隔离"></a>进程隔离</h3><p>为了保证 安全性 &amp; 独立性，一个进程 不能直接操作或者访问另一个进程，即<code>Android</code>的进程是<strong>相互独立、隔离的</strong>。2个进程之间内存可以随意访问的话，那基本上程序之间就没有任何安全性可言，若可以随意修改其他程序的数据，那计算机世界将陷入混乱。</p>
<p>基于进程之间不可互相访问数据的基础上，为了实现进程间数据共享，这里就必须采用特殊的通信机制：<strong>进程间通信（IPC）</strong></p>
<h3 id="进程空间划分"><a href="#进程空间划分" class="headerlink" title="进程空间划分"></a>进程空间划分</h3><p>一个进程空间分为 **用户空间 和内核空间（Kernel)**，二者区别：</p>
<ul>
<li>进程间，用户空间的数据不可共享</li>
<li>进程间，内核空间的数据可共享</li>
</ul>
<blockquote>
<p>所有进程共用1个内核空间</p>
</blockquote>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>虽然从逻辑上进行了用户空间和内核空间的划分，但是不可避免的用户空间需要访问内核资源，比如文件操作、访问网络等等。为了突破隔离限制，就需要借助系统调用来实现。系统调用是用户空间访问内核空间的唯一方式，保证了所有的内核资源访问都是在内核的控制下进行的，避免了用户程序对系统资源的越权访问，提升系统安全性和稳定性。</p>
<p>进程内 用户空间 &amp; 内核空间 进行交互 需通过 系统调用，主要通过函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">copy_from_user（）：将用户空间的数据拷贝到内核空间</span><br><span class="line">copy_to_user（）：将内核空间的数据拷贝到用户空间</span><br></pre></td></tr></table></figure>

<h3 id="传统IPC通信的缺点"><a href="#传统IPC通信的缺点" class="headerlink" title="传统IPC通信的缺点"></a>传统IPC通信的缺点</h3><ol>
<li>性能低下。一次数据传递需要经历：内存缓存区 –&gt; 内核缓存区 –&gt; 内存缓存区，需要 2 次数据拷贝；</li>
<li>接收数据的缓存区由数据接收进程提供，但是接收进程并不知道需要多大的空间来存放将要传递过来的数据，因此只能开辟尽可能大的内存空间或者先调用 API 接收消息头来获取消息体的大小，这两种做法<strong>不是浪费空间就是浪费时间</strong>。</li>
</ol>
<h2 id="为什么选择Binder通信？"><a href="#为什么选择Binder通信？" class="headerlink" title="为什么选择Binder通信？"></a>为什么选择Binder通信？</h2><img src="/pics/image-20210606161417803.png" alt="image-20210606161417803" style="zoom:50%;" />

<ul>
<li><p>从性能的角度</p>
<p>Binder数据拷贝只需要一次，而管道、消息队列、Socket都需要2次，但共享内存方式一次内存拷贝都不需要；从性能角度看，Binder性能仅次于共享内存。但共享内存控制复杂，难以使用。</p>
<img src="/pics/image-20210606161436142.png" alt="image-20210606161436142" style="zoom:50%;" /></li>
<li><p>从稳定性的角度<br>Binder 基于 C/S 架构，客户端（Client）有什么需求就丢给服务端（Server）去完成，架构清晰、职责明确又相互独立，自然稳定性更好。共享内存虽然无需拷贝，但是控制负责，难以使用。从稳定性的角度讲，Binder 机制是优于内存共享的。</p>
</li>
<li><p>从安全的角度<br>传统Linux IPC的接收方无法获得对方进程可靠的UID/PID，从而无法鉴别对方身份；传统Linux IPC无任何保护措施，完全由上层协议来确保。</p>
<p>Android为每个安装好的应用程序分配了自己的UID，故进程的UID是鉴别进程身份的重要标志，前面提到C/S架构，Android系统中对外只暴露Client端，Client端将任务发送给Server端，Server端会根据权限控制策略，判断UID/PID是否满足访问权限，目前权限控制很多时候是通过弹出权限询问对话框，让用户选择是否运行。</p>
<blockquote>
<p>传统IPC只能由用户在数据包里填入UID/PID；另外，可靠的身份标记只有由IPC机制本身在内核中添加。其次传统IPC访问接入点是开放的，无法建立私有通道。从安全角度，Binder的安全性更高。</p>
</blockquote>
</li>
</ul>
<h2 id="Binder-IPC原理"><a href="#Binder-IPC原理" class="headerlink" title="Binder IPC原理"></a>Binder IPC原理</h2><h3 id="动态内核可加载模块"><a href="#动态内核可加载模块" class="headerlink" title="动态内核可加载模块"></a>动态内核可加载模块</h3><p>跨进程通信是需要内核空间做支持的。传统的 IPC 机制如管道、Socket 都是内核的一部分，因此通过内核支持来实现进程间通信自然是没问题的。但是 Binder 并不是 Linux 系统内核的一部分，那怎么办呢？</p>
<p>这就得益于 Li<strong>nux 的动态内核可加载模块（Loadable Kernel Module，LKM）的机制</strong>；模块是具有独立功能的程序，它可以被单独编译，但是不能独立运行（可以简单类比成一个功能库）。模块在运行时被链接到内核作为内核的一部分运行。这样，Android 系统就可以通过动态添加一个内核模块运行在内核空间，用户进程之间通过这个内核模块作为桥梁来实现通信。</p>
<p>在 Android 系统中，这个运行在内核空间，<strong>负责各个用户进程通过 Binder 实现通信的内核模块就叫 Binder 驱动（Binder Dirver）。</strong></p>
<p>那么在 Android 系统中用户进程之间是如何通过这个内核模块（Binder 驱动）来实现通信的呢？这就不得不通道 Linux 下的另一个概念：内存映射。</p>
<h3 id="内存映射（mmap）"><a href="#内存映射（mmap）" class="headerlink" title="内存映射（mmap）"></a>内存映射（mmap）</h3><p>Binder IPC 机制中涉及到的内存映射通过 mmap() 来实现，mmap() 是操作系统中一种内存映射的方法。</p>
<p>内存映射简单的讲就是将<strong>用户空间的一块内存区域映射到内核空间</strong>。<strong>映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间</strong>。</p>
<p>内存映射能减少数据拷贝次数，实现用户空间和内核空间的高效互动。两个空间各自的修改能直接反映在映射的内存区域，从而被对方空间及时感知。也正因为如此，内存映射能够提供对进程间通信的支持。</p>
<p><a href="https://www.jianshu.com/p/719fc4758813">操作系统：图文详解 内存映射</a></p>
<h3 id="Binder-IPC实现原理"><a href="#Binder-IPC实现原理" class="headerlink" title="Binder IPC实现原理"></a>Binder IPC实现原理</h3><img src="/pics/image-20210606153721575.png" alt="image-20210606153721575" style="zoom:40%;" />

<p>一次完整的 Binder IPC 通信过程通常是这样：</p>
<ol>
<li>首先 Binder 驱动在内核空间创建一个<strong>数据接收缓存区</strong>；</li>
<li>接着在内核空间开辟一块内核缓存区，建立<ol>
<li><strong>内核缓存区 和 内核中数据接收缓存区之间</strong>的映射，</li>
<li><strong>数据接收缓存区 和 接收进程用户空间地址</strong> 的映射关系；</li>
</ol>
</li>
<li>发送方进程通过系统调用 copyfromuser() 将数据 copy 到内核中的内核缓存区，<strong>由于内核缓存区和接收进程的用户空间存在内存映射</strong>，因此也就<strong>相当于把数据发送到了接收进程的用户空间</strong>，这样便完成了一次进程间的通信。</li>
</ol>
<h2 id="Binder-通信模型"><a href="#Binder-通信模型" class="headerlink" title="Binder 通信模型"></a><strong>Binder 通信模型</strong></h2><p>一次完整的进程间通信必然至少包含两个进程，通常我们称通信的双方分别为客户端进程（Client）和服务端进程（Server），由于进程隔离机制的存在，通信双方必然需要借助 Binder 来实现。</p>
<h3 id="Client-Server-ServiceManager-驱动"><a href="#Client-Server-ServiceManager-驱动" class="headerlink" title="Client/Server/ServiceManager/驱动"></a>Client/Server/ServiceManager/驱动</h3><p>前面我们介绍过，Binder 是基于 C/S 架构的。由一系列的组件组成，包括 Client、Server、ServiceManager、Binder 驱动。其中 Client、Server、Service Manager 运行在用户空间，Binder 驱动运行在内核空间。其中 Service Manager 和 Binder 驱动由系统提供，而 Client、Server 由应用程序来实现。Client、Server 和 ServiceManager 均是通过系统调用 open、mmap 和 ioctl 来访问设备文件 /dev/binder，从而实现与 Binder 驱动的交互来间接的实现跨进程通信。</p>
<p><img src="https://pic3.zhimg.com/80/v2-729b3444cd784d882215a24067893d0e_1440w.jpg" alt="img"></p>
<p>Client、Server、ServiceManager、Binder 驱动这几个组件在通信过程中扮演的角色就如同互联网中服务器（Server）、客户端（Client）、DNS域名服务器（ServiceManager）以及路由器（Binder 驱动）之前的关系。</p>
<p><a href="https://link.zhihu.com/?target=http://blog.csdn.net/universus/article/details/6211589">Android Binder 设计与实现</a><em>一文中对 Client、Server、ServiceManager、Binder 驱动有很详细的描述，以下是部分摘录：</em></p>
<blockquote>
<p><strong>Binder 驱动</strong><br>Binder 驱动就如同路由器一样，是整个通信的核心；驱动负责进程之间 Binder 通信的建立，Binder 在进程之间的传递，Binder 引用计数管理，数据包在进程之间的传递和交互等一系列底层支持。</p>
<p><strong>ServiceManager 与实名 Binder</strong><br>ServiceManager 和 DNS 类似，作用是将字符形式的 Binder 名字转化成 Client 中对该 Binder 的引用，使得 Client 能够通过 Binder 的名字获得对 Binder 实体的引用。注册了名字的 Binder 叫实名 Binder，就像网站一样除了除了有 IP 地址意外还有自己的网址。Server 创建了 Binder，并为它起一个字符形式，可读易记得名字，将这个 Binder 实体连同名字一起以数据包的形式通过 Binder 驱动发送给 ServiceManager ，通知 ServiceManager 注册一个名为“张三”的 Binder，它位于某个 Server 中。驱动为这个穿越进程边界的 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager。ServiceManger 收到数据后从中取出名字和引用填入查找表。</p>
<p>细心的读者可能会发现，ServierManager 是一个进程，Server 是另一个进程，Server 向 ServiceManager 中注册 Binder 必然涉及到进程间通信。当前实现进程间通信又要用到进程间通信，这就好像蛋可以孵出鸡的前提却是要先找只鸡下蛋！Binder 的实现比较巧妙，就是预先创造一只鸡来下蛋。ServiceManager 和其他进程同样采用 Bidner 通信，ServiceManager 是 Server 端，有自己的 Binder 实体，其他进程都是 Client，需要通过这个 Binder 的引用来实现 Binder 的注册，查询和获取。ServiceManager 提供的 Binder 比较特殊，它没有名字也不需要注册。当一个进程使用 BINDER<em>SET</em>CONTEXT_MGR 命令将自己注册成 ServiceManager 时 Binder 驱动会自动为它创建 Binder 实体（<strong>这就是那只预先造好的那只鸡</strong>）。其次这个 Binder 实体的引用在所有 Client 中都固定为 0 而无需通过其它手段获得。也就是说，一个 Server 想要向 ServiceManager 注册自己的 Binder 就必须通过这个 0 号引用和 ServiceManager 的 Binder 通信。类比互联网，0 号引用就好比是域名服务器的地址，你必须预先动态或者手工配置好。要注意的是，这里说的 Client 是相对于 ServiceManager 而言的，一个进程或者应用程序可能是提供服务的 Server，但对于 ServiceManager 来说它仍然是个 Client。</p>
<p><strong>Client 获得实名 Binder 的引用</strong><br>Server 向 ServiceManager 中注册了 Binder 以后， Client 就能通过名字获得 Binder 的引用了。Client 也利用保留的 0 号引用向 ServiceManager 请求访问某个 Binder: 我申请访问名字叫张三的 Binder 引用。ServiceManager 收到这个请求后从请求数据包中取出 Binder 名称，在查找表里找到对应的条目，取出对应的 Binder 引用作为回复发送给发起请求的 Client。从面向对象的角度看，Server 中的 Binder 实体现在有两个引用：一个位于 ServiceManager 中，一个位于发起请求的 Client 中。如果接下来有更多的 Client 请求该 Binder，系统中就会有更多的引用指向该 Binder ，就像 Java 中一个对象有多个引用一样。</p>
</blockquote>
<h3 id="Binder-通信过程"><a href="#Binder-通信过程" class="headerlink" title="Binder 通信过程"></a>Binder 通信过程</h3><p>至此，我们大致能总结出 Binder 通信过程：</p>
<ol>
<li>首先，一个进程使用 BINDER<em>SET</em>CONTEXT_MGR 命令通过 Binder 驱动将自己注册成为 ServiceManager；</li>
<li>Server 通过驱动向 ServiceManager 中注册 Binder（Server 中的 Binder 实体），表明可以对外提供服务。驱动为这个 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager，ServiceManger 将其填入查找表。</li>
<li>Client 通过名字，在 Binder 驱动的帮助下从 ServiceManager 中获取到对 Binder 实体的引用，通过这个引用就能实现和 Server 进程的通信。</li>
</ol>
<p>我们看到整个通信过程都需要 Binder 驱动的接入。下图能更加直观的展现整个通信过程(为了进一步抽象通信过程以及呈现上的方便，下图我们忽略了 Binder 实体及其引用的概念)：</p>
<img src="https://pic4.zhimg.com/80/v2-67854cdf14d07a6a4acf9d675354e1ff_1440w.jpg" alt="img" style="zoom:50%;" />

<h3 id="详细过程"><a href="#详细过程" class="headerlink" title="详细过程"></a>详细过程</h3><ol>
<li>**<a href="http://gityuan.com/2015/11/14/binder-add-service/">注册服务(addService)</a>**：Server进程要先注册Service到ServiceManager。该过程：Server是客户端，ServiceManager是服务端。</li>
<li>**<a href="http://gityuan.com/2015/11/15/binder-get-service/">获取服务(getService)</a>**：Client进程使用某个Service前，须先向ServiceManager中获取相应的Service。该过程：Client是客户端，ServiceManager是服务端。</li>
<li><strong>使用服务</strong>：Client根据得到的Service信息建立与Service所在的Server进程通信的通路，然后就可以直接与Service交互。该过程：client是客户端，server是服务端。</li>
</ol>
<img src="/pics/image-20210530205550500.png" alt="image-20210530205550500" style="zoom:48%;" />

<p><a href="https://blog.csdn.net/carson_ho/article/details/73560642">https://blog.csdn.net/carson_ho/article/details/73560642</a></p>
<h2 id="Binder通信过程的代理模式"><a href="#Binder通信过程的代理模式" class="headerlink" title="Binder通信过程的代理模式"></a>Binder通信过程的代理模式</h2><p>跨进程通信的过程都有 Binder 驱动的参与，因此在数据流经 Binder 驱动的时候驱动会对数据做一层转换。当 A 进程想要获取 B 进程中的 object 时，驱动并不会真的把 object 返回给 A，<strong>而是返回了一个跟 object 看起来一模一样的代理对象 objectProxy</strong>，这个 objectProxy 具有和 object 一摸一样的方法，但是这些方法并没有 B 进程中 object 对象那些方法的能力，<strong>这些方法只需要把把请求参数交给驱动即可</strong>。对于 A 进程来说和直接调用 object 中的方法是一样的。</p>
<p>当 Binder 驱动接收到 A 进程的消息后，发现这是个 objectProxy 就去查询自己维护的表单，一查发现这是 B 进程 object 的代理对象。<code>于是就会去通知</code> B 进程调用 object 的方法，并要求 B 进程把返回结果发给自己。当驱动拿到 B 进程的返回结果后就会转发给 A 进程，一次通信就完成了。</p>
<img src="/pics/image-20210606150728973.png" alt="image-20210606150728973" style="zoom:40%;" />

<h2 id="Binder进程与线程"><a href="#Binder进程与线程" class="headerlink" title="Binder进程与线程"></a>Binder进程与线程</h2><p>每个Server进程在启动时会创建一个binder线程池，用来处理Binder请求；Binder的线程管理由Binder驱动自身进行管理，<strong>而不是由Server进程来管理</strong>。</p>
<p>对于一个Server进程有一个最大Binder线程数限制，默认为16个binder线程，例如Android的system_server进程就存在16个线程，超过的请求会被阻塞等待空闲的Binder线程。</p>
<p>参考：</p>
<p><a href="https://zhuanlan.zhihu.com/p/35519585">https://zhuanlan.zhihu.com/p/35519585</a></p>
<p><a href="https://blog.csdn.net/carson_ho/article/details/73560642">https://blog.csdn.net/carson_ho/article/details/73560642</a></p>
<p><a href="http://gityuan.com/2015/11/28/binder-summary/">http://gityuan.com/2015/11/28/binder-summary/</a></p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Binder</tag>
      </tags>
  </entry>
  <entry>
    <title>FrameWork_02_Binder</title>
    <url>/2021/06/06/Notes/Android/Framework/FrameWork_03_AMS/</url>
    <content><![CDATA[<h1 id="FrameWork-03-Activity-启动流程"><a href="#FrameWork-03-Activity-启动流程" class="headerlink" title="FrameWork_03_Activity 启动流程"></a>FrameWork_03_Activity 启动流程</h1><h2 id="Launcher-启动App过程"><a href="#Launcher-启动App过程" class="headerlink" title="Launcher 启动App过程"></a>Launcher 启动App过程</h2><p>以桌面（Launcher）启动Activity为例，Activity启动过程可以分为如下步骤：</p>
<p><img src="/pics/image-20210613151222905.png" alt="image-20210613151222905"></p>
<p>图解：</p>
<ol>
<li><p>Launcher 通知 AMS</p>
<p>通过<code> AMN （ActivityManagerNative）/ AMP（ActivityManagerProxy）</code>调用到<code>sytem_server</code>进程的<code>AMS</code>，使用的是Binder通信。</p>
</li>
<li><p>AMS 处理 Launcher 传递过来的信息，有3步:</p>
<ul>
<li>通过 <code>PMS(PackageManagerService)</code> 校验intent是否有效</li>
<li>通知<code>Launcher</code> pause，这里也涉及一次Binder通信，使用的是<code>ATN（ApplicationThreadNative）ATP（ApplicationThreadProxy）</code>，此时的client是AMS，server端 是Launcher。</li>
<li>启动Activity，在Activity 所在进程没启动的情况下，需要先启动activity进程。</li>
</ul>
</li>
<li><p>AMS启动新的进程</p>
<p>AMS 通过 <code>startProcessLocked </code>调用到 <code>zygote</code> 进程，通过<code>fork</code> 方式创建一个新App进程。这个过程使用的是 socket 通信</p>
<img src="/pics/image-20210613151425352.png" alt="image-20210613151425352" style="zoom:30%;" />

<p>(<a href="http://gityuan.com/2016/10/09/app-process-create-2/">Android四大组件与进程启动的关系</a>)</p>
</li>
<li><p>新进程启动，绑定AMS</p>
<p>App启动后，首先进入<code>ActivityThread</code>的main 方法中：</p>
<ol>
<li>创建主线程Looper </li>
<li>创建 Application</li>
<li>最后通过Binder IPC向<code>sytem_server</code>进程<code>AMS</code>发起attachApplication请求；</li>
</ol>
</li>
<li><p>AMS中确定要启动的Activity</p>
<p>AMS 中保存的 第一个阶段 获取到要启动的Activity信息，经过多次调用，最后会通过ATP，使用Binder IPC向App进程发送scheduleLaunchActivity请求；</p>
</li>
<li><p>启动相应的Activtity</p>
<p>主线程在收到Message后，通过反射机制创建目标Activity，并回调Activity.onCreate()等方法</p>
</li>
</ol>
<h2 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h2><h3 id="ActivityThread"><a href="#ActivityThread" class="headerlink" title="ActivityThread"></a>ActivityThread</h3><h3 id="ApplicationThread"><a href="#ApplicationThread" class="headerlink" title="ApplicationThread"></a>ApplicationThread</h3><h4 id="ApplicationThreadProxy"><a href="#ApplicationThreadProxy" class="headerlink" title="ApplicationThreadProxy"></a>ApplicationThreadProxy</h4><h4 id="ApplicationThreadNative"><a href="#ApplicationThreadNative" class="headerlink" title="ApplicationThreadNative"></a>ApplicationThreadNative</h4><h3 id="ActivityMangerService"><a href="#ActivityMangerService" class="headerlink" title="ActivityMangerService"></a>ActivityMangerService</h3><h4 id="ActivityMangerProxy"><a href="#ActivityMangerProxy" class="headerlink" title="ActivityMangerProxy"></a>ActivityMangerProxy</h4><h4 id="ActivityManagerNative"><a href="#ActivityManagerNative" class="headerlink" title="ActivityManagerNative"></a>ActivityManagerNative</h4><h3 id="ActivityStackSupervisor"><a href="#ActivityStackSupervisor" class="headerlink" title="ActivityStackSupervisor"></a>ActivityStackSupervisor</h3><h3 id="ActivityStack"><a href="#ActivityStack" class="headerlink" title="ActivityStack"></a>ActivityStack</h3><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>上述的过程是基于 Android 6.0，Andorid 11 上 AMN/AMP 的 实现变为了<code>ActivityTaskManagerService</code>,但核心的流程并未发生变化。</p>
<p><a href="http://gityuan.com/2016/03/12/start-activity/">Android6.0 startActivity启动过程分析</a></p>
<p><a href="https://calmcenter.club/2020/android-framework-activity">Android 11 Activity 启动分析</a></p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>AMS</tag>
      </tags>
  </entry>
  <entry>
    <title>FrameWork_02_Binder</title>
    <url>/2021/06/06/Notes/Android/Framework/FrameWork_02_Binder%20%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h1 id="FrameWork-02-Binder-架构"><a href="#FrameWork-02-Binder-架构" class="headerlink" title="FrameWork_02_Binder 架构"></a>FrameWork_02_Binder 架构</h1><p>Binder通信采用C/S架构，从组件视角来说，包含Client、Server、ServiceManager以及Binder驱动，其中ServiceManager用于管理系统中的各种服务。架构图如下所示：</p>
<img src="/pics/image-20210606151407737.png" alt="image-20210606151407737" style="zoom:50%;" />

<p>可以看出无论是注册服务和获取服务的过程都需要ServiceManager，需要注意的是此处的Service Manager是指Native层的ServiceManager（C++），并非指framework层的ServiceManager(Java)。ServiceManager是整个Binder通信机制的大管家，是Android进程间通信机制Binder的守护进程，要掌握Binder机制，首先需要了解系统是如何首次<a href="http://gityuan.com/2015/11/07/binder-start-sm/">启动Service Manager</a>。当Service Manager启动之后，Client端和Server端通信时都需要先<a href="http://gityuan.com/2015/11/08/binder-get-sm/">获取Service Manager</a>接口，才能开始通信服务。</p>
<p>图中Client/Server/ServiceManage之间的相互通信都是基于Binder机制。既然基于Binder机制通信，那么同样也是C/S架构，则图中的3大步骤都有相应的Client端与Server端。</p>
<ol>
<li>**<a href="http://gityuan.com/2015/11/14/binder-add-service/">注册服务(addService)</a>**：Server进程要先注册Service到ServiceManager。该过程：Server是客户端，ServiceManager是服务端。</li>
<li>**<a href="http://gityuan.com/2015/11/15/binder-get-service/">获取服务(getService)</a>**：Client进程使用某个Service前，须先向ServiceManager中获取相应的Service。该过程：Client是客户端，ServiceManager是服务端。</li>
<li><strong>使用服务</strong>：Client根据得到的Service信息建立与Service所在的Server进程通信的通路，然后就可以直接与Service交互。该过程：client是客户端，server是服务端。</li>
</ol>
<p>图中的Client,Server,Service Manager之间交互都是虚线表示，是由于它们彼此之间不是直接交互的，而是都通过与<a href="http://gityuan.com/2015/11/01/binder-driver/">Binder驱动</a>进行交互的，从而实现IPC通信方式。其中Binder驱动位于内核空间，Client,Server,Service Manager位于用户空间。Binder驱动和Service Manager可以看做是Android平台的基础架构，而Client和Server是Android的应用层，开发人员只需自定义实现client、Server端，借助Android的基本平台架构便可以直接进行IPC通信。</p>
<p>下面我们先来了解下Android 中binder驱动的核心方法。</p>
<h3 id="Binder驱动"><a href="#Binder驱动" class="headerlink" title="Binder驱动"></a>Binder驱动</h3><p>Client进程通过RPC(Remote Procedure Call Protocol)与Server通信，可以简单地划分为三层，驱动层、IPC层、业务层。<code>demo()</code>便是Client端和Server共同协商好的统一方法；handle、RPC数据、代码、协议这4项组成了IPC层的数据，通过IPC层进行数据传输；而真正在Client和Server两端建立通信的基础设施便是Binder Driver。</p>
<img src="/pics/image-20210606153003357.png" alt="image-20210606153003357" style="zoom:40%;" />

<p>Binder驱动是Android专用的，但底层的驱动架构与Linux驱动一样。binder驱动在以misc设备进行注册，作为虚拟字符设备，没有直接操作硬件，只是对设备内存的处理。主要是驱动设备的初始化(binder_init)，打开 (binder_open)，映射(binder_mmap)，数据操作(binder_ioctl)。</p>
<img src="/pics/image-20210606152124763.png" alt="image-20210606152124763" style="zoom:50%;" />

<ul>
<li>binder_init：初始化字符设备</li>
<li>binder_open：打开驱动设备</li>
<li>binder_mmap：首先在内核虚拟地址空间，申请一块与用户虚拟内存相同大小的内存；然后再申请1个page大小的物理内存，再将<strong>同一块物理内存分别映射到内核虚拟地址空间和用户虚拟内存空间</strong>，从而实现了用户空间的Buffer和内核空间的Buffer同步操作的功能。</li>
<li>binder_ioctl：binder_ioctl()函数负责在两个进程间收发IPC数据和IPC reply数据。</li>
</ul>
<p><strong>系统调用</strong></p>
<p>用户态的程序调用Kernel层驱动是需要陷入内核态，进行系统调用(<code>syscall</code>)，比如打开Binder驱动方法的调用链为： open-&gt; __open() -&gt; binder_open()。 open()为用户空间的方法，__open()便是系统调用中相应的处理方法，通过查找，对应调用到内核binder驱动的binder_open()方法，至于其他的从用户态陷入内核态的流程也基本一致。</p>
<img src="/pics/image-20210606152245305.png" alt="image-20210606152245305" style="zoom:40%;" />

<p>简单说，当用户空间调用open()方法，最终会调用binder驱动的binder_open()方法；mmap()/ioctl()方法也是同理，在BInder系列的后续文章从用户态进入内核态，都依赖于系统调用过程。</p>
<h3 id="ServiceManager"><a href="#ServiceManager" class="headerlink" title="ServiceManager"></a>ServiceManager</h3><p>ServiceManger集中管理系统内的所有服务，通过权限控制进程是否有权注册服务,通过字符串名称来查找对应的Service; 由于ServiceManger进程建立跟所有向其注册服务的死亡通知, 那么当服务所在进程死亡后, 会只需告知ServiceManager. 每个Client通过查询ServiceManager可获取Server进程的情况，降低所有Client进程直接检测会导致负载过重。</p>
<h4 id="ServiceManager启动过程"><a href="#ServiceManager启动过程" class="headerlink" title="ServiceManager启动过程"></a>ServiceManager启动过程</h4><p>ServiceManager是Binder IPC通信过程中的守护进程，本身也是一个Binder服务，但并没有采用libbinder中的多线程模型来与Binder驱动通信，而是自行编写了binder.c直接和Binder驱动来通信，并且只有一个循环binder_loop来进行读取和处理事务，这样的好处是简单而高效。</p>
<p><strong>ServiceManager启动流程：</strong></p>
<ol>
<li>打开binder驱动，并调用mmap()方法分配128k的内存映射空间：binder_open();</li>
<li>通知binder驱动使其成为守护进程：binder_become_context_manager()；</li>
<li>验证selinux权限，判断进程是否有权注册或查看指定服务；</li>
<li>进入循环状态，等待Client端的请求：binder_loop()。</li>
<li>注册服务的过程，根据服务名称，但同一个服务已注册，重新注册前会先移除之前的注册信息；</li>
<li>死亡通知: 当binder所在进程死亡后,会调用binder_release方法,然后调用binder_node_release.这个过程便会发出死亡通知的回调.</li>
</ol>
<p>ServiceManager最核心的两个功能为查询和注册服务：</p>
<ul>
<li>注册服务：记录服务名和handle信息，保存到svclist列表；</li>
<li>查询服务：根据服务名查询相应的的handle信息。</li>
</ul>
<h4 id="获取ServiceManager"><a href="#获取ServiceManager" class="headerlink" title="获取ServiceManager"></a>获取ServiceManager</h4><p>获取Service Manager是通过<code>defaultServiceManager()</code>方法来完成，当进程<a href="http://gityuan.com/2015/11/14/binder-add-service/">注册服务(addService)</a>或 <a href="http://gityuan.com/2015/11/15/binder-get-service/">获取服务(getService)</a>的过程之前，都需要先调用defaultServiceManager()方法来获取<code>gDefaultServiceManager</code>对象。对于gDefaultServiceManager对象，如果存在则直接返回；如果不存在则创建该对象，创建过程包括调用open()打开binder驱动设备，利用mmap()映射内核的地址空间。</p>
<h3 id="注册服务"><a href="#注册服务" class="headerlink" title="注册服务"></a>注册服务</h3><p>Media服务注册的过程涉及到MediaPlayerService(作为Client进程)和Service Manager(作为Service进程)，通信流程图如下所示</p>
<img src="/pics/image-20210606155146718.png" alt="image-20210606155146718" style="zoom:50%;" />

<ol>
<li><code>BINDER_COMMAND_PROTOCOL</code>：binder请求码，以”BC_“开头，简称BC码，用于从IPC层传递到Binder Driver层；</li>
<li><code>BINDER_RETURN_PROTOCOL</code> ：binder响应码，以”BR_“开头，简称BR码，用于从Binder Driver层传递到IPC层；</li>
</ol>
<h3 id="获取服务"><a href="#获取服务" class="headerlink" title="获取服务"></a>获取服务</h3><p>BpBinder(客户端)和BBinder(服务端)都是Android中Binder通信相关的代表，它们都从IBinder类中派生而来，关系图如下：</p>
<img src="/pics/image-20210606161156966.png" alt="image-20210606161156966" style="zoom:50%;" />

<ul>
<li>client端：BpBinder.transact()来发送事务请求；</li>
<li>server端：BBinder.onTransact()会接收到相应事务。</li>
</ul>
<p>请求服务(getService)过程，就是向servicemanager进程查询指定服务，当执行binder_transaction()时，会区分请求服务所属进程情况。</p>
<ol>
<li>当请求服务的进程与服务属于不同进程，则为请求服务所在进程创建binder_ref对象，指向服务进程中的binder_node;<ul>
<li>最终readStrongBinder()，返回的是BpBinder对象；</li>
</ul>
</li>
<li>当请求服务的进程与服务属于同一进程，则不再创建新对象，只是引用计数加1，并且修改type为BINDER_TYPE_BINDER或BINDER_TYPE_WEAK_BINDER。<ul>
<li>最终readStrongBinder()，返回的是BBinder对象的真实子类；</li>
</ul>
</li>
</ol>
<h3 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h3><p>binder在framework层，采用JNI技术来调用native(C/C++)层的binder架构，从而为上层应用程序提供服务。 看过binder系列之前的文章，我们知道native层中，binder是C/S架构，分为Bn端(Server)和Bp端(Client)。对于java层在命名与架构上非常相近，同样实现了一套IPC通信架构。</p>
<img src="/pics/image-20210606161741080.png" alt="image-20210606161741080" style="zoom:40%;" />

<ul>
<li>图中红色代表整个framework层 binder架构相关组件；<ul>
<li>Binder类代表Server端，BinderProxy类代码Client端；</li>
</ul>
</li>
<li>图中蓝色代表Native层Binder架构相关组件；</li>
<li>上层framework层的Binder逻辑是建立在Native层架构基础之上的，核心逻辑都是交予Native层方法来处理。</li>
<li>framework层的ServiceManager类与Native层的功能并不完全对应，framework层的ServiceManager类的实现最终是通过BinderProxy传递给Native层来完成的，后面会详细说明。</li>
</ul>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Binder</tag>
      </tags>
  </entry>
  <entry>
    <title>FrameWork_04_AMS 和 插件化</title>
    <url>/2021/07/02/Notes/Android/Framework/FrameWork_04_%E6%8F%92%E4%BB%B6%E5%8C%96/</url>
    <content><![CDATA[<h1 id="AMS-和-插件化"><a href="#AMS-和-插件化" class="headerlink" title="AMS 和 插件化"></a>AMS 和 插件化</h1><h2 id="一、插件加载"><a href="#一、插件加载" class="headerlink" title="一、插件加载"></a>一、插件加载</h2><h2 id="二、插件Activity启动"><a href="#二、插件Activity启动" class="headerlink" title="二、插件Activity启动"></a>二、插件Activity启动</h2><h2 id="三、插件资源加载"><a href="#三、插件资源加载" class="headerlink" title="三、插件资源加载"></a>三、插件资源加载</h2>]]></content>
      <tags>
        <tag>Android</tag>
        <tag>插件化</tag>
      </tags>
  </entry>
  <entry>
    <title>FrameWork_04_AMS 和 插件化</title>
    <url>/2021/06/20/Notes/Android/Framework/FrameWork_05_View%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="FrameWork-04-View绘制流程"><a href="#FrameWork-04-View绘制流程" class="headerlink" title="FrameWork_04_View绘制流程"></a>FrameWork_04_View绘制流程</h1><ul>
<li><p><strong>Activity :</strong> 对于每一个 activity 都会有拥有一个 PhoneWindow。</p>
</li>
<li><p><strong>PhoneWindow</strong> ：该类继承于 Window 类，是 Window 类的具体实现，即我们可以通过该类具体去绘制窗口。并且，该类内部包含了一个 DecorView 对象，该 DectorView 对象是所有应用窗口的根 View。</p>
</li>
<li><p><strong>DecorView</strong> 是一个应用窗口的根容器，它本质上是一个 FrameLayout。DecorView 有唯一一个子 View，它是一个垂直 LinearLayout，包含两个子元素，一个是 TitleView（ ActionBar 的容器），另一个是 ContentView（窗口内容的容器）。</p>
</li>
<li><p><strong>ContentView</strong> ：是一个 FrameLayout（android.R.id.content)，我们平常用的 setContentView 就是设置它的子 View 。</p>
</li>
<li><p><strong>WindowManager :</strong> 是一个接口，里面常用的方法有：添加View，更新View和删除View。主要是用来管理 Window 的。WindowManager 具体的实现类是WindowManagerImpl。最终，WindowManagerImpl 会将业务交给 WindowManagerGlobal 来处理。</p>
</li>
<li><p><strong>WindowManagerService (WMS)</strong> ： 负责管理各 app 窗口的创建，更新，删除， 显示顺序。运行在 system_server 进程。</p>
</li>
<li><p><strong>ViewRootImpl</strong> ：拥有 DecorView 的实例，通过该实例来控制 DecorView 绘制。ViewRootImpl 的一个内部类 W，实现了 IWindow 接口，IWindow 接口是供 WMS 使用的，WSM 通过调用 IWindow 一些方法，通过 Binder 通信的方式，最后执行到了 W 中对应的方法中。同样的，ViewRootImpl 通过 IWindowSession 来调用 WMS 的 Session 一些方法。Session 类继承自 <code>IWindowSession.Stub</code>，每一个应用进程都有一个唯一的 Session 对象与 WMS 通信。</p>
</li>
</ul>
<h2 id="一、Actvity布局加载流程"><a href="#一、Actvity布局加载流程" class="headerlink" title="一、Actvity布局加载流程"></a>一、Actvity布局加载流程</h2><h3 id="1-1、布局的层次"><a href="#1-1、布局的层次" class="headerlink" title="1.1、布局的层次"></a>1.1、布局的层次</h3><img src="/pics/image-20210620184143390.png" alt="image-20210620184143390" style="zoom:50%;" />

<h3 id="1-2、window和WMS绑定"><a href="#1-2、window和WMS绑定" class="headerlink" title="1.2、window和WMS绑定"></a>1.2、window和WMS绑定</h3><img src="/pics/image-20210704153047185.png" alt="image-20210704153047185" style="zoom:40%;" />

<h3 id="1-3、Actvity-setContentView"><a href="#1-3、Actvity-setContentView" class="headerlink" title="1.3、Actvity#setContentView"></a>1.3、Actvity#setContentView</h3><img src="/pics/image-20210620220355400.png" alt="image-20210620220355400" style="zoom:40%;" />

<h4 id="Actvity-setContentView"><a href="#Actvity-setContentView" class="headerlink" title="Actvity#setContentView"></a>Actvity#setContentView</h4><p>setContentView 调用到 PhoneWindow的<code>setContentView</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//getWindow() = PhoneWindow</span></span><br><span class="line">    getWindow().setContentView(layoutResID);</span><br><span class="line">    initWindowDecorActionBar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    attachBaseContext(context);</span><br><span class="line"></span><br><span class="line">    mFragments.attachHost(<span class="keyword">null</span> <span class="comment">/*parent*/</span>);</span><br><span class="line"></span><br><span class="line">    mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>, window, activityConfigCallback);</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="PhoneWindow-setContentView"><a href="#PhoneWindow-setContentView" class="headerlink" title="PhoneWindow#setContentView"></a>PhoneWindow#setContentView</h4><ol>
<li>创建DecorView </li>
<li>将Activity 布局添加到 mContentParent 中</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 布局顺序</span></span><br><span class="line">    setContentView(view, <span class="keyword">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// step1: 创建decorView</span></span><br><span class="line">        installDecor();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        mContentParent.removeAllViews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        <span class="keyword">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class="line">                getContext());</span><br><span class="line">        transitionTo(newScene);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// step2: 加载布局</span></span><br><span class="line">        mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParent.requestApplyInsets();</span><br><span class="line">    <span class="keyword">final</span> Callback cb = getCallback();</span><br><span class="line">    <span class="keyword">if</span> (cb != <span class="keyword">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">        cb.onContentChanged();</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParentExplicitlySet = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="PhoneWindow-installDecor"><a href="#PhoneWindow-installDecor" class="headerlink" title="PhoneWindow#installDecor"></a>PhoneWindow#installDecor</h5><ol>
<li>真正创建decorView</li>
<li>关联PhoneWindow 和 DecorView</li>
<li>生成DecorView 的 ContentParent</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mForceDecorInstall = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 1. 创建decorView</span></span><br><span class="line">        mDecor = generateDecor(-<span class="number">1</span>);</span><br><span class="line">        mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</span><br><span class="line">        mDecor.setIsRootNamespace(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != <span class="number">0</span>) &#123;</span><br><span class="line">            mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 2.关联PhoneWindow 和 DecorView</span></span><br><span class="line">        mDecor.setWindow(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 生成mContentParent 布局，</span></span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line"> 				mContentParent = generateLayout(mDecor);</span><br><span class="line">      </span><br><span class="line">    <span class="comment">//...   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>PhoneWindow#generateDecor</strong></p>
<p>创建 DecorView </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> DecorView <span class="title">generateDecor</span><span class="params">(<span class="keyword">int</span> featureId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// System process doesn&#x27;t have application context and in that case we need to directly use</span></span><br><span class="line">    <span class="comment">// the context we have. Otherwise we want the application context, so we don&#x27;t cling to the</span></span><br><span class="line">    <span class="comment">// activity.</span></span><br><span class="line">    Context context;</span><br><span class="line">    <span class="keyword">if</span> (mUseDecorContext) &#123;</span><br><span class="line">        Context applicationContext = getContext().getApplicationContext();</span><br><span class="line">        <span class="keyword">if</span> (applicationContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">            context = getContext();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            context = <span class="keyword">new</span> DecorContext(applicationContext, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (mTheme != -<span class="number">1</span>) &#123;</span><br><span class="line">                context.setTheme(mTheme);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        context = getContext();</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 创建decorView</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DecorView(context, featureId, <span class="keyword">this</span>, getAttributes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>PhoneWindow#generateLayout</strong></p>
<ol>
<li>从主题文件中获取样式信息</li>
<li>根据主题样式，加载窗口布局</li>
<li>将窗口布局添加到DecorView 中</li>
<li>初始化内容容器</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ViewGroup <span class="title">generateLayout</span><span class="params">(DecorView decor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 从主题文件中获取样式信息</span></span><br><span class="line">		TypedArray a = getWindowStyle();</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">		<span class="keyword">if</span> (a.getBoolean(R.styleable.Window_windowNoTitle, <span class="keyword">false</span>)) &#123;</span><br><span class="line">		    requestFeature(FEATURE_NO_TITLE);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.getBoolean(R.styleable.Window_windowActionBar, <span class="keyword">false</span>)) &#123;</span><br><span class="line">		    <span class="comment">// Don&#x27;t allow an action bar if there is no title.</span></span><br><span class="line">		    requestFeature(FEATURE_ACTION_BAR);</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 2.根据主题样式，加载窗口布局</span></span><br><span class="line">  	<span class="keyword">int</span> layoutResource;</span><br><span class="line">    <span class="keyword">int</span> features = getLocalFeatures();</span><br><span class="line">    <span class="comment">// System.out.println(&quot;Features: 0x&quot; + Integer.toHexString(features));</span></span><br><span class="line">    <span class="keyword">if</span> ((features &amp; ((<span class="number">1</span> &lt;&lt; FEATURE_LEFT_ICON) | (<span class="number">1</span> &lt;&lt; FEATURE_RIGHT_ICON))) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mIsFloating) &#123;</span><br><span class="line">            TypedValue res = <span class="keyword">new</span> TypedValue();</span><br><span class="line">            getContext().getTheme().resolveAttribute(</span><br><span class="line">                    R.attr.dialogTitleIconsDecorLayout, res, <span class="keyword">true</span>);</span><br><span class="line">            layoutResource = res.resourceId;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            layoutResource = R.layout.screen_title_icons;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 3.将窗口布局添加到DecorView中</span></span><br><span class="line">   	mDecor.startChanging();</span><br><span class="line">    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);</span><br><span class="line">    <span class="comment">// 4.初始化内容容器</span></span><br><span class="line">		<span class="comment">// 内容容器，ID_ANDROID_CONTENT 定义在 Window 类中，</span></span><br><span class="line">    <span class="comment">// ID_ANDROID_CONTENT = com.android.internal.R.id.content</span></span><br><span class="line">    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);</span><br><span class="line">    <span class="keyword">if</span> (contentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Window couldn&#x27;t find content container view&quot;</span>);</span><br><span class="line">    &#125;		   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DecorView # onResourcesLoaded</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onResourcesLoaded</span><span class="params">(LayoutInflater inflater, <span class="keyword">int</span> layoutResource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mBackdropFrameRenderer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        loadBackgroundDrawablesIfNeeded();</span><br><span class="line">        mBackdropFrameRenderer.onResourcesLoaded(</span><br><span class="line">                <span class="keyword">this</span>, mResizingBackgroundDrawable, mCaptionBackgroundDrawable,</span><br><span class="line">                mUserCaptionBackgroundDrawable, getCurrentColor(mStatusColorViewState),</span><br><span class="line">                getCurrentColor(mNavigationColorViewState));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDecorCaptionView = createDecorCaptionView(inflater);</span><br><span class="line">    <span class="keyword">final</span> View root = inflater.inflate(layoutResource, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (mDecorCaptionView != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mDecorCaptionView.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            addView(mDecorCaptionView,</span><br><span class="line">                    <span class="keyword">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">        &#125;</span><br><span class="line">        mDecorCaptionView.addView(root,</span><br><span class="line">                <span class="keyword">new</span> ViewGroup.MarginLayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Put it below the color views.</span></span><br><span class="line">        addView(root, <span class="number">0</span>, <span class="keyword">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">    &#125;</span><br><span class="line">    mContentRoot = (ViewGroup) root;</span><br><span class="line">    initializeElevation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>installDecor方法实质就是产生mDecor和mContentParent对象。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Actvity布局加载流程可以分为两步：</p>
<ol>
<li><p>创建<code>DecorView</code>并初始化布局</p>
<ol>
<li>创建DecorView</li>
<li>根据主题属性设置布局并将布局添加到 DecorView 中</li>
<li>初始化 mContentParent 对象</li>
<li>关联PhoneWindow 和 DecorView</li>
</ol>
</li>
<li><p>通过LayoutInflater 将activity的布局添加到 <code>mContentParent（R.id.content）</code> 中</p>
</li>
</ol>
<p><a href="https://blog.csdn.net/feiduclear_up/article/details/46711921">从setContentView方法分析Android加载布局流程</a></p>
<h2 id="二、xml解析流程"><a href="#二、xml解析流程" class="headerlink" title="二、xml解析流程"></a>二、xml解析流程</h2><p><a href="http://blog.csdn.net/feiduclear_up/article/details/46732879"><strong>从LayoutInflater分析XML布局解析成View的树形结构的过程</strong></a> </p>
<h2 id="三、view-的绘制和渲染过程"><a href="#三、view-的绘制和渲染过程" class="headerlink" title="三、view 的绘制和渲染过程"></a>三、view 的绘制和渲染过程</h2><p>DecorView是怎么添加到窗口的呢？真正的入口是在handleActivityResume 时，将DecorView和 Activity建立联系</p>
<img src="/pics/image-20210620214953160.png" alt="image-20210620214953160" style="zoom:50%;" />

<p>经过层层调用，DecorView的绘制会进入到ViewRootImpl类中的performTraversals()成员方法，这个过程可以参考上面的代码流程图。现在我们主要来分析下 ViewRootImpl类中的performTraversals方法。</p>
<p><a href="http://blog.csdn.net/feiduclear_up/article/details/46772477">从ViewRootImpl类分析View绘制的流程</a></p>
<img src="/pics/image-20210620221717118.png" alt="image-20210620221717118" style="zoom:40%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="comment">//执行测量操作</span></span><br><span class="line">  performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">//执行布局操作</span></span><br><span class="line">  performLayout(lp, desiredWindowWidth, desiredWindowHeight);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//执行绘制操作</span></span><br><span class="line">	performDraw();</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1、MeasureSpec"><a href="#3-1、MeasureSpec" class="headerlink" title="3.1、MeasureSpec"></a>3.1、MeasureSpec</h3><p>MeasureSpec表示的是一个32位的整形值，<code>它的高2位表示测量模式SpecMode，低30位表示某种测量模式下的规格大小SpecSize</code>。MeasureSpec是View类的一个静态内部类，用来说明应该如何测量这个View。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_SHIFT = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_MASK = <span class="number">0x3</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNSPECIFIED = <span class="number">0</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXACTLY = <span class="number">1</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_MOST = <span class="number">2</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeMeasureSpec</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sUseBrokenMakeMeasureSpec) &#123;</span><br><span class="line">        <span class="keyword">return</span> size + mode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (size &amp; ～MODE_MASK) | (mode &amp; MODE_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMode</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (measureSpec &amp; MODE_MASK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (measureSpec &amp; ～MODE_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MeasureSpec通过将SpecMode和SpecSize打包成一个int值来避免过多的对象内存分配，为了方便操作，其提供了打包和解包方法。</p>
<p>SpecMode有三类，每一类都表示特殊的含义，如下所示。</p>
<ul>
<li><p><strong>UNSPECIFIED</strong></p>
<p>父容器不对View有任何限制，要多大给多大，这种情况一般用于系统内部，表示一种测量的状态。</p>
</li>
<li><p><strong>EXACTLY</strong></p>
<p>父容器已经检测出View所需要的精确大小，这个时候View的最终大小就是SpecSize所指定的值。它对应于LayoutParams中的match_parent和具体的数值这两种模式。</p>
</li>
<li><p><strong>AT_MOST</strong><br>父容器指定了一个可用大小即SpecSize, View的大小不能大于这个值，具体是什么值要看不同View的具体实现。它对应于LayoutParams中的wrap_content。</p>
</li>
</ul>
<h4 id="3-1-1、DecorView-的MeasureSpec"><a href="#3-1-1、DecorView-的MeasureSpec" class="headerlink" title="3.1.1、DecorView 的MeasureSpec"></a>3.1.1、DecorView 的MeasureSpec</h4><p>对于DecorView，其MeasureSpec由<code>窗口的尺寸和其自身的LayoutParams</code>来共同确定；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRootMeasureSpec</span><span class="params">(<span class="keyword">int</span> windowSize, <span class="keyword">int</span> rootDimension)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> measureSpec;</span><br><span class="line">    <span class="keyword">switch</span> (rootDimension) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT:</span><br><span class="line">        <span class="comment">// Window can&#x27;t resize. Force root view to be windowSize.</span></span><br><span class="line">        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ViewGroup.LayoutParams.WRAP_CONTENT:</span><br><span class="line">        <span class="comment">// Window can resize. Set max size for root view.</span></span><br><span class="line">        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// Window wants to be an exact size. Force root view to be that size.</span></span><br><span class="line">        measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> measureSpec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常来说，DecorView根布局宽和高都是MATCH_PARENT，因此DecorView根布局的测量模式就是MeasureSpec.EXACTLY，测量大小一般都是整个屏幕大小，所以一般我们的Activity窗口都是全屏的。</p>
<h4 id="3-1-2、普通view的MeasureSpec"><a href="#3-1-2、普通view的MeasureSpec" class="headerlink" title="3.1.2、普通view的MeasureSpec"></a>3.1.2、普通view的MeasureSpec</h4><p>对于普通View，<code>其MeasureSpec由父容器的MeasureSpec和自身的LayoutParams来共同决定</code>，MeasureSpec一旦确定后，onMeasure中就可以确定View的测量宽/高。</p>
<p>对于普通View来说，View的measure过程由ViewGroup传递而来（所有的view根布局都是DecorView，而DecorView本身是个FrameLayout），先看一下ViewGroup的measureChildWithMargins方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line">		<span class="comment">// 1.根据父view 的Measure 和 子view 的LayoutParams 确定子view的 MeasureSpec</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">            mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</span><br><span class="line">                    + widthUsed, lp.width);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">            mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</span><br><span class="line">                    + heightUsed, lp.height);</span><br><span class="line">		<span class="comment">// 2.最终调用到子view 的 measure方法</span></span><br><span class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>getChildMeasureSpec</strong></p>
<p>根据父view 的Measure 和 子view 的LayoutParams 确定子view的 MeasureSpec。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(spec);</span><br><span class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(spec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size = Math.max(<span class="number">0</span>, specSize - padding);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> resultSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> resultMode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">    <span class="comment">// Parent has imposed an exact size on us</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to be our size. So be it.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to determine its own size. It can&#x27;t be</span></span><br><span class="line">            <span class="comment">// bigger than us.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parent has imposed a maximum size on us</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Child wants a specific size... so be it</span></span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to be our size, but our size is not fixed.</span></span><br><span class="line">            <span class="comment">// Constrain child to not be bigger than us.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to determine its own size. It can&#x27;t be</span></span><br><span class="line">            <span class="comment">// bigger than us.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parent asked to see how big we want to be</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Child wants a specific size... let them have it</span></span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to be our size... find out how big it should</span></span><br><span class="line">            <span class="comment">// be</span></span><br><span class="line">            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</span><br><span class="line">            resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to determine its own size.... find out how</span></span><br><span class="line">            <span class="comment">// big it should be</span></span><br><span class="line">            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</span><br><span class="line">            resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//noinspection ResourceType</span></span><br><span class="line">    <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结下：</p>
<p>&lt;img src=””/pics/image-20210626173859241.png” alt=”image-20210626173859241” style=”zoom:50%;” /&gt;</p>
<h3 id="3-2、measure流程"><a href="#3-2、measure流程" class="headerlink" title="3.2、measure流程"></a>3.2、measure流程</h3><img src="/pics/image-20210620224045177.png" alt="image-20210620224045177" style="zoom:50%;" />



<h4 id="3-2-1、View-的绘制流程"><a href="#3-2-1、View-的绘制流程" class="headerlink" title="3.2.1、View 的绘制流程"></a>3.2.1、View 的绘制流程</h4><p>View的measure过程由其measure方法来完成，measure方法是一个final类型的方法，这意味着子类不能重写此方法，在View的measure方法中会去调用View的onMeasure方法，因此只需要看onMeasure的实现即可，View的onMeasure方法如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>getDefaultSize</strong></p>
<p>可以看出，getDefaultSize这个方法的逻辑很简单，对于我们来说，我们只需要看AT_MOST和．EXACTLY这两种情况。简单地理解，其实getDefaultSize返回的大小就是measureSpec中的specSize，而这个specSize就是View测量后的大小，这里多次提到测量后的大小，是因为View最终的大小是在layout阶段确定的，所以这里必须要加以区分，但是几乎所有情况下View的测量大小和最终大小是相等的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = size;</span><br><span class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">        result = size;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">        result = specSize;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>getSuggestedMinimumWidth</strong></p>
<p>getSuggestedMinimumWidth和getSuggestedMinimumHeight的返回值就是View在UNSPECIFIED情况下的测量宽/高。</p>
<ul>
<li>如果View没有设置背景，那么返回android:minWidth这个属性所指定的值，这个值可以为0；</li>
<li>如果View设置了背景，则返回android:minWidth和背景的最小宽度这两者中的最大值；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>wrap_content需要定义默认宽高？</strong></p>
<p>从getDefaultSize方法的实现来看，View的宽/高由specSize决定，所以我们可以得出如下结论：<code>直接继承View的自定义控件需要重写onMeasure方法并设置wrap_content时的自身大小，否则在布局中使用wrap_content就相当于使用match_parent。</code>为什么呢？</p>
<p>如果View在布局中使用wrap_content，那么它的specMode是AT_MOST模式，在这种模式下，它的宽/高等于specSize；查表4-1可知，此时specSize就是parentSize，而parentSize是父容器中目前可以使用的大小，也就是父容器当前剩余的空间大小。</p>
<p>很显然，View的宽/高就等于父容器当前剩余的空间大小，这种效果和在布局中使用match_parent完全一致。如何解决这个问题呢？也很简单，代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> heightSpecSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">    <span class="keyword">if</span> (widthSpecMode == MeasureSpec.AT_MOST &amp;&amp; heightSpecMode ==</span><br><span class="line">    MeasureSpec.AT_MOST) &#123;</span><br><span class="line">        setMeasuredDimension(mWidth, mHeight);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (widthSpecMode == MeasureSpec.AT_MOST) &#123;</span><br><span class="line">        setMeasuredDimension(mWidth, heightSpecSize);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (heightSpecMode == MeasureSpec.AT_MOST) &#123;</span><br><span class="line">        setMeasuredDimension(widthSpecSize, mHeight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，<code>我们只需要给View指定一个默认的内部宽/高（mWidth和mHeight）</code>，并在wrap_content时设置此宽/高即可。</p>
<p>对于非wrap_content情形，我们沿用系统的测量值即可，至于这个默认的内部宽/高的大小如何指定，这个没有固定的依据，根据需要灵活指定即可。如果查看TextView、ImageView等的源码就可以知道，针对wrap_content情形，它们的onMeasure方法均做了特殊处理，读者可以自行查看它们的源码。</p>
<h4 id="3-2-2、ViewGroup的绘制流程"><a href="#3-2-2、ViewGroup的绘制流程" class="headerlink" title="3.2.2、ViewGroup的绘制流程"></a>3.2.2、ViewGroup的绘制流程</h4><p>对于ViewGroup来说，除了完成自己的measure过程以外，还会遍历去调用所有子元素的measure方法，各个子元素再递归去执行这个过程。和View不同的是，ViewGroup是一个抽象类，它没有重写View的onMeasure方法，由各个具体的ViewGroup比如 FrameLayout去实现，但是它提供了一个叫measureChildren的方法，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildren</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = mChildrenCount;</span><br><span class="line">    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = children[i];</span><br><span class="line">        <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;</span><br><span class="line">            measureChild(child, widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>measureChild</strong></p>
<p>measureChild的思想就是取出子元素的LayoutParams，然后再通过getChildMeasureSpec来创建子元素的MeasureSpec，接着将MeasureSpec直接传递给View的measure方法来进行测量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> parentHeightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> LayoutParams lp = child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">            mPaddingLeft + mPaddingRight, lp.width);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">            mPaddingTop + mPaddingBottom, lp.height);</span><br><span class="line"></span><br><span class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么ViewGroup不像View一样对其onMeasure方法做统一的实现呢？</strong></p>
<p>因为不同的ViewGroup子类有不同的布局特性，这导致它们的测量细节各不相同，比如LinearLayout和RelativeLayout这两者的布局特性显然不同，因此ViewGroup无法做统一实现</p>
<h4 id="3-2-3、view-宽高获取"><a href="#3-2-3、view-宽高获取" class="headerlink" title="3.2.3、view 宽高获取?"></a>3.2.3、view 宽高获取?</h4><p>Activity生命周期<code>onCreate和onStart()，onResume</code>方法中调用<code>View.getWidth()</code>和<code>View.getMeasuredHeight()</code>返回值为0 ?</p>
<p>&lt;img src=””/pics/image-20210626162038865.png” alt=”image-20210626162038865” style=”zoom:50%;” /&gt;</p>
<p>从上面的代码片段执行顺序来看，Activity的onStart和onResume被执行的时候，其实界面还没有开始进行绘制（wm.addView(decor, l)还没执行到），这里就可以解释为什么用Handler.post在onCreate里拿不到宽高。因为Handler机制，Activity生命周期onCreate 和 onResume的都是通过主线程handler 的回调。而view 的绘制流程也是通过向主线程发送消息的方式执行的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 也就是说启动时，主线程队列中的消息执行顺序 为 onCreate -&gt; handleResumeActivity（onResume） -&gt; </p>
<p>doTraversal 。自然而然，view都没有绘制完的情况下是不可能获取到宽高的。</p>
<p><strong>解决方案：</strong></p>
<ol>
<li><p>view.post </p>
<p>本质上也是基于handler的消息机制，比如我们在onCreate 中执行 post</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 位置1</span></span><br><span class="line">    Log.i(<span class="string">&quot;view_w_&amp;_h&quot;</span>, <span class="string">&quot;onCreate &quot;</span> + mView.getWidth() + <span class="string">&quot; &quot;</span> + mView.getHeight());</span><br><span class="line">    mView.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 位置2</span></span><br><span class="line">            Log.i(<span class="string">&quot;view_w_&amp;_h&quot;</span>, <span class="string">&quot;onCreate postRun &quot;</span> + mView.getWidth() + <span class="string">&quot; &quot;</span> + mView.getHeight());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>最终这个runnable 任务会在 <code>performTraversals</code> 完成后被调用，<a href="https://mp.weixin.qq.com/s/71OV_K7YJas7pLtsPY-jeQ">详见</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void performTraversals() &#123;</span><br><span class="line">    ...</span><br><span class="line">    // 这里再次添加到消息中</span><br><span class="line">    host.dispatchAttachedToWindow(mAttachInfo, 0);</span><br><span class="line">    ...</span><br><span class="line">    performMeasure();</span><br><span class="line">    ...</span><br><span class="line">    performLayout();</span><br><span class="line">    ...</span><br><span class="line">    performDraw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>ViewTreeObserver</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">view.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() &#123;  </span><br><span class="line">        @Override  </span><br><span class="line">        public void onGlobalLayout() &#123;  </span><br><span class="line">            mScrollView.post(new Runnable() &#123;  </span><br><span class="line">                public void run() &#123;  </span><br><span class="line">                    view.getHeight(); </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;);  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure></li>
<li><p>重写Activity的onWindowFocusChanged()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onWindowFocusChanged</span><span class="params">(<span class="keyword">boolean</span> hasFocus)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">super</span>.onWindowFocusChanged(hasFocus);  </span><br><span class="line">		<span class="keyword">if</span> (hasFocus) &#123;</span><br><span class="line">				getHeight();</span><br><span class="line">		&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-3、Layout流程"><a href="#3-3、Layout流程" class="headerlink" title="3.3、Layout流程"></a>3.3、Layout流程</h3><img src="/pics/image-20210620224422346.png" alt="image-20210620224422346" style="zoom:50%;" />



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//判断是否需要重新测量</span></span><br><span class="line">     <span class="keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class="number">0</span>) &#123;</span><br><span class="line">         onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</span><br><span class="line">         mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//保存上一次View的四个位置</span></span><br><span class="line">     <span class="keyword">int</span> oldL = mLeft;</span><br><span class="line">     <span class="keyword">int</span> oldT = mTop;</span><br><span class="line">     <span class="keyword">int</span> oldB = mBottom;</span><br><span class="line">     <span class="keyword">int</span> oldR = mRight;</span><br><span class="line">     <span class="comment">//设置当前视图View的左，顶，右，底的位置，并且判断布局是否有改变</span></span><br><span class="line">     <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</span><br><span class="line">             setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line">     <span class="comment">//如果布局有改变，条件成立，则视图View重新布局</span></span><br><span class="line">         <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class="line">         <span class="comment">//调用onLayout，将具体布局逻辑留给子类实现</span></span><br><span class="line">         onLayout(changed, l, t, r, b);</span><br><span class="line">         mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</span><br><span class="line"></span><br><span class="line">         ListenerInfo li = mListenerInfo;</span><br><span class="line">         <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">             ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</span><br><span class="line">                     (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</span><br><span class="line">             <span class="keyword">int</span> numListeners = listenersCopy.size();</span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</span><br><span class="line">                 listenersCopy.get(i).onLayoutChange(<span class="keyword">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</span><br><span class="line">     mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>3.3.1、<strong>setFrame</strong></p>
<p>layout 中调用<code>setFrame</code>确定当前View的布局位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">setFrame</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//当上，下，左，右四个位置有一个和上次的值不一样都会重新布局</span></span><br><span class="line">        <span class="keyword">if</span> (mLeft != left || mRight != right || mTop != top || mBottom != bottom) &#123;</span><br><span class="line">            changed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// Remember our drawn bit</span></span><br><span class="line">        <span class="keyword">int</span> drawn = mPrivateFlags &amp; PFLAG_DRAWN;</span><br><span class="line">        <span class="comment">//得到本次和上次的宽和高</span></span><br><span class="line">        <span class="keyword">int</span> oldWidth = mRight - mLeft;</span><br><span class="line">        <span class="keyword">int</span> oldHeight = mBottom - mTop;</span><br><span class="line">        <span class="keyword">int</span> newWidth = right - left;</span><br><span class="line">        <span class="keyword">int</span> newHeight = bottom - top;</span><br><span class="line">        <span class="comment">//判断本次View的宽高和上次View的宽高是否相等</span></span><br><span class="line">        <span class="keyword">boolean</span> sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Invalidate our old position</span></span><br><span class="line">        <span class="comment">//清楚上次布局的位置</span></span><br><span class="line">        invalidate(sizeChanged);</span><br><span class="line">        <span class="comment">//保存当前View的最新位置</span></span><br><span class="line">        mLeft = left;</span><br><span class="line">        mTop = top;</span><br><span class="line">        mRight = right;</span><br><span class="line">        mBottom = bottom;</span><br><span class="line">        mRenderNode.setLeftTopRightBottom(mLeft, mTop, mRight, mBottom);</span><br><span class="line"></span><br><span class="line">        mPrivateFlags |= PFLAG_HAS_BOUNDS;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果当前View的尺寸有所变化</span></span><br><span class="line">        <span class="keyword">if</span> (sizeChanged) &#123;</span><br><span class="line">            sizeChange(newWidth, newHeight, oldWidth, oldHeight);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...............</span><br><span class="line">    <span class="keyword">return</span> changed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-2、onLayout"><a href="#3-3-2、onLayout" class="headerlink" title="3.3.2、onLayout"></a>3.3.2、onLayout</h4><p>对于View来说，经过setFrame，view的位置就已经确定了，onLayout是一个空方法。</p>
<p>对于ViewGroup来说，位置通过setFrame已经实现，onLayout是个抽象的方法，所有继承自ViewGroup的对象都必须实现，确定子view的位置。以FrameLayout 为例，真正的实现在中<code>layoutChildren</code>。</p>
<p>不像View视图的measure测量，通过子类实现onMeasure方法来实现测量逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">    layoutChildren(left, top, right, bottom, <span class="keyword">false</span> <span class="comment">/* no force left gravity */</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutChildren</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom, <span class="keyword">boolean</span> forceLeftGravity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = getChildCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> parentLeft = getPaddingLeftWithForeground();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> parentRight = right - left - getPaddingRightWithForeground();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> parentTop = getPaddingTopWithForeground();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> parentBottom = bottom - top - getPaddingBottomWithForeground();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = getChildAt(i);</span><br><span class="line">        <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">            <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> width = child.getMeasuredWidth();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> height = child.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> childLeft;</span><br><span class="line">            <span class="keyword">int</span> childTop;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> gravity = lp.gravity;</span><br><span class="line">            <span class="keyword">if</span> (gravity == -<span class="number">1</span>) &#123;</span><br><span class="line">                gravity = DEFAULT_CHILD_GRAVITY;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = getLayoutDirection();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> verticalGravity = gravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</span><br><span class="line">                <span class="keyword">case</span> Gravity.CENTER_HORIZONTAL:</span><br><span class="line">                    childLeft = parentLeft + (parentRight - parentLeft - width) / <span class="number">2</span> +</span><br><span class="line">                    lp.leftMargin - lp.rightMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Gravity.RIGHT:</span><br><span class="line">                    <span class="keyword">if</span> (!forceLeftGravity) &#123;</span><br><span class="line">                        childLeft = parentRight - width - lp.rightMargin;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">case</span> Gravity.LEFT:</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    childLeft = parentLeft + lp.leftMargin;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (verticalGravity) &#123;</span><br><span class="line">                <span class="keyword">case</span> Gravity.TOP:</span><br><span class="line">                    childTop = parentTop + lp.topMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Gravity.CENTER_VERTICAL:</span><br><span class="line">                    childTop = parentTop + (parentBottom - parentTop - height) / <span class="number">2</span> +</span><br><span class="line">                    lp.topMargin - lp.bottomMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Gravity.BOTTOM:</span><br><span class="line">                    childTop = parentBottom - height - lp.bottomMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    childTop = parentTop + lp.topMargin;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            child.layout(childLeft, childTop, childLeft + width, childTop + height);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4、draw流程"><a href="#3-4、draw流程" class="headerlink" title="3.4、draw流程"></a>3.4、draw流程</h3><p>View视图绘制流程中的最后一步绘制draw是由ViewRootImpl中的performDraw成员方法开始的，跟踪代码，最后会在<code>ViewRootImpl.drawSoftware</code>方法绘制View：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">drawSoftware</span><span class="params">(Surface surface, AttachInfo attachInfo, <span class="keyword">int</span> xoff, <span class="keyword">int</span> yoff,</span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="keyword">boolean</span> scalingRequired, Rect dirty)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Draw with software renderer.</span></span><br><span class="line">      <span class="keyword">final</span> Canvas canvas;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//从surface对象中获得canvas变量</span></span><br><span class="line">          canvas = mSurface.lockCanvas(dirty);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// If this bitmap&#x27;s format includes an alpha channel, we</span></span><br><span class="line">          <span class="comment">// need to clear it before drawing so that the child will</span></span><br><span class="line">          <span class="comment">// properly re-composite its drawing on a transparent</span></span><br><span class="line">          <span class="comment">// background. This automatically respects the clip/dirty region</span></span><br><span class="line">          <span class="comment">// or</span></span><br><span class="line">          <span class="comment">// If we are applying an offset, we need to clear the area</span></span><br><span class="line">          <span class="comment">// where the offset doesn&#x27;t appear to avoid having garbage</span></span><br><span class="line">          <span class="comment">// left in the blank areas.</span></span><br><span class="line">          <span class="keyword">if</span> (!canvas.isOpaque() || yoff != <span class="number">0</span> || xoff != <span class="number">0</span>) &#123;</span><br><span class="line">              canvas.drawColor(<span class="number">0</span>, PorterDuff.Mode.CLEAR);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">         ......................</span><br><span class="line"></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">//调整画布的位置</span></span><br><span class="line">              canvas.translate(-xoff, -yoff);</span><br><span class="line">              <span class="keyword">if</span> (mTranslator != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  mTranslator.translateCanvas(canvas);</span><br><span class="line">              &#125;</span><br><span class="line">              canvas.setScreenDensity(scalingRequired ? mNoncompatDensity : <span class="number">0</span>);</span><br><span class="line">              attachInfo.mSetIgnoreDirtyState = <span class="keyword">false</span>;</span><br><span class="line">              <span class="comment">//调用View类中的成员方法draw开始绘制View视图</span></span><br><span class="line">              mView.draw(canvas);</span><br><span class="line">          &#125; </span><br><span class="line"></span><br><span class="line">      .....................</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可知，我们的视图View最终是绘制到Surface中去的，关于Surface相关的知识，可以参考这篇大神的博客：</p>
<p><a href="http://blog.csdn.net/luoshengyang/article/details/8303098">Android应用程序窗口（Activity）的绘图表面（Surface）的创建过程分析</a></p>
<p>跟踪代码，进入View的draw方法分析源码：</p>
<h4 id="3-4-1、Draw"><a href="#3-4-1、Draw" class="headerlink" title="3.4.1、Draw"></a>3.4.1、Draw</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void draw(Canvas canvas) &#123;</span><br><span class="line">      final int privateFlags = mPrivateFlags;</span><br><span class="line">      final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) ==</span><br><span class="line">      PFLAG_DIRTY_OPAQUE &amp;&amp;</span><br><span class="line">              (mAttachInfo == null || ! mAttachInfo.mIgnoreDirtyState);</span><br><span class="line">      mPrivateFlags = (privateFlags &amp; ～PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">      /＊</span><br><span class="line">      ＊ Draw traversal performs several drawing steps which must be executed</span><br><span class="line">      ＊ in the appropriate order:</span><br><span class="line">      ＊ in the appropriate order:</span><br><span class="line">    ＊</span><br><span class="line">    ＊       1. Draw the background</span><br><span class="line">    ＊       2. If necessary, save the canvas&#x27; layers to prepare for fading</span><br><span class="line">    ＊       3. Draw view&#x27;s content</span><br><span class="line">    ＊       4. Draw children</span><br><span class="line">    ＊       5. If necessary, draw the fading edges and restore layers</span><br><span class="line">    ＊       6. Draw decorations (scrollbars for instance)</span><br><span class="line">    ＊/</span><br><span class="line"></span><br><span class="line">   // Step 1, draw the background, if needed</span><br><span class="line">   int saveCount;</span><br><span class="line"></span><br><span class="line">   if (! dirtyOpaque) &#123;</span><br><span class="line">        drawBackground(canvas);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // skip step 2 &amp; 5 if possible (common case)</span><br><span class="line">   final int viewFlags = mViewFlags;</span><br><span class="line">   boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) ! = 0;</span><br><span class="line">   boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) ! = 0;</span><br><span class="line">   if (! verticalEdges &amp;&amp; ! horizontalEdges) &#123;</span><br><span class="line">        // Step 3, draw the content</span><br><span class="line">        if (! dirtyOpaque) onDraw(canvas);</span><br><span class="line"></span><br><span class="line">        // Step 4, draw the children</span><br><span class="line">        dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">        // Step 6, draw decorations (scrollbars)</span><br><span class="line">        onDrawScrollBars(canvas);</span><br><span class="line"></span><br><span class="line">        if (mOverlay ! = null &amp;&amp; ! mOverlay.isEmpty()) &#123;</span><br><span class="line">            mOverlay.getOverlayView().dispatchDraw(canvas);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // we&#x27;re done...</span><br><span class="line">        return;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下：</p>
<ol>
<li>绘制当前视图的背景。</li>
<li>保存canvas的图层，为fading做准备</li>
<li>绘制View的内容</li>
<li>绘制View的子View</li>
<li>绘制当前视图在滑动时的边框渐变效果。</li>
<li>绘制View的装饰(例如滚动条等等)</li>
</ol>
<img src="/pics/image-20210620231436212.png" alt="image-20210620231436212" style="zoom:50%;" />



<h4 id="3-4-2、View-的树形结构绘制流程"><a href="#3-4-2、View-的树形结构绘制流程" class="headerlink" title="3.4.2、View 的树形结构绘制流程"></a>3.4.2、View 的树形结构绘制流程</h4><p>View绘制过程的传递是通过dispatchDraw来实现的，dispatchDraw会遍历调用所有子元素的draw方法，如此draw事件就一层层地传递了下去。View有一个特殊的方法setWillNotDraw，先看一下它的源码，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/＊＊</span><br><span class="line"> ＊ If <span class="keyword">this</span> view doesn<span class="string">&#x27;t do any drawing on its own, set this flag to</span></span><br><span class="line"><span class="string"> ＊ allow further optimizations. By default, this flag is not set on</span></span><br><span class="line"><span class="string"> ＊ View, but could be set on some View subclasses such as ViewGroup.</span></span><br><span class="line"><span class="string"> ＊</span></span><br><span class="line"><span class="string"> ＊ Typically, if you override &#123;@link #onDraw(android.graphics.Canvas)&#125;</span></span><br><span class="line"><span class="string"> ＊ you should clear this flag.</span></span><br><span class="line"><span class="string"> ＊</span></span><br><span class="line"><span class="string"> ＊ @param willNotDraw whether or not this View draw on its own</span></span><br><span class="line"><span class="string"> ＊/</span></span><br><span class="line"><span class="string">public void setWillNotDraw(boolean willNotDraw) &#123;</span></span><br><span class="line"><span class="string">    setFlags(willNotDraw ? WILL_NOT_DRAW : 0, DRAW_MASK);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>从setWillNotDraw这个方法的注释中可以看出，如果一个View不需要绘制任何内容，那么设置这个标记位为true以后，系统会进行相应的优化。默认情况下，View没有启用这个优化标记位，但是ViewGroup会默认启用这个优化标记位。</p>
<p>这个标记位对实际开发的意义是：<code>当我们的自定义控件继承于ViewGroup并且本身不具备绘制功能时，就可以开启这个标记位从而便于系统进行后续的优化。</code>当然，当明确知道一个ViewGroup需要通过onDraw来绘制内容时，我们需要显式地关闭WILL_NOT_DRAW这个标记位。</p>
<img src="/pics/image-20210620232417701.png" alt="image-20210620232417701" style="zoom:50%;" />

<h2 id="四、Question"><a href="#四、Question" class="headerlink" title="四、Question"></a>四、Question</h2><p><a href="https://juejin.cn/post/6844904131136618510">https://juejin.cn/post/6844904131136618510</a></p>
<p><a href="https://blog.csdn.net/ITRenj/article/details/53819583">invalidate()和requestLayout()方法调用过程</a></p>
<p><a href="https://www.cnblogs.com/baiqiantao/p/2a3fccd829120089d24547929175ae29.html">invalidate和requestLayout方法源码分析</a></p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title>FrameWork_06_View事件分发</title>
    <url>/2021/06/26/Notes/Android/Framework/FrameWork_06_View%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/</url>
    <content><![CDATA[<h1 id="FrameWork-06-View事件分发"><a href="#FrameWork-06-View事件分发" class="headerlink" title="FrameWork_06_View事件分发"></a>FrameWork_06_View事件分发</h1><h2 id="一、MoveEvent"><a href="#一、MoveEvent" class="headerlink" title="一、MoveEvent"></a>一、MoveEvent</h2><p>在手指接触屏幕后所产生的一系列事件中，典型的事件类型有如下几种：</p>
<ul>
<li>ACTION_DOWN——手指刚接触屏幕；</li>
<li>ACTION_MOVE——手指在屏幕上移动；</li>
<li>ACTION_UP——手机从屏幕上松开的一瞬间。</li>
</ul>
<p>正常情况下，一次手指触摸屏幕的行为会触发一系列点击事件，典型的事件序列有以下2种：</p>
<ul>
<li>点击屏幕后离开松开，事件序列为DOWN -&gt; UP；</li>
<li>点击屏幕滑动一会再松开，事件序列为DOWN -&gt; MOVE -&gt; … &gt; MOVE -&gt; UP。</li>
</ul>
<h2 id="二、点击事件的传递规则"><a href="#二、点击事件的传递规则" class="headerlink" title="二、点击事件的传递规则"></a>二、点击事件的传递规则</h2><p>点击事件的事件分发，其实就是对MotionEvent事件的分发过程，即当一个MotionEvent产生了以后，系统需要把这个事件传递给一个具体的View，而这个传递的过程就是分发过程。点击事件的分发过程由三个很重要的方法来共同完成：dispatchTouchEvent、onInterceptTouchEvent和onTouchEvent，下面我们先介绍一下这几个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span></span></span><br></pre></td></tr></table></figure>

<p>用来进行事件的分发。如果事件能够传递给当前View，那么此方法一定会被调用，返回结果受当前View的onTouchEvent和下级View的dispatchTouchEvent方法的影响，表示是否消耗当前事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span></span></span><br></pre></td></tr></table></figure>

<p>在上述方法内部调用，用来判断是否拦截某个事件，如果当前View拦截了某个事件，那么在同一个事件序列当中，此方法不会被再次调用，返回结果表示是否拦截当前事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span></span></span><br></pre></td></tr></table></figure>

<p>在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一个事件序列中，当前View无法再次接收到事件。<br>上述三个方法到底有什么区别呢？它们是什么关系呢？其实它们的关系可以用如下伪代码表示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> consume = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (onInterceptTouchEvent(ev)) &#123;</span><br><span class="line">        consume = onTouchEvent(ev);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        consume = child.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> consume;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于一个根ViewGroup来说，点击事件产生后，首先会传递给它，这时它的dispatchTouchEvent就会被调用，</p>
<ul>
<li>如果这个ViewGroup的onInterceptTouchEvent方法返回true就表示它要拦截当前事件，接着事件就会交给这个ViewGroup处理，即它的onTouchEvent方法就会被调用；</li>
<li>如果这个ViewGroup的onInterceptTouchEvent方法返回false就表示它不拦截当前事件，这时当前事件就会继续传递给它的子元素，接着子元素的dispatchTouchEvent方法就会被调用，如此反复直到事件被最终处理。</li>
</ul>
<h2 id="三、activity中事件的分发过程"><a href="#三、activity中事件的分发过程" class="headerlink" title="三、activity中事件的分发过程"></a>三、activity中事件的分发过程</h2><p>当一个点击事件产生后，它的传递过程遵循如下顺序：Activity -&gt; Window -&gt; View，即事件总是先传递给Activity, Activity再传递给Window，最后Window再传递给顶级View。顶级View接收到事件后，就会按照事件分发机制去分发事件。</p>
<img src="/pics/image-20210626214517837.png" alt="image-20210626214517837" style="zoom:40%;" />



<h3 id="3-1、Activity-dispatchTouchEvent"><a href="#3-1、Activity-dispatchTouchEvent" class="headerlink" title="3.1、Activity#dispatchTouchEvent"></a>3.1、Activity#dispatchTouchEvent</h3><p>首先事件开始交给Activity所附属的Window进行分发，如果返回true，整个事件循环就结束了，返回false意味着事件没人处理，所有View的onTouchEvent都返回了false，那么Activity的onTouchEvent就会被调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        onUserInteraction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> onTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2、PhoneWindow-superDispatchTouchEvent"><a href="#3-2、PhoneWindow-superDispatchTouchEvent" class="headerlink" title="3.2、PhoneWindow#superDispatchTouchEvent"></a>3.2、PhoneWindow#superDispatchTouchEvent</h3><p>PhoneWindow将事件直接传递给了DecorView</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3、DecorView-superDispatchTouchEvent"><a href="#3-3、DecorView-superDispatchTouchEvent" class="headerlink" title="3.3、DecorView#superDispatchTouchEvent"></a>3.3、DecorView#superDispatchTouchEvent</h3><p>DecorView继承自FrameLayout，事件会传递给ViewGroup</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean superDispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">    return super.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4、ViewGroup-dispatchTouchEvent"><a href="#3-4、ViewGroup-dispatchTouchEvent" class="headerlink" title="3.4、ViewGroup#dispatchTouchEvent"></a>3.4、ViewGroup#dispatchTouchEvent</h3><p>ViewGroup 的事件分发逻辑较长，可以分为三部分讲解。</p>
<h2 id="四、事件分发"><a href="#四、事件分发" class="headerlink" title="四、事件分发"></a>四、事件分发</h2><h3 id="4-1、判断是否要拦截事件"><a href="#4-1、判断是否要拦截事件" class="headerlink" title="4.1、判断是否要拦截事件"></a>4.1、判断是否要拦截事件</h3><p>ViewGroup在如下两种情况下会判断是否要拦截当前事件：</p>
<ul>
<li><p>事件类型为ACTION_DOWN</p>
</li>
<li><p>mFirstTouchTarget ! = null，当ViewGroup不拦截事件并将事件交由子元素处理时。</p>
<p>如果事件由当前ViewGroup拦截时<code>（mFirstTouchTarget == null 成立）</code>。那么当ACTION_MOVE和ACTION_UP事件到来时，由于<code>(actionMasked == MotionEvent. ACTION_DOWN || mFirstTouchTarget ! = null) 不成立</code>，将导致ViewGroup的onInterceptTouchEvent不会再被调用，同一序列中的其他事件都会由ViewGroup处理。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Check for interception.</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">        || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">        intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">        ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        intercepted = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// There are no touch targets and this action is not an initial down</span></span><br><span class="line">    <span class="comment">// so this view group continues to intercept touches.</span></span><br><span class="line">    intercepted = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>FLAG_DISALLOW_INTERCEPT</strong></p>
<p>一般用于子View中，FLAG_DISALLOW_INTERCEPT一旦设置后，<strong>ViewGroup将无法拦截除了ACTION_DOWN以外的其他点击事件</strong>。为什么说是除了ACTION_DOWN以外的其他事件呢？这是因为ViewGroup在分发事件时，如果是ACTION_DOWN就会重置FLAG_DISALLOW_INTERCEPT这个标记位，将导致子View中设置的这个标记位无效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">    <span class="comment">// Throw away all previous state when starting a new touch gesture.</span></span><br><span class="line">    <span class="comment">// The framework may have dropped the up or cancel event for the previous gesture</span></span><br><span class="line">    <span class="comment">// due to an app switch, ANR, or some other state change.</span></span><br><span class="line">    cancelAndClearTouchTargets(ev);</span><br><span class="line">    resetTouchState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结下：</p>
<img src="/pics/image-20210627235048935.png" alt="image-20210627235048935" style="zoom:50%;" />

<p>我们可以得出结论：</p>
<blockquote>
<ol>
<li><p><strong>当ViewGroup决定拦截事件后，那么后续的点击事件将会默认交给它处理并且不再调用它的<code>onInterceptTouchEvent</code>方法。</strong></p>
</li>
<li><p>当面对ACTION_DOWN事件时，ViewGroup总是会调用自己的onInterceptTouchEvent方法来询问自己是否要拦截事件，FLAG_DISALLOW_INTERCEPT影响不到<strong>ACTION_DOWN</strong></p>
</li>
</ol>
</blockquote>
<h3 id="4-2、事件分发给子view"><a href="#4-2、事件分发给子view" class="headerlink" title="4.2、事件分发给子view"></a>4.2、事件分发给子view</h3><p>遍历ViewGroup的所有子元素，然后判断子元素是否能够接收到点击事件，</p>
<ul>
<li>如果子元素的dispatchTouchEvent返回false, ViewGroup就会把事件分发给下一个子元素（如果还有下一个子元素的话）</li>
<li>如果遍历所有的子元素后事件都没有被合适地处理，ViewGroup会自己处理点击事件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> canceled = resetCancelNextUpFlag(<span class="keyword">this</span>)</span><br><span class="line">        || actionMasked == MotionEvent.ACTION_CANCEL;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">boolean</span> alreadyDispatchedToNewTouchTarget = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">				<span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">        <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> x =</span><br><span class="line">                    isMouseEvent ? ev.getXCursorPosition() : ev.getX(actionIndex);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> y =</span><br><span class="line">                    isMouseEvent ? ev.getYCursorPosition() : ev.getY(actionIndex);</span><br><span class="line">            <span class="comment">// Find a child that can receive the event.</span></span><br><span class="line">            <span class="comment">// Scan children from front to back.</span></span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> customOrder = preorderedList == <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; isChildrenDrawingOrderEnabled();</span><br><span class="line">            <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(</span><br><span class="line">                        childrenCount, i, customOrder);</span><br><span class="line">                <span class="keyword">final</span> View child = getAndVerifyPreorderedView(</span><br><span class="line">                        preorderedList, children, childIndex);</span><br><span class="line">              	<span class="comment">// 1.判断子view 是否在播动画 或 点击事件的坐标是否落在子元素的区域内。</span></span><br><span class="line">                <span class="keyword">if</span> (!child.canReceivePointerEvents()</span><br><span class="line">                        || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                newTouchTarget = getTouchTarget(child);</span><br><span class="line">                <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Child is already receiving touch within its bounds.</span></span><br><span class="line">                    <span class="comment">// Give it the new pointer in addition to the ones it is handling.</span></span><br><span class="line">                    newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                resetCancelNextUpFlag(child);</span><br><span class="line">                <span class="comment">// 2.子view 处理事件</span></span><br><span class="line">                <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">                    <span class="comment">// Child wants to receive touch within its bounds.</span></span><br><span class="line">                    mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">                    <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// childIndex points into presorted list, find original index</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                                mLastTouchDownIndex = j;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mLastTouchDownIndex = childIndex;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mLastTouchDownX = ev.getX();</span><br><span class="line">                    mLastTouchDownY = ev.getY();</span><br><span class="line">                    <span class="comment">// 3.拦截后的处理</span></span><br><span class="line">                    newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                    alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-1、dispatchTransformedTouchEvent"><a href="#4-2-1、dispatchTransformedTouchEvent" class="headerlink" title="4.2.1、dispatchTransformedTouchEvent"></a>4.2.1、dispatchTransformedTouchEvent</h4><p>dispatchTransformedTouchEvent实际上调用的就是子元素的dispatchTouchEvent方法，上面的代码中child传递的不是null，因此它会直接调用子元素的dispatchTouchEvent方法，这样事件就交由子元素处理了，从而完成了一轮事件分发。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,</span></span></span><br><span class="line"><span class="params"><span class="function">        View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> handled;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldAction = event.getAction();</span><br><span class="line">    <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">        event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">            handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          	<span class="comment">// 传递给子view处理</span></span><br><span class="line">            handled = child.dispatchTouchEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        event.setAction(oldAction);</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果子元素的dispatchTouchEvent返回true，那么<code>mFirstTouchTarget</code>就会被赋值同时跳出for循环，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">alreadyDispatchedToNewTouchTarget = true;</span><br><span class="line">break;</span><br></pre></td></tr></table></figure>

<p>这几行代码完成了mFirstTouchTarget的赋值并终止对子元素的遍历。</p>
<h4 id="4-2-2、addTouchTarget"><a href="#4-2-2、addTouchTarget" class="headerlink" title="4.2.2、addTouchTarget"></a>4.2.2、addTouchTarget</h4><p>mFirstTouchTarget真正的赋值过程是在addTouchTarget内部完成的，mFirstTouchTarget是否被赋值，将直接影响到ViewGroup对事件的拦截策略，如果mFirstTouchTarget为null，那么ViewGroup就默认拦截接下来同一序列中所有的点击事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> TouchTarget <span class="title">addTouchTarget</span><span class="params">(View child, <span class="keyword">int</span> pointerIdBits)</span> </span>&#123;</span><br><span class="line">    TouchTarget target = TouchTarget.obtain(child, pointerIdBits);</span><br><span class="line">    target.next = mFirstTouchTarget;</span><br><span class="line">    mFirstTouchTarget = target;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果遍历所有的子元素后事件都没有被合适地处理，这包含两种情况：</p>
<ul>
<li>第一种是ViewGroup没有子元素；</li>
<li>第二种是子元素处理了点击事件，但是在dispatchTouchEvent中返回了false，这一般是因为子元素在onTouchEvent中返回了false。</li>
</ul>
<p>在这两种情况下，ViewGroup会自己处理点击事件。</p>
<h3 id="4-3、事件处理"><a href="#4-3、事件处理" class="headerlink" title="4.3、事件处理"></a>4.3、事件处理</h3><p>当mFirstTouchTarget == null，viewGroup会自己处理点击事件，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Dispatch to touch targets.</span></span><br><span class="line"><span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">  	<span class="comment">// viewGroup的分发</span></span><br><span class="line">    handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">            TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    TouchTarget predecessor = <span class="keyword">null</span>;</span><br><span class="line">    TouchTarget target = mFirstTouchTarget;</span><br><span class="line">    <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123; <span class="comment">// 多指的处理</span></span><br><span class="line">    		<span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会调用dispatchTransformedTouchEvent，此时child 参数为null，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">		handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		handled = child.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从前面的分析可以知道，很显然，这里就转到了View的dispatchTouchEvent方法，即点击事件开始交由View来处理，请看下面的分析。</p>
<h2 id="五、事件处理"><a href="#五、事件处理" class="headerlink" title="五、事件处理"></a>五、事件处理</h2><p>View的事件的处理是<code>dispatchTouchEvent</code>中，由于ViewGroup的重写的<code>dispatchTouchEvent</code>中主要负责的是事件分发，事件的处理也是调用了super.dispatchTouchEvent,    也就是说，调用的也是view的dispatchTouchEvent。</p>
<p>下面来分析下view的<code>dispatchTouchEvent</code>中事件的处理。</p>
<h3 id="5-1、View-dispatchTouchEvent"><a href="#5-1、View-dispatchTouchEvent" class="headerlink" title="5.1、View#dispatchTouchEvent"></a>5.1、View#dispatchTouchEvent</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//... 	</span></span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1. mOnTouchListener 处理</span></span><br><span class="line">        ListenerInfo li = mListenerInfo;</span><br><span class="line">        <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">                &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">// 2. onTouchEvent 处理</span></span><br><span class="line">        <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的源码可以看出View对点击事件的处理过程，可见OnTouchListener的优先级高于onTouchEvent。</p>
<h3 id="5-2、OnTouchListener-onTouch"><a href="#5-2、OnTouchListener-onTouch" class="headerlink" title="5.2、OnTouchListener.onTouch"></a>5.2、OnTouchListener.onTouch</h3><p>如果OnTouchListener中的onTouch方法返回true，那么onTouchEvent就不会被调用，可见OnTouchListener的优先级高于onTouchEvent。</p>
<h3 id="5-3、View-onTouchEvent"><a href="#5-3、View-onTouchEvent" class="headerlink" title="5.3、View#onTouchEvent"></a>5.3、View#onTouchEvent</h3><p>接着再分析onTouchEvent的实现。先看当View处于不可用状态下点击事件的处理过程，如下所示。很显然，不可用状态下的View照样会消耗点击事件，尽管它看起来不可用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE</span><br><span class="line">            || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</span><br><span class="line">            || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</span><br><span class="line">            setPressed(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class="line">        <span class="comment">// A disabled view that is clickable still consumes the touch</span></span><br><span class="line">        <span class="comment">// events, it just doesn&#x27;t respond to them.</span></span><br><span class="line">        <span class="keyword">return</span> clickable;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2、如果View设置有代理，那么还会执行TouchDelegate的onTouchEvent方法，这个onTouchEvent的工作机制看起来和OnTouchListener类似，这里不深入研究了。</span></span><br><span class="line">    <span class="keyword">if</span> (mTouchDelegate != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mTouchDelegate.onTouchEvent(event)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>View的enable属性不影响onTouchEvent的默认返回值。哪怕一个View是disable状态的，只要它的clickable或者longClickable有一个为true，那么它的onTouchEvent就返回true。</p>
</blockquote>
<h3 id="5-4、Click事件的处理"><a href="#5-4、Click事件的处理" class="headerlink" title="5.4、Click事件的处理"></a>5.4、Click事件的处理</h3><p>下面再看一下<code>onTouchEvent</code>中对点击事件的具体处理，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</span><br><span class="line">            (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                <span class="keyword">boolean</span> prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) ! = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) ! = <span class="number">0</span> || prepressed) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                    <span class="keyword">if</span> (! mHasPerformedLongPress) &#123;</span><br><span class="line">                        <span class="comment">// This is a tap, so remove the longpress check</span></span><br><span class="line">                        removeLongPressCallback();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//  Only  perform  take  click  actions  if  we  were  in  the</span></span><br><span class="line"><span class="function">pressed state</span></span><br><span class="line"><span class="function">                        <span class="title">if</span> <span class="params">(! focusTaken)</span> </span>&#123;</span><br><span class="line">                            <span class="comment">// Use a Runnable and post this rather than calling</span></span><br><span class="line">                            <span class="comment">// performClick directly. This lets other visual</span></span><br><span class="line">                                state</span><br><span class="line">                            <span class="comment">// of the view update before click actions start.</span></span><br><span class="line">                            <span class="keyword">if</span> (mPerformClick == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                mPerformClick = <span class="keyword">new</span> PerformClick();</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (! post(mPerformClick)) &#123;</span><br><span class="line">                                performClick();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码来看，只要View的CLICKABLE和LONG_CLICKABLE有一个为true，那么它就会消耗这个事件，即onTouchEvent方法返回true，不管它是不是DISABLE状态。</p>
<blockquote>
<p>View的onTouchEvent默认都会消耗事件（返回true），除非它是不可点击的（clickable和longClickable同时为false）。View的longClickable属性默认都为false, clickable属性要分情况，比如Button的clickable属性默认为true，而TextView的clickable属性默认为false。</p>
</blockquote>
<h4 id="performClick"><a href="#performClick" class="headerlink" title="performClick"></a>performClick</h4><p>当ACTION_UP事件发生时，会触发performClick方法，如果View设置了OnClickListener，那么performClick方法内部会调用它的onClick方法，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> result;</span><br><span class="line">    <span class="keyword">final</span> ListenerInfo li = mListenerInfo;</span><br><span class="line">    <span class="keyword">if</span> (li ! = <span class="keyword">null</span> &amp;&amp; li.mOnClickListener ! = <span class="keyword">null</span>) &#123;</span><br><span class="line">        playSoundEffect(SoundEffectConstants.CLICK);</span><br><span class="line">        li.mOnClickListener.onClick(<span class="keyword">this</span>);</span><br><span class="line">        result = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>onClick会发生的前提是当前View是可点击的，并且它收到了down和up的事件。</p>
</blockquote>
<p>总结下：</p>
<p>当一个View需要处理事件时，如果它设置了OnTouchListener，那么OnTouchListener中的<code>onTouch</code>方法会被回调。</p>
<ul>
<li><p>如果onTouch返回true，那么onTouchEvent方法将不会被调用。</p>
</li>
<li><p>如果onTouch返回false，则当前View的onTouchEvent方法会被调用，由此可见，给View设置的OnTouchListener，其优先级比onTouchEvent要高。</p>
<p>在<code>onTouchEvent</code>方法中，如果当前设置的有OnClickListener，那么它的onClick方法会被调用。可以看出，平时我们常用的OnClickListener，其优先级最低，即处于事件传递的尾端。</p>
</li>
</ul>
<h2 id="六、滑动冲突解决"><a href="#六、滑动冲突解决" class="headerlink" title="六、滑动冲突解决"></a>六、滑动冲突解决</h2><p>假设我们现在要处理的事 ViewPager 内部嵌套 ListView 的场景，此时外部是要响应横向滑动而内部要响应纵向滑动，那该如何处理呢？</p>
<p>首先可以明确的条件是，当 x 轴 滑动的距离大于 Y 轴时，需要ViewPager（父view）响应横向滑动；反之，就需要子view 响应 纵向滑动了。</p>
<h3 id="6-1、外部拦截法"><a href="#6-1、外部拦截法" class="headerlink" title="6.1、外部拦截法"></a>6.1、外部拦截法</h3><p>所谓外部拦截法是指点击事情都先经过父容器的拦截处理，如果父容器需要此事件就拦截，如果不需要此事件就不拦截，这种方法比较符合点击事件的分发机制。</p>
<p>外部拦截法需要重写父容器的<code>onInterceptTouchEvent</code>方法，在内部做相应的拦截即可，这种方法的代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> intercepted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</span><br><span class="line">    <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            intercepted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            <span class="comment">// 父容器需要当前事件</span></span><br><span class="line">            <span class="keyword">if</span> (Math.abs(x - mLastXIntercept) &gt; Math.abs(y - mLastYIntercept)) &#123;</span><br><span class="line">                intercepted = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                intercepted = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">            intercepted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mLastXIntercept = x;</span><br><span class="line">    mLastYIntercept = y;</span><br><span class="line">    <span class="keyword">return</span> intercepted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-1-1、MotionEvent-ACTION-DOWN"><a href="#6-1-1、MotionEvent-ACTION-DOWN" class="headerlink" title="6.1.1、MotionEvent.ACTION_DOWN"></a>6.1.1、MotionEvent.ACTION_DOWN</h4><p>按钮按下时，action = MotionEvent.ACTION_DOWN，父view中，初始状态为：</p>
<p><code>mFirstTouchTarget=null，onInterceptTouchEvent=false，</code></p>
<p>所以事件会分发到子view 中，由子view响应。</p>
<p>分发完毕后，父view中状态为：<code>mFirstTouchTarget = 子view</code>。</p>
<h4 id="6-1-2、第一次处理ACTION-MOVE"><a href="#6-1-2、第一次处理ACTION-MOVE" class="headerlink" title="6.1.2、第一次处理ACTION_MOVE"></a>6.1.2、第一次处理ACTION_MOVE</h4><p>父view中，初始状态为，mFirstTouchTarget = 子view，</p>
<p>当 横向滚动时，intercepted = true，最终事件会进入到 dispatchTransformedTouchEvent 中，此时有2个步骤：</p>
<ol>
<li>通过<code>dispatchTransformedTouchEvent</code>向子view中分发<code>ACTION_CANCEL</code>事件</li>
<li>将 mFirstTouchTarget 置为 null。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> TouchTarget next = target.next;</span><br><span class="line">    <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">        handled = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      	<span class="comment">// intercepted = true</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class="line">                || intercepted;</span><br><span class="line">      	<span class="comment">// step1: 分发cancelChild 到子view中</span></span><br><span class="line">        <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                target.child, target.pointerIdBits)) &#123; </span><br><span class="line">            handled = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cancelChild) &#123; <span class="comment">// true</span></span><br><span class="line">            <span class="keyword">if</span> (predecessor == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// step2：mFirstTouchTarget 被置为 null</span></span><br><span class="line">                mFirstTouchTarget = next; </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                predecessor.next = next;</span><br><span class="line">            &#125;</span><br><span class="line">            target.recycle();</span><br><span class="line">            target = next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    predecessor = target;</span><br><span class="line">    target = next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下这种情况下 <code>dispatchTransformedTouchEvent</code>中时如何分发事件的，此时<code>cancel=true</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,</span></span></span><br><span class="line"><span class="params"><span class="function">        View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> handled;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldAction = event.getAction();</span><br><span class="line">    <span class="comment">// 1.canceled = true</span></span><br><span class="line">    <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">       <span class="comment">// 事件改为 ACTION_CANCEL</span></span><br><span class="line">        event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">            handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		<span class="comment">// 2. 子view 分发 ACTION_CANCEL</span></span><br><span class="line">            handled = child.dispatchTouchEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.事件改回为 ACTION_MOVE</span></span><br><span class="line">        event.setAction(oldAction);</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>以上代码中：canceled = true 时，子view会将MOVE事件改为ACTION_CANCEL事件分发出去。</p>
<p>经过这步后，将 mFirstTouchTarget 值变为 null。</p>
<h4 id="6-1-3、第二次处理ACTION-MOVE"><a href="#6-1-3、第二次处理ACTION-MOVE" class="headerlink" title="6.1.3、第二次处理ACTION_MOVE"></a>6.1.3、第二次处理ACTION_MOVE</h4><p>当继续横向滚动时，由于mFirstTouchTarget == null &amp;&amp; onInterceptTouchEvent = true，所以会执行到如下代码，由父view 进行分发此事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// No touch targets so treat this as an ordinary view.</span></span><br><span class="line">    handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">            TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2、内部拦截法"><a href="#6-2、内部拦截法" class="headerlink" title="6.2、内部拦截法"></a>6.2、内部拦截法</h3><p>内部拦截法是指父容器不拦截任何事件，所有的事件都传递给子元素，如果子元素需要此事件就直接消耗掉，否则就交由父容器进行处理，需要配合<code>requestDisallowInterceptTouchEvent</code>才能正常工作，使用起来较外部拦截法稍显复杂。它的代码如下，我们需要重写子元素的dispatchTouchEvent方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</span><br><span class="line">    <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</span><br><span class="line">    Log.d(TAG, <span class="string">&quot;子view dispatchTouchEvent = &quot;</span> + event.getAction());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">            getParent().requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">            <span class="keyword">int</span> deltaX = x - mLastX;</span><br><span class="line">            <span class="keyword">int</span> deltaY = y - mLastY;</span><br><span class="line">            <span class="comment">// 容器需要此类点击事件</span></span><br><span class="line">            <span class="comment">// 横向交给父view 处理</span></span><br><span class="line">            <span class="keyword">if</span> (Math.abs(deltaX) &gt; Math.abs(deltaY)) &#123;</span><br><span class="line">                getParent().requestDisallowInterceptTouchEvent(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLastX = x;</span><br><span class="line">    mLastY = y;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了子元素需要做处理以外，父元素也要默认拦截除了ACTION_DOWN以外的其他事件，这样当子元素调用<code>parent.requestDisallowInterceptTouchEvent(false)</code>方法时，父元素才能继续拦截所需的事件。</p>
<p><strong>为什么父容器不能拦截ACTION_DOWN事件呢？</strong></p>
<p>那是因为ACTION_DOWN事件并不受FLAG_DISALLOW_INTERCEPT这个标记位的控制，所以一旦父容器拦截ACTION_DOWN事件，那么所有的事件都无法传递到子元素中去，这样内部拦截就无法起作用了。父元素所做的修改如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> action = event.getAction();</span><br><span class="line">		<span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> 	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面逐步分析下为何以上代码可以处理<strong>响应外部响应横向滑动，内部响应纵向滑动</strong>的情况？或者说子view中是如何处理横向滑动的呢？</p>
<h4 id="6-2-1、ACTION-DOWN处理"><a href="#6-2-1、ACTION-DOWN处理" class="headerlink" title="6.2.1、ACTION_DOWN处理"></a>6.2.1、ACTION_DOWN处理</h4><p>按钮按下时，action = MotionEvent.ACTION_DOWN，父view中，初始状态为：</p>
<p><code>mFirstTouchTarget=null，onInterceptTouchEvent=false, disallowIntercept=false</code></p>
<p>所以事件会分发到子view 中，由子view响应。分</p>
<p>发完毕后，父view中状态为：<code>mFirstTouchTarget = 子view， disallowIntercept = true</code>，</p>
<p>接下来看下ACTION_MOVE的处理。</p>
<h4 id="6-2-2、第一次处理ACTION-MOVE"><a href="#6-2-2、第一次处理ACTION-MOVE" class="headerlink" title="6.2.2、第一次处理ACTION_MOVE"></a><strong>6.2.2、第一次处理ACTION_MOVE</strong></h4><p>父view中，初始状态为：<code>mFirstTouchTarget=子view，disallowIntercept = true,onInterceptTouchEvent = true</code>，但是由于父view中<code>disallowIntercept = true</code>，所以还是由子view处理。</p>
<p>子view中识别到横向滑动后，会将</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (Math.abs(deltaX) &gt; Math.abs(deltaY)) &#123;</span><br><span class="line">		getParent().requestDisallowInterceptTouchEvent(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>父view中设置<code>disallowIntercept = false</code>。</p>
<h4 id="6-2-3、第二次处理ACTION-MOVE"><a href="#6-2-3、第二次处理ACTION-MOVE" class="headerlink" title="6.2.3、第二次处理ACTION_MOVE"></a>6.2.3、第二次处理ACTION_MOVE</h4><p>下一次MOVE事件到来之后，由于 <code>disallowIntercept = false</code>，<code>onInterceptTouchEvent=true，mFirstTouchTarget = 子view</code>，事件会由父view 进行处理。</p>
<p>分发事件时，intercepted = true，主要有2个步骤：</p>
<ol>
<li>通过<code>dispatchTransformedTouchEvent</code>向子view中分发<code>ACTION_CANCEL</code>事件</li>
<li>将 mFirstTouchTarget 置为 null。</li>
</ol>
<p>上面已经分析过<a href="#6.1.2%E3%80%81%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%A4%84%E7%90%86ACTION_MOVE">MOVE 变 取消</a></p>
<h4 id="6-2-4、第三次处理ACTION-MOVE"><a href="#6-2-4、第三次处理ACTION-MOVE" class="headerlink" title="6.2.4、第三次处理ACTION_MOVE"></a>6.2.4、第三次处理ACTION_MOVE</h4><p>下一次MOVE事件到来之后，父view中 <code>disallowIntercept = false</code>，<code>onInterceptTouchEvent=true，mFirstTouchTarget = null</code>，所以事件不会分发给子view 会由父view 进行处理。</p>
<h3 id="6-3、MotionEvent-UP"><a href="#6-3、MotionEvent-UP" class="headerlink" title="6.3、MotionEvent.UP"></a>6.3、MotionEvent.UP</h3><p>对于MotionEvent.UP事件来说，无论是内部拦截或是外部拦截方式，即MotionEvent.UP 只响应拦截</p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>View事件分发</tag>
      </tags>
  </entry>
  <entry>
    <title>FrameWork_08_SharedPreferences</title>
    <url>/2021/02/24/Notes/Android/Framework/FrameWork_07_SharePreference%20%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="FrameWork-08-SharedPreference"><a href="#FrameWork-08-SharedPreference" class="headerlink" title="FrameWork_08_SharedPreference"></a>FrameWork_08_SharedPreference</h1><p>SharePreferences是一个轻量级的存储类，特别适合用于保存软件配置参数。使用SharedPreferences保存数据，其背后是用xml文件存放数据，文件存放在/data/data/ &lt; package name &gt; /shared_prefs目录下，本文主要介绍下sp的用法并且从源码的角度分析下sp的写入过程。</p>
<h2 id="1-获取sp的三种方式"><a href="#1-获取sp的三种方式" class="headerlink" title="1.获取sp的三种方式"></a>1.获取sp的三种方式</h2><p>1.this.getPreferences (int mode)<br>    通过Activity对象获取，获取的是本Activity私有的Preference，保存在系统中的xml形式的文件的名称为这个Activity的名字，因此一个Activity只能有一个，属于这个Activity。</p>
<p>2.context.getSharedPreferences (String name, int mode)<br>    因为Activity继承了ContextWrapper，因此也是通过Activity对象获取，但是属于整个应用程序，可以有多个，以第一参数的name为文件名保存在系统中。</p>
<p>3.PreferenceManager.getDefaultSharedPreferences(this);<br>    PreferenceManager的静态函数，保存PreferenceActivity中的设置，属于整个应用程序，但是只有一个，命名为packagename_preferences。</p>
<h2 id="2-写入模式"><a href="#2-写入模式" class="headerlink" title="2. 写入模式"></a>2. 写入模式</h2><pre><code>Activity.MODE_PRIVATE,//默认操作模式，代表该文件是私有数据，只能被应用本身访问，在该模式下，写入的内容会覆盖原文件的内容，如果想把新写入的内容追加到原文件中，可以使用Activity.MODE_APPEND 
Activity.MODE_APPEND //该模式会检查文件是否存在，存在就往文件追加内容，否则就创建新文件
以下2种模式已废弃，不安全
Activity.MODE_WORLD_READABLE,//表示当前文件可以被其他应用读取，  
Activity.MODE_WORLD_WRITEABLE,//表示当前文件可以被其他应用写入；
</code></pre>
<h2 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3.源码分析"></a>3.源码分析</h2><h3 id="1-获取SharedPreferences对象"><a href="#1-获取SharedPreferences对象" class="headerlink" title="1.获取SharedPreferences对象"></a>1.获取SharedPreferences对象</h3><p>contextImpl.getSharedPreferences()，这里使用到了单例模式，涉及到的几个对象如下：</p>
<pre><code>ArrayMap&lt;String, File&gt; mSharedPrefsPaths ： 保存sp的路径和文件
ArrayMap&lt;String, ArrayMap&lt;File, SharedPreferencesImpl&gt;&gt; sSharedPrefsCache key 是packageName， vlaue是 file 和 对应的spImpl对象。
</code></pre>
<p>整个过程分为2步，先获取对应name的sp文件，如果没有就new一个文件放到 mSharedPrefsPaths 中，<br>再根据文件名获取对应的spImpl对象。</p>
<p>对于一个相同的SharedPreferences name，获取到的都是同一个SharedPreferences对象，也就是SharedPreferencesImpl对象。</p>
<pre><code>public SharedPreferences getSharedPreferences(String name, int mode) &#123;
    // At least one application in the world actually passes in a null
    // name.  This happened to work because when we generated the file name
    // we would stringify it to &quot;null.xml&quot;.  Nice.
    if (mPackageInfo.getApplicationInfo().targetSdkVersion &lt;
            Build.VERSION_CODES.KITKAT) &#123;
        if (name == null) &#123;
            name = &quot;null&quot;;
        &#125;
    &#125;
    
    File file;
    synchronized (ContextImpl.class) &#123;
        if (mSharedPrefsPaths == null) &#123;
            mSharedPrefsPaths = new ArrayMap&lt;&gt;();
        &#125;
        file = mSharedPrefsPaths.get(name);
        if (file == null) &#123;
            file = getSharedPreferencesPath(name);
            mSharedPrefsPaths.put(name, file);
        &#125;
    &#125;
    return getSharedPreferences(file, mode);
&#125;

 public SharedPreferences getSharedPreferences(File file, int mode) &#123;
    ...
    SharedPreferencesImpl sp;
    synchronized (ContextImpl.class) &#123;
        final ArrayMap&lt;File, SharedPreferencesImpl&gt; cache = getSharedPreferencesCacheLocked();
        sp = cache.get(file);
        if (sp == null) &#123;
            sp = new SharedPreferencesImpl(file, mode);
            cache.put(file, sp);
            return sp;
        &#125;
    &#125;
    if ((mode &amp; Context.MODE_MULTI_PROCESS) != 0 ||
        getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) &#123;
        // If somebody else (some other process) changed the prefs
        // file behind our back, we reload it.  This has been the
        // historical (if undocumented) behavior.
        sp.startReloadIfChangedUnexpectedly();
    &#125;
    return sp;
&#125;

private ArrayMap&lt;File, SharedPreferencesImpl&gt; getSharedPreferencesCacheLocked() &#123;
    if (sSharedPrefsCache == null) &#123;
        sSharedPrefsCache = new ArrayMap&lt;&gt;();
    &#125;

    final String packageName = getPackageName();
    ArrayMap&lt;File, SharedPreferencesImpl&gt; packagePrefs = sSharedPrefsCache.get(packageName);
    if (packagePrefs == null) &#123;
        packagePrefs = new ArrayMap&lt;&gt;();
        sSharedPrefsCache.put(packageName, packagePrefs);
    &#125;

    return packagePrefs;
&#125;
</code></pre>
<h3 id="2-sp-的初始化"><a href="#2-sp-的初始化" class="headerlink" title="2.sp 的初始化"></a>2.sp 的初始化</h3><p>对于一个SharedPreferences文件name，第一次调用getSharedPreferences时会去创建一个SharedPreferencesImpl对象，它会开启一个子线程，将所有的数据以Map的形式保存在内存中。</p>
<pre><code> SharedPreferencesImpl(File file, int mode) &#123;
    mFile = file;
    mBackupFile = makeBackupFile(file);
    mMode = mode;
    mLoaded = false;
    mMap = null;
    startLoadFromDisk();
&#125;

private void startLoadFromDisk() &#123;
    synchronized (mLock) &#123;
        mLoaded = false;
    &#125;
    new Thread(&quot;SharedPreferencesImpl-load&quot;) &#123;
        public void run() &#123;
            loadFromDisk();
        &#125;
    &#125;.start();
&#125;

private void loadFromDisk() &#123;
    synchronized (mLock) &#123;
        if (mLoaded) &#123;
            return;
        &#125;
        if (mBackupFile.exists()) &#123;
            mFile.delete();
            mBackupFile.renameTo(mFile);
        &#125;
    &#125;

    // Debugging
    if (mFile.exists() &amp;&amp; !mFile.canRead()) &#123;
        Log.w(TAG, &quot;Attempt to read preferences file &quot; + mFile + &quot; without permission&quot;);
    &#125;

    Map map = null;
    StructStat stat = null;
    try &#123;
        stat = Os.stat(mFile.getPath());
        if (mFile.canRead()) &#123;
            BufferedInputStream str = null;
            try &#123;
                str = new BufferedInputStream(
                        new FileInputStream(mFile), 16*1024);
                map = XmlUtils.readMapXml(str);
            &#125; catch (Exception e) &#123;
                Log.w(TAG, &quot;Cannot read &quot; + mFile.getAbsolutePath(), e);
            &#125; finally &#123;
                IoUtils.closeQuietly(str);
            &#125;
        &#125;
    &#125; catch (ErrnoException e) &#123;
        /* ignore */
    &#125;

    synchronized (mLock) &#123;
        mLoaded = true;
        if (map != null) &#123;
            mMap = map;
            mStatTimestamp = stat.st_mtime;
            mStatSize = stat.st_size;
        &#125; else &#123;
            mMap = new HashMap&lt;&gt;();
        &#125;
        mLock.notifyAll();
    &#125;
&#125;
</code></pre>
<h2 id="3-sp的读取"><a href="#3-sp的读取" class="headerlink" title="3. sp的读取"></a>3. sp的读取</h2><p>当我们在ui线程种这样调用时：</p>
<pre><code>SharedPreferences sp = getSharedPreferences(&quot;test&quot;, Context.MODE_PRIVATE);
String name = sp.getString(&quot;name&quot;, null)
</code></pre>
<p>调用getString时那个SharedPreferencesImpl构造方法开启的子线程可能还没执行完（比如文件比较大时全部读取会比较久），这时getString当然还不能获取到相应的值，必须阻塞到那个子线程读取完为止，getString方法：</p>
<pre><code>public String getString(String key, @Nullable String defValue) &#123;
    synchronized (this) &#123;
        awaitLoadedLocked();
        String v = (String)mMap.get(key);
        return v != null ? v : defValue;
    &#125;
&#125;
</code></pre>
<p>显然这个awaitLoadedLocked方法就是用来等this这个锁的，在loadFromDiskLocked方法的最后我们也可以看到它调用了notifyAll方法，这时如果getString之前阻塞了就会被唤醒。那么现在这里有一个问题，我们的getString是写在UI线程中，如果那个getString被阻塞太久了，比如60s，这时就会出现ANR，因此要根据具体情况考虑是否需要把SharedPreferences的读写放在子线程中。这里回答第二个 问题，在UI线程中调用getXXX可能会导致ANR。同时可以回答第三个问题，SharedPreferences只能用来存放少量数据，如果一个SharedPreferences对应的xml文件很大的话，在初始化时会把这个文件的所有数据都加载到内存中，这样就会占用大量的内存，有时我们只是想读取某个xml文件中一个key的value，结果它把整个文件都加载进来了，显然如果必要的话这里需要进行相关优化处理。</p>
<h2 id="4-sp的写入"><a href="#4-sp的写入" class="headerlink" title="4.sp的写入"></a>4.sp的写入</h2><pre><code>SharedPreferences.Editor editor = getSharedPreferences(&quot;test&quot;, Context.MODE_PRIVATE).edit();
editor.putString(&quot;name&quot;, &quot;test&quot;);
editor.commit();
</code></pre>
<p>首先写一个SharedPreferences文件都是先要调用edit方法获取到一个Editor对象：   </p>
<pre><code>public Editor edit() &#123;
    synchronized (this) &#123;
        awaitLoadedLocked();
    &#125;
    return new EditorImpl();
&#125;
</code></pre>
<p>这个Editor对象是SharedPreferencesImpl的一个内部类：</p>
<pre><code>public final class EditorImpl implements Editor &#123;
    private final Map&lt;String, Object&gt; mModified = Maps.newHashMap();
    private boolean mClear = false;
    public Editor putString(String key, @Nullable String value) &#123;
        synchronized (this) &#123;
            mModified.put(key, value);
            return this;
        &#125;
    &#125;
    ...
&#125;
</code></pre>
<p>可以看到它有一个Map对象mModified，用来保存修改的数据，也就是你每次put的时候其实是把那个键值对放到这个mModified 中，最后调用apply或者commit才会真正把数据写入文件中。调用commit 和 apply时都会调用到commitToMemory 和 enqueueDiskWrite这2个方法。这里我们以commit 为例先看下整个写入的过程。 </p>
<h3 id="4-1-commit"><a href="#4-1-commit" class="headerlink" title="4.1 commit"></a>4.1 commit</h3><pre><code>public boolean commit() &#123;
    MemoryCommitResult mcr = commitToMemory();
    SharedPreferencesImpl.this.enqueueDiskWrite(
        mcr, null /* sync write on this thread okay */);
    try &#123;
        mcr.writtenToDiskLatch.await();
    &#125; catch (InterruptedException e) &#123;
        return false;
    &#125;
    notifyListeners(mcr);
    return mcr.writeToDiskResult;
&#125;
</code></pre>
<h3 id="4-2-commitToMemory"><a href="#4-2-commitToMemory" class="headerlink" title="4.2 commitToMemory"></a>4.2 commitToMemory</h3><p>这个方法对应了editor的增删改查方法，这里涉及了2个对象，mMap 和mModified，一个保存当前sp中的键值对，一个保存了修改的键值对。遍历mModified键值对时可以看到这个方法中首先处理了clear标志，它调用的是mMap.clear()，然后再遍历mModified将新的键值对put进mMap，也就是说在一次commit事务中，如果同时put一些键值对和调用clear，那么clear掉的只是之前的键值对，这次put进去的键值对还是会被写入的。</p>
<pre><code>// Returns true if any changes were made
private MemoryCommitResult commitToMemory() &#123;
    MemoryCommitResult mcr = new MemoryCommitResult();
    ...
        synchronized (this) &#123;
            if (mClear) &#123;
                if (!mMap.isEmpty()) &#123;
                    mcr.changesMade = true;
                    mMap.clear();
                &#125;
                mClear = false;
            &#125;

            for (Map.Entry&lt;String, Object&gt; e : mModified.entrySet()) &#123;
                String k = e.getKey();
                Object v = e.getValue();
                // &quot;this&quot; is the magic value for a removal mutation. In addition,
                // setting a value to &quot;null&quot; for a given key is specified to be
                // equivalent to calling remove on that key.
                if (v == this || v == null) &#123;
                    if (!mMap.containsKey(k)) &#123;
                        continue;
                    &#125;
                    mMap.remove(k);
                &#125; else &#123;
                    if (mMap.containsKey(k)) &#123;
                        Object existingValue = mMap.get(k);
                        if (existingValue != null &amp;&amp; existingValue.equals(v)) &#123;
                            continue;
                        &#125;
                    &#125;
                    mMap.put(k, v);
                &#125;

                mcr.changesMade = true;
                if (hasListeners) &#123;
                    mcr.keysModified.add(k);
                &#125;
            &#125;

            mModified.clear();
        &#125;
    &#125;
    return mcr;
&#125;
</code></pre>
<p>遍历mModified时，需要处理一个特殊情况，就是如果一个键值对的value是this（SharedPreferencesImpl）或者是null那么表示将此键值对删除，这个在remove方法中可以看到： </p>
<pre><code>public Editor remove(String key) &#123;
    synchronized (this) &#123;
        mModified.put(key, this);
        return this;
    &#125;
&#125;
</code></pre>
<h2 id="4-3-enqueueDiskWrite"><a href="#4-3-enqueueDiskWrite" class="headerlink" title="4.3 enqueueDiskWrite"></a>4.3 enqueueDiskWrite</h2><p>先定义一个Runnable，注意实现Runnable与继承Thread的区别，Runnable表示一个任务，不一定要在子线程中执行，一般优先考虑使用Runnable。这个Runnable中先调用writeToFile进行写操作，写操作需要先获得mWritingToDiskLock，也就是写锁。然后执行mDiskWritesInFlight–，表示正在等待写的操作减少1。最后判断postWriteRunnable是否为null，调用commit时它为null，而调用apply时它不为null。<br>Runnable定义完，就判断这次是commit还是apply，如果是commit，即isFromSyncCommit为true，而且有1个写操作需要执行，那么就调用writeToDiskRunnable.run()，注意这个调用是在当前线程中进行的。如果不是commit，那就是apply，这时调用QueuedWork.singleThreadExecutor().execute(writeToDiskRunnable)，这个QueuedWork类其实很简单，里面有一个SingleThreadExecutor，用于异步执行这个writeToDiskRunnable。 </p>
<pre><code>private void enqueueDiskWrite(final MemoryCommitResult mcr,
                              final Runnable postWriteRunnable) &#123;
    final Runnable writeToDiskRunnable = new Runnable() &#123;
            public void run() &#123;
                synchronized (mWritingToDiskLock) &#123;
                    writeToFile(mcr);
                &#125;
                synchronized (SharedPreferencesImpl.this) &#123;
                    mDiskWritesInFlight--;
                &#125;
                if (postWriteRunnable != null) &#123;
                    postWriteRunnable.run();
                &#125;
            &#125;
        &#125;;

    final boolean isFromSyncCommit = (postWriteRunnable == null);

    // Typical #commit() path with fewer allocations, doing a write on
    // the current thread.
    if (isFromSyncCommit) &#123;
        boolean wasEmpty = false;
        synchronized (SharedPreferencesImpl.this) &#123;
            wasEmpty = mDiskWritesInFlight == 1;
        &#125;
        if (wasEmpty) &#123;
            writeToDiskRunnable.run();
            return;
        &#125;
    &#125;

    QueuedWork.singleThreadExecutor().execute(writeToDiskRunnable);
&#125;
</code></pre>
<h3 id="4-4-writeToFile"><a href="#4-4-writeToFile" class="headerlink" title="4.4 writeToFile"></a>4.4 writeToFile</h3><p>SharedPreferences在写入时会先把之前的xml文件改成名成一个备份文件mBackupFile，然后再将要写入的数据写到一个新的文件中，如果这个过程执行成功的话，就会把备份文件删除。由此可见每次即使只是添加一个键值对，也会重新写入整个文件的数据，这也说明SharedPreferences只适合保存少量数据，文件太大会有性能问题。</p>
<pre><code>private void writeToFile(MemoryCommitResult mcr) &#123;
    // Rename the current file so it may be used as a backup during the next read
    if (mFile.exists()) &#123;
        if (!mcr.changesMade) &#123;
            // If the file already exists, but no changes were
            // made to the underlying map, it&#39;s wasteful to
            // re-write the file.  Return as if we wrote it
            // out.
            mcr.setDiskWriteResult(true);
            return;
        &#125;
        if (!mBackupFile.exists()) &#123;
            if (!mFile.renameTo(mBackupFile)) &#123;
                Log.e(TAG, &quot;Couldn&#39;t rename file &quot; + mFile
                      + &quot; to backup file &quot; + mBackupFile);
                mcr.setDiskWriteResult(false);
                return;
            &#125;
        &#125; else &#123;
            mFile.delete();
        &#125;
    &#125;

    // Attempt to write the file, delete the backup and return true as atomically as
    // possible.  If any exception occurs, delete the new file; next time we will restore
    // from the backup.
    try &#123;
        FileOutputStream str = createFileOutputStream(mFile);
        if (str == null) &#123;
            mcr.setDiskWriteResult(false);
            return;
        &#125;
        XmlUtils.writeMapXml(mcr.mapToWriteToDisk, str);
        FileUtils.sync(str);
        str.close();
        ContextImpl.setFilePermissionsFromMode(mFile.getPath(), mMode, 0);
        try &#123;
            final StructStat stat = Os.stat(mFile.getPath());
            synchronized (this) &#123;
                mStatTimestamp = stat.st_mtime;
                mStatSize = stat.st_size;
            &#125;
        &#125; catch (ErrnoException e) &#123;
            // Do nothing
        &#125;
        // Writing was successful, delete the backup file if there is one.
        mBackupFile.delete();
        mcr.setDiskWriteResult(true);
        return;
    &#125; catch (XmlPullParserException e) &#123;
        Log.w(TAG, &quot;writeToFile: Got exception:&quot;, e);
    &#125; catch (IOException e) &#123;
        Log.w(TAG, &quot;writeToFile: Got exception:&quot;, e);
    &#125;
    // Clean up an unsuccessfully written file
    if (mFile.exists()) &#123;
        if (!mFile.delete()) &#123;
            Log.e(TAG, &quot;Couldn&#39;t clean up partially-written file &quot; + mFile);
        &#125;
    &#125;
    mcr.setDiskWriteResult(false);
&#125;
</code></pre>
<h3 id="5-使用apply导致的anr"><a href="#5-使用apply导致的anr" class="headerlink" title="5.使用apply导致的anr"></a>5.使用apply导致的anr</h3><p>其实无节制的使用apply方法也时会造成anr的，在主线程中无节制的使用apply其实也会造成anr，在调用apply时，会将等待写入到文件系统的任务awaitCommit放在QueuedWork的等待完成队列里。</p>
<pre><code>public void apply() &#123;
    final MemoryCommitResult mcr = commitToMemory();
    final Runnable awaitCommit = new Runnable() &#123;
            public void run() &#123;
                try &#123;
                    mcr.writtenToDiskLatch.await();
                &#125; catch (InterruptedException ignored) &#123;
                &#125;
            &#125;
        &#125;;

    QueuedWork.add(awaitCommit);

    Runnable postWriteRunnable = new Runnable() &#123;
            public void run() &#123;
                awaitCommit.run();
                QueuedWork.remove(awaitCommit);
            &#125;
        &#125;;

    SharedPreferencesImpl.this.enqueueDiskWrite(mcr, postWriteRunnable);

    // Okay to notify the listeners before it&#39;s hit disk
    // because the listeners should always get the same
    // SharedPreferences instance back, which has the
    // changes reflected in memory.
    notifyListeners(mcr);
&#125;
</code></pre>
<p>所以如果我们使用SharedPreference的apply方法,虽然该方法可以很快返回， 并在其它线程里将键值对写入到文件系统， 但是当Activity的onPause等方法被调用时，会调用等待写入到文件系统的任务完成，</p>
<pre><code>/**
 * Finishes or waits for async operations to complete.
 * (e.g. SharedPreferences$Editor#startCommit writes)
 *
 * Is called from the Activity base class&#39;s onPause(), after
 * BroadcastReceiver&#39;s onReceive, after Service command handling,
 * etc.  (so async work is never lost)
 */
public static void waitToFinish() &#123;
    Runnable toFinish;
    while ((toFinish = sPendingWorkFinishers.poll()) != null) &#123;
        toFinish.run();
    &#125;
&#125;
</code></pre>
<p>在执行任务writeToDiskRunnable时，会先等待postrunable执行完成，也就是awaitCommit执行完成，</p>
<pre><code>final Runnable awaitCommit = new Runnable() &#123;
            public void run() &#123;
                try &#123;
                    mcr.writtenToDiskLatch.await();
                &#125; catch (InterruptedException ignored) &#123;
                &#125;
            &#125;
        &#125;;
</code></pre>
<p>所以如果写入比较慢，主线程就会出现ANR问题。</p>
<p><a href="http://www.cloudchou.com/android/post-988.html">http://www.cloudchou.com/android/post-988.html</a></p>
<p>结论：<br>1.对于一个相同的SharedPreferences name，获取到的都是同一个SharedPreferences对象，它其实是SharedPreferencesImpl对象。<br>2.在UI线程中调用getXXX可能会导致ANR。<br>3.SharedPreferences只能用来存放少量数据，如果一个SharedPreferences对应的xml文件很大的话，在初始化时会把这个文件的所有数据都加载到内存中，这样就会占用大量的内存，有时我们只是想读取某个xml文件中一个key的value，结果它把整个文件都加载进来了，显然如果必要的话这里需要进行相关优化处理。<br>4.commit的写操作是在调用线程中执行的，而apply内部是用一个单线程的线程池实现的，因此写操作是在子线程中执行的。<br>5.SharedPreferences每次写入都是整个文件重新写入，不是增量写入。<br>6.apply也会造成anr。<br>参考：<br><a href="http://blog.csdn.net/u012619640/article/details/50940074">http://blog.csdn.net/u012619640/article/details/50940074</a></p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>SharedPreferences</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/02/24/Notes/Android/other/other/</url>
    <content><![CDATA[<p><a href="http://blog.leanote.com/post/svenpaper/Android-SharePreference-%E6%80%BB%E7%BB%93">http://blog.leanote.com/post/svenpaper/Android-SharePreference-%E6%80%BB%E7%BB%93</a></p>
<p><a href="http://blog.leanote.com/post/svenpaper/Android-O-%E7%89%88%E6%9C%AC%E5%AE%89%E8%A3%85%E5%8C%85%E5%A4%A7%E5%B0%8F%E8%8E%B7%E5%8F%96%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E5%8F%8A%E8%A7%A3%E5%86%B3">http://blog.leanote.com/post/svenpaper/Android-O-%E7%89%88%E6%9C%AC%E5%AE%89%E8%A3%85%E5%8C%85%E5%A4%A7%E5%B0%8F%E8%8E%B7%E5%8F%96%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E5%8F%8A%E8%A7%A3%E5%86%B3</a></p>
<p><a href="http://blog.leanote.com/post/svenpaper/JobService-%E5%92%8C-Jobschedule">http://blog.leanote.com/post/svenpaper/JobService-%E5%92%8C-Jobschedule</a></p>
]]></content>
  </entry>
  <entry>
    <title>JVM_09_JVM_GC</title>
    <url>/2021/07/24/Notes/Java/JVM/JVM_09_JVM_GC/</url>
    <content><![CDATA[<h1 id="JVM-09-JVM-GC"><a href="#JVM-09-JVM-GC" class="headerlink" title="JVM_09_JVM_GC"></a>JVM_09_JVM_GC</h1><h2 id="哪里的内存需要回收？"><a href="#哪里的内存需要回收？" class="headerlink" title="哪里的内存需要回收？"></a>哪里的内存需要回收？</h2><p>JVM GC只回收<code>堆和方法区内的对象</code>。而栈区的数据，在超出作用域后会被JVM自动释放掉，所以其不在JVM GC的管理范围内。</p>
<h2 id="如何判断对象可以回收？"><a href="#如何判断对象可以回收？" class="headerlink" title="如何判断对象可以回收？"></a>如何判断对象可以回收？</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>给对象中添加一个<code>引用计数器</code>，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p>
<p>它的优点是简单、高效，但是缺点也是异常明显：无法解决<code>对象循环引用</code>的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象循环引用示例</span></span><br><span class="line">Object objectA = <span class="keyword">new</span> Object();</span><br><span class="line">Object objectB = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">objectA.instance = objectB;</span><br><span class="line">objectB.instance = objectA;</span><br><span class="line"></span><br><span class="line">objectA = <span class="keyword">null</span>;</span><br><span class="line">objectB = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">System.gc();</span><br></pre></td></tr></table></figure>
<p>假设我们有上面的代码。程序启动后，objectA和objectB两个对象被创建并在堆中分配内存，它们都相互持有对方的引用，但是除了它们相互持有的引用之外，再无别的引用。</p>
<p>而实际上，引用已经被置空，这两个对象不可能再被访问了，但是因为它们相互引用着对方，导致它们的引用计数都不为0，因此引用计数算法无法通知GC回收它们，造成了内存的浪费。如下图：对象之间的引用形成一个有环图。<br><img src="/pics/image-20210417183019446.png" alt="image-20210417183019446" style="zoom:50%;" /></p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>通过一系列称为<code>GC Roots</code>的对象作为起始点，从这些节点开始向下搜索，搜索所走过的引用路径称为<code>引用链（Reference Chain）</code>，当一个对象到GC Roots 没有任何的引用链相连时，则证明此对象不可用的，是可以被回收的。</p>
<img src="/pics/image-20210417184107213.png" alt="image-20210417184107213" style="zoom:30%;" />

<h4 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h4><p>在 Java 语言中，可作为 GC Root 的对象包括以下 4 种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象（static）</li>
<li>方法区中常量引用的对象（static final）</li>
<li>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象</li>
</ul>
<h4 id="Java引用"><a href="#Java引用" class="headerlink" title="Java引用"></a>Java引用</h4><p>Java 中的引用类型总共有四种：强引用，软引用，弱引用，虚引用。</p>
<ul>
<li><p>强引用就是最普通的对象引用，每当 new 一个对象的时候，都是生成一个强引用。这种引用对垃圾回收免疫，即使发生 OOM，这种对象也不会被回收。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure></li>
<li><p>软引用的强度相对弱一些，用来描述一些还有用但非必须的对象。在发生 OOM 之前，JVM 会尝试去回收这些对象，软引用的实现类是 SoftReference。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Object();</span><br><span class="line">SoftReference srf = <span class="keyword">new</span> SoftReference(o);</span><br></pre></td></tr></table></figure></li>
<li><p>弱引用就更弱了，用来描述一些非必需对象，碰上了垃圾回收，弱引用的对象肯定会被回收，弱引用的实现类是 WeakReference。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Object();</span><br><span class="line">WeakReference wrf = <span class="keyword">new</span> WeakReference(o);</span><br></pre></td></tr></table></figure></li>
<li><p>虚引用无法引用对象，实际只是做一些垃圾清理之后的事情, 虚引用的实现类是 PhantomReference。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object o = new Object();</span><br><span class="line">ReferenceQueue rq = new ReferenceQueue();</span><br><span class="line">PhantomReference prf = new PhantomReference(o, rq);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>上面的各种引用都继承了 Reference 类，Reference 类中有一个 get 方法，如果软引用和弱引用所指向的对象没有被回收，那么使用 get 方法就可以获取原对象的引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Object();</span><br><span class="line">SoftReference srf = <span class="keyword">new</span> SoftReference(o);</span><br><span class="line">o = <span class="keyword">null</span>; <span class="comment">// 断开强引用</span></span><br><span class="line">System.out.println(srf.get()); <span class="comment">// java.lang.Object@17579e0f</span></span><br></pre></td></tr></table></figure>

<p>虚引用 PhantomReference 的 get 方法会一直返回 null，所以无法通过虚引用获取到对象。虚引用的意义在于提供了一种在对象被回收之后做某些事情的机制，在这里就需要谈到引用队列。</p>
<p>ReferenceQueue 称之为引用队列。如果我们为一个引用指定一个引用队列，那么这个引用所指向的队列在被垃圾回收后，该引用就会被加入到引用队列中。</p>
<p>我们就可以根据引用队列中的引用来判断某个对象是否被回收，或者直接清除引用队列的引用对象，具体的逻辑要看具体的业务场景。</p>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记 - 清除算法"></a>标记 - 清除算法</h3><p>“标记-清除”（Mark-Sweep）算法，如同它的名字一样，算法分为“标记”和“清除”两个阶段：</p>
<ul>
<li>首先标记出所有需要回收的对象</li>
<li>在标记完成后统一回收所有被标记的对象</li>
</ul>
<p>主要不足有两个：</p>
<ol>
<li><p>效率问题</p>
<p>标记和清除两个过程的效率都不高；</p>
</li>
<li><p>空间问题</p>
<p>标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>
</li>
</ol>
<img src="/pics/image-20210417202955925.png" alt="image-20210417202955925" style="zoom:50%;" />

<h4 id="可达性算法中的标记"><a href="#可达性算法中的标记" class="headerlink" title="可达性算法中的标记"></a>可达性算法中的标记</h4><p>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize方法。当对象没有覆盖finalize方法，或者finalize方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</p>
<p>如果这个对象被判定为有必要执行finalize方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。</p>
<p>finalize方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。</p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p>
<p>这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。</p>
<p>不足：内存缩小为了原来的一半。</p>
<img src="/pics/image-20210417204202632.png" alt="image-20210417204202632" style="zoom:50%;" />

<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记 - 整理算法"></a>标记 - 整理算法</h3><p>“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</p>
<img src="/pics/image-20210417204307864.png" alt="image-20210417204307864" style="zoom:50%;" />

<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，根据对象存活周期的不同将内存划分为几块，各再根据个年代的特点采用最适当的收集算法。</p>
<p><strong>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法</strong>，只需要付出少量存活对象的复制成本就可以完成收集。</p>
<p>老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。</p>
<h2 id="HotSpot的算法实现"><a href="#HotSpot的算法实现" class="headerlink" title="HotSpot的算法实现"></a>HotSpot的算法实现</h2><h3 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h3><p>Stop The World + OopMap(类加载完成后，特定位置记录类引用的类型数据的地址)</p>
<p>可达性分析时为<code>保证结果准确性，不可出现分析过程中对象引用关系还在不断变化的情况</code>，所以GC进行时必须停顿所有Java执行线程（称为“Stop The World”）。</p>
<p>当进入STW状态时，虚拟机需要知道哪些地方放着对象引用。在HotSpot的实现中，是使用一组称为<strong>OopMap</strong>的数据结构来达到这个目的的，在类加载完成的时候，<code>HotSpot就把对象内什么偏移量上是什么类型的数据计算出来</code>，在JIT编译过程中，也会在<strong>特定的位置</strong>记录下栈和寄存器中哪些位置是引用。这样，GC在扫描时就可以直接得知这些信息了。</p>
<h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举，但一个很现实的问题随之而来：可能导致引用关系变化（OopMap内容变化）的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本将会变得很高。</p>
<p>HotSpot也的确没有为每条指令都生成OopMap，前面已经提到，只是在“特定的位置”记录了这些信息，这些位置称为安全点（Safepoint），只有在到达安全点时才能暂停。</p>
<p>安全点的选定基本上是以程序<code>是否具有让程序长时间执行的特征</code>为标准进行选定的，“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生Safepoint。</p>
<h4 id="抢先式中断和主动式中断"><a href="#抢先式中断和主动式中断" class="headerlink" title="抢先式中断和主动式中断"></a>抢先式中断和主动式中断</h4><p>对于Sefepoint，另一个需要考虑的问题是如何在GC发生时让所有线程都“跑”到最近的安全点上再停顿下来。</p>
<ul>
<li><p>抢先式中断（Preemptive Suspension）</p>
<p>不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。</p>
</li>
<li><p>主动式中断（Voluntary Suspension）</p>
<p>当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。</p>
</li>
</ul>
<p>现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。</p>
<h3 id="安全区"><a href="#安全区" class="headerlink" title="安全区"></a>安全区</h3><p>Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”（没有分配CPU时间）的时候呢？比如线程处于Sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全的地方去中断挂起，JVM也显然不太可能等待线程重新被分配CPU时间。对于这种情况，就需要安全区域（Safe Region）来解决。</p>
<p><code>安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。</code></p>
<p>在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。</p>
<p>在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。</p>
<h2 id="HotSpot垃圾收集器"><a href="#HotSpot垃圾收集器" class="headerlink" title="HotSpot垃圾收集器"></a>HotSpot垃圾收集器</h2><img src="/pics/image-20210417210644456.png" alt="image-20210417210644456" style="zoom:33%;" />

<blockquote>
<p>说明：如果两个垃圾回收器之间存在连线说明他们之间是可以搭配使用的</p>
</blockquote>
<h3 id="Serial-和-Serial-Old-回收器"><a href="#Serial-和-Serial-Old-回收器" class="headerlink" title="Serial 和 Serial Old 回收器"></a>Serial 和 Serial Old 回收器</h3><p>Serial</p>
<ul>
<li>工作在新生代</li>
<li>复制算法</li>
<li>单线程的垃圾回收器，当垃圾回收线程开始的时候，工作（业务）线程必须暂停</li>
</ul>
<p>Serial Old</p>
<ul>
<li>工作在老年代</li>
<li>标记-整理算法<img src="/pics/image-20210417213537906.png" alt="image-20210417213537906" style="zoom:50%;" /></li>
</ul>
<h3 id="ParNew-回收器"><a href="#ParNew-回收器" class="headerlink" title="ParNew 回收器"></a>ParNew 回收器</h3><ul>
<li>ParNew可以认为是Serial的<code>多线程</code>版本</li>
<li>ParNew是<code>多线程并行</code>回收的，回收时<code>工作线程</code>必须暂停</li>
</ul>
<img src="/pics/image-20210417211623550.png" alt="image-20210417211623550" style="zoom:50%;" />

<blockquote>
<p>注意　从ParNew收集器开始，后面还会接触到几款并发和并行的收集器。并发和并行。这两个名词都是并发编程中的概念，在谈论垃圾收集器的上下文语境中，它们可以解释如下。</p>
<p>●并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于暂停（等待）状态。</p>
<p>●并发（Concurrent）：指工作（用户）线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上</p>
</blockquote>
<h3 id="Parallel-Scavenge-Parallel-Old-回收器"><a href="#Parallel-Scavenge-Parallel-Old-回收器" class="headerlink" title="Parallel Scavenge/Parallel Old 回收器"></a>Parallel Scavenge/Parallel Old 回收器</h3><p>Parallel Scavenge </p>
<ul>
<li>新生代</li>
<li>复制算法</li>
<li>使用多线程进行垃圾回收，回收时工作线程处于暂停状态</li>
</ul>
<p>Parallel Old </p>
<ul>
<li>是 Parallel Scavenge 的老年代版本，也就是说<code>Parallel Old</code>工作在<code>老年代</code></li>
<li>标记-整理</li>
<li>多线程并行</li>
</ul>
<p>JDK1.8默认采用的垃圾回收器：Parallel Scavenge、Parallel Old</p>
<img src="/pics/image-20210417212833916.png" alt="image-20210417212833916" style="zoom:50%;" />

<p>Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是<code>尽可能地缩短垃圾收集时用户线程的停顿时间</code>，而Parallel Scavenge收集器的目标则是<code>达到一个可控制的吞吐量（Throughput）</code>。</p>
<p>Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX：MaxGCPauseMillis）以及直接设置吞吐量大小的-XX：GCTimeRatio参数。</p>
<p>MaxGCPauseMillis参数允许的值是一个大于0的毫秒数，收集器将尽可能地保证内存回收花费的时间不超过设定值。不过大家不要认为如果把这个参数的值设置得稍小一点就能使得系统的垃圾收集速度变得更快，<code>GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的</code>：系统把新生代调小一些，收集300MB新生代肯定比收集500MB快吧，这也直接导致垃圾收集发生得更频繁一些，原来10秒收集一次、每次停顿100毫秒，现在变成5秒收集一次、每次停顿70毫秒。停顿时间的确在下降，但吞吐量也降下来了。</p>
<h3 id="CMS-回收器"><a href="#CMS-回收器" class="headerlink" title="CMS 回收器"></a>CMS 回收器</h3><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。</p>
<ul>
<li><p>老年代</p>
</li>
<li><p>CMS是<code>多线程并发</code>的，也就是说<code>垃圾线程</code>和<code>工作线程</code>是可以<code>一起执行</code>的</p>
</li>
<li><p>采用 <code>标记-清除</code> 算法实现</p>
</li>
<li><p>运行步骤：</p>
<ul>
<li>初始标记(CMS initial mark)：标记 GC Roots 能直接关联到的对象</li>
<li>并发标记(CMS concurrent mark)：进行 GC Roots Tracing</li>
<li>重新标记(CMS remark)：修正并发标记期间的变动部分<ul>
<li>这里要注意：重新标记就不能业务线程和垃圾线程一起执行了，也就是不能并发执行了</li>
</ul>
</li>
<li>并发清除(CMS concurrent sweep)</li>
</ul>
</li>
</ul>
<img src="/pics/image-20210417222939099.png" alt="image-20210417222939099" style="zoom:50%;" />

<h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4><ul>
<li><p>CMS收集器对CPU资源非常敏感</p>
<p>在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。</p>
</li>
<li><p>CMS收集器无法处理浮动垃圾（Floating Garbage）</p>
<p>由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”。</p>
<p>也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。</p>
</li>
<li><p>CMS是一款基于“标记—清除”算法实现的收集器。</p>
<p>收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。</p>
</li>
</ul>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><ul>
<li>Java堆，划分成一个个Region</li>
<li>标记- 整理 （整体上看）</li>
<li>运作步骤：<ul>
<li>初始标记(Initial Marking)</li>
<li>并发标记(Concurrent Marking)</li>
<li>最终标记(Final Marking)</li>
<li>筛选回收(Live Data Counting and Evacuation)</li>
</ul>
</li>
</ul>
<p><img src="/pics/image-20210417215936579.png" alt="image-20210417215936579"></p>
<p>G1优点</p>
<ol>
<li>并行与并发：多线程并行回收；工作线程和GC线程并发执行</li>
<li>分代收集：采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象</li>
<li>空间整合：G1从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的。没有CMS标记—清理的缺点。</li>
<li>可预测的停顿：这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</li>
</ol>
<h4 id="Region"><a href="#Region" class="headerlink" title="Region"></a>Region</h4><p>使用G1收集器时，Java堆的内存布局就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。</p>
<p>G1跟踪各个Region里面的垃圾堆积的价值大小<code>（回收所获得的空间大小以及回收所需时间的经验值）</code>，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</p>
<h4 id="Remembered-Set"><a href="#Remembered-Set" class="headerlink" title="Remembered Set"></a>Remembered Set</h4><p>在G1收集器中，Region之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，虚拟机都是使用Remembered Set来避免全堆扫描的。G1中每个Region都有一个与之对应的Remembered Set，虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，<code>检查Reference引用的对象是否处于不同的Region之中，如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set之中</code>。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。</p>
<h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><ol>
<li><p>对象优先在Eden分配</p>
</li>
<li><p>大对象直接进入老年代</p>
</li>
<li><p>长期存活的对象将进入老年代</p>
</li>
<li><p>动态对象年龄判定</p>
<p>为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold（默认15）才能晋升老年代。</p>
<p>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</p>
</li>
<li><p>空间分配担保</p>
<p>在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。</p>
<p>如果不成立，则虚拟机会判断是否允许<code>冒险担保失败（HandlePromotionFailure）</code>。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者不允许冒险担保，那这时也要改为进行一次Full GC。</p>
</li>
</ol>
<p>“冒险”是冒了什么风险？</p>
<blockquote>
<p>前面提到过，新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。</p>
<p>与生活中的贷款担保类似，老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象会活下来在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。</p>
</blockquote>
<p>Minor GC和Full GC有什么不一样吗？</p>
<blockquote>
<p>新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。</p>
<p>老年代GC（Major GC/Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。</p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM_08_方法区</title>
    <url>/2021/04/17/Notes/Java/JVM/JVM_08_%E6%96%B9%E6%B3%95%E5%8C%BA/</url>
    <content><![CDATA[<h1 id="JVM-08-方法区"><a href="#JVM-08-方法区" class="headerlink" title="JVM_08_方法区"></a>JVM_08_方法区</h1><p><strong>方法区主要存放的是 Class</strong>，<strong>而堆中主要存放的是实例化的对象</strong>，<strong>方法区可以看作是一块独立于Java堆的内存空间</strong>。</p>
<ul>
<li>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域</li>
<li>多个线程同时加载统一个类时，只能有一个线程能加载该类，其他线程只能等等待该线程加载完毕，然后直接使用该类，即类只能加载一次</li>
<li>方法区在JVM启动的时候被创建，并且它的实际物理内存空间和Java堆区一样都可以是不连续的。</li>
<li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展</li>
<li>方法区是接口，元空间或者永久代是方法区的实现</li>
<li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：java.lang.OutofMemoryError:PermGen space（JDK7之前）或者 java.lang.OutOfMemoryError:Metaspace（JDK8之后）</li>
<li>关闭JVM就会释放方法区内存</li>
</ul>
<h2 id="栈、堆、方法区的交互关系"><a href="#栈、堆、方法区的交互关系" class="headerlink" title="栈、堆、方法区的交互关系"></a>栈、堆、方法区的交互关系</h2><h3 id="线程共享的角度"><a href="#线程共享的角度" class="headerlink" title="线程共享的角度"></a>线程共享的角度</h3><p><img src="/pics/image-20210416100231841.png" alt="image-20210416100231841"></p>
<p>线程共享：堆 + 方法区，存在OOM 和 GC</p>
<p>线程私有：虚拟机栈 + 本地方法栈 + PC寄存器，虚拟机栈 + 本地方法栈存在栈溢出问题，PC寄存器</p>
<h3 id="相互的关系"><a href="#相互的关系" class="headerlink" title="相互的关系"></a>相互的关系</h3><img src="/pics/image-20210416100432888.png" alt="image-20210416100432888" style="zoom:67%;" />

<p>虚拟机栈中对象引用执行堆中的Persion对象实例数据，Persion对象的class信息又是保存在方法区中的，需要通过类型数据指针指向Persion.class类型信息。</p>
<h2 id="Hotspot中方法区的演进过程"><a href="#Hotspot中方法区的演进过程" class="headerlink" title="Hotspot中方法区的演进过程"></a>Hotspot中方法区的演进过程</h2><p><strong>在 JDK7 及以前，习惯上把方法区，称为永久代。JDK8开始，使用元空间取代了永久代</strong>。</p>
<ul>
<li>本质上，方法区和永久代并不等价。仅是对Hotspot而言的可以看作等价。</li>
<li>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。</li>
<li><strong>元空间不在虚拟机的内存中，而是使用本地内存</strong>。</li>
</ul>
<img src="/pics/image-20210416102338775.png" alt="image-20210416102338775" style="zoom:70%;" />

<h3 id="永久代的演进过程"><a href="#永久代的演进过程" class="headerlink" title="永久代的演进过程"></a>永久代的演进过程</h3><p><img src="/pics/image-20210416145726419.png" alt="image-20210416145726419"></p>
<ul>
<li>JDK6，方法区由永久代实现，使用 JVM 虚拟机内存</li>
</ul>
<p><img src="/pics/image-20210416150341751.png" alt="image-20210416150341751"></p>
<ul>
<li>JDK7 方法区由永久代实现，使用 JVM 虚拟机内存，静态变量和字符串常量池保存在堆中</li>
</ul>
<p><img src="/pics/image-20210416150504193.png" alt="image-20210416150504193"></p>
<p>JDK8及以后，方法区由元空间实现，<strong>使用本地内存</strong></p>
<img src="/pics/image-20210416150414929.png" alt="image-20210416150414929" style="zoom:70%;" />

<h3 id="元空间为什么要替代永久代"><a href="#元空间为什么要替代永久代" class="headerlink" title="元空间为什么要替代永久代"></a>元空间为什么要替代永久代</h3><ul>
<li><p>官方的牵强解释：JRockit是和HotSpot融合后的结果，因为JRockit没有永久代，所以他们不需要配置永久代，HotSpot也就取消了永久代</p>
</li>
<li><p>为永久代设置空间大小是很难确定的</p>
<p>如果动态加载类过多，容易产生Perm区的OOM。<strong>元空间并不在虚拟机中，而是使用本地内存，元空间的大小仅受本地内存限制</strong></p>
</li>
<li><p>对永久代进行调优是很困难的</p>
<ul>
<li>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再用的类型，方法 区的调优主要是为了降低Full GC</li>
<li>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。</li>
</ul>
</li>
</ul>
<h2 id="设置方法区大小与OOM"><a href="#设置方法区大小与OOM" class="headerlink" title="设置方法区大小与OOM"></a>设置方法区大小与OOM</h2><p>方法区的大小不必是固定的，JVM可以根据应用的需要动态调整</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试设置方法区大小参数的默认值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * jdk7及以前：</span></span><br><span class="line"><span class="comment"> * -XX:PermSize=100m -XX:MaxPermSize=100m</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * jdk8及以后：</span></span><br><span class="line"><span class="comment"> * -XX:MetaspaceSize=100m  -XX:MaxMetaspaceSize=100m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;end...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h3><p><strong>内存泄漏就是有大量的引用指向某些对象，但是这些对象以后不会使用了</strong>，但是因为它们还和GC ROOT有关联，所以导致以后这些对象也不会被回收，这就是内存泄漏的问题</p>
<p>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。<strong>于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的</strong>。掌握了泄漏对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置。</p>
<h2 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h2><p>它用于存储已被虚拟机加载的<strong>类型信息、运行时常量池、静态变量、即时编译器编译后的代码缓存</strong>等。</p>
<p><img src="/pics/image-20210416162001528.png" alt="image-20210416162001528"></p>
<h3 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h3><p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：</p>
<ul>
<li>这个类型的完整有效名称（全类名=包名.类名）</li>
<li>这个类型直接父类的完整有效名（对于interface或是java.lang.Object，都没有父类）</li>
<li>这个类型的修饰符（public，abstract，final的某个子集）</li>
<li>这个类型直接接口的一个有序列表</li>
</ul>
<h3 id="域（Field）信息"><a href="#域（Field）信息" class="headerlink" title="域（Field）信息"></a>域（Field）信息</h3><p>JVM 必须在方法区中保存类型的所有域的相关信息以及域的声明顺序</p>
<ul>
<li><p><code>域信息</code>通俗来讲是类的成员变量（static 修饰）</p>
</li>
<li><p>域的相关信息包括：域名称、域类型、域修饰符（public、private、protected、static、final、volatile、transient 的某个子集）</p>
</li>
</ul>
<h3 id="方法（Method）信息"><a href="#方法（Method）信息" class="headerlink" title="方法（Method）信息"></a>方法（Method）信息</h3><p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p>
<ul>
<li>方法名称</li>
<li>方法的返回类型</li>
<li>方法参数的数量和类型</li>
<li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract 的一个子集）</li>
<li>方法的字符码（bytecodes）、操作数栈、局部变量表及大小（abstract 和 native 方法除外）</li>
<li>异常表（abstract 和 native 方法除外），每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li>
</ul>
<blockquote>
<p>static final 修饰的常量在编译的时候就会被分配了。</p>
</blockquote>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。</p>
<ul>
<li>运行时常量池，JVM加载类和后，就会创建对应的运行时常量池。</li>
<li>JVM为每个类都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。</li>
<li>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。<strong>此时不再是常量池中的符号应用了，这里换为直接引用（真实地址）</strong>。</li>
<li>运行时常量池，相对于Class文件常量池的另一重要特征是：<strong>具备动态性</strong>。不如可以通过String.intern() 向运行时常量池中放置常量。</li>
</ul>
<blockquote>
<p>常量池和运行时常量池</p>
<p><strong>常量池表（Constant Pool Table）是Class字节码文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中</strong>。</p>
<p><strong>运行时常量池（Runtime Constant Pool）是方法区的一部分</strong>。</p>
</blockquote>
<h4 id="为什么需要常量池？"><a href="#为什么需要常量池？" class="headerlink" title="为什么需要常量池？"></a>为什么需要常量池？</h4><p>字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外，还包含一项信息就是<strong>常量池表</strong>（<strong>Constant Pool Table</strong>），包括<strong>各种字面量（属性值）和对类型、域（成员变量）和方法的符号引用</strong>。</p>
<img src="/pics/image-20210417184336117.png" alt="image-20210417184336117" style="zoom:30%;" />

<p>Java文件中的类、接口，编译后产生字节码文件，而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，所以使用<strong>符号引用</strong>的方式存到了常量池。而这些符号引用，在程序运行时被转化为<strong>直接引用</strong>（地址），这个过程称为<strong>动态链接</strong>。</p>
<h3 id="内部结构举例"><a href="#内部结构举例" class="headerlink" title="内部结构举例"></a>内部结构举例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodInnerStrucTest</span> <span class="keyword">extends</span> <span class="title">Object</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> xx = <span class="number">1001L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> yy = <span class="number">1000L</span>;</span><br><span class="line">    <span class="keyword">private</span> String nihao = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String str = <span class="string">&quot;测试方法的内部结构&quot;</span>;</span><br><span class="line">    <span class="comment">//构造器没写</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">20</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;count = &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test2</span><span class="params">(<span class="keyword">int</span> cal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> value = <span class="number">30</span>;</span><br><span class="line">            result = value / cal;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ======反编译字节码结果====</span></span><br><span class="line">Classfile /E:/work/JavaLearn/out/production/jvm/MethodInnerStrucTest.class</span><br><span class="line">  Last modified <span class="number">2021</span>-<span class="number">4</span>-<span class="number">16</span>; size <span class="number">1646</span> bytes</span><br><span class="line">  MD5 checksum ea25c6e80bbc8e5b2650095fd4359124</span><br><span class="line">  Compiled from <span class="string">&quot;MethodInnerStructTest.java&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodInnerStrucTest</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Comparable</span>&lt;<span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class">  <span class="title">minor</span> <span class="title">version</span>: 0</span></span><br><span class="line"><span class="class">  <span class="title">major</span> <span class="title">version</span>: 52</span></span><br><span class="line"><span class="class">  <span class="title">flags</span>: <span class="title">ACC_SUPER</span></span></span><br><span class="line"><span class="class"><span class="title">Constant</span> <span class="title">pool</span>: // 常量池</span></span><br><span class="line"><span class="class">   #1 </span>= Methodref          #<span class="number">20.</span>#<span class="number">55</span>        <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">19.</span>#<span class="number">56</span>        <span class="comment">// MethodInnerStrucTest.num:I</span></span><br><span class="line">   #<span class="number">3</span> = String             #<span class="number">57</span>            <span class="comment">// hello world</span></span><br><span class="line">   #<span class="number">4</span> = Fieldref           #<span class="number">19.</span>#<span class="number">58</span>        <span class="comment">// MethodInnerStrucTest.nihao:Ljava/lang/String;</span></span><br><span class="line">   #<span class="number">5</span> = Fieldref           #<span class="number">59.</span>#<span class="number">60</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   #<span class="number">6</span> = Class              #<span class="number">61</span>            <span class="comment">// java/lang/StringBuilder</span></span><br><span class="line">   #<span class="number">7</span> = Methodref          #<span class="number">6.</span>#<span class="number">55</span>         <span class="comment">// java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">8</span> = String             #<span class="number">62</span>            <span class="comment">// count =</span></span><br><span class="line">   #<span class="number">9</span> = Methodref          #<span class="number">6.</span>#<span class="number">63</span>         <span class="comment">// java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">  #<span class="number">10</span> = Methodref          #<span class="number">6.</span>#<span class="number">64</span>         <span class="comment">// java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span></span><br><span class="line">  #<span class="number">11</span> = Methodref          #<span class="number">6.</span>#<span class="number">65</span>         <span class="comment">// java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">  #<span class="number">12</span> = Methodref          #<span class="number">66.</span>#<span class="number">67</span>        <span class="comment">// java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">  #<span class="number">13</span> = Class              #<span class="number">68</span>            <span class="comment">// java/lang/Exception</span></span><br><span class="line">  #<span class="number">14</span> = Methodref          #<span class="number">13.</span>#<span class="number">69</span>        <span class="comment">// java/lang/Exception.printStackTrace:()V</span></span><br><span class="line">  #<span class="number">15</span> = Class              #<span class="number">70</span>            <span class="comment">// java/lang/String</span></span><br><span class="line">  #<span class="number">16</span> = Methodref          #<span class="number">19.</span>#<span class="number">71</span>        <span class="comment">// MethodInnerStrucTest.compareTo:(Ljava/lang/String;)I</span></span><br><span class="line">  #<span class="number">17</span> = String             #<span class="number">72</span>            <span class="comment">// 测试方法的内部结构</span></span><br><span class="line"><span class="comment">// 省略 ...</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> num; <span class="comment">// 域信息</span></span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: <span class="function">ACC_PUBLIC</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>; <span class="comment">// 方法信息</span></span><br><span class="line">    descriptor: ()V    <span class="comment">// 方法返回值</span></span><br><span class="line">    flags: ACC_PUBLIC  <span class="comment">// 方法修饰符 </span></span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span> <span class="comment">//方法字节码信息</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">20</span></span><br><span class="line">         <span class="number">2</span>: istore_1</span><br><span class="line">         <span class="number">3</span>: getstatic     #<span class="number">5</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">6</span>: <span class="keyword">new</span>           #<span class="number">6</span>                  <span class="comment">// class java/lang/StringBuilder</span></span><br><span class="line">         <span class="number">9</span>: dup</span><br><span class="line">        <span class="number">10</span>: invokespecial #<span class="number">7</span>                  <span class="comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        <span class="number">13</span>: ldc           #<span class="number">8</span>                  <span class="comment">// String count =</span></span><br><span class="line">        <span class="number">15</span>: invokevirtual #<span class="number">9</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">        <span class="number">18</span>: iload_1</span><br><span class="line">        <span class="number">19</span>: invokevirtual #<span class="number">10</span>                 <span class="comment">// Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span></span><br><span class="line">        <span class="number">22</span>: invokevirtual #<span class="number">11</span>                 <span class="comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">        <span class="number">25</span>: invokevirtual #<span class="number">12</span>                 <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">        <span class="number">28</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">13</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">14</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">15</span>: <span class="number">28</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">29</span>     <span class="number">0</span>  <span class="keyword">this</span>   LMethodInnerStrucTest;</span><br><span class="line">            <span class="number">3</span>      <span class="number">26</span>     <span class="number">1</span> count   I</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         <span class="number">0</span>: ldc           #<span class="number">17</span>                 <span class="comment">// String 测试方法的内部结构</span></span><br><span class="line">         <span class="number">2</span>: putstatic     #<span class="number">18</span>                 <span class="comment">// Field str:Ljava/lang/String;</span></span><br><span class="line">         <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">Signature: #<span class="number">52</span>                          <span class="comment">// Ljava/lang/Object;Ljava/lang/Comparable&lt;Ljava/lang/String;&gt;;Ljava/io/Serializable;</span></span><br><span class="line">SourceFile: <span class="string">&quot;MethodInnerStructTest.java&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="字符串常量池-StringTable-为什么要调整位置？"><a href="#字符串常量池-StringTable-为什么要调整位置？" class="headerlink" title="字符串常量池 StringTable 为什么要调整位置？"></a>字符串常量池 StringTable 为什么要调整位置？</h3><p>JDK7中将StringTable放到了堆空间中。<strong>因为永久代的回收效率很低</strong>，在Full GC的时候才会执行永久代的垃圾回收，而Full GC是老年代的空间不足、永久代不足时才会触发。</p>
<p>这就导致StringTable回收效率不高，而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。<strong>放到堆里，能及时回收内存</strong>。</p>
<h3 id="静态变量对象存放在哪里？"><a href="#静态变量对象存放在哪里？" class="headerlink" title="静态变量对象存放在哪里？"></a>静态变量对象存放在哪里？</h3><p>静态变量引用对应的对象实体始终都在堆空间中（符合堆的内存分配规则） ，变量引用放在了元空间。</p>
<p><img src="/pics/image-20210418203012633.png" alt="image-20210418203012633"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 结论：</span></span><br><span class="line"><span class="comment"> *  静态变量在jdk6/7存在与永久代中，在jdk8存在于堆中 //private static byte[] arr</span></span><br><span class="line"><span class="comment"> *  静态引用对应的对象实体始终都存在堆空间 //new byte[1024 * 1024 * 100];</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * jdk7：</span></span><br><span class="line"><span class="comment"> * -Xms200m -Xmx200m -XX:PermSize=300m -XX:MaxPermSize=300m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> * jdk 8：</span></span><br><span class="line"><span class="comment"> * -Xms200m -Xmx200m -XX:MetaspaceSize=300m -XX:MaxMetaspaceSize=300m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticFieldTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>]; <span class="comment">//100MB</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(StaticFieldTest.arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h3><p>方法区内常量池之中主要存放的两大类常量：<strong>字面量和符号引用</strong></p>
<ul>
<li>字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等</li>
<li>符号引用则属于编译原理方面的概念，包括下面三类常量：<ul>
<li>类和接口的全限定名</li>
<li>域（字段）的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
</li>
</ul>
<p>HotSpot虚拟机对常量池的回收策略是很明确的，<code>只要运行时常量池中的常量没有被任何地方引用，就可以被回收</code>。</p>
<p>而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了</p>
<ul>
<li><strong>该类所有的实例都已经被回收</strong>，也就是Java堆中不存在该类及其任何派生子类的实例。</li>
<li><strong>该类的类加载器已经被回收</strong>，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</li>
<li><strong>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</strong></li>
</ul>
<p>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用<code>-verbose:class 以及 -XX：+TraceClass-Loading、-XX：+TraceClassUnLoading</code>查看类加载和卸载信息。</p>
<p>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及 OSGi 这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</p>
<h3 id="大厂面试题"><a href="#大厂面试题" class="headerlink" title="大厂面试题"></a>大厂面试题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">百度</span><br><span class="line"></span><br><span class="line">三面：说一下JVM内存模型吧，有哪些区？分别干什么的？</span><br><span class="line">字节跳动</span><br><span class="line"></span><br><span class="line">二面：Java的内存分区</span><br><span class="line">二面：讲讲vm运行时数据库区</span><br><span class="line">什么时候对象会进入老年代？</span><br><span class="line">蚂蚁金服</span><br><span class="line"></span><br><span class="line">Java8的内存分代改进</span><br><span class="line">JVM内存分哪几个区，每个区的作用是什么？</span><br><span class="line">一面：JVM内存分布/内存结构？栈和堆的区别？堆的结构？为什么两个survivor区？</span><br><span class="line">二面：Eden和survior的比例分配</span><br><span class="line">小米</span><br><span class="line"></span><br><span class="line">jvm内存分区，为什么要有新生代和老年代</span><br><span class="line">京东</span><br><span class="line"></span><br><span class="line">JVM的内存结构，Eden和Survivor比例。</span><br><span class="line">JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和survivor。</span><br><span class="line">天猫</span><br><span class="line"></span><br><span class="line">一面：Jvm内存模型以及分区，需要详细到每个区放什么。</span><br><span class="line">一面：JVM的内存模型，Java8做了什么改</span><br><span class="line">拼多多</span><br><span class="line"></span><br><span class="line">JVM内存分哪几个区，每个区的作用是什么？</span><br><span class="line">美团</span><br><span class="line"></span><br><span class="line">java内存分配</span><br><span class="line">jvm的永久代中会发生垃圾回收吗？</span><br><span class="line">一面：jvm内存分区，为什么要有新生代和老年代</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM_07_本地方法栈</title>
    <url>/2021/04/12/Notes/Java/JVM/JVM_07_%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/</url>
    <content><![CDATA[<h1 id="JVM-07-本地方法栈"><a href="#JVM-07-本地方法栈" class="headerlink" title="JVM_07_本地方法栈"></a>JVM_07_本地方法栈</h1><img src="/pics/image-20210412214838032.png" alt="image-20210412214838032" style="zoom:50%;" />

<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>Java 虚拟机栈用于管理 Java 方法的调用，而<code>本地方法栈(Native Method Stack)</code>用于管理本地方法的调用。</p>
<ul>
<li>本地方法栈也是线程私有的</li>
<li>允许线程固定或者可动态扩展的内存大小<ul>
<li>如果线程请求分配的栈容量<code>超过本地方法栈允许的最大容量</code>，Java 虚拟机将会抛出一个 <code>StackOverflowError</code> 异常</li>
<li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么 Java虚拟机将会抛出一个<code>OutofMemoryError</code>异常</li>
</ul>
</li>
<li>本地方法一般是使用 C 语言实现的</li>
<li>它的具体做法是 <code>Native Method Stack</code> 中登记 native 方法，在 <code>Execution Engine</code> 执行时加载本地方法库当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</li>
<li><strong>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</strong><ul>
<li>本地方法可以通过本地方法接口来访问<strong>虚拟机内部的运行时数据区</strong></li>
<li>甚至可以直接使用本地处理器中的寄存器</li>
<li>直接从本地内存的堆中分配任意数量的内存</li>
</ul>
</li>
<li>并不是所有 JVM 都支持本地方法。因为 Java 虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果 JVM 产品不打算支持 native 方法，也可以无需实现本地方法栈</li>
<li><strong>在 Hotspot JVM 中，直接将本地方栈和虚拟机栈合二为一</strong></li>
</ul>
<h2 id="本地方法接口-JNI"><a href="#本地方法接口-JNI" class="headerlink" title="本地方法接口(JNI)"></a>本地方法接口(JNI)</h2><p>JNI(Java Native Interface) 就是Java 调用本地方法库（一般是C或C++库）接口。</p>
<ul>
<li>在定义一个native method时，<strong>并不提供实现体</strong>（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。</li>
<li>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是<code>融合C/C++程序</code>。</li>
</ul>
<p>JDK 中有很多被native关键修饰的方法。比如Object#getClass( )等等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure>

<h3 id="为什么要使用本地方法（NativeMethod）？"><a href="#为什么要使用本地方法（NativeMethod）？" class="headerlink" title="为什么要使用本地方法（NativeMethod）？"></a>为什么要使用本地方法（NativeMethod）？</h3><p>Java使用起来非常方便，<code>然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时</code>，问题就来了。</p>
<ul>
<li><strong>与Java环境外交互</strong><br><code>有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因</code>。你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。<br>本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</li>
<li><strong>与操作系统的交互</strong><br>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。<br><code>通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的</code>。<br>还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</li>
<li><strong>Sun’s Java</strong><br><code>Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。</code><br>例如：类java.lang.Thread的setPriority( )方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriority0( )。这个本地方法是用C实现的，并被植入JVM内部在Windows 95的平台上，这个本地方法最终将调用Win32 setpriority( ) API。<br>这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。</li>
</ul>
<blockquote>
<p>总结：Java方法可以通过JNI调用到本地方法；本地方法是在本地方法栈中执行的。</p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM_06_堆</title>
    <url>/2021/04/17/Notes/Java/JVM/JVM_06_%E5%A0%86/</url>
    <content><![CDATA[<h1 id="JVM-06-堆"><a href="#JVM-06-堆" class="headerlink" title="JVM_06_堆"></a>JVM_06_堆</h1><p>堆（Heap）存放对象实例，几乎所有的对象实例以及数据都在这里分配内存。</p>
<p>一个进程对应一个JVM实例，一个JVM实例对应一个堆空间进程包含多个线程，所以线程之间共享同一个堆空间堆也是Java内存管理的核心区域。</p>
<ul>
<li>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了，堆是JVM管理的最大一块内存空间，它的大小是可以调节的。</li>
<li>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</li>
<li>《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。</li>
<li>《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。从实际使用角度看的：“几乎”所有的对象实例都在这里分配内存。因为还有一些对象是在栈上分配的（逃逸分析，标量替换）</li>
<li>堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集（GC）的时候才会被移除。如果堆中对象马上被回收，那么用户线程就会收到影响，因为有 stop the word。</li>
</ul>
<img src="/pics/image-20210415113030622.png" alt="image-20210415113030622" style="zoom:80%;" />

<h2 id="内存划分"><a href="#内存划分" class="headerlink" title="内存划分"></a>内存划分</h2><p>Java 8之前堆内存逻辑上分为三部分：<strong>新生代 + 老年代 + 永久代</strong>，新生代又可划分为 <strong>Eden区 和 Survivor区</strong>。</p>
<p><img src="/pics/image-20210415152003048.png" alt="image-20210415152003048"></p>
<p>Java 8及之后堆内存，<code>永久代</code> 被替换成 <code>元空间</code>，<code>永久代/元空间</code>，实际上控制不到。</p>
<img src="/pics/image-20210415115152421.png" alt="image-20210415115152421" style="zoom:70%;" />



<h3 id="新生代-Young-Generation"><a href="#新生代-Young-Generation" class="headerlink" title="新生代 (Young Generation)"></a>新生代 (Young Generation)</h3><p>年轻代是所有新对象创建的地方。当填充年轻代时，执行垃圾收集。这种垃圾收集称为 <strong>Minor GC</strong>。年轻代被分为三个部分伊甸园（<strong>Eden Memory</strong>）和两个幸存区（<strong>Survivor Memory</strong>，被称为from/to或s0/s1），默认比例是<code>8:1:1</code></p>
<h3 id="老年代-Old-Generation"><a href="#老年代-Old-Generation" class="headerlink" title="老年代(Old Generation)"></a>老年代(Old Generation)</h3><p>经过多轮MinorGC 后仍然存活的对象被移动到老年代。JVM默认<strong>新生代和老年代的比例是1：2</strong>。老年代垃圾收集MajorGC，通常需要更长的时间。</p>
<p>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象），目的是避免在Eden区和两个Survivor 区之间发生大量的内存拷贝。</p>
<h3 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h3><p>不管是 JDK8 之前的永久代，还是 JDK8 及以后的元空间，都可以看作是 Java 虚拟机规范中方法区的实现。</p>
<p>虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 <strong>Non-Heap（非堆）</strong>，目的应该是与 Java 堆区分开。所以元空间放在后边的方法区再说。</p>
<h2 id="对象分配的过程"><a href="#对象分配的过程" class="headerlink" title="对象分配的过程"></a>对象分配的过程</h2><p><img src="/pics/image-20210415162006461.png" alt="image-20210415162006461"></p>
<blockquote>
<p>注意：上图中的FullGC可以理解为老年代GC ，等价于 MajorGC，不区分majorGC和FullGC。</p>
</blockquote>
<h3 id="图解对象分配"><a href="#图解对象分配" class="headerlink" title="图解对象分配"></a>图解对象分配</h3><ol>
<li>我们创建的对象，一般都是存放在Eden区的，<strong>当我们的Eden区满了后，就会触发GC操作</strong>，一般被称为 <code>YGC / Minor GC</code>操作</li>
</ol>
<p><img src="/pics/image-20210415155215283.png" alt="image-20210415155215283"></p>
<ol start="2">
<li><p>当我们进行一次垃圾收集后，红色的对象将会被回收，而绿色的独享还被占用着，存放在S0(Survivor From)区。同时我们给每个对象设置了一个年龄计数器，经过一次回收后还存在的对象，将其年龄加 1。</p>
</li>
<li><p>同时Eden区继续存放对象，当Eden区再次存满的时候，又会触发一个MinorGC操作，此时GC将会把 Eden和S0中的对象进行一次垃圾收集，把存活的对象放到 S1区，同时让存活的对象年龄 + 1</p>
<p><img src="/pics/image-20210415155539388.png" alt="image-20210415155539388"></p>
</li>
<li><p>此时若再次经历MinorGC，又会对Eden区和S1区进行清理，剩下的对象放到S0区，也就是说S0和S1（from和to）在minorGC时<code>逻辑上</code>是不停交换的</p>
</li>
<li><p>我们继续不断的进行对象生成和垃圾回收，当Survivor中的对象的年龄达到15的时候（-XX:MaxTenuringThreshold 设置），将会触发一次 <code>Promotion 晋升</code>的操作，也就是将年轻代中的对象晋升到老年代中</p>
</li>
</ol>
<p><img src="/pics/image-20210415155419659.png" alt="image-20210415155419659"></p>
<blockquote>
<p>注意：在Eden区满了的时候，才会触发MinorGC，而Survivor区满了，不会触发MinorGC操作</p>
</blockquote>
<h3 id="对象分配的特殊情况"><a href="#对象分配的特殊情况" class="headerlink" title="对象分配的特殊情况"></a>对象分配的特殊情况</h3><ol>
<li><p><strong>Eden区存放对象</strong></p>
<ol>
<li>如果 Eden 放得下，则直接放到 Eden 区</li>
<li>如果 Eden 放不下，则触发 MinorGc，执行垃圾回收；如果还不能放下，则直接放入到老年代</li>
<li>如果 Eden 区满了，MinorGC完将对象往Survivor拷贝时，发现Survivor放不下，直接晋升至老年代</li>
</ol>
</li>
<li><p><strong>将对象存放到老年代</strong></p>
<ul>
<li>如果 Eden 执行了MinorGc 还是无法放不下该对象，说明是超大对象，只能直接放到到老年代</li>
<li>老年代都放不下，则先触发MajorGC ，再看看能不能放下，如果还是放不下，就会报 OOM</li>
</ul>
</li>
</ol>
<h3 id="对象分配原则"><a href="#对象分配原则" class="headerlink" title="对象分配原则"></a>对象分配原则</h3><ul>
<li>new 对象优先分配到Eden</li>
<li>大对象直接分配到老年代</li>
<li>长期存活的对象分配到老年代</li>
<li><strong>动态对象年龄判断</strong>：如果Survivor区中相同年龄的所有对象大小的总和 大于 Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</li>
<li><strong>空间分配担保</strong>：经过Minor GC后，所有的对象都存活，因为Survivor比较小，所以就需要将Survivor无法容纳的对象，存放到老年代中</li>
</ul>
<h3 id="相关JVM参数"><a href="#相关JVM参数" class="headerlink" title="相关JVM参数"></a>相关JVM参数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 设置堆空间大小的参数</span></span><br><span class="line"><span class="comment"> * -Xms 用来设置堆空间（年轻代+老年代）的初始内存大小</span></span><br><span class="line"><span class="comment"> *      -X 是jvm的运行参数</span></span><br><span class="line"><span class="comment"> *      ms 是memory start</span></span><br><span class="line"><span class="comment"> * -Xmx 用来设置堆空间（年轻代+老年代）的最大内存大小</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. 默认堆空间的大小</span></span><br><span class="line"><span class="comment"> *      初始内存大小：物理电脑内存大小 / 64</span></span><br><span class="line"><span class="comment"> *      最大内存大小：物理电脑内存大小 / 4</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3. 手动设置：-Xms600m -Xmx600m</span></span><br><span class="line"><span class="comment"> *     开发中建议将初始堆内存和最大的堆内存设置成相同的值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 4. 查看设置的参数：方式一： jps   /  jstat -gc 进程id</span></span><br><span class="line"><span class="comment"> *                  方式二：-XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSpaceInitial</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回Java虚拟机中的堆内存总量</span></span><br><span class="line">        <span class="keyword">long</span> initialMemory = Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">        <span class="comment">//返回Java虚拟机试图使用的最大堆内存量</span></span><br><span class="line">        <span class="keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-Xms : &quot;</span> + initialMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-Xmx : &quot;</span> + maxMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Minor-GC、Major-GC、Full-GC"><a href="#Minor-GC、Major-GC、Full-GC" class="headerlink" title="Minor GC、Major GC、Full GC"></a>Minor GC、Major GC、Full GC</h2><p>JVM在进行GC时，并非每次都对上面三个内存( 新生代、老年代；方法区 )区域一起回收的，大部分时候回收的都是指新生代。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）</p>
<p>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：</p>
<ul>
<li><strong>新生代收集（ Minor GC/Young GC ）</strong>：只是新生代( Eden、S0/S1 )的垃圾收集</li>
<li><strong>老年代收集（ Major GC/Old GC</strong> ）：只是老年代的垃圾收集<ul>
<li>目前，只有CMS GC会有单独收集老年代的行为</li>
<li><code>注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</code></li>
</ul>
</li>
<li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。目前，只有G1 GC会有这种行为</li>
<li><strong>整堆收集（Full GC）</strong>：收集整个java堆和方法区的垃圾收集</li>
</ul>
<h3 id="新生代-GC（Minor-GC）触发机制"><a href="#新生代-GC（Minor-GC）触发机制" class="headerlink" title="新生代 GC（Minor GC）触发机制"></a>新生代 GC（Minor GC）触发机制</h3><p>当新生代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden区满，Survivor区满不会触发GC。（每次Minor GC会清理年轻代的内存）</p>
<p>因为Java对象<code>大多都具备朝生夕灭</code>的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解</p>
<p>Minor GC会引发STW，暂停其它用户的线程，等待垃圾回收线程结束，用户线程才恢复运行</p>
<h3 id="老年代GC（Major-GC）-触发机制"><a href="#老年代GC（Major-GC）-触发机制" class="headerlink" title="老年代GC（Major GC） 触发机制"></a>老年代GC（Major GC） 触发机制</h3><ul>
<li>指发生在老年代的GC，对象从老年代消失时，我们说 “Major Gc” 或 “Full GC” 发生了</li>
<li>出现了MajorGc，经常会伴随至少一次的Minor GC但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程<ul>
<li>也就是在老年代空间不足时，会先尝试触发Minor GC，如果之后空间还不足，则触发Major GC</li>
</ul>
</li>
<li>Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长</li>
<li>如果Major GC后，内存还不足，就报OOM了</li>
</ul>
<h3 id="整堆收集（Full-GC）触发机制"><a href="#整堆收集（Full-GC）触发机制" class="headerlink" title="整堆收集（Full GC）触发机制"></a>整堆收集（Full GC）触发机制</h3><ol>
<li><p>调用System.gc( )时，系统建议执行Full GC，但是不必然执行</p>
</li>
<li><p>老年代空间不足</p>
</li>
<li><p>方法区空间不足</p>
</li>
<li><p>通过Minor GC后进入老年代的平均大小 大于 老年代的可用内存</p>
</li>
<li><p>由Eden和From区 向 To 区复制时，对象大小大于To 区的可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</p>
<p>说明：Full GC 是开发或调优中尽量要避免的。这样STW时间会短一些。</p>
</li>
</ol>
<h2 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h2><p>TLAB：Thread Local Allocation Buffer，Eden为每个线程单独分配了一个私有缓冲区域</p>
<ul>
<li><strong>JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内</strong>。</li>
<li>多线程同时分配内存时，<strong>使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量</strong>，因此我们可以将这种内存分配方式称之为<strong>快速分配策略</strong>。</li>
</ul>
<p><img src="/pics/image-20210415212342136.png" alt="image-20210415212342136"></p>
<h3 id="为什么有TLAB（Thread-Local-Allocation-Buffer）？"><a href="#为什么有TLAB（Thread-Local-Allocation-Buffer）？" class="headerlink" title="为什么有TLAB（Thread Local Allocation Buffer）？"></a>为什么有TLAB（Thread Local Allocation Buffer）？</h3><ul>
<li>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</li>
<li>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li>
<li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</li>
</ul>
<h3 id="TLAB-分配过程"><a href="#TLAB-分配过程" class="headerlink" title="TLAB 分配过程"></a>TLAB 分配过程</h3><ul>
<li><p>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选</p>
</li>
<li><p>在程序中，开发人员可以通过选项“-XX:UseTLAB”设置是否开启TLAB空间</p>
</li>
<li><p>默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选项“-</p>
<p>XX:TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小</p>
</li>
<li><p>一旦对象在TLAB空间分配内存失败时，<strong>JVM就会尝试着通过使用加锁机制确保数据操作的原子性</strong>，从而直接在Eden空间中分配内存</p>
</li>
</ul>
<p>也就是说，JVM分配对象时预先会尝试分配在TLAB上，如果对象较大，无法分配在 TLAB 上，则JVM会试图直接分配在Eden其他位置上。</p>
<img src="/pics/image-20210415211025999.png" alt="image-20210415211025999" style="zoom:80%;" />

<h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><p>逃逸分析，根据新对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p>
<p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p>
<p>逃逸分析的基本行为就是分析对象动态作用域：</p>
<ul>
<li><strong>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸</strong>。</li>
<li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li>
</ul>
<p>使用逃逸分析，编译器可以对代码做如下优化：</p>
<ul>
<li>栈上分配</li>
<li>同步省略</li>
<li>分离对象或标量替换</li>
</ul>
<h3 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h3><ul>
<li>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。</li>
<li>分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</li>
</ul>
<h3 id="同步省略"><a href="#同步省略" class="headerlink" title="同步省略"></a>同步省略</h3><ul>
<li><p>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</p>
</li>
<li><p>在动态编译同步块的时候，<code>JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程</code>。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫<code>锁消除</code>。</p>
</li>
</ul>
<h3 id="分离对象或标量替换"><a href="#分离对象或标量替换" class="headerlink" title="分离对象或标量替换"></a>分离对象或标量替换</h3><ul>
<li>标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</li>
<li>相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</li>
<li>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point point = <span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;point.x&quot;</span> + point.x + <span class="string">&quot;;point.y&quot;</span> + point.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上代码，经过标量替换后，就会变成</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;point.x = &quot;</span> + x + <span class="string">&quot;; point.y=&quot;</span> + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于逃逸分析的论文在1999年就已经发表了，但直到JDK 1.6才有实现，而且这项技术到如今也并不是十分成熟的。</p>
<p><strong>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</strong></p>
<p>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p>
<p>虽然这项技术并不十分成熟，但是他也是即时编译器优化技术中一个十分重要的手段。</p>
<p><strong>Oracle Hotspot JVM中并未这么做</strong>，Oracle Hotspot JVM是通过标量替换实现逃逸分析的</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>新生代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</p>
<p>当然，也有特殊情况，我们知道普通的对象可能会被分配在TLAB上。如果对象较大，无法分配在 TLAB 上，则JVM会试图直接分配在Eden其他位置上。如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代</p>
</li>
<li><p>老年代放置长生命周期的对象，通常都是从Survivor区域筛选拷贝过来的Java对象。</p>
</li>
<li><p>当GC只发生在新生代中，回收新生代对象的行为被称为Minor GC</p>
</li>
<li><p>当GC发生在老年代时则被称为Major GC或者Full GC。一般的，Minor GC的发生频率要比Major GC高很多，即老年代中垃圾回收发生的频率将大大低于新生代。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM_05_虚拟机栈</title>
    <url>/2021/04/17/Notes/Java/JVM/JVM_05_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/</url>
    <content><![CDATA[<h1 id="JVM-05-虚拟机栈"><a href="#JVM-05-虚拟机栈" class="headerlink" title="JVM_05_虚拟机栈"></a>JVM_05_虚拟机栈</h1><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。</p>
<p>Java虚拟机栈描述的是<strong>方法执行的内存模型</strong>：每个方法执行时都会创建一个<strong>栈帧</strong>，方法从调用到执行完成，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p>
<p>Java虚拟机栈的生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了。栈是线程私有的，对于栈来说不存在垃圾回收 (GC) 问题，但存在栈溢出的情况（StackOverFlowError）</p>
<p>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。</p>
<ul>
<li>JVM直接对Java栈的操作只有两个：<ul>
<li>方法时执行入栈</li>
<li>执行结束后出栈</li>
</ul>
</li>
<li>对于栈来说不存在垃圾回收 (GC) 问题，但是栈存在溢出的情况</li>
</ul>
<p>Java 虚拟机规范允许<code>Java栈的大小是动态的或者是固定不变的</code>。</p>
<ul>
<li>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。<br>如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个<code>StackoverflowError</code> 异常（栈溢出）。</li>
<li>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 <code>OutOfMemoryError</code> 异常。</li>
</ul>
<p>可以通过参数<code>-Xss</code>来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。</p>
<h1 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h1><p>每个线程都有自己的栈，栈中的数据都是以<code>栈帧（Stack Frame）</code>为基本单位存储的。</p>
<p><strong>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</strong></p>
<p>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</p>
<h2 id="栈的运行原理"><a href="#栈的运行原理" class="headerlink" title="栈的运行原理"></a>栈的运行原理</h2><ul>
<li>JVM 直接对 Java 栈的操作只有两个，对栈帧的<strong>压栈</strong>和<strong>出栈</strong>，遵循<code>FILO</code>原则</li>
<li>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为<strong>当前栈帧</strong>（Current Frame），与当前栈帧对应的方法就是<strong>当前方法</strong>（Current Method），定义这个方法的类就是<strong>当前类</strong>（Current Class）</li>
<li>执行引擎运行的字节码指令只针对当前栈帧进行操作，PC寄存器中存储也是当前栈帧的执行地址。</li>
<li><strong>不同线程中所包含的栈帧是不允许存在相互引用的，即线程间私有数据是隔离的</strong>。</li>
<li>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，称为新的当前栈帧</li>
<li>当前方法返回时，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧</li>
<li>Java 方法有两种返回函数的方式，<strong>一种是正常的函数返回，使用 return 指令，另一种是抛出异常，不管用哪种方式，都会导致栈帧被弹出</strong></li>
</ul>
<img src="/pics/image-20210411223806924.png" alt="image-20210411223806924" style="zoom:33%;" />

<h2 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h2><p>每个<strong>栈帧</strong>（Stack Frame）中存储着：</p>
<ul>
<li><code>局部变量表（Local Variables）</code></li>
<li><code>操作数栈（Operand Stack）(或称为表达式栈)</code></li>
<li>动态链接（Dynamic Linking）：指向运行时常量池中当前方法引用</li>
<li>方法返回地址（Return Address）：方法正常退出或异常退出的地址</li>
<li>一些附加信息</li>
</ul>
<img src="/pics/image-20210411223657857.png" alt="image-20210411223657857" style="zoom:33%;" />

<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>局部变量表：Local Variables，也被称之为局部变量数组或本地变量表，是一组变量值存储空间，<strong>用于存放方法参数和方法内定义的局部变量</strong>。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li><strong>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</strong>，这些数据类型包括各类基本数据类型、对象引用（reference），以及 returnAddress(返回值) 类型</li>
<li>由于局部变量表是建立在线程的栈上，是线程的私有数据，<strong>因此不存在数据安全问题</strong></li>
<li><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的Code属性的maximum local variables数据项中，方法运行期间局部变量表的大小是不会改变。</li>
<li>对于一个方法来说<ul>
<li><strong>方法嵌套调用的次数由栈的大小决定</strong>。一般来说，栈越大，方法嵌套调用次数越多</li>
<li>方法的参数和局部变量越多，<strong>局部变量表越大，它的栈帧就越大</strong>。进而方法调用就会占用更多的栈空间，导致其嵌套调用次数就会减少</li>
</ul>
</li>
<li>局部变量表中的变量只在当前方法调用中有效<ul>
<li>在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程</li>
<li>当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁</li>
</ul>
</li>
<li><strong>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</strong></li>
</ul>
<h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>通过jclasslib 查看字节码信息，java代码及其对应的字节码结构如图所示。</p>
<img src="/pics/image-20210413113124288.png" alt="image-20210413113124288" style="zoom:100%;" /> 

<h4 id="Slot"><a href="#Slot" class="headerlink" title="Slot"></a>Slot</h4><p>Slot（变量槽），局部变量表的最基本存储单元。</p>
<ul>
<li><p>局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</p>
<ul>
<li>32位以内的类型（包括 <strong>引用类型、returnAddress类型</strong>）只占用一个slot；64位的类型（long和double）占用两个slot</li>
<li>byte、short、char 在存储前被转换为int，boolean 也被转换为int（false -&gt; 0，true- &gt; 非零），long 和 double 则占据两个Slot</li>
</ul>
</li>
<li><p>方法被调用的时候，<strong>方法参数和方法体内定义的局部变量将会按照顺序被复制到局部变量表中的每一个slot上</strong></p>
<ul>
<li>局部变量表中的每一个Slot有一个访问索引，通过这个索引可访问到局部变量值</li>
<li>访问64bit（long或double类型变量）的局部变量时，只需要使用起始索引</li>
</ul>
</li>
<li><p>对于构造方法或者实例方法，那么<strong>该对象this引用将会存放在index为0的slot处</strong>，其余的参数按照参数表顺序排列</p>
</li>
<li><p><strong>栈帧中的局部变量表中的槽位是可以重用的</strong>，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而<strong>达到节省资源的目的</strong>。下图中，this、a、b、c 理论上应该有 4 个变量，<strong>c 复用了 b 的槽</strong></p>
<img src="/pics/image-20210413221825354.png" alt="image-20210413221825354" style="zoom:70%;" /></li>
</ul>
<h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。</p>
<ul>
<li><p>操作数栈就是 JVM 执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，此时这个方法的操作数栈是空的。</p>
</li>
<li><p>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在<code>编译期</code>就定义好了，保存在方法的 Code 属性的 <code>stack</code> 数据项中</p>
<img src="/pics/image-20210415005545972.png" alt="image-20210415005545972" style="zoom:50%;" /></li>
<li><p>方法执行过程中，根据字节码指令，往操作数栈中写入数据或取出数据</p>
<ul>
<li>栈中的任何一个元素都可以是任意的 Java 数据类型。32bit 的类型占用一个栈单位深度，64bit 的类型占用两个栈单位深度</li>
<li>操作数栈并非采用索引方式进行数据访问，只能通过入栈和出栈来完成数据访问</li>
</ul>
</li>
<li><p>另外，我们说<strong>Java虚拟机的解释引擎是基于栈的执行引擎</strong>，其中的栈指的就是操作数栈</p>
</li>
</ul>
<h4 id="栈顶缓存技术-Top-Of-Stack-Cashing"><a href="#栈顶缓存技术-Top-Of-Stack-Cashing" class="headerlink" title="栈顶缓存技术(Top Of Stack Cashing)"></a>栈顶缓存技术(Top Of Stack Cashing)</h4><p>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数。</p>
<p>由于<strong>操作数是存储在内存中</strong>的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，将<code>栈顶元素</code>全部缓存在<code>物理CPU的寄存器</code>中，以此降低对内存的读/写次数，提升执行引擎的执行效率。</p>
<h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a><strong>动态链接</strong></h3><p>动态链接（Dynamic Linking），指向运行时常量池的该栈帧所属<code>方法的引用</code>。每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态链接。</p>
<p>在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为<strong>符号引用</strong>（Symbolic Reference）保存在 Class 文件的常量池中。</p>
<p>字节码中的方法调用指令就是以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或第一次使用时转化为直接引用，这种转化称为静态链接（或静态解析）。另一部分将在每一次运行期间转化为直接引用，这部分称为动态链接。</p>
<p>为什么要用常量池呢？</p>
<ul>
<li>不同的方法，都可能调用相同常量或者方法，所以<code>只需要存储一份即可，然后记录其引用即可，节省空间</code></li>
<li>常量池的作用：就是为了提供一些符号和常量，便于指令的识别</li>
</ul>
<img src="/pics/image-20210414205105346.png" alt="image-20210414205105346" style="zoom:33%;" />

<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicLinkingTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodA()....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodB()....&quot;</span>);</span><br><span class="line">        methodA();</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ============反编译字节码命令 ============</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// =====常量池===========  </span></span><br><span class="line"></span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">9.</span>#<span class="number">23</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">8.</span>#<span class="number">24</span>         <span class="comment">// cn/sxt/java1/DynamicLinkingTest.num:I</span></span><br><span class="line">   #<span class="number">3</span> = Fieldref           #<span class="number">25.</span>#<span class="number">26</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   #<span class="number">4</span> = String             #<span class="number">27</span>            <span class="comment">// methodA()....</span></span><br><span class="line">   #<span class="number">5</span> = Methodref          #<span class="number">28.</span>#<span class="number">29</span>        <span class="comment">// java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">   #<span class="number">6</span> = String             #<span class="number">30</span>            <span class="comment">// methodB()....</span></span><br><span class="line">   #<span class="number">7</span> = Methodref          #<span class="number">8.</span>#<span class="number">31</span>         <span class="comment">// cn/sxt/java1/DynamicLinkingTest.methodA:()V</span></span><br><span class="line">   #<span class="number">8</span> = Class              #<span class="number">32</span>            <span class="comment">// cn/sxt/java1/DynamicLinkingTest</span></span><br><span class="line">   #<span class="number">9</span> = Class              #<span class="number">33</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">  #<span class="number">10</span> = Utf8               num</span><br><span class="line">  #<span class="number">11</span> = Utf8               I</span><br><span class="line">  #<span class="number">12</span> = Utf8               &lt;init&gt;</span><br><span class="line">  #<span class="number">13</span> = Utf8               ()V</span><br><span class="line">  #<span class="number">14</span> = Utf8               Code</span><br><span class="line">  #<span class="number">15</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">16</span> = Utf8               LocalVariableTable</span><br><span class="line">  #<span class="number">17</span> = Utf8               <span class="keyword">this</span></span><br><span class="line">  #<span class="number">18</span> = Utf8               Lcn/sxt/java1/DynamicLinkingTest;</span><br><span class="line">  #<span class="number">19</span> = Utf8               methodA</span><br><span class="line">  #<span class="number">20</span> = Utf8               methodB</span><br><span class="line">  #<span class="number">21</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">22</span> = Utf8               DynamicLinkingTest.java</span><br><span class="line">  #<span class="number">23</span> = NameAndType        #<span class="number">12</span>:#<span class="number">13</span>        <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">24</span> = NameAndType        #<span class="number">10</span>:#<span class="number">11</span>        <span class="comment">// num:I</span></span><br><span class="line">  #<span class="number">25</span> = Class              #<span class="number">34</span>            <span class="comment">// java/lang/System</span></span><br><span class="line">  #<span class="number">26</span> = NameAndType        #<span class="number">35</span>:#<span class="number">36</span>        <span class="comment">// out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">27</span> = <span class="function">Utf8               <span class="title">methodA</span><span class="params">()</span>....</span></span><br><span class="line"><span class="function">  #28 </span>= Class              #<span class="number">37</span>            <span class="comment">// java/io/PrintStream</span></span><br><span class="line">  #<span class="number">29</span> = NameAndType        #<span class="number">38</span>:#<span class="number">39</span>        <span class="comment">// println:(Ljava/lang/String;)V</span></span><br><span class="line">  #<span class="number">30</span> = <span class="function">Utf8               <span class="title">methodB</span><span class="params">()</span>....</span></span><br><span class="line"><span class="function">  #31 </span>= NameAndType        #<span class="number">19</span>:#<span class="number">13</span>        <span class="comment">// methodA:()V</span></span><br><span class="line">  #<span class="number">32</span> = Utf8               cn/sxt/java1/DynamicLinkingTest</span><br><span class="line">  #<span class="number">33</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">34</span> = Utf8               java/lang/System</span><br><span class="line">  #<span class="number">35</span> = Utf8               out</span><br><span class="line">  #<span class="number">36</span> = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #<span class="number">37</span> = Utf8               java/io/PrintStream</span><br><span class="line">  #<span class="number">38</span> = Utf8               println</span><br><span class="line">  #<span class="number">39</span> = Utf8               (Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==== 字节码命令 ====</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: getstatic     #<span class="number">3</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">3</span>: ldc           #<span class="number">6</span>                  <span class="comment">// String methodB()....</span></span><br><span class="line">         <span class="number">5</span>: invokevirtual #<span class="number">5</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">         <span class="number">8</span>: aload_0</span><br><span class="line">         <span class="number">9</span>: invokevirtual #<span class="number">7</span>                  <span class="comment">// Method methodA:()V</span></span><br><span class="line"><span class="comment">//	...  </span></span><br></pre></td></tr></table></figure>

<p>看一下methodBn调用methodA的过程</p>
<blockquote>
<p>#7 = Methodref #8.#31<br>先找 #8 ：<br>#8 = Class #32 ：去找 #32<br>#32 = Utf8 cn/sxt/java1/DynamicLinkingTest<br>结论：通过 #8 我们找到了 DynamicLinkingTest 这个类</p>
<p>再来找 #31：<br>#31 = NameAndType #19:#13 ：去找 #19 和 #13<br>#19 = Utf8 methodA ：方法名为 methodA<br>#13 = Utf8 ()V ：方法没有形参，返回值为 void<br>结论：通过 #7 我们就能找到需要调用的 methodA( ) 方法，并进行调用</p>
</blockquote>
<p>以上的过程也是符号引用转换为直接引用，就是说通过符号引用一直查找到方法名的过程。</p>
<h3 id="返回地址"><a href="#返回地址" class="headerlink" title="返回地址"></a>返回地址</h3><p>用来存放调用该方法的 <strong>PC 寄存器的值</strong>（PC寄存器存储着下一条要执行的指令）。</p>
<p><strong>方法执行完成时，调用者的 PC 寄存器的值作为返回地址，即调用该方法的指令的下一条指令的地址。</strong>而通过异常退出的，返回地址是要通过异常表来确定的，栈帧中一般不会保存这部分信息。</p>
<img src="/pics/image-20210414232209000.png" alt="image-20210414232209000" style="zoom:50%;" />



<p>一个方法的结束，有两种方式</p>
<ul>
<li>正常执行完成</li>
<li>出现未处理的异常，非正常退出</li>
</ul>
<p>这2者区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</p>
<h4 id="正常完成出口"><a href="#正常完成出口" class="headerlink" title="正常完成出口"></a>正常完成出口</h4><p>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者正常完成<br>一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。</p>
<blockquote>
<p>在字节码指令中，返回指令包含：</p>
<ul>
<li>ireturn：当返回值是boolean，byte，char，short和int类型时使用</li>
<li>lreturn：Long类型</li>
<li>freturn：Float类型</li>
<li>dreturn：Double类型</li>
<li>areturn：引用类型</li>
<li>return：返回值类型为void的方法以及类的构造器、静态代码块</li>
</ul>
</blockquote>
<h4 id="异常完成出口"><a href="#异常完成出口" class="headerlink" title="异常完成出口"></a>异常完成出口</h4><p>在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称异常完成出口。</p>
<p><img src="/pics/image-20210414230130630.png" alt="image-20210414230130630"></p>
<p>方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码 </p>
<h3 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h3><p>栈帧中还允许携带与 Java 虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息，但这些信息取决于具体的虚拟机实现。</p>
<blockquote>
<p>一般会把动态链接、方法返回地址与其他信息归为一类，称为栈帧信息。</p>
</blockquote>
<h1 id="方法调用（解析和分派）"><a href="#方法调用（解析和分派）" class="headerlink" title="方法调用（解析和分派）"></a>方法调用（解析和分派）</h1><p>方法调用并不等同于方法中的代码被执行，方法调用阶段唯一的任务就是确定被调用方法，暂时还未涉及方法内部的具体运行过程。一切方法调用在Class文件里面存储的都只是符号引用，我们知道符号引用在运行时需要转化为直接引用（方法在实际运行时内存布局中的入口地址），转换的情况有2种分别是：静态链接与动态链接。</p>
<h2 id="静态链接与动态链接"><a href="#静态链接与动态链接" class="headerlink" title="静态链接与动态链接"></a>静态链接与动态链接</h2><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p>
<ul>
<li>静态链接：<br>当一个字节码文件被装载进JVM内部时，<strong>如果被调用的目标方法在编译期确定</strong>，且运行期保持不变时，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接</li>
<li>动态链接：<br>如果被调用的方法在编译期无法被确定下来，也就是说，<strong>只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性</strong>，因此也被称之为动态链接。</li>
</ul>
<p>静态链接和动态链接对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</p>
<h4 id="方法的绑定机制"><a href="#方法的绑定机制" class="headerlink" title="方法的绑定机制"></a>方法的绑定机制</h4><ul>
<li>早期绑定<br>早期绑定就是指被调用的目标方法<strong>如果在编译期可知，且运行期保持不变时</strong>，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</li>
<li>晚期绑定<br>如果被调用的方法在编译期无法被确定下来，<strong>只能够在程序运行期根据实际的类型绑定相关的方法</strong>，这种绑定方式也就被称之为晚期绑定。</li>
</ul>
<p>随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</p>
<blockquote>
<p>解析一定是个静态的过程，在编译期间就能完全确定，而分派可能是静态的也可能是动态的。也就是说解析一定是静态链接，而分派可能是动态链接也可能是静态链接。</p>
</blockquote>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>所有方法调用的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能够成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。</p>
<p>换句话说，调用目标在程序代码写好、编译器进行编译那一刻就已经确定下来。这类方法的调用被称为<strong>解析（Resolution）</strong>。</p>
<h3 id="方法的分类"><a href="#方法的分类" class="headerlink" title="方法的分类"></a>方法的分类</h3><ul>
<li>非虚方法：如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为<code>非虚方法</code>。</li>
<li>其他方法称为虚方法。</li>
</ul>
<h3 id="方法调用指令"><a href="#方法调用指令" class="headerlink" title="方法调用指令"></a>方法调用指令</h3><ul>
<li><code>invokestatic</code>：用于调用静态方法。</li>
<li><code>invokespecial</code>：用于调用实例构造器<init>()方法、私有方法和父类中的方法。</li>
<li><code>invokevirtual</code>：用于调用所有的虚方法。</li>
<li><code>invokeinterface</code>：用于调用接口方法，会在运行时再确定一个实现该接口的对象。</li>
<li><code>invokedynamic</code>：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。</li>
</ul>
<blockquote>
<p>以上指令的区别：</p>
<ol>
<li>invokestatic指令和invokespecial指令调用的方法称为非虚方法</li>
<li>invokevirtual 除（final修饰）称为虚方法。</li>
<li>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预而invokedynamic指令则支持由用户确定方法版本</li>
</ol>
</blockquote>
<h2 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h2><p><strong>分派会解释多态性特征的一些最基本的体现，如“重载”、“重写”在Java虚拟机中是如何实现的</strong>，当然这里的实现不是语法上该怎么写，我们关心的是虚拟机如何确定正确的目标方法。</p>
<p>分派（Dispatch）它可能是静态的也可能是动态的，按照分派依据的宗量数可分为单分派和多分派。这两类分派方式两两组合就构成了静态单分派、静态多分派、动态单分派、动态多分派4种分派组合情况。</p>
<h3 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h3><p><strong>依赖静态类型来决定方法执行版本的分派动作，都称为静态分派</strong>。静态分派的最典型应用表现就是<strong>方法重载</strong>，虚拟机（或者准确地说是编译器）在重载时是通过参数的静态类型来作为判定依据的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Human guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,guy!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Man guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,gentleman!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Woman guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,lady!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        StaticDispatch sr = <span class="keyword">new</span> StaticDispatch();</span><br><span class="line">        sr.sayHello(man);</span><br><span class="line">        sr.sayHello(woman);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line">hello,guy!</span><br><span class="line">hello,guy!</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Human man = <span class="keyword">new</span> Man();</span><br></pre></td></tr></table></figure>

<p>这里的<code>Human </code>就是变量的“静态类型”（Static Type），或者叫“外观类型”（Apparent Type）；<code>Man</code>就是变量的“实际类型”（Actual Type）或者叫“运行时类型”（Runtime Type）。</p>
<h3 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h3><p><strong>在运行期根据实际类型确定方法执行版本的分派过程称为动态分派</strong>。最典型的表现就是重写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello,Man!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello,Woman!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">        woman.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果：</span></span><br><span class="line">hello,Man!</span><br><span class="line">hello,Woman!</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反编译字节码</span></span><br><span class="line">...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class com/xiaolyuh/DynamicDispatch$Man</span></span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         <span class="number">4</span>: invokespecial #<span class="number">3</span>                  <span class="comment">// Method com/xiaolyuh/DynamicDispatch$Man.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">7</span>: astore_1</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">new</span>           #<span class="number">4</span>                  <span class="comment">// class com/xiaolyuh/DynamicDispatch$Woman</span></span><br><span class="line">        <span class="number">11</span>: dup</span><br><span class="line">        <span class="number">12</span>: invokespecial #<span class="number">5</span>                  <span class="comment">// Method com/xiaolyuh/DynamicDispatch$Woman.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        <span class="number">15</span>: astore_2</span><br><span class="line">        <span class="number">16</span>: aload_1</span><br><span class="line">        <span class="number">17</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method com/xiaolyuh/DynamicDispatch$Human.sayHello:()V</span></span><br><span class="line">        <span class="number">20</span>: aload_2</span><br><span class="line">        <span class="number">21</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method com/xiaolyuh/DynamicDispatch$Human.sayHello:()V</span></span><br><span class="line">        <span class="number">24</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">27</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">28</span>: <span class="number">8</span></span><br><span class="line">        line <span class="number">29</span>: <span class="number">16</span></span><br><span class="line">        line <span class="number">30</span>: <span class="number">20</span></span><br><span class="line">        line <span class="number">31</span>: <span class="number">24</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">25</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">8</span>      <span class="number">17</span>     <span class="number">1</span>   man   Lcom/xiaolyuh/DynamicDispatch$Human;</span><br><span class="line">           <span class="number">16</span>       <span class="number">9</span>     <span class="number">2</span> woman   Lcom/xiaolyuh/DynamicDispatch$Human;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>通过字节码我们发现：在main方法中，<code>sayHello()</code>方法的调用对应的<strong>符号引用是一样的</strong>，<code>com/xiaolyuh/DynamicDispatch$Human.sayHello:()V </code>。在这里我们可以得出一个结论：<strong>在动态分派的情况下，在编译时期我们是无法确定方法的直接引用的</strong>，那么它是怎么实现重载方法的调用的呢？问题关键是在<code>invokevirtual</code>指令上，在执行<code>invokevirtual</code>指令时，<code>invokevirtual</code>指令会去确定方法的调用版本。</p>
<h4 id="invokevirtual指令的运行过程"><a href="#invokevirtual指令的运行过程" class="headerlink" title="invokevirtual指令的运行过程"></a>invokevirtual指令的运行过程</h4><ol>
<li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。</li>
<li>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError 异常</li>
<li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</li>
</ol>
<blockquote>
<p>正是因为invokevirtual指令执行的第一步就是在运行期确定接收者的实际类型，所以两次调用中的invokevirtual指令并不是把常量池中方法的符号引用解析到直接引用上就结束了，还会根据方法接收者的实际类型来选择方法版本，这个过程就是Java语言中方法重写的本质</p>
</blockquote>
<h4 id="动态分派的实现"><a href="#动态分派的实现" class="headerlink" title="动态分派的实现"></a>动态分派的实现</h4><p>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。</p>
<p>因此，为了提高性能，JVM在方法区建立一个<strong>虚方法表（virtual method table）</strong>，表中存放着各个虚方法的实际入口，非虚方法不会出现在表中。</p>
<p>虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表中的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类虚方法表中的地址也会被替换为指向子类实现版本的入口地址。</p>
<img src="/pics/image-20210415000959425.png" alt="image-20210415000959425" style="zoom:33%;" />

<blockquote>
<p><strong>虚方法表是什么时候被创建的呢？</strong></p>
<p>虚方法表会在类加载的链接阶段被创建并开始初始化，类变量初始值准备完成之后，JVM会把该类的虚方法表也初始化完毕。</p>
</blockquote>
<h3 id="单分派与多分派"><a href="#单分派与多分派" class="headerlink" title="单分派与多分派"></a>单分派与多分派</h3><p>方法的接收者与方法的参数统称为方法的宗量。分派基于多少种宗量，可以将分派划分为单分派和多分派两种。单分派是根据一个宗量对目标方法进行选择，多分派则是根据两个及以上的宗量对目标方法进行选择。</p>
<ul>
<li><p>静态分派需要根据<strong>静态类型和方法参数</strong>两个宗量来确定方法调用，所以属于多分派。</p>
</li>
<li><p>动态分派只需要根据<strong>实际类型</strong>一个宗量来确定方法的调用，所以属于单分派。</p>
<p>在动态分派的过程中，方法签名是确定的，所以方法参数就不会变，方法调用就取决于参数的实际类型。</p>
</li>
</ul>
<h2 id="动态类型语言和静态类型语言"><a href="#动态类型语言和静态类型语言" class="headerlink" title="动态类型语言和静态类型语言"></a>动态类型语言和静态类型语言</h2><p>动态类型语言和静态类型语言两者的区别就在于<strong>对类型的检查是在编译期还是在运行期</strong>，满足前者就是静态类型语言，反之是动态类型语言。</p>
<p>说的再直白一点就是，静态类型语言是判断<strong>变量自身的类型信息</strong>；动态类型语言是判断<strong>变量值的类型信息</strong>，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Java语言：String info = <span class="string">&quot;mogu blog&quot;</span>;     		(Java是静态类型语言的，会先编译再进行类型检查)</span><br><span class="line">JS语言：<span class="keyword">var</span> name = <span class="string">&quot;shkstart&quot;</span>;  <span class="keyword">var</span> name = <span class="number">10</span>;	（运行时才进行检查）</span><br><span class="line">Python语言：info = <span class="number">130.5</span>;  （动态类型语言）</span><br></pre></td></tr></table></figure>

<img src="/pics/image-20210414233954002.png" alt="image-20210414233954002" style="zoom:33%;" />

<h3 id="invokedynamic"><a href="#invokedynamic" class="headerlink" title="invokedynamic"></a>invokedynamic</h3><p>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现<code>【动态类型语言】</code>支持而做的一种改进。</p>
<p>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。<strong>直到Java8的 Lambda表达式 的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。</strong></p>
<p>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>线程执行方法时，会创建一个栈帧，用来保存方法需要的信息。其中，局部变量表中存储着方法需要的各个变量信息；操作数栈用于存储方法执行过程中的中间变量；动态连接指向的是常量池中方法的引用；返回地址存储的是调用该方法的 PC 寄存器的值，PC寄存器存储着下一条要执行的指令。</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/sj15814963053/article/details/109922984">https://blog.csdn.net/sj15814963053/article/details/109922984</a></p>
]]></content>
      <categories>
        <category>java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM_04_PC寄存器</title>
    <url>/2021/04/17/Notes/Java/JVM/JVM_04_PC%E5%AF%84%E5%AD%98%E5%99%A8/</url>
    <content><![CDATA[<h1 id="JVM-04-PC寄存器"><a href="#JVM-04-PC寄存器" class="headerlink" title="JVM_04_PC寄存器"></a>JVM_04_PC寄存器</h1><p>PC寄存器（<strong>Program Counter Register</strong>）或称为程序计数器，<code>记录正在执行的虚拟机字节码指令地址</code>。Register 的命名源于 CPU 的寄存器，寄存器存储指令相关的线程信息，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器（CPU寄存器，不是我们程PCRegister）才能够运行</p>
<p>这里，并非是广义上所指的物理寄存器，叫程序计数器（或PC计数器或指令计数器）会更加贴切，并且也不容易引起一些不必要的误会。<strong>JVM 中的 PC 寄存器是对物理 PC 寄存器的一种抽象模拟</strong>。</p>
<blockquote>
<p>PC寄存器的作用有2种定义：</p>
<p>第一种解释：记录正在执行的虚拟机字节码指令地址（深入理解Java虚拟机）</p>
<p>第二种解释：用来存储指向下一条指令的地址，也就是即将要执行的指令代码。</p>
<p>这2种解释其实都可以，我们主要理解PC寄存器记录的是虚拟机栈执行的字节码指令就好，至于是下一条还是当前，不必细究。</p>
</blockquote>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域</li>
<li>在 JVM 规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期一致</li>
<li>任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。如果当前线程正在执行的是 Java 方法，程序计数器记录的是 JVM 字节码指令地址，如果是执行 natice 方法，则是未指定值（undefined）</li>
<li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖它来完成</li>
<li>字节码解释器工作 时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令</li>
<li>它是唯一一个在 JVM 规范中没有规定任何 <code>OutOfMemoryError</code> 情况的区域，<code>也不存在GC</code>。</li>
</ul>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><code>PC寄存器用来存储指向下一条指令的地址，也就是即将要执行的指令代码。</code>由执行引擎读取下一条指令，并执行该指令。</p>
<img src="/pics/image-20210411210734629.png" alt="image-20210411210734629" style="zoom:33%;" />

<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PCRegisterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">int</span> k = i + j;</span><br><span class="line">        System.out.println(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用反编译：javap -v PCRegisterTest.class 或通过 IDEA 插件 <code>Jclasslib</code> 查看字节码指令。</p>
<img src="/pics/image-20210411212618773.png" alt="image-20210411212618773" style="zoom:33%;" />

<p><strong>理解下方法执行的过程：</strong></p>
<blockquote>
<ol>
<li>Java代码执行时，代码会首先被编译成字节码命令</li>
<li>某个方法执行时，相应的代码的字节码指令会被压入虚拟机栈</li>
<li>方法执行的线程中的PC寄存器会记录当前字节码执行的偏移地址</li>
<li>执行引擎会读取PC寄存器当前偏移地址的字节码指令，转换成机器指令，再由cpu执行</li>
</ol>
</blockquote>
<p>以上的步骤画图理解下：</p>
<img src="/pics/image-20210411210630941.png" alt="image-20210411210630941" style="zoom:33%;" />



<h2 id="CPU时间片"><a href="#CPU时间片" class="headerlink" title="CPU时间片"></a>CPU时间片</h2><p>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</p>
<ul>
<li>在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</li>
<li>但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</li>
</ul>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ul>
<li><p><code>使用PC寄存器存储字节码指令地址有什么用呢？为什么使用PC寄存器记录当前线程的执行地址呢？</code></p>
<p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p>
</li>
<li><p><code>PC寄存器为什么会被设定为线程私有的？</code></p>
<p>多线程在一个特定的时间段内只会执行其中某一个线程方法，CPU会不停的做任务切换，这样必然会导致经常中断或恢复。为了能够准确的记录各个线程正在执行的当前字节码指令地址，所以为每个线程都分配了一个PC寄存器，每个线程都独立计算，不会互相影响。</p>
</li>
</ul>
<p><a href="https://blog.csdn.net/sj15814963053/article/details/109864077">https://blog.csdn.net/sj15814963053/article/details/109864077</a></p>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></p>
]]></content>
      <categories>
        <category>java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM_03_运行时数据区和线程</title>
    <url>/2021/04/11/Notes/Java/JVM/JVM_03_%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</url>
    <content><![CDATA[<h1 id="JVM-03-运行时数据区和线程"><a href="#JVM-03-运行时数据区和线程" class="headerlink" title="JVM_03_运行时数据区和线程"></a>JVM_03_运行时数据区和线程</h1><p>本节主要讲的是<code>运行时数据区</code>，也就是下图这部分，它是在类加载完成后的阶段</p>
<img src="/pics/image-20210411175545037.png" alt="image-20210411175545037" style="zoom:33%;" />

<p>当我们通过前面的：类的加载 –&gt; 验证 –&gt; 准备 –&gt; 解析 –&gt; 初始化，这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们的运行时数据区。</p>
<p>JVM 中运行时数据的结构如下：</p>
<img src="/pics/image-20210411171930165.png" alt="image-20210411171930165" style="zoom:70%;" />



<h2 id="运行时数据区与线程"><a href="#运行时数据区与线程" class="headerlink" title="运行时数据区与线程"></a>运行时数据区与线程</h2><p>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。</p>
<p>不同的JVM对于内存的划分方式和管理机制存在着部分差异。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。</p>
<p>我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁。下图是JDK8运行时数据区划分</p>
<img src="/pics/image-20210411174039107.png" alt="image-20210411174039107" style="zoom:33%;" />



<p>说明：方法区在JVM规范中是一个逻辑概念，由虚拟机自己进行具体实现，<code>jdk7和以前的版本使用的是堆上的永久代实现的方法区，而在jdk8及以后使用的是元数据区实现方法区。</code></p>
<h2 id="线程的内存空间"><a href="#线程的内存空间" class="headerlink" title="线程的内存空间"></a>线程的内存空间</h2><p>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机的退出而销毁。<code>另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</code></p>
<img src="/pics/image-20210411174801884.png" alt="image-20210411174801884" style="zoom:50%;" />

<p>灰色的为<code>单独线程私有的</code>，红色的为<code>多个线程共享的</code>。即：</p>
<ul>
<li>线程独有：独立包括<code>程序计数器</code>、<code>栈</code>、<code>本地方法栈</code></li>
<li>线程间共享：<code>堆</code>、<code>堆外内存（永久代或元空间、代码缓存）</code></li>
</ul>
<img src="/pics/image-20210411180542906.png" alt="image-20210411180542906" style="zoom:33%;" />

<p><code>每个JVM只有一个Runtime实例</code>。即为运行时环境，相当于内存结构的中间的那个框框：运行时环境。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="JVM线程"><a href="#JVM线程" class="headerlink" title="JVM线程"></a>JVM线程</h3><ul>
<li>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行<ul>
<li>在Hotspot JVM里，每个线程都与<code>操作系统的本地线程直接映射</code></li>
<li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收</li>
</ul>
</li>
<li>操作系统负责将线程安排调度到任何一个可用的CPU上。<ul>
<li>一旦本地线程初始化成功，它就会调用Java线程中的run( )方法。</li>
<li>Java中的线程有2种类型一种是守护线程，另一种是普通线程；当进程中只有守护线程时，那么进程将停止。<a href="https://blog.51cto.com/u_14820287/2507947">Java中守护线程和本地线程区别</a></li>
</ul>
</li>
</ul>
<h3 id="JVM系统线程"><a href="#JVM系统线程" class="headerlink" title="JVM系统线程"></a>JVM系统线程</h3><ul>
<li>如果你使用 jconsole 或者是任何一个调试工具，都能看到在后台有许多线程在运行。<br>这些后台线程不包括调用public static void main(String [ ])的main线程以及所有由这个main方法自己创建的线程。</li>
<li>这些主要的后台系统线程在Hotspot JVM里主要是以下几个：<ul>
<li><strong>虚拟机线程：</strong>这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销</li>
<li>周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行</li>
<li><strong>GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持（重点）</strong></li>
<li>编译线程：这种线程在运行时会将字节码编译成 本地代码</li>
<li>信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM_02_类加载机制</title>
    <url>/2021/04/14/Notes/Java/JVM/JVM_02%20%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="JVM-02-类加载机制"><a href="#JVM-02-类加载机制" class="headerlink" title="JVM_02_类加载机制"></a>JVM_02_类加载机制</h1><h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><p><strong>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</strong></p>
<p>Class 文件由类装载器装加载后，在 JVM 中将形成一份描述 Class 结构的元信息对象，通过该元信息对象可以获知 Class 的结构信息：如构造函数，属性和方法等，Java 允许用户借由这个 Class 相关的元信息对象间接调用 Class 对象的功能，这里就是我们经常能见到的 Class 类。</p>
<img src="/pics/image-20210411165909852.png" alt="image-20210411165909852" style="zoom:30%" />

<h2 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h2><ul>
<li>类加载子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识（0xCAFEBABE）</li>
<li>ClassLoader 只负责 class 文件的加载。至于它是否可以运行，则由 Execution Engine 决定</li>
<li>加载的类信息存放于一块称为**<code>方法区</code>**的内存空间。除了类的信息外，方法区中还存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</li>
<li>Class 对象是存放在堆区的</li>
</ul>
<img src="/pics/image-20210409215629775.png" alt="image-20210409215629775" style="zoom:67%;" />



<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><img src="/pics/image-20210409215512294.png" alt="image-20210409215629775" style="zoom:80%;" />

<h3 id="加载（Loading）"><a href="#加载（Loading）" class="headerlink" title="加载（Loading）"></a>加载（Loading）</h3><ul>
<li>通过一个类的全限定名获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>
</ul>
<h3 id="链接（Linking）"><a href="#链接（Linking）" class="headerlink" title="链接（Linking）"></a>链接（Linking）</h3><h4 id="验证（Verify）"><a href="#验证（Verify）" class="headerlink" title="验证（Verify）"></a>验证（Verify）</h4><p>确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。</p>
<p>主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</p>
<h4 id="准备（Prepare）"><a href="#准备（Prepare）" class="headerlink" title="准备（Prepare）"></a>准备（Prepare）</h4><ul>
<li><p>为类变量(静态变量，static修饰的变量)分配内存并且设置该类变量的默认初始值，即<strong>零值</strong></p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>零值</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
</tr>
<tr>
<td>short</td>
<td>(short)0</td>
</tr>
<tr>
<td>char</td>
<td>‘\u0000’</td>
</tr>
<tr>
<td>byte</td>
<td>(byte)0</td>
</tr>
<tr>
<td>boolean</td>
<td>false</td>
</tr>
<tr>
<td>float</td>
<td>0.0f</td>
</tr>
<tr>
<td>double</td>
<td>0.0d</td>
</tr>
<tr>
<td>reference</td>
<td>null</td>
</tr>
</tbody></table>
</li>
<li><p>这里不包含用 final 修饰的 static，因为 final 在<code>编译</code>的时候就会分配了，准备阶段会显式初始化</p>
</li>
<li><p>这里<strong>不会为实例变量分配初始化</strong>，类变量会分配在<strong>方法区</strong>中，而实例变量是会随着对象一起分配到 Java 堆中</p>
</li>
</ul>
<blockquote>
<p>byte 是字节数据类型 ，是有符号型的，占1 个字节；大小范围为-128—127 。</p>
<p>char 是字符数据类型 ，是无符号型的，占2字节(Unicode码 ）；大小范围 是0—65535 ；</p>
<p>char是一个16位二进制的Unicode字符，JAVA用char来表示一个字符 。</p>
<p>char类型：</p>
<p>char：2个字节。</p>
<p>整型：</p>
<p>byte:1个字节 8位 -128~127，1byte = 8bit</p>
<p>short ：2个字节 16位</p>
<p>int ：4个字节 32位</p>
<p>long：8个字节 64位</p>
<p>浮点型：</p>
<p>float：4个字节 32 位</p>
<p>double ：8个字节 64位</p>
<p>注：默认的是double类型，如3.14是double类型的，加后缀F（3.14F）则为float类型的。</p>
</blockquote>
<h4 id="解析（Resolve）"><a href="#解析（Resolve）" class="headerlink" title="解析（Resolve）"></a>解析（Resolve）</h4><ul>
<li><p><strong>将常量池内的<code>符号引用</code>转换为<code>直接引用</code>的过程</strong></p>
<p>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《Java虚拟机规范》的 Class文件格式中。</p>
<p>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</p>
</li>
<li><p>事实上，解析操作往往会伴随着 JVM 在执行完初始化之后再执行</p>
<p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的<code>CONSTANT_Class_info</code>、<code>CONSTANT_Fieldref_info</code>、<code>CONSTANT_Methodref_info</code>等，可用通过javap -v 命令查看class 文件的符合应用。</p>
<img src="/pics/image-20210414125116226.png" alt="image-20210414125116226" style="zoom:70%;" /></li>
</ul>
<h3 id="初始化（Initialization）"><a href="#初始化（Initialization）" class="headerlink" title="初始化（Initialization）"></a>初始化（Initialization）</h3><ul>
<li> 初始化阶段就是执行类构造器方法 <clinit>() 的过程</li>
<li>此方法不需要定义，是 javac 编译器自动收集类中的所有**<code>类变量的赋值动作和静态代码块</code>**中的语句合并而来构造器方法中指令按语句在源文件中出现的顺序执行</li>
<li><clinit>() 不同于类的构造器（构造器是虚拟机视角下的 <init>()）</li>
<li>若该类具有父类，JVM 会保证子类的 <clinit>() 执行前，父类的 <clinit>() 已经执行完毕</li>
<li>虚拟机必须保证一个类的 <clinit>() 方法在多线程下被同步加锁</li>
</ul>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><h2 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h2><p>JVM 支持两种类型的类加载器，分别为<strong>启动（引导）类加载器</strong>（Bootstrap ClassLoader）和<strong>自定义类加载器</strong>（User-Defined ClassLoader。</p>
<ul>
<li>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是 Java 虚拟机规范却没有这么定义，而是<code>将所有派生于抽象类 ClassLoader 的类加载器都划分为自定义类加载器</code>。</li>
</ul>
<ul>
<li>从功能角度，类加载器又可以分为4类，它们的<code>等级关系</code> 如下所示：</li>
</ul>
<img src="/pics/image-20210411153335541.png" alt="image-20210411153335541" style="zoom:50%;" />

<p>注意：这里系统类SytemClassLoader加载器在jvm中的实现是AppClassLoader，也叫应用程序类加载器，是一个东西。</p>
<h2 id="JVM-自带的类加载器"><a href="#JVM-自带的类加载器" class="headerlink" title="JVM 自带的类加载器"></a>JVM 自带的类加载器</h2><p>jvm虚拟机中自带的加载器有启动类加载器，扩展类加载器，应用程序类加载器。</p>
<h3 id="启动类加载器（引导类加载器，Bootstrap-ClassLoader）"><a href="#启动类加载器（引导类加载器，Bootstrap-ClassLoader）" class="headerlink" title="启动类加载器（引导类加载器，Bootstrap ClassLoader）"></a>启动类加载器（引导类加载器，Bootstrap ClassLoader）</h3><ul>
<li>这个类加载使用 C/C++ 语言实现，嵌套在 JVM 内部</li>
<li>它用来加载 Java 的核心库（<code>JAVA_HOME/jre/lib/rt.jar</code>、<code>resource.jar</code>或<code>sun.boot.class.path</code>路径下的内容），用于提供 JVM 自身需要的类</li>
<li>并不继承自 <code>java.lang.ClassLoader</code>，没有父加载器</li>
<li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器</li>
<li>出于安全考虑，Bootstrap 启动类加载器只加载名为 java、javax、sun 等开头的类</li>
</ul>
<h3 id="扩展类加载器（Extension-ClassLoader）"><a href="#扩展类加载器（Extension-ClassLoader）" class="headerlink" title="扩展类加载器（Extension ClassLoader）"></a>扩展类加载器（Extension ClassLoader）</h3><ul>
<li>Java 语言编写，由 <code>sun.misc.Launcher$ExtClassLoader</code> 实现</li>
<li>派生于 ClassLoader</li>
<li>父类加载器为启动类加载器</li>
<li>从 <code>java.ext.dirs</code> 系统属性所指定的目录中加载类库，或从 JDK 的安装目录的 <code>jre/lib/ext</code> 子目录（扩展目录）下加载类库。如果用户创建的 JAR 放在此目录下，也会自动由扩展类加载器加载</li>
</ul>
<h3 id="应用程序类加载器（也叫系统类加载器，AppClassLoader）"><a href="#应用程序类加载器（也叫系统类加载器，AppClassLoader）" class="headerlink" title="应用程序类加载器（也叫系统类加载器，AppClassLoader）"></a>应用程序类加载器（也叫系统类加载器，AppClassLoader）</h3><ul>
<li>Java 语言编写，由 <code>sun.misc.Lanucher$AppClassLoader</code> 实现</li>
<li>派生于 ClassLoader</li>
<li>父类加载器为扩展类加载器</li>
<li>它负责加载环境变量 <code>classpath</code> 或系统属性 <code>java.class.path</code> 指定路径下的类库</li>
<li>该类加载是<strong>程序中默认的类加载器</strong>，一般来说，Java 应用的类都是由它来完成加载的</li>
<li>通过 <code>ClassLoader#getSystemClassLoader()</code> 方法可以获取到该类加载器</li>
</ul>
<h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><p>在 Java 的日常应用程序开发中，类的加载几乎由以上3 种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。</p>
<h3 id="为什么要自定义类加载器？"><a href="#为什么要自定义类加载器？" class="headerlink" title="为什么要自定义类加载器？"></a>为什么要自定义类加载器？</h3><ul>
<li>隔离加载类</li>
<li>修改类加载的方式</li>
<li>拓展加载源</li>
<li>防止源码泄漏</li>
</ul>
<h3 id="用户自定义加载器实现步骤"><a href="#用户自定义加载器实现步骤" class="headerlink" title="用户自定义加载器实现步骤"></a>用户自定义加载器实现步骤</h3><ol>
<li>开发人员可以通过继承抽象类 <code>java.lang.ClassLoader</code> 类的方式，实现自己的类加载器，以满足一些特殊的需求</li>
<li>在 JDK1.2 之前，在自定义类加载器时，总会去继承 ClassLoader 类并重写 loadClass() 方法，从而实现自定义的类加载类，但是 JDK1.2 之后已经不建议用户去覆盖 <code>loadClass()</code> 方式，而是建议把自定义的类加载逻辑写在 <code>findClass()</code> 方法中</li>
<li>编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承 URLClassLoader 类，这样就可以避免自己去编写 findClass() 方法及其获取字节码流的方式，使自定义类加载器编写更加简洁</li>
</ol>
<h1 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h1><p>ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><p>系统类加载器和扩展类加载器都继承自ClassLoader，继承关系如下图</p>
<img src="/pics/image-20210411152641950.png" alt="image-20210411152641950" style="zoom:25%;" />

<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p>ClassLoader类的常用方法如下：</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>getParent（）</td>
<td>返回该类加载器的超类加载器</td>
</tr>
<tr>
<td>loadClass（String name）</td>
<td>加载名称为name的类，返回结果为java.lang.Class类的实例</td>
</tr>
<tr>
<td>findClass（String name）</td>
<td>查找名称为name的类，返回结果为java.lang.Class类的实例</td>
</tr>
<tr>
<td>findLoadedClass（String name）</td>
<td>查找名称为name的已经被加载过的类，返回结果为java.lang.Class类的实例</td>
</tr>
<tr>
<td>defineClass（String name，byte[] b,int off,int len）</td>
<td>把字节数组b中的内容转换为一个Java类 ，返回结果为java.lang.Class类的实例</td>
</tr>
<tr>
<td>resolveClass（Class&lt;?&gt; c）</td>
<td>连接指定的一个java类</td>
</tr>
</tbody></table>
<h2 id="获取ClassLoader"><a href="#获取ClassLoader" class="headerlink" title="获取ClassLoader"></a>获取ClassLoader</h2><p>Java层获取ClassLoader的方式有4种</p>
<img src="/pics/image-20210411155040511.png" alt="image-20210411155040511" style="zoom:50%;" />



<h1 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h1><p>Java虚拟机对class文件采用的是<code>按需加载</code>的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成的class对象。而且加载某个类的class文件时，java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。</p>
<h2 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h2><ul>
<li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li>
<li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li>
<li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li>
</ul>
<img src="/pics/image-20210411155736044.png" alt="image-20210411155736044" style="zoom:50%;" />

<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul>
<li><p><strong>避免类的重复加载</strong></p>
<p>JVM 中区分不同类，不仅仅是根据类名，相同的 class 文件被不同的 ClassLoader 加载就属于两个不同的类（比如，Java中的Object类，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，如果不采用双亲委派模型，由各个类加载器自己去加载的话，系统中会存在多种不同的 Object 类（后面会解释）。</p>
</li>
<li><p><strong>保护程序安全，防止核心 API 被随意篡改</strong></p>
<p>避免用户自己编写的类动态替换 Java 的一些核心类，比如我们自定义类：<code>java.lang.String</code></p>
</li>
</ul>
<h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h2><p>Java安全模型的核心就是Java沙箱（sandbox），什么是沙箱？沙箱是一个<code>限制程序运行的环境</code>。沙箱机制就是将 Java 代码限定在虚拟机(JVM)特定的运行范围中，并且严格限制代码对本地系统资源访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏。沙箱主要限制系统资源访问，那系统资源包括什么？——CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。</p>
<p>举例：</p>
<img src="/pics/image-20210411164041615.png" alt="image-20210411164041615" style="zoom:50%;" />

<p>我们自己定义一个java.lang包，在其下面定义一个String类，里面声明了静态代码块。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;我是自定义的String类的静态代码块&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在一个测试类中加载String类，看看加载的String类是JDK自带的，还是我们自己编写的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="keyword">new</span> java.lang.String();</span><br><span class="line">        System.out.println(<span class="string">&quot;hello，world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">你好，世界</span><br></pre></td></tr></table></figure>

<p>结果：程序并没有输出我们静态代码块中的内容，可见仍然加载的是 JDK 自带的 String 类</p>
<p>如果我们自己定义的 String 类中加个 main( ) 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是自定义的String类的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,String&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line">错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">否则 JavaFX 应用程序类必须扩展javafx.application.Application</span></span><br></pre></td></tr></table></figure>

<p>在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java.lang.String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</p>
<p><a href="https://www.cnblogs.com/MyStringIsNotNull/p/8268351.html">https://www.cnblogs.com/MyStringIsNotNull/p/8268351.html</a></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h3 id="如何判断两个class对象是否相同？"><a href="#如何判断两个class对象是否相同？" class="headerlink" title="如何判断两个class对象是否相同？"></a>如何判断两个class对象是否相同？</h3><p>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p>
<ul>
<li><p>类的完整类名必须一致，包括包名</p>
</li>
<li><p>加载这个类的 ClassLoader（指ClassLoader实例对象）必须相同</p>
<p>换句话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的 ClassLoader 实例对象不同，那么这两个类对象也是不相等的</p>
</li>
</ul>
<h3 id="对类加载器的引用"><a href="#对类加载器的引用" class="headerlink" title="对类加载器的引用"></a>对类加载器的引用</h3><ul>
<li>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的</li>
<li>如果一个类型是由用户类加载器加载的，那么<code>JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</code></li>
<li>当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的</li>
</ul>
<h3 id="类的主动使用和被动使用"><a href="#类的主动使用和被动使用" class="headerlink" title="类的主动使用和被动使用"></a>类的主动使用和被动使用</h3><p>Java程序对类的使用方式分为：主动使用 和 被动使用。</p>
<p>主动使用，又分为七种情况：</p>
<ol>
<li>创建类的实例</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射（ 比如：Class.forName(“cn.sxt.Test”) )</li>
<li>初始化一个类的子类</li>
<li>Java虚拟机启动时被标明为启动类的类</li>
<li>JDK7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化</li>
</ol>
<p>除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化，即不会执行初始化阶段（不会调用 clinit( ) 方法和 init( ) 方法）</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/sj15814963053/article/details/109851454">https://blog.csdn.net/sj15814963053/article/details/109851454</a></p>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p><a href="https://github.com/ingokegel/jclasslib/releases">https://github.com/ingokegel/jclasslib/releases</a></p>
<p>反编译命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javap -v xxx.class</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM_01_JVM</title>
    <url>/2021/04/09/Notes/Java/JVM/JVM_01_JVM%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="JVM-01-JVM简介"><a href="#JVM-01-JVM简介" class="headerlink" title="JVM_01_JVM简介"></a>JVM_01_JVM简介</h1><h2 id="JVM-是什么"><a href="#JVM-是什么" class="headerlink" title="JVM 是什么"></a>JVM 是什么</h2><p><code>JVM</code> 是 <code>Java Virtual Machine</code>（<strong>Java虚拟机</strong>)的缩写，<code>JVM</code>是一种用于计算设备的<strong>规范</strong>，它是一个<strong>虚构</strong>的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。</p>
<p>Java 虚拟机是二进制字节码的运行环境，负责装载<strong>字节码</strong>到其内部，解释/编译为对应平台的机器指令执行。每一条 Java 指令，Java 虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>一次编译，到处运次（跨平台）</li>
<li>自动内存管理</li>
<li>自动垃圾回收功能</li>
</ul>
<h3 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h3><p>我们平时所说的 java 字节码，指的是用 java 语言编写的字节码，准确的说任何能在 jvm 平台上执行的字节码格式都是一样的，所以应该统称为 <strong>jvm字节码</strong>。</p>
<p>不同的编译器可以编译出相同的字节码文件，字节码文件也可以在不同的 jvm 上运行。</p>
<p>JVM 与 Java 语言没有必然的联系，它只与特定的二进制文件格式——Class 文件格式关联，Class 文件中包含了 Java 虚拟机指令集（或者称为字节码、Bytecodes）和符号集，还有一些其他辅助信息。</p>
<img src="/pics/image-20210411170035870.png" alt="image-20210411170035870" style="zoom:20%;" />

<h2 id="JVM-的位置"><a href="#JVM-的位置" class="headerlink" title="JVM 的位置"></a>JVM 的位置</h2><p>JVM 是运行在操作系统之上的，它与硬件没有直接的交互。</p>
<p><code>JDK</code>(Java Development Kit) 是 <code>Java</code> 语言的软件开发工具包（<code>SDK</code>）。<code>JDK</code> 物理存在，是 <code>Java Language</code>、<code>Tools</code>、<code>JRE</code> 和 <code>JVM</code> 的一个集合。</p>
<img src="/pics/image-20210411170149148.png" alt="image-20210411170149148" style="zoom:30%;" />

<h2 id="JVM-整体结构"><a href="#JVM-整体结构" class="headerlink" title="JVM 整体结构"></a>JVM 整体结构</h2><img src="/pics/image-20210409200106588.png" alt="image-20210409200106588" style="zoom:75%;" />

<h2 id="JVM-生命周期"><a href="#JVM-生命周期" class="headerlink" title="JVM 生命周期"></a>JVM 生命周期</h2><h4 id="虚拟机的启动"><a href="#虚拟机的启动" class="headerlink" title="虚拟机的启动"></a>虚拟机的启动</h4><p>Java 虚拟机的启动是通过引导类加载器（Bootstrap Class Loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</p>
<h4 id="虚拟机的执行"><a href="#虚拟机的执行" class="headerlink" title="虚拟机的执行"></a>虚拟机的执行</h4><ul>
<li>一个运行中的 Java 虚拟机有着一个清晰的任务：执行 Java 程序</li>
<li>程序开始执行时它才运行，程序结束时它就停止</li>
<li>执行一个所谓的 Java 程序的时候，真正执行的是一个叫做 Java 虚拟机的进程</li>
<li>你在同一台机器上运行三个程序，就会有三个运行中的 Java 虚拟机。 Java 虚拟机总是开始于一个**main()**方法，这个方法必须是公有、返回 void、只接受一个字符串数组。在程序执行时，你必须给 Java 虚拟机指明这个包含 main() 方法的类名。</li>
</ul>
<h4 id="虚拟机的退出"><a href="#虚拟机的退出" class="headerlink" title="虚拟机的退出"></a>虚拟机的退出</h4><p>有以下几种情况：</p>
<ul>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而异常终止</li>
<li>由于操作系统出现错误而导致 Java 虚拟机进程终止</li>
<li>某线程调用 Runtime 类或 System 类的 exit 方法，或 Runtime 类的 halt 方法，并且 Java 安全管理器也允许这次 exit 或 halt 操作</li>
<li>除此之外，JNI(Java Native Interface)规范描述了用<code>JNI Invocation API</code>来加载或卸载 Java 虚拟机时，Java 虚拟机的退出情况</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.starfish.ink/java/JVM/JVM-Java.html#%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8Ejava%E8%99%9A%E6%8B%9F%E6%9C%BA">http://www.starfish.ink/java/JVM/JVM-Java.html#%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8Ejava%E8%99%9A%E6%8B%9F%E6%9C%BA</a></p>
]]></content>
      <categories>
        <category>java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC_01_JMM</title>
    <url>/2021/04/09/Notes/Java/JUC/JUC01_Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="JUC-01-JMM"><a href="#JUC-01-JMM" class="headerlink" title="JUC_01_JMM"></a>JUC_01_JMM</h1><p>介绍 Java 内存模型之前，先温习下计算机硬件内存模型。</p>
<p>计算机在执行程序的时候，每条指令都是在 CPU 中执行的，而执行的时候，又免不了要和数据打交道。而计算机上面的数据，是存放在主存当中的，也就是计算机的物理内存。</p>
<p>计算机硬件架构简易图：</p>
<img src="/pics/image-20210318234901621.png" alt="image-20210318234901621" style="zoom:50%;" />

<p>我们以多核 CPU 为例，每个CPU 核都包含<strong>一组 「CPU 寄存器」</strong>，这些寄存器本质上是在 CPU 内存中。CPU 在这些寄存器上执行操作的速度要比在主内存(RAM)中执行的速度快得多。</p>
<p>因为<strong>CPU速率高， 内存速率慢，为了让存储体系可以跟上CPU的速度，所以中间又加上 Cache 层，就是我们说的 「CPU 高速缓存」</strong>。</p>
<h3 id="CPU多级缓存"><a href="#CPU多级缓存" class="headerlink" title="CPU多级缓存"></a>CPU多级缓存</h3><p>由于CPU的运算速度远远超越了1级缓存的数据IO能力，CPU厂商又引入了多级的缓存结构。通常L1、L2 是每个CPU 核有一个，L3 是多个核共用一个。</p>
<h3 id="Cache-Line"><a href="#Cache-Line" class="headerlink" title="Cache Line"></a>Cache Line</h3><p>Cache又是由很多个<strong>「缓存行」</strong>(Cache line) 组成的。Cache line 是 Cache 和 RAM 交换数据的最小单位。</p>
<p>Cache 存储数据是固定大小为单位的，称为一个<strong>Cache entry</strong>，这个单位称为<strong>Cache line</strong>或<strong>Cache block</strong>。给定Cache 容量大小和 Cache line size 的情况下，它能存储的条目个数(number of cache entries)就是固定的。因为Cache 是固定大小的，所以它从主内存获取数据也是固定大小。对于X86来讲，是 64Bytes。对于ARM来讲，较旧的架构的Cache line是32Bytes，但一次内存访存只访问一半的数据也不太合适，所以它经常是一次填两个 Cache line，叫做 double fill。</p>
<h3 id="缓存的工作原理"><a href="#缓存的工作原理" class="headerlink" title="缓存的工作原理"></a>缓存的工作原理</h3><p>这里的缓存的工作原理和我们项目中用 memcached、redis 做常用数据的缓存层是一个道理。</p>
<p>当 CPU 要读取一个数据时，首先从缓存中查找，如果找到就立即读取并送给CPU处理；如果没有找到，就去内存中读取并送给 CPU 处理，同时把这个数据所在的<strong>数据块</strong>（就是我们上边说的 Cache block）调入缓存中，即把临近的共 64 Byte 的数据也一同载入，因为临近的数据在将来被访问的可能性更大，可以使得以后对整块数据的读取都从缓存中进行，<strong>不必再调用内存</strong>。</p>
<p>这就增加了CPU读取缓存的<strong>命中率</strong>（Cache hit）了。</p>
<h3 id="计算机层级存储"><a href="#计算机层级存储" class="headerlink" title="计算机层级存储"></a>计算机层级存储</h3><p>计算机存储系统是有层次结构的，类似一个金字塔，顶层的寄存器读写速度较高，但是空间较小。底层的读写速度较低，但是空间较大。</p>
<img src="/pics/image-20210318235811049.png" alt="image-20210318235811049" style="zoom:50%;" />

<h3 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h3><p>既然每个核中都有单独的缓存，那我的 4 核 8 线程 CPU 处理主内存数据的时候，不就会出现数据不一致问题了吗？</p>
<p>为了解决这个问题，先后有过两种方法：<strong>总线锁机制</strong>和<strong>缓存锁机制</strong>。</p>
<p>总线锁就是使用 CPU 提供的一个<code>LOCK#</code>信号，当一个处理器在总线上输出此信号，其他处理器的请求将被阻塞，那么该处理器就可以独占共享锁。这样就保证了数据一致性。</p>
<p>但是总线锁开销太大，我们需要控制锁的粒度，所以又有了缓存锁，核心就是“<strong>缓存一致性协议</strong>”，不同的 CPU 硬件厂商实现方式稍有不同，有MSI、MESI、MOSI等。</p>
<h3 id="代码乱序执行优化"><a href="#代码乱序执行优化" class="headerlink" title="代码乱序执行优化"></a>代码乱序执行优化</h3><p>为了使得处理器内部的运算单元尽量被充分利用，提高运算效率，处理器可能会对输入的代码进行「乱序执行」**(Out-Of-Order Execution)，处理器会在计算之后将乱序执行的结果重组，**乱序优化可以保证在单线程下该执行结果与顺序执行的结果是一致的，但不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致。</p>
<p><strong>乱序执行技术是处理器为提高运算速度而做出违背代码原有顺序的优化</strong>。在单核时代，处理器保证做出的优化不会导致执行结果远离预期目标，但在多核环境下却并非如此。</p>
<p>多核环境下， 如果存在一个核的计算任务依赖另一个核的计算任务的中间结果，而且对相关数据读写没做任何防护措施，那么其顺序性并不能靠代码的先后顺序来保证，处理器最终得出的结果和我们逻辑得到的结果可能会大不相同。</p>
<h4 id="编译器指令重排"><a href="#编译器指令重排" class="headerlink" title="编译器指令重排"></a>编译器指令重排</h4><p>除了上述由处理器和缓存引起的乱序之外，现代编译器同样提供了乱序优化。之所以出现编译器乱序优化其根本原因在于处理器每次只能分析一小块指令，但编译器却能在很大范围内进行代码分析，从而做出更优的策略，充分利用处理器的乱序执行功能。</p>
<h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><p>尽管我们看到乱序执行初始目的是为了提高效率，但是它看来其好像在这多核时代不尽人意，其中的某些”自作聪明”的优化导致多线程程序产生各种各样的意外。因此有必要存在一种机制来消除乱序执行带来的坏影响，也就是说应该允许程序员显式的告诉处理器对某些地方禁止乱序执行。这种机制就是所谓内存屏障。不同架构的处理器在其指令集中提供了不同的指令来发起内存屏障，对应在编程语言当中就是提供特殊的关键字来调用处理器相关的指令，JMM里我们再探讨。</p>
<h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><p>Java 内存模型即 <code>Java Memory Model</code>，简称 <strong>JMM</strong>。</p>
<p>这里的内存模型可不是 JVM 里的运行时数据区。</p>
<p>「内存模型」可以理解为<strong>在特定操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象</strong>。</p>
<p>不同架构的物理计算机可以有不一样的内存模型，Java虚拟机也有自己的内存模型。</p>
<p>Java虚拟机规范中试图定义一种「 <strong>Java 内存模型</strong>」来<strong>屏蔽掉各种硬件和操作系统的内存访问差异</strong>，以实现<strong>让 Java 程序在各种平台下都能达到一致的内存访问效果</strong>，不必因为不同平台上的物理机的内存模型的差异，对各平台定制化开发程序。</p>
<p>Java 内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。这里的变量与我们写 Java 代码中的变量不同，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量和方法参数，因为他们是线程私有的，不会被共享。</p>
<h3 id="JMM-组成"><a href="#JMM-组成" class="headerlink" title="JMM 组成"></a>JMM 组成</h3><ul>
<li><p><strong>主内存</strong>：Java 内存模型规定了所有变量都存储在主内存(Main Memory)中（此处的主内存与物理硬件的主内存RAM 名字一样，两者可以互相类比，但此处仅是虚拟机内存的一部分）。</p>
</li>
<li><p><strong>工作内存</strong>：每条线程都有自己的工作内存(Working Memory，又称本地内存，可与CPU高速缓存类比)，线程的工作内存中保存了该线程使用到的主内存中的共享变量的副本拷贝。<strong>线程对变量的所有操作都必须在工作内存进行，而不能直接读写主内存中的变量</strong>。<strong>工作内存是 JMM 的一个抽象概念，并不真实存在</strong>。</p>
<img src="/pics/image-20210318234012867.png" alt="image-20210318234012867" style="zoom:50%;" /></li>
</ul>
<h3 id="JMM-与-JVM-内存结构"><a href="#JMM-与-JVM-内存结构" class="headerlink" title="JMM 与 JVM 内存结构"></a>JMM 与 JVM 内存结构</h3><p>JMM 与 Java 内存区域中的堆、栈、方法区等并不是同一个层次的内存划分，两者基本没有关系。如果一定要勉强对应，那从变量、主内存、工作内存的定义看，<strong>主内存主要对应 Java 堆中的对象实例数据部分，工作内存则对应虚拟机栈的部分区域</strong>（与上图对应着看哈）。</p>
<img src="/pics/image-20210319000613709.png" alt="image-20210319000613709" style="zoom:50%;" />

<h3 id="JMM-与计算机内存结构"><a href="#JMM-与计算机内存结构" class="headerlink" title="JMM 与计算机内存结构"></a>JMM 与计算机内存结构</h3><p>Java 内存模型和硬件内存体系结构也没有什么关系。硬件内存体系结构不区分栈和堆。在硬件上，线程栈和堆都位于主内存中。线程栈和堆的一部分有时可能出现在高速缓存和CPU寄存器中。如下图所示:</p>
<img src="/pics/image-20210319000711299.png" alt="image-20210319000711299" style="zoom:50%;" />

<p>当对象和变量可以存储在计算机中不同的内存区域时，这就可能会出现某些问题。两个主要问题是:</p>
<ul>
<li><strong>线程更新(写)到共享变量的可见性</strong></li>
<li><strong>读取、检查和写入共享变量时的竞争条件</strong></li>
</ul>
<h4 id="可见性问题（Visibility-of-Shared-Objects）"><a href="#可见性问题（Visibility-of-Shared-Objects）" class="headerlink" title="可见性问题（Visibility of Shared Objects）"></a>可见性问题（Visibility of Shared Objects）</h4><p>如果两个或多个线程共享一个对象，则一个线程对共享对象的更新可能对其他线程不可见（当然可以用 Java 提供的关键字 volatile）。 假设共享对象最初存储在主内存中。在 CPU 1上运行的线程将共享对象读入它的CPU缓存后修改，但是还没来得及即刷新回主内存，这时其他 CPU 上运行的线程就不会看到共享对象的更改。这样，每个线程都可能以自己的线程结束，就出现了可见性问题，如下</p>
<img src="/pics/image-20210319004455084.png" alt="image-20210319004455084" style="zoom:50%;" />

<h4 id="竞争条件（Race-Conditions）"><a href="#竞争条件（Race-Conditions）" class="headerlink" title="竞争条件（Race Conditions）"></a>竞争条件（Race Conditions）</h4><p>这个其实就是我们常说的原子问题。</p>
<p>如果两个或多个线程共享一个对象，并且多个线程更新该共享对象中的变量，则可能出现竞争条件。</p>
<p>想象一下，如果线程 A 将一个共享对象的变量读入到它的 CPU 缓存中。此时，线程 B 执行相同的操作，但是进入不同的 CPU 缓存。现在线程A执行 +1 操作，线程B也这样做。现在该变量增加了两次，在每个 CPU 缓存中一次。</p>
<p>如果这些增量是按顺序执行的，则变量结果会是 3，并将原始值 +2 写回主内存。但是，这两个增量是同时执行的，没有适当的同步。不管将哪个线程的结构写回主内存，更新后的值只比原始值高1，显然是有问题的。如下（当然可以用 Java 提供的关键字 Synchronized）</p>
<img src="/pics/image-20210319004553218.png" alt="image-20210319004553218" style="zoom:50%;" />

<h3 id="JMM-特性"><a href="#JMM-特性" class="headerlink" title="JMM 特性"></a>JMM 特性</h3><p>JMM 就是用来解决如上问题的。 <strong>JMM是围绕着并发过程中如何处理可见性、原子性和有序性这 3 个 特征建立起来的</strong></p>
<ul>
<li><p><strong>可见性</strong>：<strong>可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改</strong>。Java 中的 volatile、synchronzied、final 都可以实现可见性</p>
</li>
<li><p><strong>原子性</strong>：即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。<strong>即使在多个线程一起执行的时候</strong>，一个操作一旦开始，就不会被其他线程所干扰。</p>
</li>
<li><p><strong>有序性</strong>：计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排，一般分为以下 3 种：</p>
<p><img src="/pics/image-20210319001149455.png" alt="image-20210319001149455">单线程环境里确保程序最终执行结果和代码顺序执行的结果一致；</p>
<p>处理器在进行重排序时必须要考虑指令之间的<strong>数据依赖性</strong>；</p>
<p>多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。</p>
</li>
</ul>
<h3 id="内存之间的交互操作"><a href="#内存之间的交互操作" class="headerlink" title="内存之间的交互操作"></a>内存之间的交互操作</h3><p>关于主内存和工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java 内存模型中定义了 8 种 操作来完成，<strong>虚拟机实现必须保证每一种操作都是原子的、不可再拆分的</strong>（double和long类型例外）</p>
<ul>
<li><strong>lock</strong>（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</li>
<li><strong>unlock</strong>（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li><strong>read</strong>（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li>
<li><strong>load</strong>（载入）：作用于工作内存的变量，它把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li><strong>use</strong>（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</li>
<li><strong>assign</strong>（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li><strong>store</strong>（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的 write操作使用。</li>
<li><strong>write</strong>（写入）：作用于主内存的变量，它把 store 操作从工作内存中得到的变量的值放入主内存的变量中。</li>
</ul>
<p>如果需要把一个变量从主内存复制到工作内存，那就要顺序地执行 <strong>read 和 load 操作</strong>，如果要把变量从工作内存同步回主内存，就要顺序地执行 <strong>store 和 write 操作</strong>。注意，<strong>Java 内存模型只要求上述两个操作必须按顺序执行，而没有保证是连续执行</strong>。也就是说 read 与 load 之间、store 与write 之间是可插入其他指令的，如对主内存中的变量 a、b 进行访问时，一种可能出现顺序是 read a、read b、load b、load a。</p>
<img src="/pics/image-20210319001848007.png" alt="image-20210319001848007" style="zoom:50%;" />

<p>除此之外，Java 内存模型还规定了在执行上述 8 种基本操作时必须满足如下规则</p>
<ul>
<li>不允许 read 和 load、store 和 write 操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。</li>
<li>不允许一个线程丢弃它的最近的 assign 操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li>
<li>不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从线程的工作内存同步回主内存。</li>
<li>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load 或 assign）的变量，换句话说，就是对一个变量实施 use、store 操作之前，必须先执行过了 assign 和 load 操作。</li>
<li>一个变量在同一时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。</li>
<li>如果对一个变量执行 lock 操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值。</li>
<li>如果一个变量事先没有被 lock 操作锁定，那就不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定住的变量。</li>
<li>对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中（执行 store、write 操作）。</li>
</ul>
<h4 id="long-和-double-型变量的特殊规则"><a href="#long-和-double-型变量的特殊规则" class="headerlink" title="long 和 double 型变量的特殊规则"></a>long 和 double 型变量的特殊规则</h4><p>Java 内存模型要求 lock，unlock，read，load，assign，use，store，write 这 8 个操作都具有原子性，但对于64 位的数据类型（ long 或 double），在模型中定义了一条相对宽松的规定，允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作划分为两次 32 位的操作来进行，即允许虚拟机实现选择可以不保证 64 位数据类型的load，store，read，write 这 4 个操作的原子性，即 <strong>long 和 double 的非原子性协定</strong>。</p>
<p>如果多线程的情况下double 或 long 类型并未声明为 volatile，可能会出现“半个变量”的数值，也就是既非原值，也非修改后的值。</p>
<p>虽然 Java 规范允许上面的实现，但商用虚拟机中基本都采用了原子性的操作，因此在日常使用中几乎不会出现读取到“半个变量”的情况，so，这个了解下就行。</p>
<h3 id="先行发生原则（这8种情况不可以重排序，必须加屏障）"><a href="#先行发生原则（这8种情况不可以重排序，必须加屏障）" class="headerlink" title="先行发生原则（这8种情况不可以重排序，必须加屏障）"></a>先行发生原则（这8种情况不可以重排序，必须加屏障）</h3><p>先行发生（happens-before）是 Java 内存模型中定义的两项操作之间的偏序关系，<strong>如果操作A 先行发生于操作B，那么A的结果对B可见</strong>。happens-before关系的分析需要分为<strong>单线程和多线程</strong>的情况：</p>
<ul>
<li><strong>单线程下的 happens-before</strong> 字节码的先后顺序天然包含 happens-before 关系：因为单线程内共享一份工作内存，不存在数据一致性的问题。 在程序控制流路径中靠前的字节码 happens-before 靠后的字节码，即靠前的字节码执行完之后操作结果对靠后的字节码可见。然而，这并不意味着前者一定在后者之前执行。实际上，如果后者不依赖前者的运行结果，那么它们可能会被重排序。</li>
<li><strong>多线程下的 happens-before</strong> 多线程由于每个线程有共享变量的副本，如果没有对共享变量做同步处理，线程 1 更新执行操作 A 共享变量的值之后，线程 2 开始执行操作 B，此时操作 A 产生的结果对操作 B 不一定可见。</li>
</ul>
<p>为了方便程序开发，Java 内存模型实现了下述的先行发生关系（“天然的”先行发生关系，无需任何同步器协助就存在）：</p>
<ul>
<li><strong>程序次序规则：</strong> 一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作。</li>
<li><strong>管程锁定规则：</strong> 一个 unLock 操作先行发生于后面对同一个锁的 lock 操作。</li>
<li><strong>volatile变量规则：</strong> 对一个变量的写操作先行发生于后面对这个变量的读操作。</li>
<li><strong>传递规则：</strong> 如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出操作 A 先行发生于操作 C。</li>
<li><strong>线程启动规则：</strong> Thread对象的 <code>start()</code> 方法先行发生于此线程的每一个动作。</li>
<li><strong>线程中断规则：</strong> 对线程 <code>interrupt()</code> 方法的调用先行发生于被中断线程的代码检测到中断事件的发生。</li>
<li><strong>线程终结规则：</strong> 线程中所有的操作都先行发生于线程的终止检测，我们可以通过<code>Thread.join()</code>方法结束、<code>Thread.isAlive()</code>的返回值手段检测到线程已经终止执行。</li>
<li><strong>对象终结规则：</strong> 一个对象的初始化完成先行发生于它的 <code>finalize()</code>方法的开始</li>
</ul>
<h3 id="内存屏障-1"><a href="#内存屏障-1" class="headerlink" title="内存屏障"></a>内存屏障</h3><p>上边的一系列操作保证了数据一致性，Java 中如何保证底层操作的有序性和可见性？可以通过内存屏障。</p>
<p>内存屏障是被插入两个 CPU 指令之间的一种指令，用来禁止处理器指令发生重排序（像屏障一样），从而保障<strong>有序性</strong>的。另外，为了达到屏障的效果，它也会使处理器写入、读取值之前，将主内存的值写入高速缓存，清空无效队列，从而保障<strong>可见性</strong>。eg:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Store1; </span><br><span class="line">Store2;   </span><br><span class="line">Load1;   </span><br><span class="line">StoreLoad;  //内存屏障</span><br><span class="line">Store3;   </span><br><span class="line">Load2;   </span><br><span class="line">Load3;</span><br></pre></td></tr></table></figure>

<p>StoreLoad 屏障之前的 Store 指令无法与 StoreLoad 屏障之后的 Load 指令进行交换位置，即<strong>重排序</strong>。但是 StoreLoad 屏障之前和之后的指令是可以互换位置的，即 Store1 可以和 Store2 互换，Load2 可以和 Load3 互换。</p>
<p>常见的 4 种屏障：<strong>注意这些不是cpu的指令，而是JVM的规范要求，</strong>不同的CPU有不同的实现。 </p>
<ul>
<li><p><strong>LoadLoad</strong> 屏障： 对于这样的语句 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Load1; LoadLoad; Load2</span><br></pre></td></tr></table></figure>

<p>在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</p>
</li>
<li><p><strong>StoreStore</strong> 屏障： 对于这样的语句 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Store1; StoreStore; Store2</span><br></pre></td></tr></table></figure>

<p>在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</p>
</li>
<li><p><strong>LoadStore</strong> 屏障： 对于这样的语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Load1; LoadStore; Store2</span><br></pre></td></tr></table></figure>

<p>在Store2及后续写入操作被执行前，保证Load1要读取的数据被读取完毕。</p>
</li>
<li><p><strong>StoreLoad</strong> 屏障： 对于这样的语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Store1; StoreLoad; Load2</span><br></pre></td></tr></table></figure>

<p>在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的（冲刷写缓冲器，清空无效化队列）。在大多数处理器的实现中，这个屏障也被称为<strong>全能屏障</strong>，兼具其它三种内存屏障的功能。</p>
</li>
</ul>
<p>Java 中对内存屏障的使用在一般的代码中不太容易见到，常见的有 volatile 和 synchronized 关键字修饰的代码块，还可以通过 Unsafe 这个类来使用内存屏障。（下一章扯扯这些）</p>
<p>Java 内存模型就是通过定义的这些来解决可见性、原子性和有序性的。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="JMM-是什么？"><a href="#JMM-是什么？" class="headerlink" title="JMM 是什么？"></a>JMM 是什么？</h3><p>JMM，java内存模型，定义了内存中变量的访问规范（JVM和RAM交互规则），是一种抽象的概念。目的是为了让<strong>java程序在各种平台下都能达到一致的并发效果</strong>，屏蔽掉各种硬件和操作系统的差异。</p>
<p>JMM规定了内存主要划分为<strong>主内存</strong>和<strong>工作内存</strong>两种。</p>
<ul>
<li>主内存(Main Memory)：JMM规定<strong>所有的变量都存储在主内存</strong>中。</li>
<li>工作内存：线程私有的，每条线程都有自己的工作内存。保存了该线程使用到的主内存中的共享变量的副本。<strong>线程对变量的所有操作都必须在工作内存进行，而不能直接读写主内存中的变量</strong>。</li>
</ul>
<h3 id="JMM解决什么问题？"><a href="#JMM解决什么问题？" class="headerlink" title="JMM解决什么问题？"></a>JMM解决什么问题？</h3><p>JMM主要是为了解决并发过程中<strong>可见性问题和竞争问题</strong>，围绕着并发过程中如何处理可见性、原子性和有序性这3个特性建立起来的。</p>
<ul>
<li><p>原子性</p>
<p>一个操作是不可分割、不可中断的，<strong>一个线程在执行时不会被其他线程干扰</strong>。synchronized + lock + cas</p>
</li>
<li><p>可见性</p>
<p>当一个线程修改共享变量的值，其他线程能够立即知道。 volatile  + synchronized + lock</p>
</li>
<li><p>有序性</p>
<p>程序执行的顺序按照代码的先后顺序执行。程序执行过程中，编译器和处理器对指令进行的重排序优化，使得<strong>并发过程中代码的执行顺序和代码的先后顺序不一致</strong>，导致最终的结果无法预测。synchronized + happensbefore + lock</p>
</li>
</ul>
<h3 id="JMM中的8种内存交互操作？"><a href="#JMM中的8种内存交互操作？" class="headerlink" title="JMM中的8种内存交互操作？"></a>JMM中的8种内存交互操作？</h3><ul>
<li>lock + unlock : 作用于主内存中的变量；lock，加锁，表示线程独占；unlock ，释放锁，允许其他线程再锁定</li>
<li>read +  write ：作用于主内存变量，read把变量从主内存传输到工作线程；load把变量从工作线程写入到主内存</li>
<li>load + store  ：作用于工作内存的变量，load把read 操作从主内存中得到的变量放入工作内存的变量副本中；store 把工作内存中一个变量的值传送到主内存中，以便随后的 write操作使用</li>
<li>use + assign ：作用于工作内存的变量，use把工作内存中一个变量的值传递给执行引擎；assgin把一个从执行引擎接收到的值赋给工作内存的变量</li>
</ul>
<h3 id="内存屏障？"><a href="#内存屏障？" class="headerlink" title="内存屏障？"></a>内存屏障？</h3><p>保证底层操作的有序性和可见性</p>
<ul>
<li>就像一套栅栏分割前后的代码，阻止栅栏前后的没有数据依赖性的代码进行指令重排序，保证程序在一定程度上的<strong>有序性</strong>。</li>
<li>强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效，保证数据的<strong>可见性</strong>。</li>
</ul>
<h3 id="happens-before原则理解？"><a href="#happens-before原则理解？" class="headerlink" title="happens-before原则理解？"></a>happens-before原则理解？</h3><p>先行发生（happens-before）是 Java 内存模型中定义的两项操作之间的偏序关系，<strong>如果操作A 先行发生于操作B，那么A的结果对B可见</strong>。共定义了8种规则，单线程是天然有序的，对于多线程来说，多个并发线程间必需要符合这个规则中的任一条，否则就不能保证有序。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://yq.aliyun.com/articles/750655">https://yq.aliyun.com/articles/750655</a></p>
<p><a href="https://www.cnblogs.com/54chensongxia/p/12120117.html">https://www.cnblogs.com/54chensongxia/p/12120117.html</a></p>
<p>《深入理解 Java 虚拟机》第二版</p>
<p><a href="http://tutorials.jenkov.com/java-concurrency/java-memory-model.html">http://tutorials.jenkov.com/java-concurrency/java-memory-model.html</a> <a href="https://juejin.im/post/5bf2977751882505d840321d#heading-5">https://juejin.im/post/5bf2977751882505d840321d#heading-5</a> <a href="http://rsim.cs.uiuc.edu/Pubs/popl05.pdf">http://rsim.cs.uiuc.edu/Pubs/popl05.pdf</a> <a href="http://ifeve.com/wp-content/uploads/2014/03/JSR133%E4%B8%AD%E6%96%87%E7%89%88.pdf">http://ifeve.com/wp-content/uploads/2014/03/JSR133中文版.pdf</a></p>
]]></content>
      <categories>
        <category>java</category>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC_02_CAS</title>
    <url>/2021/04/09/Notes/Java/JUC/JUC02_CAS/</url>
    <content><![CDATA[<h1 id="JUC-02-CAS"><a href="#JUC-02-CAS" class="headerlink" title="JUC_02_CAS"></a>JUC_02_CAS</h1>]]></content>
      <categories>
        <category>java</category>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC_03_volatile</title>
    <url>/2021/04/09/Notes/Java/JUC/JUC03_Volatile/</url>
    <content><![CDATA[<h1 id="JUC-03-volatile"><a href="#JUC-03-volatile" class="headerlink" title="JUC_03_volatile"></a>JUC_03_volatile</h1><p>被volatile修饰的共享变量，具有了以下特性：</p>
<ul>
<li>线程间可见性</li>
<li>禁止指令重排序 – 有序性</li>
<li>不保证原子性</li>
</ul>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>被volatile修饰的变量，如果在工作内存中发生了变化，回立刻写入到主内存中，同时使得其他工作内存中的变量无效。</p>
<p>写入过程中操作如下： <strong>lock + storge + write +  unlock</strong> 。</p>
<img src="../../pics/image-20210320170110425.png" alt="image-20210320170110425" style="zoom:50%;" />



<h3 id="lock-指令"><a href="#lock-指令" class="headerlink" title="lock 指令"></a>lock 指令</h3><p>volatile的底层实现是汇编的lock指令，<strong>它会锁定这块内存区域的缓存（缓存行锁定）</strong>。lock 前缀的指令在多核处理器下会引发两件事情：</p>
<ul>
<li>将当前处理器<strong>缓存行的数据写回到系统内存</strong></li>
<li><strong>使其他 CPU 里缓存了该内存地址的数据失效（MESI）</strong></li>
</ul>
<h3 id="不保证原子性"><a href="#不保证原子性" class="headerlink" title="不保证原子性"></a>不保证原子性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPlusPlus</span><span class="params">()</span></span>&#123;</span><br><span class="line">        number ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAtomic</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  MyData myData = <span class="keyword">new</span> MyData();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">        myData.add();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;addPlusThread:&quot;</span>+ i).start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//等待上边20个线程结束后(预计5秒肯定结束了)，在main线程中获取最后的number</span></span><br><span class="line">  TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>)&#123;</span><br><span class="line">    Thread.yield();</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(<span class="string">&quot;final value：&quot;</span>+myData.number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行 <code>testAtomic</code> 发现最后的输出值 &lt;= 10000 。</p>
<p>为什么会这样呢? 假设有2个线程同时执行 i ++，执行完工作内存值都是1，执行assgin回写时。此时出现线程竞争的话，<strong>线程1先会lock写入，线程2中的值会被置为无效</strong>，需要重新去主存中读取再继续执行，相当于丢失了一次值。</p>
<img src="../../pics/image-20210320162753252.png" alt="image-20210320162753252" style="zoom:50%;" />



<p>volatile的底层是使用内存屏障来保证有序性的。写volatile变量时，可以确保volatile写之前的操作不会被编译器重排序到volatile写之后。读volatile变量时，可以确保volatile读之后的操作不会被编译器重排序到volatile读之前。</p>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>禁止指令重排序 .从而避免了多线程环境下程序出现乱序执行的现象。</p>
<p>最常见的多线程环境中 <code>DCL(double-checked locking)</code> 版本的单例模式中，就是使用了 volatile 禁止指令重排的特性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123; <span class="comment">// 线程B</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">              	<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;<span class="comment">// 线程A</span></span><br><span class="line">                      instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为有指令重排序的存在，双端检索机制也不一定是线程安全的。</p>
<p><code>instance = new Singleton();</code> </p>
<p>初始化对象的过程其实并不是一个原子的操作，它会分为三部分执行：</p>
<ol>
<li>给 instance 分配内存</li>
<li>调用 instance 的构造函数来初始化对象</li>
<li>将 instance 对象指向分配的内存空间</li>
</ol>
<p>步骤 2 和 3 不存在数据依赖(as-if-serial)关系，如果虚拟机存在指令重排序优化，则步骤 2 和 3 的顺序是无法确定的。</p>
<p>如果 A 线程率先进入同步代码块并先执行了步骤3 而没有执行 2，也就是先给赋值给引用，但未进行初始化。</p>
<p>这时候线程 B 在第一次检查的时候，会发现 instance 已经是 非null 了，就将其返回使用，但是此时 instance 实际上还未初始化，自然就会出错。所以我们要限制实例对象的指令重排，用 volatile 修饰（JDK 5 之前使用了 volatile 的双检锁是有问题的）。</p>
<p>通过 hsdis 工具获取 JIT 编译器生成的汇编指令来看看对 volatile 进行写操作 CPU 会做什么事情，还是用上边的单例模式，可以看到</p>
<img src="../../pics/image-20210320214507422.png" alt="image-20210320214507422" style="zoom:50%;" />

<p>有 volatile 修饰的共享变量进行写操作时会多出第二行汇编代码，该句代码的意思是<strong>对原值加零</strong>，其中相加指令addl 前有 <strong>lock</strong> 修饰。</p>
<p>lock指令除了前面所讲的2个作用外，还有一个作用是<strong>提供内存屏障的作用</strong>，即</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br></pre></td></tr></table></figure>

<p>赋值操作的3条指令不可重排序。</p>
<p><a href="https://www.cnblogs.com/54chensongxia/p/12120117.html">https://www.cnblogs.com/54chensongxia/p/12120117.html</a></p>
]]></content>
      <categories>
        <category>java</category>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>AQS</tag>
      </tags>
  </entry>
</search>
