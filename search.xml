<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ALG_04_Tree</title>
    <url>/2021/05/24/Notes/Algorithm/ALG_04_Tree/</url>
    <content><![CDATA[<h1 id="ALG-04-Tree"><a href="#ALG-04-Tree" class="headerlink" title="ALG_04_Tree"></a>ALG_04_Tree</h1><span id="more"></span>

<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>二叉树，顾名思义，每个节点最多有两个“叉”，也就是两个子节点，分别是左子节点和右子节点。不过，二叉树并不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点。</p>
<h2 id="二叉树的种类"><a href="#二叉树的种类" class="headerlink" title="二叉树的种类"></a>二叉树的种类</h2><ul>
<li><p><strong>满二叉树</strong></p>
<p>二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。<strong>除了叶子节点之外，每个节点都有左右两个子节点</strong>，这种二叉树就叫做满二叉树。</p>
</li>
<li><p><strong>完全二叉树</strong></p>
<p>在完全二叉树中，<strong>除了最底层节点可能没填满外，其余每层节点数都达到最大值</strong>，并且<strong>最下面一层的节点都集中在该层最左边的若干位置</strong>，最底层节点从左到右是连续的。若最底层为第 h 层，则该层包含 1~ 2^n -1  个节点。<a href="http://baike.baidu.com/view/427110.htm">满二叉树</a>一定是完全二叉树，完全二叉树不一定是满二叉树。</p>
<p><img src="/pics/image-20210507182330231.png" alt="image-20210507182330231"></p>
</li>
</ul>
<ul>
<li><p><strong>二叉搜索/查找树（BST）</strong></p>
<p>前面介绍的树，都没有数值的，而二叉搜索树是有数值的了，<strong>二叉搜索树是一个有序树</strong>。</p>
<ul>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>它的左、右子树也分别为二叉排序树</li>
</ul>
</li>
<li><p><strong>平衡二叉搜索树 （AVL）</strong></p>
<p>它是一棵空树或它的<strong>左右两个子树的高度差的绝对值不超过1</strong>，并且左右两个子树都是一棵平衡二叉树。</p>
</li>
<li><p><strong>红黑树（RBT）</strong></p>
<p>红黑树相比于AVL树，牺牲了部分平衡性，以换取删除/插入操作时少量的旋转次数，整体来说，性能优于AVL树。</p>
</li>
</ul>
<h2 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h2><ul>
<li>深度优先<ul>
<li>前序遍历：中左右</li>
<li>中序遍历：左中右</li>
<li>后序遍历：左右中</li>
</ul>
</li>
<li>广度优先</li>
</ul>
<h2 id="二叉树的存储方式"><a href="#二叉树的存储方式" class="headerlink" title="二叉树的存储方式"></a>二叉树的存储方式</h2><ul>
<li><p>链式，节点数据结构如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    TreeNode() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>数组</p>
<p>用数组来存储二叉树如何遍历的呢？</p>
<p><strong>如果父节点的数组下标是i，那么它的左孩子就是i * 2 + 1，右孩子就是 i * 2 + 2。</strong></p>
<p>但是用链式表示的二叉树，更有利于我们理解，所以一般我们都是用链式存储二叉树。</p>
</li>
</ul>
<h1 id="LC归纳"><a href="#LC归纳" class="headerlink" title="LC归纳"></a>LC归纳</h1><p><img src="/pics/image-20210524180021425.png" alt="image-20210524180021425"></p>
<h2 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h2><p>递归三部曲</p>
<ol>
<li>确定递归函数的参数和返回值</li>
<li>确定终止条件</li>
<li>确定单层递归的逻辑</li>
</ol>
<h2 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h2><p>深度遍历（DFS）：前序遍历、中序遍历、后序遍历</p>
<p>广度遍历（BFS）：层序遍历</p>
<p>一般用DFS 和 BFS都能解决，一般来说DFS都要和递归配合起来使用，BFS ，但从理解角度具体问题具体分析。</p>
<h3 id="深度优先遍历（DFS）"><a href="#深度优先遍历（DFS）" class="headerlink" title="深度优先遍历（DFS）"></a>深度优先遍历（DFS）</h3><h4 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144.二叉树的前序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144.二叉树的前序遍历</a></h4><blockquote>
<p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// 1.确定递归函数的参数和返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        // 2.确定终止条件</span></span><br><span class="line"><span class="comment">//        if (root == null) &#123;</span></span><br><span class="line"><span class="comment">//            return Collections.emptyList();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        // 3.确定单层递归条件</span></span><br><span class="line"><span class="comment">//        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        list.add(root.val);</span></span><br><span class="line"><span class="comment">//        list.addAll(preorderTraversal(root.left));</span></span><br><span class="line"><span class="comment">//        list.addAll(preorderTraversal(root.right));</span></span><br><span class="line"><span class="comment">//        return list;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 解法二：层序遍历</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            res.add(node.val);</span><br><span class="line">            <span class="comment">// 由于栈的特性是 FILO，所以 根左右的顺序 应该变成 根右左</span></span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145.二叉树的后序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145.二叉树的后序遍历</a></h4><blockquote>
<p>给定一个二叉树，返回它的 <em>后序</em> 遍历。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        // 2.确定终止条件</span></span><br><span class="line"><span class="comment">//        if (root == null) &#123;</span></span><br><span class="line"><span class="comment">//            return Collections.emptyList();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        // 3.确定单层递归条件</span></span><br><span class="line"><span class="comment">//        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        list.addAll(postorderTraversal(root.left));</span></span><br><span class="line"><span class="comment">//        list.addAll(postorderTraversal(root.right));</span></span><br><span class="line"><span class="comment">//        list.add(root.val);</span></span><br><span class="line"><span class="comment">//        return list;</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// 解法二：层序遍历</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            res.add(node.val);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 后序遍历 反着来</span></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94.二叉树的中序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94.二叉树的中序遍历</a></h4><blockquote>
<p>给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        if(root == null) &#123;</span></span><br><span class="line"><span class="comment">//            return Collections.emptyList();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        list.addAll(inorderTraversal(root.left));</span></span><br><span class="line"><span class="comment">//        list.add(root.val);</span></span><br><span class="line"><span class="comment">//        list.addAll(inorderTraversal(root.right));</span></span><br><span class="line"><span class="comment">//        return list;</span></span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                res.add(cur.val);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="广度优先遍历BFS"><a href="#广度优先遍历BFS" class="headerlink" title="广度优先遍历BFS"></a>广度优先遍历BFS</h3><blockquote>
<p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
</blockquote>
<h4 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102.二叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102.二叉树的层序遍历</a></h4><blockquote>
<p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.初始化</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; nodeQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    nodeQueue.offer(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.开始遍历</span></span><br><span class="line">    <span class="keyword">while</span> (!nodeQueue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 当前层拥有的节点个数</span></span><br><span class="line">        <span class="keyword">int</span> count = nodeQueue.size();</span><br><span class="line">        List&lt;Integer&gt; level = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 遍历每一层的节点</span></span><br><span class="line">        <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            TreeNode node = nodeQueue.poll();</span><br><span class="line">            level.add(node.val);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123; <span class="comment">// 顺序添加左右节点</span></span><br><span class="line">                nodeQueue.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                nodeQueue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(level);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199.二叉树的右视图"></a><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/">199.二叉树的右视图</a></h4><blockquote>
<p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
</blockquote>
<p>层序遍历找 <code>这一层最右边的节点</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.初始化</span></span><br><span class="line">    List&lt;Integer&gt; l = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;<span class="comment">// 利用广度优先搜索进行层次遍历，记录下每层的最后一个元素。</span></span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (i == size - <span class="number">1</span>) &#123;</span><br><span class="line">                l.add(node.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116.填充每个节点的下一个右侧节点指针"></a><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">116.填充每个节点的下一个右侧节点指针</a></h4><blockquote>
<p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<p>struct Node {<br>  int val;<br>  Node *left;<br>  Node *right;<br>  Node *next;<br>}<br>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。</p>
</blockquote>
<p>层序遍历的方式可以解决，递归方式思路如下：</p>
<ol>
<li>站在当前节点上</li>
<li>连接当前节点的 左右子节点</li>
<li>连接左右子节点的 左右节点。</li>
<li>连接左子节点的右 和 右子节点的左</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        if (root == null) &#123;</span></span><br><span class="line"><span class="comment">//            return null;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        // 1.初始化</span></span><br><span class="line"><span class="comment">//        Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        queue.offer(root);</span></span><br><span class="line"><span class="comment">//        while (!queue.isEmpty()) &#123;</span></span><br><span class="line"><span class="comment">//            int size = queue.size();</span></span><br><span class="line"><span class="comment">//            Node nodePre = null;</span></span><br><span class="line"><span class="comment">//            for (int i = 0; i &lt; size; i++) &#123;</span></span><br><span class="line"><span class="comment">//                Node node = queue.poll();</span></span><br><span class="line"><span class="comment">//                if (i == 0) &#123;</span></span><br><span class="line"><span class="comment">//                    nodePre = node;</span></span><br><span class="line"><span class="comment">//                &#125; else &#123;</span></span><br><span class="line"><span class="comment">//                    nodePre.next = node;</span></span><br><span class="line"><span class="comment">//                    nodePre = node;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                if (node.left != null) &#123;</span></span><br><span class="line"><span class="comment">//                    queue.offer(node.left);</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//                if (node.right != null) &#123;</span></span><br><span class="line"><span class="comment">//                    queue.offer(node.right);</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">   						<span class="comment">// </span></span><br><span class="line"><span class="comment">//            if (nodePre != null) &#123;</span></span><br><span class="line"><span class="comment">//                nodePre.next = null;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        return root;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归方案</span></span><br><span class="line">        <span class="comment">// 1.退出条件</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">  		  connectTwoNode(root.left, root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connectTwoNode</span><span class="params">(Node left, Node right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> || right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 连接孩子左右</span></span><br><span class="line">        left.next = right;</span><br><span class="line">        <span class="comment">// 连接 左孩子 的左右</span></span><br><span class="line">        connectTwoNode(left.left, left.right);</span><br><span class="line">        <span class="comment">// 连接 右孩子的左右</span></span><br><span class="line">        connectTwoNode(right.left,right.right);</span><br><span class="line">        <span class="comment">// 连接 左孩子的右 和 右孩子的左</span></span><br><span class="line">        connectTwoNode(left.right, right.left);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="117-填充每个节点的下一个右侧节点指针II"><a href="#117-填充每个节点的下一个右侧节点指针II" class="headerlink" title="117.填充每个节点的下一个右侧节点指针II"></a><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/">117.填充每个节点的下一个右侧节点指针II</a></h4><blockquote>
<p>给定一个二叉树</p>
<p>struct Node {<br>  int val;<br>  Node *left;<br>  Node *right;<br>  Node *next;<br>}<br>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。</p>
</blockquote>
<p>DFS递归解决起来很难，层序遍历是通解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        if (root == null) &#123;</span></span><br><span class="line"><span class="comment">//            return null;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        // 1.初始化</span></span><br><span class="line"><span class="comment">//        Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        queue.offer(root);</span></span><br><span class="line"><span class="comment">//        while (!queue.isEmpty()) &#123;</span></span><br><span class="line"><span class="comment">//            int size = queue.size();</span></span><br><span class="line"><span class="comment">//            Node nodePre = null;</span></span><br><span class="line"><span class="comment">//            for (int i = 0; i &lt; size; i++) &#123;</span></span><br><span class="line"><span class="comment">//                Node node = queue.poll();</span></span><br><span class="line"><span class="comment">//                if (i == 0) &#123;</span></span><br><span class="line"><span class="comment">//                    nodePre = node;</span></span><br><span class="line"><span class="comment">//                &#125; else &#123;</span></span><br><span class="line"><span class="comment">//                    nodePre.next = node;</span></span><br><span class="line"><span class="comment">//                    nodePre = node;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                if (node.left != null) &#123;</span></span><br><span class="line"><span class="comment">//                    queue.offer(node.left);</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//                if (node.right != null) &#123;</span></span><br><span class="line"><span class="comment">//                    queue.offer(node.right);</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            if (nodePre != null) &#123;</span></span><br><span class="line"><span class="comment">//                nodePre.next = null;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        return root;</span></span><br><span class="line">        <span class="comment">// 1.退出条件</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归情况 1</span></span><br><span class="line">        <span class="comment">// 1.子节点有相同的的父节点，有子节点的情况</span></span><br><span class="line">        <span class="comment">//  a</span></span><br><span class="line">        <span class="comment">// / \</span></span><br><span class="line">        <span class="comment">//b  c</span></span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                root.left.next = root.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 递归情况 2</span></span><br><span class="line">                <span class="comment">//       a</span></span><br><span class="line">                <span class="comment">//     /   \</span></span><br><span class="line">                <span class="comment">//    b -&gt;   c</span></span><br><span class="line">                <span class="comment">//   / \    / \</span></span><br><span class="line">                <span class="comment">//  d      (e)  h</span></span><br><span class="line">                <span class="comment">// 如果是root是b时c， 需要将d (e, f) 建立连接</span></span><br><span class="line">                root.left.next = getNext(root.next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            root.right.next = getNext(root.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ！！！！先递归右子树 ！！！</span></span><br><span class="line">        connect(root.left);</span><br><span class="line">        connect(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">getNext</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) <span class="keyword">return</span> root.left;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) <span class="keyword">return</span> root.right;</span><br><span class="line">        <span class="keyword">if</span> (root.next != <span class="keyword">null</span>) <span class="keyword">return</span> getNext(root.next);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="同类题目"><a href="#同类题目" class="headerlink" title="同类题目"></a>同类题目</h3><h4 id="107-二叉树的层次遍历II"><a href="#107-二叉树的层次遍历II" class="headerlink" title="107.二叉树的层次遍历II"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">107.二叉树的层次遍历II</a></h4><h4 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513. 找树左下角的值"></a><a href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/">513. 找树左下角的值</a></h4><h4 id="429-N叉树的层序遍历"><a href="#429-N叉树的层序遍历" class="headerlink" title="429.N叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/">429.N叉树的层序遍历</a></h4><h4 id="515-在每个树行中找最大值"><a href="#515-在每个树行中找最大值" class="headerlink" title="515.在每个树行中找最大值"></a><a href="https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/">515.在每个树行中找最大值</a></h4><h4 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637.二叉树的层平均值"></a><a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/">637.二叉树的层平均值</a></h4><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><h3 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a><a href="https://leetcode-cn.com/problems/same-tree/">100. 相同的树</a></h3><p>Difficulty: **给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。   示例 1： 输入：p = [1,2,3], q = [1,2,3] 输出：true 示例 2： 输入：p = [1,2], q = [1,null,2] 输出：false 示例 3： 输入：p = [1,2,1], q = [1,1,2] 输出：false   提示： 两棵树上的节点数目都在范围 [0, 100] 内 -104 &lt;= Node.val &lt;= 104 **</p>
<p>给你两棵二叉树的根节点 <code>p</code> 和 <code>q</code> ，编写一个函数来检验这两棵树是否相同。</p>
<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：p = [1,2,3], q = [1,2,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：p = [1,2], q = [1,null,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：p = [1,2,1], q = [1,1,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  两棵树上的节点数目都在范围 <code>[0, 100]</code> 内</li>
<li>  <code>-10&lt;sup&gt;4&lt;/sup&gt; &lt;= Node.val &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
</ul>
<h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p.val == q.val &amp;&amp; isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h3><p>Difficulty: **给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。   示例 1: 输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7] 输出: [3,9,20,null,null,15,7] 示例 2: 输入: preorder = [-1], inorder = [-1] 输出: [-1]   提示: 1 &lt;= preorder.length &lt;= 3000 inorder.length == preorder.length -3000 &lt;= preorder[i], inorder[i] &lt;= 3000 preorder 和 inorder 均 无重复 元素 inorder 均出现在 preorder preorder 保证 为二叉树的前序遍历序列 inorder 保证 为二叉树的中序遍历序列 **</p>
<p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p>
<p><strong>示例 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]</span><br><span class="line">输出: [3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: preorder = [-1], inorder = [-1]</span><br><span class="line">输出: [-1]</span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li>  <code>1 &lt;= preorder.length &lt;= 3000</code></li>
<li>  <code>inorder.length == preorder.length</code></li>
<li>  <code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></li>
<li>  <code>preorder</code> 和 <code>inorder</code> 均 <strong>无重复</strong> 元素</li>
<li>  <code>inorder</code> 均出现在 <code>preorder</code></li>
<li>  <code>preorder</code> <strong>保证</strong> 为二叉树的前序遍历序列</li>
<li>  <code>inorder</code> <strong>保证</strong> 为二叉树的中序遍历序列</li>
</ul>
<h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">public TreeNode buildTree(int[] preorder, int[] inorder) &#123;</span><br><span class="line">    for (int i = 0; i &lt; inorder.length; i++) &#123;</span><br><span class="line">        map.put(inorder[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    return buildTree(preorder, 0, preorder.length, inorder, 0, inorder.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private TreeNode buildTree(int[] preorder, int pleft, int pRight, int[] inorder, int iLeft, int iRight) &#123;</span><br><span class="line">    if (iRight - iLeft &lt;= 0) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int splitVal = preorder[pleft];</span><br><span class="line">    int splitIndex = map.get(splitVal);</span><br><span class="line">    TreeNode root = new TreeNode(splitVal);</span><br><span class="line">    if (iRight - iLeft == 1) &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    // 中序遍历左部分的分割范围</span><br><span class="line">    root.left = buildTree(preorder, pleft + 1, pleft + 1 + (splitIndex - iLeft), // 起始索引 + 区间大小</span><br><span class="line">            inorder, iLeft, splitIndex);</span><br><span class="line">    root.right = buildTree(preorder, pleft + 1 + (splitIndex - iLeft), pRight, inorder, splitIndex + 1, iRight);</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h3><p>Difficulty: **给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。   示例 1: 输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3] 输出：[3,9,20,null,null,15,7] 示例 2: 输入：inorder = [-1], postorder = [-1] 输出：[-1]   提示: 1 &lt;= inorder.length &lt;= 3000 postorder.length == inorder.length -3000 &lt;= inorder[i], postorder[i] &lt;= 3000 inorder 和 postorder 都由 不同 的值组成 postorder 中每一个值都在 inorder 中 inorder 保证是树的中序遍历 postorder 保证是树的后序遍历 **</p>
<p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗 <em>二叉树</em> 。</p>
<p><strong>示例 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]</span><br><span class="line">输出：[3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：inorder = [-1], postorder = [-1]</span><br><span class="line">输出：[-1]</span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li>  <code>1 &lt;= inorder.length &lt;= 3000</code></li>
<li>  <code>postorder.length == inorder.length</code></li>
<li>  <code>-3000 &lt;= inorder[i], postorder[i] &lt;= 3000</code></li>
<li>  <code>inorder</code> 和 <code>postorder</code> 都由 <strong>不同</strong> 的值组成</li>
<li>  <code>postorder</code> 中每一个值都在 <code>inorder</code> 中</li>
<li>  <code>inorder</code> <strong>保证</strong>是树的中序遍历</li>
<li>  <code>postorder</code> <strong>保证</strong>是树的后序遍历</li>
</ul>
<h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h4><p>主要思路：</p>
<ul>
<li>根据后序遍历确定根节点</li>
<li>根据中序遍历确定分割区间</li>
<li>中序和后序的区间范围是相同的</li>
</ul>
<p><img src="/pics/image-20210524152926208.png" alt="image-20210524152926208"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = postorder.length;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span> || inorder.length != length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序遍历数组最后一个元素，就是当前的中间节点</span></span><br><span class="line">    <span class="keyword">int</span> rootVal = postorder[length - <span class="number">1</span>];</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 找到中序遍历的切割点</span></span><br><span class="line">    <span class="keyword">int</span> inOrderSplitIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (inOrderSplitIndex &lt; length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder[inOrderSplitIndex] == rootVal) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrderSplitIndex++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 切割中序数组</span></span><br><span class="line">    <span class="comment">// 左闭右开区间：[0, inOrderSplitIndex)</span></span><br><span class="line">    <span class="keyword">int</span>[] leftInorder = Arrays.copyOfRange(inorder, <span class="number">0</span>, inOrderSplitIndex);</span><br><span class="line">    <span class="keyword">int</span>[] rightInorder = Arrays.copyOfRange(inorder, inOrderSplitIndex + <span class="number">1</span>, length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切割后序数组</span></span><br><span class="line">    <span class="comment">// 依然左闭右开，注意这里使用了左中序数组大小作为切割点</span></span><br><span class="line">    <span class="comment">// [0, leftInorder.size)</span></span><br><span class="line">    <span class="keyword">int</span> leftInorderLen = leftInorder.length;</span><br><span class="line">    <span class="keyword">int</span>[] leftPostOrder = Arrays.copyOfRange(postorder, <span class="number">0</span>, leftInorderLen);</span><br><span class="line">    <span class="keyword">int</span>[] rightPostOrder = Arrays.copyOfRange(postorder, leftInorderLen, leftInorderLen + rightInorder.length);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 划分成更小的左区间</span></span><br><span class="line">    root.left = buildTree(leftInorder, leftPostOrder);</span><br><span class="line">    <span class="comment">// 划分成更小的右区间</span></span><br><span class="line">    root.right = buildTree(rightInorder, rightPostOrder);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化空间复杂度和时间复杂度：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用map来优化取分割数的时间复杂度</span></span><br><span class="line">HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree2</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">        map.put(inorder[i], i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buildTree(inorder, <span class="number">0</span>, inorder.length, postorder, <span class="number">0</span>, postorder.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意区间范围是 [)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span> inorderLeft, <span class="keyword">int</span> inorderRight, <span class="keyword">int</span>[] postOrder, <span class="keyword">int</span> pLeft, <span class="keyword">int</span> pRight)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = inorderRight - inorderLeft;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> rootVal = postOrder[pRight - <span class="number">1</span>];</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过hashMap 优化中序遍历中 root节点的索引查找</span></span><br><span class="line">    <span class="keyword">int</span> inorderSplit = map.get(rootVal);</span><br><span class="line">    <span class="comment">//int inorderSplit = inorderLeft;</span></span><br><span class="line">    <span class="comment">//while (inorderSplit &lt; len) &#123;</span></span><br><span class="line">    <span class="comment">//    if (inorder[inorderSplit] == rootVal) &#123;</span></span><br><span class="line">    <span class="comment">//        break;</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//    inorderSplit++;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序的左区间 + 后序的左</span></span><br><span class="line">    root.left = buildTree(inorder, inorderLeft, inorderSplit, postOrder,</span><br><span class="line">            pLeft, pLeft + inorderSplit - inorderLeft);</span><br><span class="line">    <span class="comment">// 中序的右 + 后序的右</span></span><br><span class="line">    root.right = buildTree(inorder, inorderSplit + <span class="number">1</span>, inorderRight,</span><br><span class="line">            postOrder, pLeft + inorderSplit - inorderLeft, pRight - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树</a></h3><p>Difficulty: **给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。   示例 1： 输入：root = [4,2,7,1,3,6,9] 输出：[4,7,2,9,6,3,1] 示例 2： 输入：root = [2,1,3] 输出：[2,3,1] 示例 3： 输入：root = [] 输出：[]   提示： 树中节点数目范围在 [0, 100] 内 -100 &lt;= Node.val &lt;= 100 **</p>
<p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [2,1,3]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  树中节点数目范围在 <code>[0, 100]</code> 内</li>
<li>  <code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<h4 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        if (root == null) &#123;</span></span><br><span class="line"><span class="comment">//            return null;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//				TreeNode tmp = root.left;</span></span><br><span class="line"><span class="comment">//        root.left = root.right;</span></span><br><span class="line"><span class="comment">//        root.right = tmp;</span></span><br><span class="line"><span class="comment">//        invertTree(root.left);</span></span><br><span class="line"><span class="comment">//        invertTree(root.right);</span></span><br><span class="line"><span class="comment">//        return root;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                swap(node);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404. 左叶子之和"></a><a href="https://leetcode-cn.com/problems/sum-of-left-leaves/">404. 左叶子之和</a></h3><p>Difficulty: **给定二叉树的根节点 root ，返回所有左叶子之和。   示例 1： 输入: root = [3,9,20,null,null,15,7] 输出: 24 解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24 示例 2: 输入: root = [1] 输出: 0   提示: 节点数在 [1, 1000] 范围内 -1000 &lt;= Node.val &lt;= 1000   **</p>
<p>给定二叉树的根节点 <code>root</code> ，返回所有左叶子之和。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/04/08/leftsum-tree.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: root = [3,9,20,null,null,15,7] </span><br><span class="line">输出: 24 </span><br><span class="line">解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: root = [1]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li>  节点数在 <code>[1, 1000]</code> 范围内</li>
<li>  <code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<h4 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果左节点不为空，且左节点没有左右孩子，那么这个节点的左节点就是左叶子</span></span><br><span class="line">    <span class="comment">// 这道题前中后序都能做，核心是判断左节点</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="keyword">null</span> &amp;&amp; root.left.left == <span class="keyword">null</span> &amp;&amp; root.left.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sum += root.left.val ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = sumOfLeftLeaves(root.left);</span><br><span class="line">    <span class="keyword">int</span> right = sumOfLeftLeaves(root.right);</span><br><span class="line">    <span class="keyword">return</span> sum + left + right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="572-另一棵树的子树"><a href="#572-另一棵树的子树" class="headerlink" title="572. 另一棵树的子树"></a><a href="https://leetcode-cn.com/problems/subtree-of-another-tree/">572. 另一棵树的子树</a></h3><p>Difficulty: ** 给你两棵二叉树 root 和 subRoot 。检验 root 中是否包含和 subRoot 具有相同结构和节点值的子树。如果存在，返回 true ；否则，返回 false 。 二叉树 tree 的一棵子树包括 tree 的某个节点和这个节点的所有后代节点。tree 也可以看做它自身的一棵子树。   示例 1： 输入：root = [3,4,5,1,2], subRoot = [4,1,2] 输出：true 示例 2： 输入：root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2] 输出：false   提示： root 树上的节点数量范围是 [1, 2000] subRoot 树上的节点数量范围是 [1, 1000] -104 &lt;= root.val &lt;= 104 -104 &lt;= subRoot.val &lt;= 104 **</p>
<p>给你两棵二叉树 <code>root</code> 和 <code>subRoot</code> 。检验 <code>root</code> 中是否包含和 <code>subRoot</code> 具有相同结构和节点值的子树。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>二叉树 <code>tree</code> 的一棵子树包括 <code>tree</code> 的某个节点和这个节点的所有后代节点。<code>tree</code> 也可以看做它自身的一棵子树。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/04/28/subtree1-tree.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,4,5,1,2], subRoot = [4,1,2]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/04/28/subtree2-tree.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>root</code> 树上的节点数量范围是 <code>[1, 2000]</code></li>
<li>  <code>subRoot</code> 树上的节点数量范围是 <code>[1, 1000]</code></li>
<li>  <code>-10&lt;sup&gt;4&lt;/sup&gt; &lt;= root.val &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
<li>  <code>-10&lt;sup&gt;4&lt;/sup&gt; &lt;= subRoot.val &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
</ul>
<h4 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h4><p>双条件递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode root, TreeNode subRoot)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 这是 isSubtree 递归结束条件</span></span><br><span class="line">  		<span class="comment">//递归结束条件1：当二者都为空时，返回true</span></span><br><span class="line">			<span class="keyword">if</span>(s==<span class="keyword">null</span> &amp;&amp; t==<span class="keyword">null</span>)   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">//递归结束条件2：当有一方已经遍历完，但另一颗还未遍历完时，返回false    </span></span><br><span class="line">      <span class="keyword">if</span>(s==<span class="keyword">null</span> || t==<span class="keyword">null</span>)  <span class="keyword">return</span> <span class="keyword">false</span>;   </span><br><span class="line"></span><br><span class="line">        <span class="comment">/*t为s的子树，共有三种情况：</span></span><br><span class="line"><span class="comment">        1. t和s相同；</span></span><br><span class="line"><span class="comment">        2. t是s的某个左子树；</span></span><br><span class="line"><span class="comment">        3. t是s的某个右子树</span></span><br><span class="line"><span class="comment">        只要符合三条中的一条，就是符合题意的*/</span></span><br><span class="line">    <span class="keyword">return</span> isSameTree(root, subRoot)</span><br><span class="line">            || isSubtree(root.left, subRoot)</span><br><span class="line">            || isSubtree(root.right, subRoot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">100.</span>相同的树](https:<span class="comment">//leetcode-cn.com/problems/same-tree/)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; q != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.val != q.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">617. 合并二叉树</a></h3><p>Difficulty: **给你两棵二叉树： root1 和 root2 。 想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。 返回合并后的二叉树。 注意: 合并过程必须从两个树的根节点开始。   示例 1： 输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7] 输出：[3,4,5,5,4,null,7] 示例 2： 输入：root1 = [1], root2 = [1,2] 输出：[2,2]   提示： 两棵树中的节点数目在范围 [0, 2000] 内 -104 &lt;= Node.val &lt;= 104 **</p>
<p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p>
<p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p>
<p>返回合并后的二叉树。</p>
<p><strong>注意:</strong> 合并过程必须从两个树的根节点开始。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/05/merge.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]</span><br><span class="line">输出：[3,4,5,5,4,null,7]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root1 = [1], root2 = [1,2]</span><br><span class="line">输出：[2,2]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  两棵树中的节点数目在范围 <code>[0, 2000]</code> 内</li>
<li>  <code>-10&lt;sup&gt;4&lt;/sup&gt; &lt;= Node.val &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
</ul>
<h4 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="keyword">null</span> &amp;&amp; root2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root1.val = root1.val + root2.val;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        root1.left = mergeTrees(root1.left, root2.left);</span><br><span class="line">        root1.right = mergeTrees(root1.right, root2.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654. 最大二叉树"></a><a href="https://leetcode-cn.com/problems/maximum-binary-tree/">654. 最大二叉树</a></h3><p>Difficulty: **给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建: 创建一个根节点，其值为 nums 中的最大值。 递归地在最大值 左边 的 子数组前缀上 构建左子树。 递归地在最大值 右边 的 子数组后缀上 构建右子树。 返回 nums 构建的 最大二叉树 。   示例 1： 输入：nums = [3,2,1,6,0,5] 输出：[6,3,5,null,2,0,null,null,1] 解释：递归调用如下所示： - [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。 - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。 - 空数组，无子节点。 - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。 - 空数组，无子节点。 - 只有一个元素，所以子节点是一个值为 1 的节点。 - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。 - 只有一个元素，所以子节点是一个值为 0 的节点。 - 空数组，无子节点。 示例 2： 输入：nums = [3,2,1] 输出：[3,null,2,null,1]   提示： 1 &lt;= nums.length &lt;= 1000 0 &lt;= nums[i] &lt;= 1000 nums 中的所有整数 互不相同 **</p>
<p>给定一个不重复的整数数组 <code>nums</code> 。 <strong>最大二叉树</strong> 可以用下面的算法从 <code>nums</code> 递归地构建:</p>
<ol>
<li> 创建一个根节点，其值为 <code>nums</code> 中的最大值。</li>
<li> 递归地在最大值 <strong>左边</strong> 的 <strong>子数组前缀上</strong> 构建左子树。</li>
<li> 递归地在最大值 <strong>右边</strong> 的 <strong>子数组后缀上</strong> 构建右子树。</li>
</ol>
<p>返回 <em><code>nums</code> 构建的</em> <strong><em>最大二叉树</em></strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,1,6,0,5]</span><br><span class="line">输出：[6,3,5,null,2,0,null,null,1]</span><br><span class="line">解释：递归调用如下所示：</span><br><span class="line">- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。</span><br><span class="line">    - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。</span><br><span class="line">        - 空数组，无子节点。</span><br><span class="line">        - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。</span><br><span class="line">            - 空数组，无子节点。</span><br><span class="line">            - 只有一个元素，所以子节点是一个值为 1 的节点。</span><br><span class="line">    - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。</span><br><span class="line">        - 只有一个元素，所以子节点是一个值为 0 的节点。</span><br><span class="line">        - 空数组，无子节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/24/tree2.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,1]</span><br><span class="line">输出：[3,null,2,null,1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 1000</code></li>
<li>  <code>0 &lt;= nums[i] &lt;= 1000</code></li>
<li>  <code>nums</code> 中的所有整数 <strong>互不相同</strong></li>
</ul>
<h4 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h4><p>二叉树递归的难点是分析出<strong>最小递归子问题</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> constructMaximumBinaryTree(nums, <span class="number">0</span>, nums.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (right - left &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right - left == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(nums[left]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxIndex = left;</span><br><span class="line">    <span class="keyword">int</span> maxValue = nums[left];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; right; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; maxValue) &#123;</span><br><span class="line">            maxValue = nums[i];</span><br><span class="line">            maxIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(maxValue);</span><br><span class="line">    root.left = constructMaximumBinaryTree(nums, left, maxIndex);</span><br><span class="line">    root.right = constructMaximumBinaryTree(nums, maxIndex + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a></h3><p>Difficulty: **给你一个二叉树的根节点 root ， 检查它是否轴对称。   示例 1： 输入：root = [1,2,2,3,4,4,3] 输出：true 示例 2： 输入：root = [1,2,2,null,3,null,3] 输出：false   提示： 树中节点数目在范围 [1, 1000] 内 -100 &lt;= Node.val &lt;= 100   进阶：你可以运用递归和迭代两种方法解决这个问题吗？ **</p>
<p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,2,3,4,4,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,2,null,3,null,3]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  树中节点数目在范围 <code>[1, 1000]</code> 内</li>
<li>  <code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p><strong>进阶：</strong>你可以运用递归和迭代两种方法解决这个问题吗？</p>
<h4 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h4><p>主要解法为<strong>后序遍历 + 递归</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// step1.确定的递归的参数和返回值，判断左 右节点是不是对称的</span></span><br><span class="line">    <span class="keyword">return</span> isSymmetric(root.left, root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode left, TreeNode right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) &#123;</span><br><span class="line">		    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (left == <span class="keyword">null</span> || right == <span class="keyword">null</span>) &#123;</span><br><span class="line">		    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (left.val != right.val) &#123;</span><br><span class="line">		    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> isSymmetric(left.left, right.right) &amp;&amp; isSymmetric(left.right, right.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h3><p>Difficulty: **给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例： 给定二叉树 [3,9,20,null,null,15,7]， 3 / \ 9 20 / \ 15 7 返回它的最大深度 3 。 **</p>
<p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<p><strong>示例：</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回它的最大深度 3 。</p>
<h4 id="Solution-9"><a href="#Solution-9" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归的终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// 单层递归的逻辑</span></span><br><span class="line">    <span class="keyword">int</span> left = maxDepth(root.left); </span><br><span class="line">    <span class="keyword">int</span> right = maxDepth(root.right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + Math.max(left, right);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解法2：层序遍历</span></span><br><span class="line">    <span class="comment">//if (root == null) &#123;</span></span><br><span class="line">    <span class="comment">//    return 0;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//Deque&lt;TreeNode&gt; treeNodes = new LinkedList&lt;&gt;();</span></span><br><span class="line">    <span class="comment">//treeNodes.offer(root);</span></span><br><span class="line">    <span class="comment">//int sum = 0;</span></span><br><span class="line">    <span class="comment">//while (!treeNodes.isEmpty()) &#123;</span></span><br><span class="line">    <span class="comment">//    int size = treeNodes.size();</span></span><br><span class="line">    <span class="comment">//    while (size &gt; 0) &#123;</span></span><br><span class="line">    <span class="comment">//        TreeNode treeNode = treeNodes.poll();</span></span><br><span class="line">    <span class="comment">//        if (treeNode.left != null) &#123;</span></span><br><span class="line">    <span class="comment">//            treeNodes.offer(treeNode.left);</span></span><br><span class="line">    <span class="comment">//        &#125;</span></span><br><span class="line">    <span class="comment">//        if (treeNode.right != null) &#123;</span></span><br><span class="line">    <span class="comment">//            treeNodes.offer(treeNode.right);</span></span><br><span class="line">    <span class="comment">//        &#125;</span></span><br><span class="line">    <span class="comment">//        size--;</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//    sum += 1;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a href="https://leetcode-cn.com/problems/balanced-binary-tree/">110. 平衡二叉树</a></h3><p>Difficulty: **给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。   示例 1： 输入：root = [3,9,20,null,null,15,7] 输出：true 示例 2： 输入：root = [1,2,2,3,3,null,null,4,4] 输出：false 示例 3： 输入：root = [] 输出：true   提示： 树中的节点数在范围 [0, 5000] 内 -104 &lt;= Node.val &lt;= 104 **</p>
<p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<blockquote>
<p>一个二叉树_每个节点 _的左右两个子树的高度差的绝对值不超过 1 。</p>
</blockquote>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,2,3,3,null,null,4,4]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  树中的节点数在范围 <code>[0, 5000]</code> 内</li>
<li>  <code>-10&lt;sup&gt;4&lt;/sup&gt; &lt;= Node.val &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
</ul>
<h4 id="Solution-10"><a href="#Solution-10" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> getHeight(root) != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = getHeight(root.left);</span><br><span class="line">    <span class="keyword">int</span> right = getHeight(root.right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左右2个又一个不符合，这个节点也是-1</span></span><br><span class="line">    <span class="keyword">if</span> (left == -<span class="number">1</span> || right == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左右差值 &gt; 1</span></span><br><span class="line">    <span class="keyword">if</span> (Math.abs(left - right) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 返回最大高度</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h3><p>Difficulty: **给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明：叶子节点是指没有子节点的节点。   示例 1： 输入：root = [3,9,20,null,null,15,7] 输出：2 示例 2： 输入：root = [2,null,3,null,4,null,5,null,6] 输出：5   提示： 树中节点数的范围在 [0, 105] 内 -1000 &lt;= Node.val &lt;= 1000 **</p>
<p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p><strong>说明：</strong>叶子节点是指没有子节点的节点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [2,null,3,null,4,null,5,null,6]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  树中节点数的范围在 <code>[0, 10&lt;sup&gt;5&lt;/sup&gt;]</code> 内</li>
<li>  <code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<h4 id="Solution-11"><a href="#Solution-11" class="headerlink" title="Solution"></a>Solution</h4><p>注意递归条件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。，注意是叶子节点。</span></span><br><span class="line">    <span class="comment">// 当一个左子树为空，右不为空，这时并不是最低点</span></span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> leftHigh = minDepth(root.left);</span><br><span class="line">    <span class="keyword">int</span> rightHigh = minDepth(root.right);</span><br><span class="line">    <span class="comment">// 如果右子树为空，则返回左子树</span></span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + rightHigh;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果左子树为空，则返回右子树</span></span><br><span class="line">    <span class="keyword">if</span> (root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="number">1</span> + leftHigh;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左右均不为空，则返回较小的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + Math.min(leftHigh, rightHigh);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h3><p>Difficulty: **给你二叉树的根结点 root ，请你将它展开为一个单链表： 展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。 展开后的单链表应该与二叉树 先序遍历 顺序相同。   示例 1： 输入：root = [1,2,5,3,4,null,6] 输出：[1,null,2,null,3,null,4,null,5,null,6] 示例 2： 输入：root = [] 输出：[] 示例 3： 输入：root = [0] 输出：[0]   提示： 树中结点数在范围 [0, 2000] 内 -100 &lt;= Node.val &lt;= 100   进阶：你可以使用原地算法（O(1) 额外空间）展开这棵树吗？ **</p>
<p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p>
<ul>
<li>  展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li>
<li>  展开后的单链表应该与二叉树 顺序相同。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,5,3,4,null,6]</span><br><span class="line">输出：[1,null,2,null,3,null,4,null,5,null,6]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  树中结点数在范围 <code>[0, 2000]</code> 内</li>
<li>  <code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p><strong>进阶：</strong>你可以使用原地算法（<code>O(1)</code> 额外空间）展开这棵树吗？</p>
<h4 id="Solution-12"><a href="#Solution-12" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**** 后序遍历位置 ****/</span></span><br><span class="line">    <span class="comment">// 1、左右子树已经被拉平成一条链表</span></span><br><span class="line">    flatten(root.left);</span><br><span class="line">    flatten(root.right);</span><br><span class="line"></span><br><span class="line">    TreeNode left = root.left;</span><br><span class="line">    TreeNode right = root.right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、将左子树作为右子树</span></span><br><span class="line">    root.left = <span class="keyword">null</span>;</span><br><span class="line">    root.right = left;</span><br><span class="line">    <span class="comment">// 3、将原先的右子树接到当前右子树的末端</span></span><br><span class="line">    TreeNode p = root;</span><br><span class="line">    <span class="keyword">while</span> (p.right != <span class="keyword">null</span>) &#123; <span class="comment">// p.right 还是 p，这是容易出错的地方</span></span><br><span class="line">        p = p.right;</span><br><span class="line">    &#125;</span><br><span class="line">     p.right = right;</span><br><span class="line">          <span class="comment">// 错误写法</span></span><br><span class="line"><span class="comment">//        TreeNode p = root.right;</span></span><br><span class="line"><span class="comment">//        while (p != null) &#123;</span></span><br><span class="line"><span class="comment">//            p = p.right;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        p = right;</span></span><br><span class="line">  </span><br><span class="line">     <span class="comment">// 前序遍历的解法</span></span><br><span class="line">	<span class="comment">//   if (root == null) &#123;</span></span><br><span class="line">	<span class="comment">//       return;</span></span><br><span class="line">	<span class="comment">//   &#125;</span></span><br><span class="line">	<span class="comment">//   List&lt;TreeNode&gt; list = preOrder(root);</span></span><br><span class="line">	<span class="comment">//   TreeNode pre = null;</span></span><br><span class="line">	<span class="comment">//   for(int i = 0; i &lt; list.size(); i++) &#123;</span></span><br><span class="line">	<span class="comment">//       TreeNode node = list.get(i);</span></span><br><span class="line">	<span class="comment">//       if (i &gt; 0) &#123;</span></span><br><span class="line">	<span class="comment">//           pre.right = node;</span></span><br><span class="line">	<span class="comment">//            pre.left = null;</span></span><br><span class="line">	<span class="comment">//       &#125;</span></span><br><span class="line">	<span class="comment">//       pre = node;</span></span><br><span class="line">	<span class="comment">//   &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;TreeNode&gt; <span class="title">preOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;TreeNode&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    res.add(root);</span><br><span class="line">    res.addAll(preOrder(root.left));</span><br><span class="line">    res.addAll(preOrder(root.right));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h3 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></h3><p>Difficulty: **给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。 完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。   示例 1： 输入：root = [1,2,3,4,5,6] 输出：6 示例 2： 输入：root = [] 输出：0 示例 3： 输入：root = [1] 输出：1   提示： 树中节点的数目范围是[0, 5 * 104] 0 &lt;= Node.val &lt;= 5 * 104 题目数据保证输入的树是 完全二叉树   进阶：遍历树来统计节点是一种时间复杂度为 O(n) 的简单解决方案。你可以设计一个更快的算法吗？ **</p>
<p>给你一棵 <strong>完全二叉树</strong> 的根节点 <code>root</code> ，求出该树的节点个数。</p>
<p>的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 <code>h</code> 层，则该层包含 <code>1~ 2&lt;sup&gt;h&lt;/sup&gt;</code> 个节点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/14/complete.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,3,4,5,6]</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  树中节点的数目范围是<code>[0, 5 * 10&lt;sup&gt;4&lt;/sup&gt;]</code></li>
<li>  <code>0 &lt;= Node.val &lt;= 5 * 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
<li>  题目数据保证输入的树是 <strong>完全二叉树</strong></li>
</ul>
<p><strong>进阶：</strong>遍历树来统计节点是一种时间复杂度为 <code>O(n)</code> 的简单解决方案。你可以设计一个更快的算法吗？</p>
<h4 id="Solution-13"><a href="#Solution-13" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = countNodes(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = countNodes(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + left + right;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></h3><p>Difficulty: **给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]   示例 1: 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 示例 2: 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 输出: 2 解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。   说明: 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉搜索树中。 **</p>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>
<p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png"></p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4</span><br><span class="line">输出: 2</span><br><span class="line">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ul>
<li>  所有节点的值都是唯一的。</li>
<li>  p、q 为不同节点且均存在于给定的二叉搜索树中。</li>
</ul>
<h4 id="Solution-14"><a href="#Solution-14" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 二叉搜索树</span></span><br><span class="line">    <span class="comment">// 左子树&lt;根节点&lt;右子树</span></span><br><span class="line">    <span class="comment">// 结束条件：公共节点确定</span></span><br><span class="line">    <span class="comment">// 1、p,q刚好是根节点的左右节点。</span></span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &lt; q.val </span><br><span class="line">        || root.val &lt; p.val &amp;&amp; root.val &gt; q.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p或者q刚好是根节点。</span></span><br><span class="line">		<span class="comment">// 1、p q 是在同一个分叉上的话，第一个找到的节点一定是根结点</span></span><br><span class="line">    <span class="comment">// 2、p q 不在一个分叉上的话 直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (root.val == p.val || root.val == q.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单层逻辑：</span></span><br><span class="line">    <span class="comment">// 1.如果p,q节点均&gt;根节点，则最近公共祖先在根节点右侧寻找</span></span><br><span class="line">    <span class="keyword">if</span>(p.val &gt; root.val &amp;&amp; q.val &gt; root.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果p,q节点均&lt;根节点，则最近公共祖先在根节点左侧寻找</span></span><br><span class="line">    <span class="keyword">if</span>(p.val &lt; root.val &amp;&amp; q.val &lt; root.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h3><p>Difficulty: **给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”   示例 1： 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 输出：3 解释：节点 5 和节点 1 的最近公共祖先是节点 3 。 示例 2： 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 输出：5 解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。 示例 3： 输入：root = [1,2], p = 1, q = 2 输出：1   提示： 树中节点数目在范围 [2, 105] 内。 -109 &lt;= Node.val &lt;= 109 所有 Node.val 互不相同 。 p != q p 和 q 均存在于给定的二叉树中。 **</p>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">输出：3</span><br><span class="line">解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class="line">输出：5</span><br><span class="line">解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2], p = 1, q = 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  树中节点数目在范围 <code>[2, 10&lt;sup&gt;5&lt;/sup&gt;]</code> 内。</li>
<li>  <code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= Node.val &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code></li>
<li>  所有 <code>Node.val</code> <code>互不相同</code> 。</li>
<li>  <code>p != q</code></li>
<li>  <code>p</code> 和 <code>q</code> 均存在于给定的二叉树中。</li>
</ul>
<h4 id="Solution-15"><a href="#Solution-15" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 题解：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-hou-xu/</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 终止条件：</span></span><br><span class="line">    <span class="comment">//1. root == null</span></span><br><span class="line">     <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   	<span class="comment">// 2.如果找到了 节点p或者q, 不能再往下找了</span></span><br><span class="line">     <span class="comment">// 1、p q 是在同一个分叉上的话，第一个找到的节点一定是根结点</span></span><br><span class="line">     <span class="comment">// 2、p q 不在一个分叉上的话，返回就行，再找没有意义 </span></span><br><span class="line">     <span class="keyword">if</span> (root == p || root == q) &#123;</span><br><span class="line">         <span class="keyword">return</span> root;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 分别查找左树和右树</span></span><br><span class="line">     TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">     TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 如果left 和 right都不为空，说明此时root就是最近公共节点，向上返回</span></span><br><span class="line">     <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> root;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 如果左边有，返回左边的值，否则返回右边的</span></span><br><span class="line">     <span class="keyword">return</span> left != <span class="keyword">null</span> ? left : right;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>本题中的二叉树的最近公共祖先在本层是<strong>无法判断我们应当在root节点的左子树中查找，还是右子树中查找</strong>。因为它不像二叉搜索树存在和根节点相比左小右大的关系。<strong>而只能继续调用递归在左右子树中去寻找答案</strong>。二叉搜索树因为有确定的大小关系，查找时知道改如何查找。</p>
<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p>中序遍历适合解决二叉搜索树的问题，利用中序遍历BST是有序的这个特性。</p>
<h3 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h3><p>Difficulty: **给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。 有效 二叉搜索树定义如下： 节点的左子树只包含 小于 当前节点的数。 节点的右子树只包含 大于 当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。   示例 1： 输入：root = [2,1,3] 输出：true 示例 2： 输入：root = [5,1,4,null,null,3,6] 输出：false 解释：根节点的值是 5 ，但是右子节点的值是 4 。   提示： 树中节点数目范围在[1, 104] 内 -231 &lt;= Node.val &lt;= 231 - 1 **</p>
<p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p>
<p><strong>有效</strong> 二叉搜索树定义如下：</p>
<ul>
<li>  节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li>
<li>  节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li>
<li>  所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [2,1,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [5,1,4,null,null,3,6]</span><br><span class="line">输出：false</span><br><span class="line">解释：根节点的值是 5 ，但是右子节点的值是 4 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  树中节点数目范围在<code>[1, 10&lt;sup&gt;4&lt;/sup&gt;]</code> 内</li>
<li>  <code>-2&lt;sup&gt;31&lt;/sup&gt; &lt;= Node.val &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1</code></li>
</ul>
<h4 id="Solution-16"><a href="#Solution-16" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!isValidBST(root.left))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="keyword">null</span> &amp;&amp; pre.val &gt;= root.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!isValidBST(root.right)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530. 二叉搜索树的最小绝对差"></a><a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差</a></h3><p>Difficulty: **给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。 差值是一个正数，其数值等于两值之差的绝对值。   示例 1： 输入：root = [4,2,6,1,3] 输出：1 示例 2： 输入：root = [1,0,48,null,null,12,49] 输出：1   提示： 树中节点的数目范围是 [2, 104] 0 &lt;= Node.val &lt;= 105   注意：本题与 783 <a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/">https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/</a> 相同 **</p>
<p>给你一个二叉搜索树的根节点 <code>root</code> ，返回 <strong>树中任意两不同节点值之间的最小差值</strong> 。</p>
<p>差值是一个正数，其数值等于两值之差的绝对值。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [4,2,6,1,3]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/05/bst2.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,0,48,null,null,12,49]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  树中节点的数目范围是 <code>[2, 10&lt;sup&gt;4&lt;/sup&gt;]</code></li>
<li>  <code>0 &lt;= Node.val &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></li>
</ul>
<p><strong>注意：</strong>本题与 783 相同</p>
<h4 id="Solution-17"><a href="#Solution-17" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(root);</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(root.left);</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="keyword">null</span>) &#123;</span><br><span class="line">            min = Math.min(Math.abs(root.val - pre.val), min);</span><br><span class="line">        &#125;    </span><br><span class="line">        pre = root;</span><br><span class="line">        inOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700. 二叉搜索树中的搜索"></a><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></h3><p>Difficulty: **给定二叉搜索树（BST）的根节点 root 和一个整数值 val。 你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。   示例 1: 输入：root = [4,2,7,1,3], val = 2 输出：[2,1,3] Example 2: 输入：root = [4,2,7,1,3], val = 5 输出：[]   提示： 数中节点数在 [1, 5000] 范围内 1 &lt;= Node.val &lt;= 107 root 是二叉搜索树 1 &lt;= val &lt;= 107 **</p>
<p>给定二叉搜索树（BST）的根节点 <code>root</code> 和一个整数值 <code>val</code>。</p>
<p>你需要在 BST 中找到节点值等于 <code>val</code> 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 <code>null</code> 。</p>
<p><strong>示例 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/12/tree1.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3], val = 2</span><br><span class="line">输出：[2,1,3]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/12/tree2.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3], val = 5</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  数中节点数在 <code>[1, 5000]</code> 范围内</li>
<li>  <code>1 &lt;= Node.val &lt;= 10&lt;sup&gt;7&lt;/sup&gt;</code></li>
<li>  <code>root</code> 是二叉搜索树</li>
<li>  <code>1 &lt;= val &lt;= 10&lt;sup&gt;7&lt;/sup&gt;</code></li>
</ul>
<h4 id="Solution-18"><a href="#Solution-18" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || root.val == val) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; val) &#123;</span><br><span class="line">        <span class="keyword">return</span> searchBST(root.left, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> searchBST(root.right, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树-回溯"><a href="#二叉树-回溯" class="headerlink" title="二叉树+回溯"></a>二叉树+回溯</h2><p>一般回溯的的问题都可以通过层序遍历解决</p>
<h3 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a href="https://leetcode-cn.com/problems/path-sum/">112. 路径总和</a></h3><img src="/pics/image-20210530112056774.png" alt="image-20210530112056774" style="zoom:50%;" />

<p>这道题涉及到了回溯，难点是你站在root节点位置时怎么去定义退出条件。</p>
<p><code>节点是子节点 &amp; targetSum == root.val</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> targetSum)</span> </span>&#123; </span><br><span class="line">	<span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dfs(root, targetSum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (targetSum - root.val == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 找到了就立刻退出</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> left = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 1. 先找左边</span></span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        left = dfs(root.left, targetSum - root.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.左边没找到才向右边找</span></span><br><span class="line">    <span class="keyword">if</span> (!left &amp;&amp; root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root.right, targetSum - root.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113. 路径总和 II"></a><a href="https://leetcode-cn.com/problems/path-sum-ii/">113. 路径总和 II</a></h3><blockquote>
<p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p>
<p>叶子节点 是指没有子节点的节点。</p>
</blockquote>
<p><code>节点是子节点 &amp; targetSum == root.val</code> 的条件下需要将当前路径增加进去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> targetSum) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Deque&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    dfs(root, targetSum, path, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> targetSum, Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.val == targetSum) &#123;</span><br><span class="line">            path.addLast(root.val);</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        path.addLast(root.val);</span><br><span class="line">        dfs(root.left, targetSum - root.val, path, res);</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        path.addLast(root.val);</span><br><span class="line">        dfs(root.right, targetSum - root.val, path, res);</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257.二叉树的所有路径"></a><a href="https://leetcode-cn.com/problems/binary-tree-paths/">257.二叉树的所有路径</a></h3><img src="/pics/image-20210530112647863.png" alt="image-20210530112647863" style="zoom:50%;" />

<p>经典回溯问题，记录所有的路径。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root, <span class="string">&quot;&quot;</span>, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root,  String temp, List&lt;String&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp = temp + root.val;</span><br><span class="line">            result.add(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            binaryTreePaths(root.left, temp + root.val + <span class="string">&quot;-&gt;&quot;</span>, result); <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            binaryTreePaths(root.right, temp + root.val + <span class="string">&quot;-&gt;&quot;</span>, result);<span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        binaryTreePaths(root, <span class="string">&quot;&quot;</span>, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 		解法2：层序遍历</span></span><br><span class="line"><span class="comment">//        if (root == null) &#123;</span></span><br><span class="line"><span class="comment">//            return Collections.emptyList();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        Queue&lt;String&gt; paths = new LinkedList&lt;&gt;(); // 记录遍历到的路径</span></span><br><span class="line"><span class="comment">//        List&lt;String&gt; ans = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        queue.offer(root);</span></span><br><span class="line"><span class="comment">//        paths.offer(String.valueOf(root.val));</span></span><br><span class="line"><span class="comment">//        while (!queue.isEmpty()) &#123;</span></span><br><span class="line"><span class="comment">//            int size = queue.size();</span></span><br><span class="line"><span class="comment">//            while (size &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">//                TreeNode treeNode = queue.poll();</span></span><br><span class="line"><span class="comment">//                String path = paths.poll();</span></span><br><span class="line"><span class="comment">//                if (treeNode.left == null &amp;&amp; treeNode.right == null) &#123; // 终止条件</span></span><br><span class="line"><span class="comment">//                    ans.add(path); // 有效路径</span></span><br><span class="line"><span class="comment">//                &#125; else &#123;</span></span><br><span class="line"><span class="comment">//                    if (treeNode.left != null) &#123; // 层序遍历所有路径</span></span><br><span class="line"><span class="comment">//                        queue.offer(treeNode.left);</span></span><br><span class="line"><span class="comment">//                        paths.offer(path + &quot;-&gt;&quot; + treeNode.left.val); // !! 关键 ！！</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                    if (treeNode.right != null) &#123;</span></span><br><span class="line"><span class="comment">//                        queue.offer(treeNode.right);</span></span><br><span class="line"><span class="comment">//                        paths.offer(path + &quot;-&gt;&quot; + treeNode.right.val); // !! 关键 ！！</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//                size--;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        return ans;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Alg</category>
      </categories>
  </entry>
  <entry>
    <title>ALG_01_数据结构和算法之美</title>
    <url>/2021/05/14/Notes/Algorithm/ALG_01_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="ALG-01-数据结构和算法之美"><a href="#ALG-01-数据结构和算法之美" class="headerlink" title="ALG_01_数据结构和算法之美"></a>ALG_01_数据结构和算法之美</h1><span id="more"></span>

<h1 id="一、入门"><a href="#一、入门" class="headerlink" title="一、入门"></a>一、入门</h1><h2 id="1-1-核心数据结构和算法"><a href="#1-1-核心数据结构和算法" class="headerlink" title="1.1 核心数据结构和算法"></a>1.1 核心数据结构和算法</h2><p>10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；</p>
<p>10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。<img src="/pics/913e0ababe43a2d57267df5c5f0832a7-1591080554105.jpg" alt="913e0ababe43a2d57267df5c5f0832a7"></p>
<h2 id="1-2-复杂度分析"><a href="#1-2-复杂度分析" class="headerlink" title="1.2 复杂度分析"></a>1.2 复杂度分析</h2><h3 id="1、时间复杂度"><a href="#1、时间复杂度" class="headerlink" title="1、时间复杂度"></a>1、时间复杂度</h3><p>大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。</p>
<ol>
<li><p>只关注循环执行次数最多的一段代码</p>
</li>
<li><p>加法法则：总复杂度等于量级最大的那段代码的复杂度</p>
</li>
<li><p>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</p>
</li>
</ol>
<h3 id="2、几种常见时间复杂度实例分析"><a href="#2、几种常见时间复杂度实例分析" class="headerlink" title="2、几种常见时间复杂度实例分析"></a>2、几种常见时间复杂度实例分析</h3><p><img src="/pics/image-20200805160547310.png" alt="image-20200805160547310"></p>
<p>对于刚罗列的复杂度量级，我们可以粗略地分为两类，多项式量级和非多项式量级。其中，非多项式量级只有两个：O(2n) 和 O(n!)。</p>
<p>我们把时间复杂度为非多项式量级的算法问题叫作 NP（Non-Deterministic Polynomial，非确定多项式）问题。</p>
<p>当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。因此，关于 NP 时间复杂度我就不展开讲了。我们主要来看几种常见的多项式时间复杂度。</p>
<h4 id="1-O-1"><a href="#1-O-1" class="headerlink" title="1. O(1)"></a>1. O(1)</h4><p>首先你必须明确一个概念，O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。比如这段代码，即便有 3 行，它的时间复杂度也是 O(1），而不是 O(3)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i = 8;</span><br><span class="line">int j = 6;</span><br><span class="line">int sum = i + j;</span><br></pre></td></tr></table></figure>

<p>我稍微总结一下，只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)。或者说，一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。</p>
<h4 id="2-O-logn-、O-nlogn"><a href="#2-O-logn-、O-nlogn" class="headerlink" title="2. O(logn)、O(nlogn)"></a>2. O(logn)、O(nlogn)</h4><p>对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i=1;</span><br><span class="line">while (i &lt;= n)  &#123;</span><br><span class="line">  i = i * 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量 i 的取值就是一个等比数列，<br>$$<br>2^x = n<br>$$<br>所以，这段代码的时间复杂度就是<br>$$<br>O(log_2n）<br>$$<br>如果你理解了我前面讲的 O(logn)，那 O(nlogn) 就很容易理解了。还记得我们刚讲的乘法法则吗？<strong>如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。</strong>而且，O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn)。</p>
<h4 id="3-O-m-n-、O-m-n"><a href="#3-O-m-n-、O-m-n" class="headerlink" title="3. O(m+n)、O(m*n)"></a>3. O(m+n)、O(m*n)</h4><p>我们再来讲一种跟前面都不一样的时间复杂度，代码的复杂度由两个数据的规模来决定。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum_1 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; m; ++i) &#123;</span><br><span class="line">    sum_1 = sum_1 + i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> sum_2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; j &lt; n; ++j) &#123;</span><br><span class="line">    sum_2 = sum_2 + j;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum_1 + sum_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、空间复杂度分析"><a href="#3、空间复杂度分析" class="headerlink" title="3、空间复杂度分析"></a>3、空间复杂度分析</h3><p>空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void print(int n) &#123;</span><br><span class="line">  int i = 0;</span><br><span class="line">  int[] a = new int[n];</span><br><span class="line">  for (i; i &lt;n; ++i) &#123;</span><br><span class="line">    a[i] = i * i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for (i = n-1; i &gt;= 0; --i) &#123;</span><br><span class="line">    print out a[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟时间复杂度分析一样，我们可以看到，第 2 行代码中，我们申请了一个空间存储变量 i，但是它是常量阶的，跟数据规模 n 没有关系，所以我们可以忽略。第 3 行申请了一个大小为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)。</p>
<p>我们常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多。所以，对于空间复杂度，掌握刚我说的这些内容已经足够了。</p>
<p><img src="/pics%5Cimage-20200601212047477-1591080559983.png" alt="image-20200601212047477"></p>
<h3 id="4-最好、最坏、平均、均摊时间复杂度"><a href="#4-最好、最坏、平均、均摊时间复杂度" class="headerlink" title="4.最好、最坏、平均、均摊时间复杂度"></a>4.最好、最坏、平均、均摊时间复杂度</h3><h4 id="1-最好、最坏情况时间复杂度"><a href="#1-最好、最坏情况时间复杂度" class="headerlink" title="1.最好、最坏情况时间复杂度"></a>1.最好、最坏情况时间复杂度</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// n表示数组array的长度</span><br><span class="line">int find(int[] array, int n, int x) &#123;</span><br><span class="line">  int i = 0;</span><br><span class="line">  int pos = -1;</span><br><span class="line">  for (; i &lt; n; ++i) &#123;</span><br><span class="line">    if (array[i] == x) pos = i;</span><br><span class="line">  &#125;</span><br><span class="line">  return pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该可以看出来，这段代码要实现的功能是，在一个无序的数组（array）中，查找变量 x 出现的位置。如果没有找到，就返回 -1。按照上节课讲的分析方法，这段代码的复杂度是 O(n)，其中，n 代表数组的长度。</p>
<p>我们在数组中查找一个数据，并不需要每次都把整个数组都遍历一遍，因为有可能中途找到就可以提前结束循环了。但是，这段代码写得不够高效。我们可以这样优化一下这段查找代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// n表示数组array的长度</span><br><span class="line">int find(int[] array, int n, int x) &#123;</span><br><span class="line">  int i = 0;</span><br><span class="line">  int pos = -1;</span><br><span class="line">  for (; i &lt; n; ++i) &#123;</span><br><span class="line">    if (array[i] == x) &#123;</span><br><span class="line">       pos = i;</span><br><span class="line">       break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候，问题就来了。我们优化完之后，这段代码的时间复杂度还是 O(n) 吗？如果数组中第一个元素正好是要查找的变量 x，那就不需要继续遍历剩下的 n-1 个数据了，那时间复杂度就是 O(1)。但如果数组中不存在变量 x，那我们就需要把整个数组都遍历一遍，时间复杂度就成了 O(n)。所以，不同的情况下，这段代码的时间复杂度是不一样的。</p>
<p>为了表示代码在不同情况下的不同时间复杂度，我们需要引入三个概念：<strong>最好情况时间复杂度、最坏情况时间复杂度和平均情况时间复杂度</strong>。顾名思义，最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度。就像我们刚刚讲到的，在最理想的情况下，要查找的变量 x 正好是数组的第一个元素，这个时候对应的时间复杂度就是最好情况时间复杂度。同理，最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度。就像刚举的那个例子，如果数组中没有要查找的变量 x，我们需要把整个数组都遍历一遍才行，所以这种最糟糕情况下对应的时间复杂度就是最坏情况时间复杂度。</p>
<h4 id="2-平均情况时间复杂度-amp-期望时间复杂度"><a href="#2-平均情况时间复杂度-amp-期望时间复杂度" class="headerlink" title="2. 平均情况时间复杂度 &amp;  期望时间复杂度"></a>2. 平均情况时间复杂度 &amp;  期望时间复杂度</h4><p>平均时间复杂度又该怎么分析呢？我还是借助刚才查找变量 x 的例子来给你解释。要查找的变量 x 在数组中的位置，有 n+1 种情况：在数组的 0～n-1 位置中和不在数组中。我们把每种情况下，查找需要遍历的元素个数累加起来，然后再除以 n+1，就可以得到需要遍历的元素个数的平均值，即：<br>$$<br>\frac{1+2+3+n+n}{n+1} =\frac{n(n+3)/2}{(n+1)}<br>$$<br>我们知道，时间复杂度的大 O 标记法中，可以省略掉系数、低阶、常量，所以，咱们把刚刚这个公式简化之后，得到的平均时间复杂度就是 O(n)。</p>
<p>这个结论虽然是正确的，但是计算过程稍微有点儿问题。究竟是什么问题呢？我们刚讲的这 n+1 种情况，出现的概率并不是一样的。我带你具体分析一下。</p>
<p>我们知道，要查找的变量 x，要么在数组里，要么就不在数组里。这两种情况对应的概率统计起来很麻烦，为了方便你理解，我们假设在数组中与不在数组中的概率都为 1/2。另外，要查找的数据出现在 0～n-1 这 n 个位置的概率也是一样的，为 1/n。所以，根据概率乘法法则，要查找的数据出现在 0～n-1 中任意位置的概率就是 1/(2n)。</p>
<p>因此，前面的推导过程中存在的最大问题就是，没有将各种情况发生的概率考虑进去。如果我们把每种情况发生的概率也考虑进去，那平均时间复杂度的计算过程就变成了这样：</p>
<p><img src="/pics%5Cimage-20200601213410715.png" alt="image-20200601213410715"></p>
<p><strong>这个值就是概率论中的加权平均值，也叫作期望值，所以平均时间复杂度的全称应该叫加权平均时间复杂度或者期望时间复杂度。</strong></p>
<p>在大多数情况下，我们并不需要区分最好、最坏、平均情况时间复杂度三种情况。像我们上一节课举的那些例子那样，很多时候，我们使用一个复杂度就可以满足需求了。只有同一块代码在不同的情况下，时间复杂度有量级的差距，我们才会使用这三种复杂度表示法来区分。</p>
<h4 id="3-均摊时间复杂度"><a href="#3-均摊时间复杂度" class="headerlink" title="3. 均摊时间复杂度"></a>3. 均摊时间复杂度</h4><p>均摊时间复杂度，听起来跟平均时间复杂度有点儿像。对于初学者来说，这两个概念确实非常容易弄混。我前面说了，大部分情况下，我们并不需要区分最好、最坏、平均三种复杂度。平均复杂度只在某些特殊情况下才会用到，而均摊时间复杂度应用的场景比它更加特殊、更加有限。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// array表示一个长度为n的数组</span></span><br><span class="line"><span class="comment">// 代码中的array.length就等于n</span></span><br><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (count == array.length) &#123;</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; ++i) &#123;</span><br><span class="line">         sum = sum + array[i];</span><br><span class="line">      &#125;</span><br><span class="line">      array[<span class="number">0</span>] = sum;</span><br><span class="line">      count = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   array[count] = val;</span><br><span class="line">   ++count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>码实现了一个往数组中插入数据的功能。当数组满了之后，也就是代码中的 count == array.length 时，我们用 for 循环遍历数组求和，并清空数组，将求和之后的 sum 值放到数组的第一个位置，然后再将新的数据插入。但如果数组一开始就有空闲空间，则直接将数据插入数组。</p>
<p>那这段代码的时间复杂度是多少呢？你可以先用我们刚讲到的三种时间复杂度的分析方法来分析一下。最理想的情况下，数组中有空闲空间，我们只需要将数据插入到数组下标为 count 的位置就可以了，所以最好情况时间复杂度为 O(1)。最坏的情况下，数组中没有空闲空间了，我们需要先做一次数组的遍历求和，然后再将数据插入，所以最坏情况时间复杂度为 O(n)。那平均时间复杂度是多少呢？答案是 O(1)。我们还是可以通过前面讲的概率论的方法来分析。</p>
<p>假设数组的长度是 n，根据数据插入的位置的不同，我们可以分为 n 种情况，每种情况的时间复杂度是 O(1)。除此之外，还有一种“额外”的情况，就是在数组没有空闲空间时插入一个数据，这个时候的时间复杂度是 O(n)。而且，这 n+1 种情况发生的概率一样，都是 1/(n+1)。所以，根据加权平均的计算方法，我们求得的平均时间复杂度就是：</p>
<p><img src="/pics%5Cimage-20200601213945204.png" alt="image-20200601213945204"></p>
<p>至此为止，前面的最好、最坏、平均时间复杂度的计算，理解起来应该都没有问题。但是这个例子里的平均复杂度分析其实并不需要这么复杂，不需要引入概率论的知识。这是为什么呢？我们先来对比一下这个 insert() 的例子和前面那个 find() 的例子，你就会发现这两者有很大差别。</p>
<p>首先，find() 函数在极端情况下，复杂度才为 O(1)。但 insert() 在大部分情况下，时间复杂度都为 O(1)。只有个别情况下，复杂度才比较高，为 O(n)。这是 insert()第一个区别于 find() 的地方。</p>
<p>我们再来看第二个不同的地方。对于 insert() 函数来说，O(1) 时间复杂度的插入和 O(n) 时间复杂度的插入，出现的频率是非常有规律的，而且有一定的前后时序关系，一般都是一个 O(n) 插入之后，紧跟着 n-1 个 O(1) 的插入操作，循环往复。</p>
<p>所以，针对这样一种特殊场景的复杂度分析，我们并不需要像之前讲平均复杂度分析方法那样，找出所有的输入情况及相应的发生概率，然后再计算加权平均值。针对这种特殊的场景，我们引入了一种更加简单的分析方法：摊还分析法，通过摊还分析得到的时间复杂度我们起了一个名字，叫均摊时间复杂度。</p>
<p>究竟如何使用摊还分析法来分析算法的均摊时间复杂度呢？我们还是继续看在数组中插入数据的这个例子。每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1)。这就是均摊分析的大致思路。你都理解了吗？</p>
<p>均摊时间复杂度和摊还分析应用场景比较特殊，所以我们并不会经常用到。为了方便你理解、记忆，我这里简单总结一下它们的应用场景。如果你遇到了，知道是怎么回事儿就行了。对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。</p>
<p>尽管很多数据结构和算法书籍都花了很大力气来区分平均时间复杂度和均摊时间复杂度，但其实我个人认为，<strong>均摊时间复杂度就是一种特殊的平均时间复杂度</strong>，我们没必要花太多精力去区分它们。你最应该掌握的是它的分析方法，摊还分析。至于分析出来的结果是叫平均还是叫均摊，这只是个说法，并不重要。</p>
<h1 id="二、线性表"><a href="#二、线性表" class="headerlink" title="二、线性表"></a>二、线性表</h1><h2 id="2-1-数组"><a href="#2-1-数组" class="headerlink" title="2.1 数组"></a>2.1 数组</h2><p>数组是一种线性表，存储时是<strong>连续的</strong>内存空间和相同类型的数据。</p>
<h3 id="1、插入和删除"><a href="#1、插入和删除" class="headerlink" title="1、插入和删除"></a>1、插入和删除</h3><p>数组插入和删除过程中均需要搬移数据。</p>
<p><img src="/pics/image-20200810164157017.png" alt="image-20200810164157017"></p>
<p>平均的搬移次数为 :<br>$$<br>（n-i）/2<br>$$<br>i 表示插入的位置。</p>
<h3 id="2、容器vs数组"><a href="#2、容器vs数组" class="headerlink" title="2、容器vs数组"></a>2、容器vs数组</h3><ul>
<li>ArrayList 的优势：就是可以将很多数组操作的细节封装起来。比如前面提到的数组插入、删除数据时需要搬移其他数据等。另外，它还有一个优势，就是支持动态扩容。</li>
<li>数组的优势：1.Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。2.如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。3.要表示多维数组时，用数组往往会更加直观。比如 Object[][] array；而用容器的话则需要这样定义：ArrayList &lt;ArrayList<Object>&gt;</li>
</ul>
<h2 id="2-2-链表"><a href="#2-2-链表" class="headerlink" title="2.2 链表"></a>2.2 链表</h2><p>线性表，具有非连续的存储空间。存储单元除了存储元素信息外，还需存储后继节点的地址。</p>
<h3 id="1、类型"><a href="#1、类型" class="headerlink" title="1、类型"></a>1、类型</h3><ul>
<li><p>单链表： 每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址，尾结点的指针指向null。</p>
</li>
<li><p>双向链表：支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。</p>
</li>
<li><p>循环链表：能通过任何一个节点找到其他所有的节点，将两种(双向/单向)链表的最后一个结点指向第一个结点从而实现循环。</p>
</li>
</ul>
<h3 id="2、插入和删除"><a href="#2、插入和删除" class="headerlink" title="2、插入和删除"></a>2、插入和删除</h3><h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p><img src="/pics/image-20200810154021103.png" alt="image-20200810154021103"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p-&gt;next = x;  <span class="comment">// 将p的next指针指向x结点；</span></span><br><span class="line">x-&gt;next = p-&gt;next;  <span class="comment">// 将x的结点的next指针指向b结点；</span></span><br></pre></td></tr></table></figure>

<p>插入时这两句话的顺序不可交换，否则第二行代码的 x-&gt;next = p-&gt;next（x）；x-&gt;next 指向了自己，整个列表断裂开来。</p>
<p>对于删除：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p -&gt; next = p-&gt;next -&gt;next;</span><br></pre></td></tr></table></figure>

<h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><p>插入时：</p>
<p><img src="/pics/image-20200810162534670.png" alt="image-20200810162534670"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s-&gt;pre = p; // s的前驱</span><br><span class="line">s-&gt;next = p-&gt;next; // s的后继</span><br><span class="line">p-&gt;next-&gt;pre = s; // p的后继的前驱 = s</span><br><span class="line">p-&gt;next = s; // p的后继 = s</span><br></pre></td></tr></table></figure>

<p>删除时：</p>
<p><img src="/pics/image-20200810163501739.png" alt="image-20200810163501739"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p-&gt;next-&gt;pre = p-&gt;pre; // p的后继的前驱 = p的前驱</span><br><span class="line">p-&gt;pre-&gt;next = p-&gt;next; // p的前驱的后继 = p的后继</span><br></pre></td></tr></table></figure>

<p><strong>指针的理解：</strong>将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针**，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。</p>
<h3 id="3、头结点vs头指针"><a href="#3、头结点vs头指针" class="headerlink" title="3、头结点vs头指针"></a>3、头结点vs头指针</h3><p>头指针：链表的第一个节点称为头指针。</p>
<p>头结点：为方便对单链表进行操作，通常会在单链表第一个节点前附设一个节点称为头结点。头节点的数据域可以不存储任何元素也可以存储链表的大小。<strong>使用头结点可以简化插入第一个节点以及删除最后一个节点时的操作。</strong></p>
<p><img src="/pics/image-20200810171434090.png" alt="image-20200810171434090"></p>
<h3 id="4、链表vs数组性能"><a href="#4、链表vs数组性能" class="headerlink" title="4、链表vs数组性能"></a>4、链表vs数组性能</h3><p><img src="/pics/image-20200810172138477.png" alt="image-20200810172138477"></p>
<h1 id="三、栈与队列"><a href="#三、栈与队列" class="headerlink" title="三、栈与队列"></a>三、栈与队列</h1><h2 id="3-1-栈"><a href="#3-1-栈" class="headerlink" title="3.1  栈"></a>3.1  栈</h2><p>限定仅在表尾进行插入和删除操作的线性表，元素具有后进先出（LIFO）的特性。</p>
<p>那栈可以用来解决哪些问题呢？</p>
<h3 id="1、递归"><a href="#1、递归" class="headerlink" title="1、递归"></a>1、递归</h3><p>我们先看一个经典的递归例子，斐波那契数列数列。兔子出生2个月后，就有繁殖能力，一对兔子每个月能生一对小兔子，不考虑死亡的情况下，一年能有多少对对兔子？</p>
<p><img src="/pics/image-20200810201914105.png" alt="image-20200810201914105"></p>
<p>转换成数学公式就是：</p>
<p><img src="/pics/image-20200810201950148.png" alt="image-20200810201950148"></p>
<p>使用递归实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; </span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>) </span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>) </span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">	<span class="keyword">return</span> f(n-<span class="number">1</span>) + f(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、四则运算"><a href="#2、四则运算" class="headerlink" title="2、四则运算"></a>2、四则运算</h3><p>平时我们所用的四则表达式又称为中辍表达式，除了加减乘除等符号外还有括号等等，能够改变运算符执行优先级，导致很难转换成合适的计算指令。如果要通过机器计算，常见的方法是将中缀表达式转化为后缀表达式（逆波兰），去除原来表达式中的括号，因为括号只指示运算顺序，不是实际参与计算的元素。同时使得运算顺序有规律可寻，计算机能编写出代码完成计算。比如 9 + (3 - 1) * 2 + 10 / 2 转换成后缀表达式就是 9 3 1 - 3 * + 10 2 / +。</p>
<ul>
<li>中缀表达式转化后缀表达式规则：从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号（乘除优先加减）则栈顶元素依次出栈并输出（右括号匹配到左括号），并将当前符号进栈，一直到最终输出后缀表达式为止。</li>
<li>后缀表达式计算法：从左到右遍历表达式的每个数字和符号，遇到数字就进栈，遇到符号就将处于栈顶的两个数字出栈，一直到最终获得结果。</li>
</ul>
<p>将以上2步结合起来的规则如下：</p>
<p>先建立两个栈，一个保存操作数的栈，另一个是保存运算符的栈。从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；</p>
<p>当遇到运算符，就与运算符栈的栈顶元素进行比较；如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。</p>
<p><img src="/pics/image-20200810203502825.png" alt="image-20200810203502825"></p>
<h2 id="3-2-队列"><a href="#3-2-队列" class="headerlink" title="3.2 队列"></a>3.2 队列</h2><p>限定在一端进行插入，而在另一端进行删除操作的线性表，具有FIFO特性。</p>
<h3 id="1、顺序队列"><a href="#1、顺序队列" class="headerlink" title="1、顺序队列"></a>1、顺序队列</h3><p>使用数组实现的队列，队头和队尾分别用2个指针表示，font指队头的第一个元素，rear指队尾的下一个元素。在入队和出队的过程中通过指针移动来查找元素。</p>
<p><img src="/pics/image-20200811111219333.png" alt="image-20200811111219333"></p>
<p>此种方式存在的问题：1.队满时，rear指针数组越界；2.队满时，队列存在空闲元素，假溢出情况。</p>
<p><img src="/pics/image-20200811113630996.png" alt="image-20200811113630996"></p>
<p>对于这个问题其中的一种解决方案是在队满时进行整体搬移。</p>
<p><img src="/pics/image-20200811111908528.png" alt="image-20200811111908528"></p>
<p>这种方案会导致入队的最坏时间复杂度变成O(n)，更好的解决方案是采用循环队列。</p>
<h3 id="2、循环队列"><a href="#2、循环队列" class="headerlink" title="2、循环队列"></a>2、循环队列</h3><p>将队列的头尾相接。</p>
<p><img src="/pics/image-20200811112239043.png" alt="image-20200811112239043"></p>
<p>对于循环队列，队空的条件是：rear == front；<strong>队满条件为：(rear +1)%n=front。</strong>对应的入队和出队操作如下：</p>
<p><img src="/pics/image-20200811113137622.png" alt="image-20200811113137622"></p>
<h3 id="3、链式队列"><a href="#3、链式队列" class="headerlink" title="3、链式队列"></a>3、链式队列</h3><h4 id="1、入队"><a href="#1、入队" class="headerlink" title="1、入队"></a>1、入队</h4><p><img src="/pics/image-20200811112653905.png" alt="image-20200811112653905"></p>
<h4 id="2、出队"><a href="#2、出队" class="headerlink" title="2、出队"></a>2、出队</h4><p><img src="/pics/image-20200811112721747.png" alt="image-20200811112721747"></p>
<h1 id="四、串"><a href="#四、串" class="headerlink" title="四、串"></a>四、串</h1><p>由0个或多个字符组成的有限序列，又称为字符串。</p>
<p>下面主要讲下串的匹配算法。</p>
<h3 id="1、朴素模式"><a href="#1、朴素模式" class="headerlink" title="1、朴素模式"></a>1、朴素模式</h3><h4 id="1、原理"><a href="#1、原理" class="headerlink" title="1、原理"></a>1、原理</h4><p><strong>对主串的每一个字符作为开头，与要匹配的字符串进行匹配。对主串做大循环，每个字符开头做T长度的小循环，直到匹配成功或者全部遍历完成为止。</strong></p>
<p><img src="/pics/image-20200817143455781.png" alt="image-20200817143455781"></p>
<p><img src="/pics/image-20200817143508642.png" alt="image-20200817143508642"></p>
<h4 id="2、实现"><a href="#2、实现" class="headerlink" title="2、实现"></a>2、实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">match</span><span class="params">(String source, String match)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] sourceArr = source.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] matchArr = match.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sourceArr.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果第一位相等了，就迭代里面循环</span></span><br><span class="line">            <span class="keyword">if</span> (sourceArr[i] == matchArr[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="comment">// 开始比较第二位到最后一位</span></span><br><span class="line">                <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; matchArr.length) &#123;</span><br><span class="line">                    <span class="comment">// 当出现不相当的情况时，提前终止循环</span></span><br><span class="line">                    <span class="keyword">if</span> (sourceArr[i + j] != matchArr[j]) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 若子串比较到最后，没有提前退出循环，说明匹配成功</span></span><br><span class="line">                <span class="keyword">if</span> (j ==  matchArr.length) &#123;</span><br><span class="line">                    index = i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;matched, from source index &quot;</span> + index);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;not matched &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、KMP匹配-再理解一下"><a href="#2、KMP匹配-再理解一下" class="headerlink" title="2、KMP匹配(再理解一下)"></a>2、KMP匹配(再理解一下)</h3><p><img src="/pics/image-20200817205422048.png" alt="image-20200817205422048"></p>
<p><img src="/pics/image-20200817205459425.png" alt="image-20200817205459425"></p>
<h4 id="1、原理-1"><a href="#1、原理-1" class="headerlink" title="1、原理"></a>1、原理</h4><p>KMP算法通过寻找子串字符的规律，与主串匹配过程中，若发现失配，将子串回溯到合适位置，重新适配，直至匹配到主串结束或者匹配到子串。 </p>
<p><a href="https://wiki.jikexueyuan.com/project/kmp-algorithm/define.html">https://wiki.jikexueyuan.com/project/kmp-algorithm/define.html</a></p>
<h4 id="2、部分匹配表（pmt）-amp-next数组"><a href="#2、部分匹配表（pmt）-amp-next数组" class="headerlink" title="2、部分匹配表（pmt） &amp; next数组"></a>2、部分匹配表（pmt） &amp; next数组</h4><p><img src="/pics/image-20200817202922035.png" alt="image-20200817202922035"></p>
<p><img src="/pics/image-20200817210302264.png" alt="image-20200817210302264"></p>
<p>总结下：</p>
<ul>
<li>失配时，模式串向右移动的距离 = 失配字符所在位置 - 失配字符对应的next值，也就是说jj回溯的距离 = j - next[j]；相当于索引从 j 变为了 next[j]。</li>
<li>next表 = 部分匹配表整体右移一位；</li>
</ul>
<p><a href="https://www.cnblogs.com/Yintianhao/p/9996524.html">KMP算法理解及java实现</a></p>
<h4 id="3、next数组实现"><a href="#3、next数组实现" class="headerlink" title="3、next数组实现"></a>3、next数组实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getNext(<span class="keyword">char</span>[] match) &#123;</span><br><span class="line">       <span class="keyword">int</span> size = match == <span class="keyword">null</span> ? <span class="number">0</span> : match.length;</span><br><span class="line">       <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">       next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> k = -<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (i &lt; size - <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (k == -<span class="number">1</span> || next[i] == next[k]) &#123;</span><br><span class="line">               i++;</span><br><span class="line">               k++;</span><br><span class="line">               next[i] = k;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               k = next[k];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、next数组优化"><a href="#4、next数组优化" class="headerlink" title="4、next数组优化"></a>4、next数组优化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getNextMore(<span class="keyword">char</span>[] match) &#123;</span><br><span class="line">    <span class="keyword">int</span> size = match == <span class="keyword">null</span> ? <span class="number">0</span> : match.length;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = -<span class="number">1</span>; <span class="comment">// k代表前缀</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">// j代表后缀</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; size - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == -<span class="number">1</span> || match[k] == match[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">            k++;</span><br><span class="line">            <span class="keyword">if</span> (match[k] != match[j]) &#123;</span><br><span class="line">                next[j] = k;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 前缀和后缀相同情况下，那么当前后缀的回溯==前缀的回溯</span></span><br><span class="line">                next[j] = next[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5、KMP实现"><a href="#5、KMP实现" class="headerlink" title="5、KMP实现"></a>5、KMP实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] next = getNext(matchArr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; sourceArr.length &amp;&amp; j &lt; matchArr.length) &#123;</span><br><span class="line">    <span class="comment">// j == -1 表示的是第一个字符</span></span><br><span class="line">    <span class="comment">// 当字符串相同时，继续遍历</span></span><br><span class="line">    <span class="keyword">if</span> (j == -<span class="number">1</span> || sourceArr[i] == matchArr[j]) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        j++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 字符串不同时子串索引j开始回溯</span></span><br><span class="line">        j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若子串迭代结束到最后，说明匹配到了</span></span><br><span class="line"><span class="keyword">if</span> (j == matchArr.length) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;matched, from source index&quot;</span> + (i - j));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;not matched&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6、性能"><a href="#6、性能" class="headerlink" title="6、性能"></a>6、性能</h4><p>所以，如果文本串的长度为 n，模式串的长度为 m，那么匹配过程的时间复杂度为 O(n)，算上计算 next 的 O(m) 时间，KMP 的整体时间复杂度为 O(m + n)。</p>
<h3 id="3、BM算法"><a href="#3、BM算法" class="headerlink" title="3、BM算法"></a>3、BM算法</h3><h1 id="五、树"><a href="#五、树" class="headerlink" title="五、树"></a>五、树</h1><h2 id="5-1-树的定义"><a href="#5-1-树的定义" class="headerlink" title="5.1 树的定义"></a>5.1 树的定义</h2><p><img src="/pics/image-20200911102322716.png" alt="image-20200911102322716"></p>
<h3 id="1、度"><a href="#1、度" class="headerlink" title="1、度"></a>1、度</h3><p><img src="/pics/image-20200911102306980.png" alt="image-20200911102306980"></p>
<h3 id="2、深度和层次"><a href="#2、深度和层次" class="headerlink" title="2、深度和层次"></a>2、深度和层次</h3><p><img src="/pics/image-20200911102529207.png" alt="image-20200911102529207"></p>
<h2 id="5-2-二叉树"><a href="#5-2-二叉树" class="headerlink" title="5.2 二叉树"></a>5.2 二叉树</h2><p>二叉树，顾名思义，每个节点最多有两个“叉”，也就是两个子节点，分别是左子节点和右子节点。不过，二叉树并不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点。</p>
<h3 id="1、二叉树的类型"><a href="#1、二叉树的类型" class="headerlink" title="1、二叉树的类型"></a>1、二叉树的类型</h3><h4 id="1、满二叉树"><a href="#1、满二叉树" class="headerlink" title="1、满二叉树"></a>1、满二叉树</h4><p>除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫做满二叉树。</p>
<h4 id="2、完全二叉树"><a href="#2、完全二叉树" class="headerlink" title="2、完全二叉树"></a>2、完全二叉树</h4><p>最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫做完全二叉树。</p>
<p><img src="/pics/image-20200911103306293.png" alt="image-20200911103306293"></p>
<h4 id="3、斜树"><a href="#3、斜树" class="headerlink" title="3、斜树"></a>3、斜树</h4><p>所有节点都只有左子树或者右子树。所有节点都只有左子树的二叉树叫左斜树，所有节点只有右子树二叉树叫斜树。</p>
<p><img src="/pics/image-20200911110241749.png" alt="image-20200911110300815"></p>
<h3 id="2、二叉树的性质"><a href="#2、二叉树的性质" class="headerlink" title="2、二叉树的性质"></a>2、二叉树的性质</h3><p><img src="/pics/image-20200911111109174.png" alt="image-20200911111109174"></p>
<p><img src="/pics/image-20200911111135840.png" alt="image-20200911111135840"></p>
<p><img src="/pics/image-20200911111219114.png" alt="image-20200911111219114"></p>
<h3 id="3、二叉树的存储"><a href="#3、二叉树的存储" class="headerlink" title="3、二叉树的存储"></a>3、二叉树的存储</h3><p>存储一棵二叉树，有两种方法，一种是基于指针或者引用的二叉链式存储法，一种是基于数组的顺序存储法。</p>
<h4 id="1、链式存储"><a href="#1、链式存储" class="headerlink" title="1、链式存储"></a>1、链式存储</h4><p>我们只要拎住根节点，就可以通过左右子节点的指针，把整棵树都串起来。这种存储方式我们比较常用。大部分二叉树代码都是通过这种结构来实现的。</p>
<p><img src="/pics/image-20200911111935159.png" alt="image-20200911111935159"></p>
<h4 id="2、顺序存储"><a href="#2、顺序存储" class="headerlink" title="2、顺序存储"></a>2、顺序存储</h4><p>基于数组的顺序存储法。我们把根节点存储在下标 i = 1 的位置，<strong>那左子节点存储在下标 2 * i = 2 的位置，右子节点存储在 2 * i + 1</strong> = 3 的位置。以此类推，B 节点的左子节点存储在 2 * i = 2 * 2 = 4 的位置，右子节点存储在 2 * i + 1 = 2 * 2 + 1 = 5 的位置。</p>
<p><img src="/pics/image-20200911111827044.png" alt="image-20200911111827044"></p>
<p>如果某棵二叉树是一棵完全二叉树，那用数组存储无疑是最节省内存的一种方式。因为数组的存储方式并不需要像链式存储法那样，要存储额外的左右子节点的指针。</p>
<h3 id="4、二叉树的遍历"><a href="#4、二叉树的遍历" class="headerlink" title="4、二叉树的遍历"></a>4、二叉树的遍历</h3><p>如何将所有节点都遍历打印出来呢？经典的方法有三种，前序遍历、中序遍历和后序遍历。其中，前、中、后序，表示的是节点与它的左右子树节点遍历打印的先后顺序。</p>
<ul>
<li><p>前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。</p>
<p>ABDGHCEIF</p>
<p><img src="/pics/image-20200911112757396.png" alt="image-20200911112757396"></p>
</li>
<li><p>中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。</p>
<p>GDHBAEICF</p>
<p><img src="/pics/image-20200911113232315.png" alt="image-20200911113232315"></p>
</li>
<li><p>后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。GHDBIEFCA</p>
</li>
</ul>
<p><img src="/pics/image-20200911113315231.png" alt="image-20200911113315231"></p>
<p>此外还有一种遍历方式叫层序遍历，顾名思义，从上至下，一层一层遍历。ABCDEFGHI</p>
<p><img src="/pics/image-20200911113748626.png" alt="image-20200911113748626"></p>
<h3 id="5、遍历顺序复原二叉树"><a href="#5、遍历顺序复原二叉树" class="headerlink" title="5、遍历顺序复原二叉树"></a>5、遍历顺序复原二叉树</h3><p><img src="/pics/image-20200911114327205.png" alt="image-20200911114327205"></p>
<h2 id="5-3-树、森林与二叉树的转换"><a href="#5-3-树、森林与二叉树的转换" class="headerlink" title="5.3 树、森林与二叉树的转换"></a>5.3 树、森林与二叉树的转换</h2><h3 id="1、树转换为二叉树"><a href="#1、树转换为二叉树" class="headerlink" title="1、树转换为二叉树"></a>1、树转换为二叉树</h3><p><img src="/pics/image-20200911114940272.png" alt="image-20200911114940272"></p>
<h3 id="2、森林转换为二叉树"><a href="#2、森林转换为二叉树" class="headerlink" title="2、森林转换为二叉树"></a>2、森林转换为二叉树</h3><p><img src="/pics/image-20200911115025993.png" alt="image-20200911115025993"></p>
<h3 id="3、二叉树转换为树"><a href="#3、二叉树转换为树" class="headerlink" title="3、二叉树转换为树"></a>3、二叉树转换为树</h3><p><img src="/pics/image-20200911115238390.png" alt="image-20200911115238390"></p>
<p><img src="/pics/image-20200911115323265.png" alt="image-20200911115323265"></p>
<h3 id="4、二叉树转化为森林"><a href="#4、二叉树转化为森林" class="headerlink" title="4、二叉树转化为森林"></a>4、二叉树转化为森林</h3><p><img src="/pics/image-20200911115353816.png" alt="image-20200911115353816"></p>
<p><img src="/pics/image-20200911115428376.png" alt="image-20200911115428376"></p>
<h2 id="5-5-赫夫曼树"><a href="#5-5-赫夫曼树" class="headerlink" title="5.5 赫夫曼树"></a>5.5 赫夫曼树</h2><p>带权路径和最短的树，提升排序和查找的效率。</p>
<p><img src="/pics/image-20200911180457956.png" alt="image-20200911180457956"></p>
<h3 id="1、哈夫曼树的构造"><a href="#1、哈夫曼树的构造" class="headerlink" title="1、哈夫曼树的构造"></a>1、哈夫曼树的构造</h3><p><img src="/pics/image-20200911180244241.png" alt="image-20200911180244241"></p>
<p><img src="/pics/image-20200911180407556.png" alt="image-20200911180407556"></p>
<h3 id="2、哈夫曼编码"><a href="#2、哈夫曼编码" class="headerlink" title="2、哈夫曼编码"></a>2、哈夫曼编码</h3><p>哈夫曼树的应用很广，哈夫曼编码就是其在电讯通信中的应用之一。广泛地用于数据文件压缩的十分有效的编码方法。其压缩率通常在20%～90%之间。在电讯通信业务中，通常用二进制编码来表示字母或其他字符，并用这样的编码来表示字符序列。 </p>
<p><img src="/pics/image-20200911180606089.png" alt="image-20200911180606089"></p>
<p><img src="/pics/image-20200911180638659.png" alt="image-20200911180638659"></p>
<h1 id="六、图"><a href="#六、图" class="headerlink" title="六、图"></a>六、图</h1><h2 id="6-1-图"><a href="#6-1-图" class="headerlink" title="6.1 图"></a>6.1 图</h2><h3 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h3><p><img src="/pics/image-20200915105022777.png" alt="image-20200915105022777"></p>
<h4 id="1、无向图和有向图"><a href="#1、无向图和有向图" class="headerlink" title="1、无向图和有向图"></a>1、无向图和有向图</h4><p><img src="/pics/image-20200915105500416.png" alt="image-20200915105500416"></p>
<p><img src="/pics/image-20200915105606224.png" alt="image-20200915105606224"></p>
<p><img src="/pics/image-20200915105626442.png" alt="image-20200915105626442"></p>
<p><img src="/pics/image-20200915105706437.png" alt="image-20200915105706437"></p>
<h4 id="2、网"><a href="#2、网" class="headerlink" title="2、网"></a>2、网</h4><p><img src="/pics/image-20200915105805034.png" alt="image-20200915105805034"></p>
<h4 id="3、环"><a href="#3、环" class="headerlink" title="3、环"></a>3、环</h4><p><img src="/pics/image-20200915110356072.png" alt="image-20200915110356072"></p>
<p><img src="/pics/image-20200915110411756.png" alt="image-20200915110411756"></p>
<h3 id="2、存储结构"><a href="#2、存储结构" class="headerlink" title="2、存储结构"></a>2、存储结构</h3><h4 id="1、邻接矩阵"><a href="#1、邻接矩阵" class="headerlink" title="1、邻接矩阵"></a>1、邻接矩阵</h4><p><img src="/pics/image-20200915143617330.png" alt="image-20200915143617330"></p>
<p><img src="/pics/image-20200915143641884.png" alt="image-20200915143641884"></p>
<p><img src="/pics/image-20200915143942044.png" alt="image-20200915143942044"></p>
<p>邻接矩阵在边数相对较少的情况下，存在存储空间浪费的情况。</p>
<h4 id="2、邻接表"><a href="#2、邻接表" class="headerlink" title="2、邻接表"></a>2、邻接表</h4><p><img src="/pics/image-20200915144216413.png" alt="image-20200915144216413"></p>
<p>对于有向图，邻接表是顶点作为弧尾来存储边表，这样可以很容易的确定顶点的出度；有时为了更方便的确定顶点的入度，会采用逆领接表的方式存储数据。</p>
<p><img src="/pics/image-20200915145504103.png" alt="image-20200915145504103"></p>
<h3 id="3-、遍历"><a href="#3-、遍历" class="headerlink" title="3 、遍历"></a>3 、遍历</h3><p>从图的某一个顶点出发访遍图中的其余顶点，且使每一个顶点仅被访问一次，这一过程就叫做图的遍历。</p>
<h4 id="1、深度优先遍历DFS"><a href="#1、深度优先遍历DFS" class="headerlink" title="1、深度优先遍历DFS"></a>1、深度优先遍历DFS</h4><p>每次遍历当前访问顶点的临界点，一直到访问的顶点没有未被访问过的临界点为止。然后采用依次回退的方式，查看来的路上每一个顶点是否有其它未被访问的临界点。访问完成后，判断图中的顶点是否已经全部遍历完成，如果没有，以未访问的顶点为起始点，重复上述过程。</p>
<h4 id="2、广度优先遍历BFS"><a href="#2、广度优先遍历BFS" class="headerlink" title="2、广度优先遍历BFS"></a>2、广度优先遍历BFS</h4><p>广度优先搜索类似于树的层次遍历。从图中的某一顶点出发，遍历每一个顶点时，依次遍历其所有的邻接点，然后再从这些邻接点出发，同样依次访问它们的邻接点。按照此过程，直到图中所有被访问过的顶点的邻接点都被访问到。</p>
<h2 id="6-2-最小生成树"><a href="#6-2-最小生成树" class="headerlink" title="6.2 最小生成树"></a>6.2 最小生成树</h2><p><img src="/pics/image-20200917111916805.png" alt="image-20200917111916805"></p>
<p>构造连通网的最小代价生成树称为最小生成树。找到连通网的最小树，通常有2种做法分别是：</p>
<ol>
<li>Prim算法是以点为对象，挑选与点相连的最短边来构成最小生成树。</li>
<li>Kruskal算法是以边为对象，不断地加入新的不构成环路的最短边来构成最小生成树。</li>
</ol>
<h3 id="1、Prim算法"><a href="#1、Prim算法" class="headerlink" title="1、Prim算法"></a>1、Prim算法</h3><p>基本原理：</p>
<ol>
<li>从某个点开始，查找当前点可以访问的所有边；</li>
<li>找到离当前顶点权值最小的边，并且将该顶点加入到集合V[]。</li>
<li>寻找当前集合可以访问的所有边，重复2过程，直到没有新的点可以加入。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INF = <span class="number">65535</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">miniTree</span><span class="params">(<span class="keyword">int</span>[][] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    <span class="comment">// 边的集合,访问过的顶点标记为0</span></span><br><span class="line">    <span class="comment">// 初始化为第0行的数组</span></span><br><span class="line">    <span class="keyword">int</span>[] lowCost = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 记录访问的节点顺序</span></span><br><span class="line">    <span class="keyword">int</span>[] path = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="comment">// 路径长度</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 默认从第一个顶点开始查找</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 记录查找到的顶点</span></span><br><span class="line">    lowCost[k] = <span class="number">0</span>;</span><br><span class="line">    path[k] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = INF;</span><br><span class="line">        <span class="comment">// 查找当前lowest中的最小值即最短边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lowCost[j] != <span class="number">0</span> &amp;&amp; lowCost[j] &lt; min) &#123;</span><br><span class="line">                min = lowCost[j];</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//标记节点为已访问</span></span><br><span class="line">        lowCost[k] = <span class="number">0</span>;</span><br><span class="line">        path[i] = k;</span><br><span class="line">        <span class="comment">// 节点路径权值和</span></span><br><span class="line">        sum += min;</span><br><span class="line">        <span class="comment">// 更新最短路径的边，[k,j] 新加入的节点到其余未访问节点的权值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lowCost[j] != <span class="number">0</span> &amp;&amp; arr[k][j] &lt; lowCost[j]) &#123;</span><br><span class="line">                lowCost[j] = arr[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : path) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、Kruskal-算法"><a href="#2、Kruskal-算法" class="headerlink" title="2、Kruskal 算法"></a>2、Kruskal 算法</h3><p>将最短路径的顶点连接成树，在连接过程中要注意判断是不是形成了环，如果形成了环则调过这个顶点。环的判断方法为：<strong>当某边的2个顶点的根节点相同时，此时就形成了环。</strong></p>
<p><strong>步骤：</strong></p>
<ol>
<li>将边的权值从小到大排序</li>
<li>选择最小权重的边，判断是否其在当前的生成树中形成了一个环路。如果环路没有形成，则将该边加入树中，否则放弃。</li>
<li>重复步骤2，直到有n-1条边（n表示顶点数）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">miniTree</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = graph.length;</span><br><span class="line">    <span class="comment">//1.生成边的列表</span></span><br><span class="line">    ArrayList&lt;Edge&gt; edgeList = getEdges(graph, len);</span><br><span class="line">    <span class="comment">//2.对边进行排序</span></span><br><span class="line">    sortEdge(edgeList);</span><br><span class="line">    <span class="comment">//3.初始化的parent数组值都为0，理解为顶点都是根节点</span></span><br><span class="line">    <span class="comment">// parent 数组用来查找节点的根节点</span></span><br><span class="line">    <span class="keyword">int</span>[] parent = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.对边进行遍历，权值从低到高</span></span><br><span class="line">    <span class="keyword">int</span> edgeCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Edge edge : edgeList) &#123;</span><br><span class="line">        <span class="keyword">int</span> root1 = findRoot(parent, edge.from);</span><br><span class="line">        <span class="keyword">int</span> root2 = findRoot(parent, edge.to);</span><br><span class="line">        <span class="keyword">if</span> (root1 != root2) &#123; <span class="comment">// 判断是否形成了环，如果不同就可以合并2个节点或者树，让他们有相同的根</span></span><br><span class="line">            parent[root2] = root1; <span class="comment">// 两个顶点组成树</span></span><br><span class="line">            System.out.println(<span class="string">&quot;edge from = &quot;</span> + edge.from + <span class="string">&quot;, to = &quot;</span> + edge.to + <span class="string">&quot;, weight = &quot;</span> + edge.weight);</span><br><span class="line">            edgeCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (edgeCount == len - <span class="number">1</span>) &#123;<span class="comment">// 当边的个数 = 顶点数 - 1时，构造完成</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span>[] parent, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (parent[n] &gt; <span class="number">0</span>) &#123; <span class="comment">// 查找根节点的过程</span></span><br><span class="line">        n = parent[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;Edge&gt; <span class="title">getEdges</span><span class="params">(<span class="keyword">int</span>[][] arr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Edge&gt; edgeList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i][j] != INF) &#123;</span><br><span class="line">                edgeList.add(<span class="keyword">new</span> Edge(i, j, arr[i][j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> edgeList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortEdge</span><span class="params">(ArrayList&lt;Edge&gt; edgeList)</span> </span>&#123;</span><br><span class="line">    edgeList.sort(<span class="keyword">new</span> Comparator&lt;Edge&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Edge o1, Edge o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o1.weight - o2.weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//for (Edge edge : edgeList) &#123;</span></span><br><span class="line"><span class="comment">//      System.out.println(edge);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> from;</span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line">        <span class="keyword">this</span>.to = to;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Edge&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;from=&quot;</span> + from +</span><br><span class="line">                <span class="string">&quot;, to=&quot;</span> + to +</span><br><span class="line">                <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、对比"><a href="#3、对比" class="headerlink" title="3、对比"></a>3、对比</h3><p>Prim算法的时间复杂度为O（n^2）；Kruskal  的算法复杂度为O（ElogE）E表示边数。</p>
<p>Kruskal主要是针对边来展开，边数少时效率会非常高，对于稀疏图效率非常高；</p>
<p>Prim算法更适用于稠密图，即边数较多的情况。</p>
<h2 id="6-3-最短路径"><a href="#6-3-最短路径" class="headerlink" title="6.3 最短路径"></a>6.3 最短路径</h2><p><img src="/pics/image-20200920162912673.png" alt="image-20200920162912673"></p>
<h3 id="1、Dijkstra算法"><a href="#1、Dijkstra算法" class="headerlink" title="1、Dijkstra算法"></a>1、Dijkstra算法</h3><p><img src="/pics/image-20200920154441523.png" alt="image-20200920154441523"></p>
<p><img src="/pics/image-20200920154502413.png" alt="image-20200920154502413"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">minPath</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = graph.length;</span><br><span class="line">    <span class="comment">// 算法从0节点开始</span></span><br><span class="line">    <span class="comment">// vex 表示访问过的顶点</span></span><br><span class="line">    <span class="keyword">int</span>[] vex = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="comment">// path 表示访问这个顶点需要经过的顶点</span></span><br><span class="line">    <span class="keyword">int</span>[] path = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="comment">// dist 表示访问到顶点最小权值</span></span><br><span class="line">    <span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        dist[i] = graph[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vex[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vex[i] == <span class="number">0</span> &amp;&amp; dist[i] &lt; min) &#123;</span><br><span class="line">                min = dist[i];</span><br><span class="line">                k = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vex[k] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 选中k位后，比较【0-&gt;剩余顶点】及【0-&gt;k + k-&gt;剩余顶点】的距离，</span></span><br><span class="line">            <span class="comment">// 更新到【0-&gt;剩余顶点】的最小距离</span></span><br><span class="line">            <span class="keyword">if</span> (vex[i] == <span class="number">0</span> &amp;&amp; (min + graph[k][i] &lt; dist[i])) &#123;</span><br><span class="line">                dist[i] = min + graph[k][i];</span><br><span class="line">                path[i] = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [0,0,0,2] 表示的含义为，最短路径中从0节点开始到这个节点的前驱节点</span></span><br><span class="line">    System.out.println(<span class="string">&quot;路径访问的前驱, 默认索引是 0, 1, 2..&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> value : path) &#123;</span><br><span class="line">        System.out.print(value + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;权值，从0到这个节点的最大权值&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> value : dist) &#123;</span><br><span class="line">        System.out.print(value + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Prim和Dijkstra算法具体原理非常相似，区别是：</p>
<ul>
<li>Prim更新的是<strong>未标记集合到已标记集合之间的距离</strong>。</li>
<li>Dijkstra更新的是<strong>源点到未标记集合之间的距离。</strong></li>
</ul>
<h3 id="2、Floyd算法"><a href="#2、Floyd算法" class="headerlink" title="2、Floyd算法"></a>2、Floyd算法</h3><p>Floyd算法能够计算图中<strong>任意两点间的最短路径</strong>。核心原理是：i,j 是目标2点，若i,j中点为v，那么i，j直接的最短距离为：<br>$$<br>D[i][j] = min( D[i][j], (D[i][v] + D[v][j]) )（i!=j,v!=i,v!=j）<br>$$</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void minPath(int[][] graph) &#123;</span><br><span class="line">    int len = graph.length;</span><br><span class="line"></span><br><span class="line">    int[][] path = new int[len][len];</span><br><span class="line">    // path 表示i，j直接的最短距离的中点。</span><br><span class="line">    // 初始化</span><br><span class="line">    for (int i = 0; i &lt;len; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; len; j++) &#123;</span><br><span class="line">            // 有2种方式</span><br><span class="line">            // 1.&quot;顶点i&quot;到&quot;顶点j&quot;的最短路径是经过顶点j</span><br><span class="line">            // 2.-1 表示直接连接</span><br><span class="line">            path[i][j] = -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // u 表示i,j中间顶点的索引</span><br><span class="line">    for (int u = 0; u &lt; len; u++) &#123;</span><br><span class="line">        for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; len; j++) &#123;</span><br><span class="line">                // 顶点不能首尾相接 &amp;&amp; 中间点不能和头尾相同，比如 i=1,j=2,u=2，此时</span><br><span class="line">                // graph [1][2] &gt; graph[1][2] + graph[2][2]</span><br><span class="line">                if (i == j || u == j || u == i) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                //比较时若后面出现无穷值时，前后是不能比较的，取最大值为INF</span><br><span class="line">                int tmp = (graph[i][u] == INF || graph[u][j] == INF) ? INF : graph[i][u] + graph[u][j];</span><br><span class="line">                if (graph[i][j] &gt; tmp) &#123;</span><br><span class="line">                    // i j 间的最小距离</span><br><span class="line">                    graph[i][j] = tmp;</span><br><span class="line">                    // i j要经过的点</span><br><span class="line">                    path[i][j] = u;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;=== graph ======&quot;);</span><br><span class="line">    printGraph(graph);</span><br><span class="line">    System.out.println(&quot;=== path ======&quot;);</span><br><span class="line">    printGraph(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、比较"><a href="#3、比较" class="headerlink" title="3、比较"></a>3、比较</h3><p>Dijkstra算法主要用于计算单源最短路径，时间复杂度为O（n^2)；若要计算任意2点间的最短距离，那么时间复杂度为 n * n^2 = O(n^3);</p>
<p>Floyd算法可以计算任意2点间的最短距离，时间复杂度为O(n^2)；所以说在求任意2点间最短距离时，这2种算法的时间复杂度基本相当。</p>
<h2 id="6-4-拓补排序（算法待补充）"><a href="#6-4-拓补排序（算法待补充）" class="headerlink" title="6.4 拓补排序（算法待补充）"></a>6.4 拓补排序（算法待补充）</h2><p><img src="/pics/image-20200920163617146.png" alt="image-20200920163617146"></p>
<p><img src="/pics/image-20200920163704632.png" alt="image-20200920163704632"></p>
<h3 id="1、拓补排序算法"><a href="#1、拓补排序算法" class="headerlink" title="1、拓补排序算法"></a>1、拓补排序算法</h3><p><img src="/pics/image-20200920164156582.png" alt="image-20200920164156582"></p>
<p><img src="/pics/image-20200920164246852.png" alt="image-20200920164246852"></p>
<h3 id="2、关键路径"><a href="#2、关键路径" class="headerlink" title="2、关键路径"></a>2、关键路径</h3><p><img src="/pics/image-20200920171450218.png" alt="image-20200920171450218"></p>
<p><img src="/pics/image-20200920171619096.png" alt="image-20200920171619096"></p>
<p><img src="/pics/image-20200920172528702.png" alt="image-20200920172528702"></p>
<p>关键路径步骤：</p>
<ol>
<li>从源点开始到汇点求所有事件的最早开始时间Ve</li>
<li>从汇点到源点求所有事件的最晚开始时间Le</li>
<li>通过Le和Ve求活动的最早、最晚开始时间ete、lte</li>
<li>若ete == lte，说明此活动为关键路径</li>
</ol>
<p><img src="/pics/image-20200920175143682.png" alt="image-20200920175143682"></p>
<h4 id="1、事件的最早-最晚发生时间"><a href="#1、事件的最早-最晚发生时间" class="headerlink" title="1、事件的最早/最晚发生时间"></a>1、事件的最早/最晚发生时间</h4><table>
<thead>
<tr>
<th></th>
<th>V0</th>
<th>V1</th>
<th>V2</th>
<th>V3</th>
<th>V4</th>
<th>V5</th>
<th>V6</th>
<th>V7</th>
<th>V8</th>
<th>V9</th>
</tr>
</thead>
<tbody><tr>
<td>etv(最早发生时间<strong>，多个入度取最大</strong>)</td>
<td>0</td>
<td>3</td>
<td>4</td>
<td>12</td>
<td>15</td>
<td>11</td>
<td>24</td>
<td>19</td>
<td>24</td>
<td>27</td>
</tr>
<tr>
<td>Ltv（最晚发生时间，<strong>多个入度取最小</strong>）</td>
<td>0</td>
<td>7</td>
<td>4</td>
<td>12</td>
<td>15</td>
<td>13</td>
<td>25</td>
<td>19</td>
<td>24</td>
<td>27</td>
</tr>
</tbody></table>
<h4 id="2、活动的最早、最晚开始时间"><a href="#2、活动的最早、最晚开始时间" class="headerlink" title="2、活动的最早、最晚开始时间"></a>2、活动的最早、最晚开始时间</h4><table>
<thead>
<tr>
<th></th>
<th>a0</th>
<th>a1</th>
<th>a2</th>
<th>a3</th>
<th>a4</th>
<th>a5</th>
<th>a6</th>
<th>a7</th>
<th>a8</th>
<th>a9</th>
<th>a10</th>
<th>a11</th>
<th>a12</th>
</tr>
</thead>
<tbody><tr>
<td>ete(etv(k),弧尾节点的最早发生时间）</td>
<td>0</td>
<td>0</td>
<td>3</td>
<td>3</td>
<td>4</td>
<td>4</td>
<td>12</td>
<td>15</td>
<td>15</td>
<td>11</td>
<td>24</td>
<td>19</td>
<td>24</td>
</tr>
<tr>
<td>lte</td>
<td>4</td>
<td>0</td>
<td>7</td>
<td>9</td>
<td>4</td>
<td>8</td>
<td>12</td>
<td>16</td>
<td>15</td>
<td>13</td>
<td>25</td>
<td>19</td>
<td>24</td>
</tr>
</tbody></table>
<p>lte[4] = Ltv[j] - w[j,k]，lte = 弧头节点的Ltv - 路径权值；比如Lte（a4） = Ltv[3] - wa4  = 12 - 8 = 4</p>
<h4 id="3、ete-lte为关键路径"><a href="#3、ete-lte为关键路径" class="headerlink" title="3、ete == lte为关键路径"></a>3、ete == lte为关键路径</h4><p>也就是说a1,a4,a6,a8,a11,a12为关键路径，缩短关键路径的时间能够提高整个工程的周期，当然如果缩短太多，关键路径可能发生变化；关键路径可能不止一条。</p>
<h1 id="七、查找"><a href="#七、查找" class="headerlink" title="七、查找"></a>七、查找</h1><h2 id="7-1-有序表的查找"><a href="#7-1-有序表的查找" class="headerlink" title="7.1 有序表的查找"></a>7.1 有序表的查找</h2><h3 id="1、二分查找"><a href="#1、二分查找" class="headerlink" title="1、二分查找"></a>1、二分查找</h3><p>又称为折半查找法，取中间的记录进行比较；若给定值小于中间值，则向记录的左半区继续查找；若给定值大于中间值，则向记录的右半区查找。不断重复上述步骤，知道查找成功。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> find = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = arr.length;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; arr[mid]) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; arr[mid]) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            find = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (find != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;find &quot;</span> + find);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;not find &quot;</span> + find);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> find;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、插值查找"><a href="#2、插值查找" class="headerlink" title="2、插值查找"></a>2、插值查找</h3><p>二分查找的改善算法，适用于记录较多，关键字分布比较均匀的表，只需要更改下mid的算法<br>$$<br>mid = low + （high - low）* (key - a[low]) / (a[high] - a[low])<br>$$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] sortedList, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> find = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = sortedList.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + (high - low) * (key - sortedList[low]) / (sortedList[high] - sortedList[low]);</span><br><span class="line">        <span class="keyword">if</span> (key &lt; sortedList[mid]) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; sortedList[mid]) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            find = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (find != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;find &quot;</span> + find);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;not find &quot;</span> + find);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> find;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、斐波那契查找"><a href="#3、斐波那契查找" class="headerlink" title="3、斐波那契查找"></a>3、斐波那契查找</h3><p>斐波那契查找是利用斐波那契数列对查找区间进行分割。<br>$$<br>F[k] = F[k-1] + F[ k-2]<br>$$<br>F[k]表示的是数组总长度，F[k-1],F[k-2]分别表示分割后，前后数组的长度。</p>
<p><img src="/pics/image-20200928174611685.png" alt="image-20200928174611685"></p>
<p><img src="/pics/image-20200928174622275.png" alt="image-20200928174622275"></p>
<p>$$<br>mid = low + F[k-1] - 1<br>$$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] F = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> find = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 计算n位于斐波那契数列的位置</span></span><br><span class="line">        <span class="keyword">while</span> (arr.length &gt; F[k]) &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[F[k]];</span><br><span class="line">        <span class="comment">// 将数列补充为斐波那契的长度F[k]，不足的位数取值为数组最后一位的值。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; F[k]; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; arr.length) &#123;</span><br><span class="line">                temp[i] = arr[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[i] = arr[high];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// F[k] = F[k-1] + F[k-2]</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            mid = low + F[k - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (key &lt; temp[mid]) &#123;</span><br><span class="line">                <span class="comment">// 当关键字小于中间值时，取前边的序列，high从mid -1开始，长度为F[k-1]，所以k-=1 </span></span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">                k -= <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; temp[mid]) &#123;</span><br><span class="line">                <span class="comment">// 当关键字大于中间值时，取后边的序列，low要从mid+1开始，长度为F[k-2]，所以k-=2 </span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">                k -= <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                find = mid;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (find &lt; arr.length) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;find = &quot;</span> + find + <span class="string">&quot; , k = &quot;</span> + k);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;find out of arr &quot;</span> + find + <span class="string">&quot; , k = &quot;</span> + k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> find;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-2-线性索引查询"><a href="#7-2-线性索引查询" class="headerlink" title="7.2 线性索引查询"></a>7.2 线性索引查询</h2><p>常见的线性索引主要有三种：稠密索引、分块索引、倒排索引</p>
<p>稠密索引：数据集中每一个记录对应一个索引项。对于稠密索引的的索引表来说，索引项是按照关键码有序的排列。也就是说查找索引关键字时可以运用二分查找等算法。</p>
<p>分块索引：分块有序，把数据集的记录分成若干块，并且这些块需要满足2个条件：</p>
<ul>
<li>块内无序，即每一块内的记录不要求有序</li>
<li>块间有序，例如，要求第二块的所有记录关键字大于第一块，依次类推。</li>
</ul>
<p><img src="/pics/image-20201008101806029.png" alt="image-20201008101806029"></p>
<p>倒排索引：记录好存储具有相同次关键字的所有的记录的记录号，主要用于搜索引擎</p>
<h2 id="7-3-二叉排序树"><a href="#7-3-二叉排序树" class="headerlink" title="7.3 二叉排序树"></a>7.3 二叉排序树</h2><p>又称为二叉查找树，可以是空树，非空树具有如下的性质：</p>
<ul>
<li><p>若它的左子树不为空，则左子树上所有节点的值均小于根节点的值</p>
</li>
<li><p>若右子树不为空，则右子树所有节点值均大于等于根节点值</p>
</li>
<li><p>左右子树也分别为二叉树</p>
</li>
<li><p>中序遍历二叉排序树会得到一个有序序列</p>
</li>
</ul>
<h3 id="1、查找"><a href="#1、查找" class="headerlink" title="1、查找"></a>1、查找</h3><p>从根节点开始查找，若小于key则从继续查找左子树，否则查找右子树，直到查找到或者节点没有子节点。</p>
<h3 id="2、插入"><a href="#2、插入" class="headerlink" title="2、插入"></a>2、插入</h3><p>从根节点开始查找，若小于key则从继续查找左子树，否则查找右子树，直到查找的节点缺少左或右节点，则再此位置插入。</p>
<h3 id="3、删除"><a href="#3、删除" class="headerlink" title="3、删除"></a>3、删除</h3><p>删除时有以下几种情况：</p>
<p>1、删除节点时叶子节点，直接删除即可</p>
<p>2、节点只有左子树或者右子树，将节点删除后，将左子树或者右子树移动到删除节点的位置</p>
<p>3、删除节点有左右子树，找到要删除节点的p的直接前驱（或直接后继）s，用s来替换p，然后再删除s节点。</p>
<h3 id="4、实现"><a href="#4、实现" class="headerlink" title="4、实现"></a>4、实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BstTree tree = <span class="keyword">new</span> BstTree();</span><br><span class="line"></span><br><span class="line">        tree.insert(<span class="number">62</span>);</span><br><span class="line">        tree.insert(<span class="number">88</span>);</span><br><span class="line">        tree.insert(<span class="number">58</span>);</span><br><span class="line">        tree.insert(<span class="number">47</span>);</span><br><span class="line">        tree.insert(<span class="number">35</span>);</span><br><span class="line">        tree.insert(<span class="number">73</span>);</span><br><span class="line">        tree.insert(<span class="number">51</span>);</span><br><span class="line">        tree.insert(<span class="number">99</span>);</span><br><span class="line">        tree.insert(<span class="number">37</span>);</span><br><span class="line">        tree.insert(<span class="number">93</span>);</span><br><span class="line">        <span class="comment">//        62</span></span><br><span class="line">        <span class="comment">//      /    \</span></span><br><span class="line">        <span class="comment">//     58    88</span></span><br><span class="line">        <span class="comment">//     / \   / \</span></span><br><span class="line">        <span class="comment">//    47     73 99</span></span><br><span class="line">        <span class="comment">//    / \      /</span></span><br><span class="line">        <span class="comment">//   35  51   93</span></span><br><span class="line">        <span class="comment">//    \</span></span><br><span class="line">        <span class="comment">//     37</span></span><br><span class="line"></span><br><span class="line">        System.out.println(tree.search(<span class="number">47</span>));</span><br><span class="line">        System.out.println(tree.search(<span class="number">52</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(&quot;\n前序遍历结果&quot;);</span></span><br><span class="line"><span class="comment">//        tree.preOrder(tree.root);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n中序遍历结果&quot;</span>);</span><br><span class="line">        tree.midOrder(tree.root);</span><br><span class="line"><span class="comment">//        System.out.println(&quot;\n后序遍历结果&quot;);</span></span><br><span class="line"><span class="comment">//        tree.postOrder(tree.root);</span></span><br><span class="line"></span><br><span class="line">        tree.delete(tree.root, <span class="number">58</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;\n中序遍历结果&quot;</span>);</span><br><span class="line">        tree.midOrder(tree.root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> data;</span><br><span class="line">        <span class="keyword">public</span> TreeNode left;</span><br><span class="line">        <span class="keyword">public</span> TreeNode right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;TreeNode&#123;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;data=&quot;</span> + data +</span><br><span class="line">                    <span class="string">&quot;, left=&quot;</span> + left +</span><br><span class="line">                    <span class="string">&quot;, right=&quot;</span> + right +</span><br><span class="line">                    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BstTree</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> TreeNode root;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TreeNode <span class="title">search</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> search(root, data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> TreeNode <span class="title">search</span><span class="params">(TreeNode currentNode, <span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (currentNode == <span class="keyword">null</span> || currentNode.data == data) &#123;</span><br><span class="line">                <span class="keyword">return</span> currentNode;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data &lt; currentNode.data) &#123;</span><br><span class="line">                <span class="keyword">return</span> search(currentNode.left, data);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> search(currentNode.right, data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            root = insert(root, data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> TreeNode <span class="title">insert</span><span class="params">(TreeNode rootNode, <span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == rootNode) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(data);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (data &lt; rootNode.data) &#123;</span><br><span class="line">                rootNode.left = insert(rootNode.left, data);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (data &gt; rootNode.data) &#123;</span><br><span class="line">                rootNode.right = insert(rootNode.right, data);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> rootNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> TreeNode <span class="title">delete</span><span class="params">(TreeNode treeNode, <span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (treeNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (data &lt; treeNode.data) &#123;</span><br><span class="line">                <span class="comment">// 递归赋值的过程</span></span><br><span class="line">                treeNode.left = delete(treeNode.left, data);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data &gt; treeNode.data) &#123;</span><br><span class="line">                treeNode.right = delete(treeNode.right, data);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (treeNode.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> treeNode.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (treeNode.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> treeNode.left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 找到节点右子树的最小值，后继节点</span></span><br><span class="line">                TreeNode minNode = minRightNode(treeNode.right);</span><br><span class="line">                <span class="comment">// 用后继节点替换删除节点</span></span><br><span class="line">                treeNode.data = minNode.data;</span><br><span class="line">                <span class="comment">// 将后继节点删除</span></span><br><span class="line">                treeNode.right = delete(minNode, minNode.data);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 第二种方式</span></span><br><span class="line"><span class="comment">//                TreeNode maxNode = maxLeftNode(treeNode.left);</span></span><br><span class="line"><span class="comment">//                treeNode.data = maxNode.data;</span></span><br><span class="line"><span class="comment">//                treeNode.left = delete(maxNode, maxNode.data);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> treeNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左子树的最大值</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> TreeNode <span class="title">maxLeftNode</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右子树的最小值</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> TreeNode <span class="title">minRightNode</span><span class="params">(TreeNode targetNode)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (targetNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                targetNode = targetNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> targetNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != treeNode) &#123;</span><br><span class="line">                System.out.print(treeNode.data + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">                preOrder(treeNode.left);</span><br><span class="line">                preOrder(treeNode.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">midOrder</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != treeNode) &#123;</span><br><span class="line">                midOrder(treeNode.left);</span><br><span class="line">                System.out.print(treeNode.data + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">                midOrder(treeNode.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != treeNode) &#123;</span><br><span class="line">                postOrder(treeNode.left);</span><br><span class="line">                postOrder(treeNode.right);</span><br><span class="line">                System.out.print(treeNode.data + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、效率"><a href="#5、效率" class="headerlink" title="5、效率"></a>5、效率</h3><p><img src="/pics/image-20201009103249878.png" alt="image-20201009103249878"></p>
<h2 id="7-4-平衡二叉树（AVL树）"><a href="#7-4-平衡二叉树（AVL树）" class="headerlink" title="7.4 平衡二叉树（AVL树）"></a>7.4 平衡二叉树（AVL树）</h2><p>是一种二叉排序树，具有二叉排序树的所有特性，除此外新的特性有：</p>
<ul>
<li>每一个节点的左子树和右子树的高度差至多为1。将二叉树节点的左子树深度减去右子树深度的值称为平衡因子BF，那么二叉树所有节点的平衡因子只可能是0/1/-1。只要二叉树上有一个节点的BF绝对值大于1，那么这棵树就是不平衡的。</li>
<li>距离插入节点最近的，且BF绝对值大于1的节点做为根的子树，称为<strong>最小不平衡子树</strong>。</li>
</ul>
<h3 id="1、失衡调整"><a href="#1、失衡调整" class="headerlink" title="1、失衡调整"></a>1、失衡调整</h3><p>插入节点不平衡时，取最小不平衡树，进行调整，失衡的情况及调整策略有4种：</p>
<p><img src="/pics/image-20201010113610142.png" alt="image-20201010113610142"></p>
<h3 id="2、实现-1"><a href="#2、实现-1" class="headerlink" title="2、实现"></a>2、实现</h3><h2 id="7-5-红黑树"><a href="#7-5-红黑树" class="headerlink" title="7.5 红黑树"></a>7.5 红黑树</h2><p>红黑树是每个节点都带有<em>颜色</em>属性的，颜色为<em>红色</em>或<em>黑色</em>。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：</p>
<ol>
<li>节点是红色或黑色。</li>
<li>根是黑色。</li>
<li>所有叶子都是黑色（叶子是NIL节点）。</li>
<li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</li>
<li>从任一节点到其每个叶子的所有<a href="https://zh.wikipedia.org/wiki/%E9%81%93%E8%B7%AF_(%E5%9B%BE%E8%AE%BA)">简单路径</a>都包含相同数目的黑色节点。</li>
</ol>
<p>下面是一个具体的红黑树的图例：</p>
<p><img src="/pics/image-20201010165702505.png" alt="image-20201010165702505"></p>
<p>红黑树相对于AVL树来说，牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树。</p>
<h3 id="1、红黑树的调整："><a href="#1、红黑树的调整：" class="headerlink" title="1、红黑树的调整："></a>1、红黑树的调整：</h3><p><a href="https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91">https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91</a></p>
<p><a href="https://time.geekbang.org/column/article/68976">https://time.geekbang.org/column/article/68976</a></p>
<h2 id="7-6-B树和B-树"><a href="#7-6-B树和B-树" class="headerlink" title="7.6 B树和B+树"></a>7.6 B树和B+树</h2><h3 id="1、多路查找树"><a href="#1、多路查找树" class="headerlink" title="1、多路查找树"></a>1、多路查找树</h3><p>每一个节点的孩子可以多于2个，且每一个节点可以存储多个元素。</p>
<p><a href="https://blog.csdn.net/wtyvhreal/article/details/46442091">https://blog.csdn.net/wtyvhreal/article/details/46442091</a></p>
<h3 id="2、B树"><a href="#2、B树" class="headerlink" title="2、B树"></a>2、B树</h3><p>B/B+树是为了磁盘或其它存储设备而设计的一种平衡多路查找树，与AVL树相比，在相同的的节点的情况下，一颗B/B+树的高度远远小于AVL树的高度(<strong>在下面B/B+树的性能分析中会提到</strong>)。B/B+树上操作的时间通常由存取磁盘的时间和CPU计算时间这两部分构成，而CPU的速度非常快，所以B树的操作效率取决于访问磁盘的次数，关键字总数相同的情况下B树的高度越小，磁盘I/O所花的时间越少。</p>
<p><img src="/pics/image-20201010150846225.png" alt="image-20201010150846225"></p>
<h3 id="3、B-树"><a href="#3、B-树" class="headerlink" title="3、B+树"></a>3、B+树</h3><p><img src="/pics/image-20201010151620998.png" alt="image-20201010151620998"></p>
<p><img src="/pics/image-20201010151527119.png" alt="image-20201010151527119"></p>
<h2 id="7-7-散列表"><a href="#7-7-散列表" class="headerlink" title="7.7 散列表"></a>7.7 散列表</h2><p><img src="/pics/image-20201012102804659.png" alt="image-20201012102804659"></p>
<h3 id="1、散列函数"><a href="#1、散列函数" class="headerlink" title="1、散列函数"></a>1、散列函数</h3><p>散列函数构造有2个原则：1、计算简单 2、散列地址分布均匀</p>
<h4 id="1、直接定址法"><a href="#1、直接定址法" class="headerlink" title="1、直接定址法"></a>1、直接定址法</h4><p>适合查找表较小且连续的情况，实际中应用较少。<br>$$<br>F(key) = a * key + b<br>$$</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f(key) = a * key + b</span><br></pre></td></tr></table></figure>

<h4 id="2、除留余数法"><a href="#2、除留余数法" class="headerlink" title="2、除留余数法"></a>2、除留余数法</h4><p>最常用的构造散列函数的方法，方法的关键在于选择合适的p，对于散列表长为m的散列函数公式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f(key) = key mod p (p &lt;= m)</span><br></pre></td></tr></table></figure>

<h2 id="2、散列冲突处理"><a href="#2、散列冲突处理" class="headerlink" title="2、散列冲突处理"></a>2、散列冲突处理</h2><p>不同关键字经过散列函数计算得到相同的散列地址。</p>
<h4 id="1、-线性探测法"><a href="#1、-线性探测法" class="headerlink" title="1、 线性探测法"></a>1、 线性探测法</h4><p><img src="/pics/image-20201012110343653.png" alt="image-20201012110343653"></p>
<h4 id="2、二次探测法-随机数法"><a href="#2、二次探测法-随机数法" class="headerlink" title="2、二次探测法 +随机数法"></a>2、二次探测法 +随机数法</h4><p><img src="/pics/image-20201012112015612.png" alt="image-20201012112015612"></p>
<h4 id="3、链地址法"><a href="#3、链地址法" class="headerlink" title="3、链地址法"></a>3、链地址法</h4><p><img src="/pics/image-20201012112142672.png" alt="image-20201012112142672"></p>
<p><img src="/pics/image-20201012112100954.png" alt="image-20201012112100954"></p>
<h3 id="3、实现"><a href="#3、实现" class="headerlink" title="3、实现"></a>3、实现</h3><h1 id="八、排序"><a href="#八、排序" class="headerlink" title="八、排序"></a>八、排序</h1><ol>
<li><p>算法的执行效率：</p>
<p>算法的时间复杂度。排序时主要关注的是比较和移动的次数。</p>
</li>
<li><p>算法的稳定性：</p>
<p>如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。我通过一个例子来解释一下。比如我们有一组数据 2，9，3，4，8，3，按照大小排序之后就是 2，3，3，4，8，9。这组数据里有两个 3。经过某种排序算法排序之后，如果两个 3 的前后顺序没有改变，那我们就把这种排序算法叫作稳定的排序算法；如果前后顺序发生变化，那对应的排序算法就叫作不稳定的排序算法。当存在多个排序因子时，比如订单要根据金额和下单时间排序，稳定和不稳定的结果差异很大。</p>
</li>
<li><p>算法的内存消耗：</p>
<p>算法的空间复杂度，即进行排序时所需要的的辅助存储空间。</p>
</li>
</ol>
<h2 id="8-1-冒泡排序"><a href="#8-1-冒泡排序" class="headerlink" title="8.1 冒泡排序"></a>8.1 冒泡排序</h2><p><strong>两两比较相邻记录的顺序</strong>，如果反序则交换，直到没有反序记录为止，从小到大排。</p>
<p><img src="/pics/image-20200812175129105.png" alt="image-20200812175129105"></p>
<h3 id="1、冒泡的三种实现"><a href="#1、冒泡的三种实现" class="headerlink" title="1、冒泡的三种实现"></a>1、冒泡的三种实现</h3><p>冒泡初级版，严格意义上非冒泡排序，只是将最小值放到这一轮的第一位，更准确的描述应该是交换排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort0</span><span class="params">(<span class="keyword">int</span>[] source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = source == <span class="keyword">null</span> ? <span class="number">0</span> : source.length;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span> || len == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;element less 1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="comment">// 当前元素大于后续的元素，则进行交换，</span></span><br><span class="line">            <span class="comment">// 这样的结果就是每轮结束时，会找到当前轮最小的元素放到当前轮的第一位</span></span><br><span class="line">            <span class="keyword">if</span> (source[i] &gt; source[j]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = source[i];</span><br><span class="line">                source[i] = source[j];</span><br><span class="line">                source[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dump(source);</span><br><span class="line">    &#125;</span><br><span class="line">    dump(source);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dump</span><span class="params">(<span class="keyword">int</span>[] source)</span> </span>&#123;</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> element : source) &#123;</span><br><span class="line">        builder.append(element).append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(builder.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>改进版1，标准冒泡排序：第一种方式严格来讲并不是冒泡排序，不是两两相邻进行比较，每次只是比较这一轮的“第一位”和其余位置，若是逆序则交换<strong>。两两比较过程中，会将其余位置较小的元素也往前移动。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序，两两相邻比较并交换</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort1</span><span class="params">(<span class="keyword">int</span>[] source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = source == <span class="keyword">null</span> ? <span class="number">0</span> : source.length;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span> || len == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;element less 1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = len - <span class="number">1</span>; j &gt; i; j--) &#123; <span class="comment">// 从后往前遍历</span></span><br><span class="line">            <span class="comment">// 前 &gt; 后时，交换元素</span></span><br><span class="line">            <span class="keyword">if</span> (source[j - <span class="number">1</span>] &gt; source[j]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = source[j];</span><br><span class="line">                source[j] = source[j - <span class="number">1</span>];</span><br><span class="line">                source[j - <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dump(source);</span><br><span class="line">    &#125;</span><br><span class="line">    dump(source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>试想一下，冒泡排序过程中，某一轮如果没有发生任何交换，那么就说明此时序列已经是有序的，就不需要再进行比较了，也就是说可以再进一步优化下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 优化2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort2</span><span class="params">(<span class="keyword">int</span>[] source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = source == <span class="keyword">null</span> ? <span class="number">0</span> : source.length;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span> || len == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;element less 1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = len - <span class="number">1</span>; j &gt; i; j--) &#123; <span class="comment">// 从后往前遍历</span></span><br><span class="line">            <span class="comment">// 前 &gt; 后时，交换元素</span></span><br><span class="line">            <span class="keyword">if</span> (source[j - <span class="number">1</span>] &gt; source[j]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = source[j];</span><br><span class="line">                source[j] = source[j - <span class="number">1</span>];</span><br><span class="line">                source[j - <span class="number">1</span>] = temp;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果某一轮没有发生元素交换，说明已经排好序了</span></span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dump(source);</span><br><span class="line">    &#125;</span><br><span class="line">    dump(source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、性能分析"><a href="#2、性能分析" class="headerlink" title="2、性能分析"></a>2、性能分析</h3><ul>
<li><p>时间复杂度</p>
<p><img src="/pics/image-20200812210611764.png" alt="image-20200812210611764"></p>
</li>
<li><p>稳定性</p>
<p>在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。</p>
</li>
<li><p>空间复杂度</p>
<p>冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)。</p>
</li>
</ul>
<h2 id="8-2-选择排序"><a href="#8-2-选择排序" class="headerlink" title="8.2 选择排序"></a>8.2 选择排序</h2><p>数组中的数据分为两个区间，已排序区间和未排序区间，通过n-1次遍历，每次找到未排序区间的最小元素，将其放到已排序区间末尾。</p>
<p><img src="/pics/image-20200812175024173.png" alt="image-20200812175024173"></p>
<h3 id="1、实现"><a href="#1、实现" class="headerlink" title="1、实现"></a>1、实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort0</span><span class="params">(<span class="keyword">int</span>[] source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = source == <span class="keyword">null</span> ? <span class="number">0</span> : source.length;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span> || len == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;element less 1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (source[minIndex] &gt; source[j]) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = source[minIndex];</span><br><span class="line">            source[minIndex] = source[i];</span><br><span class="line">            source[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        SortHelper.dump(source);</span><br><span class="line">    &#125;</span><br><span class="line">    SortHelper.dump(source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、性能"><a href="#2、性能" class="headerlink" title="2、性能"></a>2、性能</h3><ul>
<li><p>时间复杂度：</p>
<p><img src="/pics/image-20200812210524669.png" alt="image-20200812210524669"></p>
<p><img src="/pics/image-20200812210531732.png" alt="image-20200812210531732"></p>
</li>
<li><p>稳定性：</p>
<p>选择排序是一种不稳定的排序算法。从前面画的那张图中可以看出来，选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。</p>
</li>
<li><p>空间复杂度：O(1)</p>
</li>
</ul>
<p>​       相比于冒泡排序，选择排序的性能略好，因为元素交换的次数较少，但是不具备稳定性。</p>
<h2 id="8-3-插入排序"><a href="#8-3-插入排序" class="headerlink" title="8.3 插入排序"></a>8.3 插入排序</h2><p>数组中的数据分为两个区间，<strong>已排序区间和未排序区间</strong>，初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。</p>
<h3 id="1、实现-1"><a href="#1、实现-1" class="headerlink" title="1、实现"></a>1、实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort0</span><span class="params">(<span class="keyword">int</span>[] source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = source == <span class="keyword">null</span> ? <span class="number">0</span> : source.length;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span> || len == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;element less 1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123; <span class="comment">// 从第二位开始</span></span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">int</span> temp = source[j]; <span class="comment">//记录当前位置，若移位，当前位置会被覆盖</span></span><br><span class="line">        <span class="keyword">for</span> (; j &gt; <span class="number">0</span> &amp;&amp; source[j - <span class="number">1</span>] &gt; temp; j--) &#123; <span class="comment">// 从后往前遍历，查找插入的位置</span></span><br><span class="line">            <span class="comment">//若前一位值大于当前位置，前一位向后移动一位</span></span><br><span class="line">            source[j] = source[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        source[j] = temp; <span class="comment">// 将值插入到合适的位置</span></span><br><span class="line">        SortHelper.dump(source);</span><br><span class="line">    &#125;</span><br><span class="line">    SortHelper.dump(source);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移位判断使用while循环，更好理解一点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort1</span><span class="params">(<span class="keyword">int</span>[] source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = source == <span class="keyword">null</span> ? <span class="number">0</span> : source.length;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span> || len == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;element less 1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123; <span class="comment">// 从第二位开始</span></span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">int</span> temp = source[j];</span><br><span class="line">        <span class="comment">// 查找并移位置</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; source[j - <span class="number">1</span>] &gt; temp) &#123;</span><br><span class="line">            source[j] = source[j - <span class="number">1</span>];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果j！=i ，说明移动过了位置</span></span><br><span class="line">        <span class="keyword">if</span> (j != i) &#123;</span><br><span class="line">            source[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        SortHelper.dump(source);</span><br><span class="line">    &#125;</span><br><span class="line">    SortHelper.dump(source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、性能-1"><a href="#2、性能-1" class="headerlink" title="2、性能"></a>2、性能</h3><ul>
<li><p>时间复杂度</p>
<p><img src="/pics/image-20200812210309877.png" alt="image-20200812210309877"></p>
</li>
<li><p>稳定性</p>
<p>在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。</p>
</li>
<li><p>空间复杂度：O(1)</p>
</li>
</ul>
<h2 id="8-4-希尔排序"><a href="#8-4-希尔排序" class="headerlink" title="8.4 希尔排序"></a>8.4 希尔排序</h2><p>希尔排序是将待排序的数组元素 按下标的一定增量分组 ，分成多个子序列，然后对各个子序列进行直接插入排序算法排序；然后依次缩减增量再进行排序，直到增量为1时，进行最后一次直接插入排序，排序结束。</p>
<p><img src="/pics/image-20200825194744273.png" alt="image-20200825194744273"></p>
<h3 id="1、实现-2"><a href="#1、实现-2" class="headerlink" title="1、实现"></a>1、实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort0</span><span class="params">(<span class="keyword">int</span>[] source)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> len = source.length;</span><br><span class="line">      <span class="comment">// 步长循环直到1</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> step = len / <span class="number">2</span>; step &gt;= <span class="number">1</span>; step /= <span class="number">2</span>) &#123;</span><br><span class="line">          <span class="comment">// 间隔为step的插入排序</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = step; i &lt; len; i++) &#123;</span><br><span class="line">              <span class="keyword">int</span> temp = source[i];</span><br><span class="line">              <span class="comment">// j表示向前间隔多少位</span></span><br><span class="line">              <span class="keyword">int</span> j = i - step;</span><br><span class="line">              <span class="comment">// 从小到大排序，前面的数 &gt; 后面的数，向后移动</span></span><br><span class="line">              <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; source[j] &gt; temp) &#123;</span><br><span class="line">                  source[j + step] = source[j];</span><br><span class="line">                  j -= step;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//  优化，没有发生移动时，尾部不需要再赋值</span></span><br><span class="line">              <span class="keyword">if</span> ( j != i - step) &#123;</span><br><span class="line">                  source[j + step] = temp;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          SortHelper.dump(source);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、性能-2"><a href="#2、性能-2" class="headerlink" title="2、性能"></a>2、性能</h3><p><img src="/pics/image-20200824174735736.png" alt="image-20200824174735736"></p>
<p><img src="/pics/image-20200824174835386.png" alt="image-20200824174835386"></p>
<p>由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，<strong>所以希尔排序是不稳定的</strong>。</p>
<h2 id="8-5-堆排序"><a href="#8-5-堆排序" class="headerlink" title="8.5 堆排序"></a>8.5 堆排序</h2><p>将待排序的序列构造成一个大顶堆，整个序列的最大值就是堆顶的根节点。将其移动到队尾，然后继续对剩余的元素进行构造，保证剩余元素也具有大顶堆的特性。</p>
<h3 id="1、实现-3"><a href="#1、实现-3" class="headerlink" title="1、实现"></a>1、实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort0</span><span class="params">(<span class="keyword">int</span>[] source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = source.length;</span><br><span class="line">    <span class="comment">// 建堆，从中间节点开始，中间节点必有子节点</span></span><br><span class="line">    <span class="comment">// 建堆的过程先自下而上，在自上而下（递归）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapify(source, n, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 排序，最大值在堆顶（索引为0）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">        <span class="comment">// 将最大值放到末尾</span></span><br><span class="line">        swap(source, j, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 对剩余元素继续维护堆的性质</span></span><br><span class="line">        heapify(source, j, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    SortHelper.dump(source);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 维护堆的算法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> source</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n      数组长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target      待维护节点下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] source, <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// large 表示当前最大值索引</span></span><br><span class="line">    <span class="keyword">int</span> large = target;</span><br><span class="line">    <span class="keyword">int</span> leftSon = target * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> rightSon = target * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (leftSon &lt; n &amp;&amp; source[leftSon] &gt; source[large]) &#123;</span><br><span class="line">        large = leftSon;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rightSon &lt; n &amp;&amp; source[rightSon] &gt; source[large]) &#123;</span><br><span class="line">        large = rightSon;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若父节点小于左节点或者小于右节点，那么就要交换父子节点的值，</span></span><br><span class="line">    <span class="comment">// 交换完毕后，还需要对新的子节点进行维护</span></span><br><span class="line">    <span class="keyword">if</span> (large != target) &#123;</span><br><span class="line">        swap(source, target, large);</span><br><span class="line">        <span class="comment">// large 指向的是被交换子节点的索引，交换后索引位置的值发生了变化，需要重新维护有序性</span></span><br><span class="line">        heapify(source, n, large);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] source, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = source[left];</span><br><span class="line">    source[left] = source[right];</span><br><span class="line">    source[right] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、性能-3"><a href="#2、性能-3" class="headerlink" title="2、性能"></a>2、性能</h3><p>第1步，把无序数组构建成二叉堆，这一步的时间复杂度是O(n) 。<br>第2步，需要进行n-1次循环。每次循环调用一次heapify方法，所以 第2步的计算规模是 (n-1)×logn ，时间复杂度为O(nlogn) 。 两个步骤是并列关系，所以整体的时间复杂度是O(nlogn) 。</p>
<h2 id="8-6-归并排序"><a href="#8-6-归并排序" class="headerlink" title="8.6 归并排序"></a>8.6 归并排序</h2><p>如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。</p>
<p><img src="/pics/image-20200825194433665.png" alt="image-20200825194433665"></p>
<h3 id="1、递归实现"><a href="#1、递归实现" class="headerlink" title="1、递归实现"></a>1、递归实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void sort0(int[] source) &#123;</span><br><span class="line">    sort(source, 0, source.length - 1);</span><br><span class="line">    SortHelper.dump(source);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void sort(int[] source, int left, int right) &#123;</span><br><span class="line">    if (left &gt;= right) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int center = (left + right) / 2;</span><br><span class="line">    sort(source, left, center);</span><br><span class="line">    sort(source, center + 1, right);</span><br><span class="line">    merge(source, left, center, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void merge(int[] source, int left, int center, int right) &#123;</span><br><span class="line">    int[] tmp = new int[right - left + 1];</span><br><span class="line">    int k = 0;</span><br><span class="line">    int i = left;</span><br><span class="line">    int j = center + 1;</span><br><span class="line">    // 从小到大排，取较小值放到tmp数组里</span><br><span class="line">    while (i &lt;= center &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">        if (source[i] &lt; source[j]) &#123;</span><br><span class="line">            tmp[k++] = source[i++];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            tmp[k++] = source[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 多的元素放到末尾</span><br><span class="line">    while (i &lt;= center) &#123;</span><br><span class="line">        tmp[k++] = source[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    // 多的元素放到末尾</span><br><span class="line">    while (j &lt;= right) &#123;</span><br><span class="line">        tmp[k++] = source[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    // 将排序好的数组替换原数组相同位置</span><br><span class="line">    for (int i1 = 0; i1 &lt; tmp.length; i1++) &#123;</span><br><span class="line">        source[left + i1] = tmp[i1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、迭代实现"><a href="#2、迭代实现" class="headerlink" title="2、迭代实现"></a>2、迭代实现</h3><h3 id="3、性能"><a href="#3、性能" class="headerlink" title="3、性能"></a>3、性能</h3><p>时间复杂度是 O(nlogn)，稳定的排序算法</p>
<h2 id="8-7-快速排序"><a href="#8-7-快速排序" class="headerlink" title="8.7 快速排序"></a>8.7 快速排序</h2><p>通过一趟排序将待排记录分割成独立的两部分，其中一部分的记录的关键字均比另一个部分关键字小，则可对这两部分记录进行排序，以达到整个序列有序的目的。</p>
<h3 id="1、实现-4"><a href="#1、实现-4" class="headerlink" title="1、实现"></a>1、实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] source, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pivot = partition(source, left, right);</span><br><span class="line">    SortHelper.dump(source);</span><br><span class="line">    sort(source, left, pivot - <span class="number">1</span>);</span><br><span class="line">    sort(source, pivot + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] source, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = source[left];</span><br><span class="line">    <span class="comment">// 从两端同时向中间遍历，将较小的数放到左边，较大的数放到右边</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (source[left] &lt; pivot) &#123;</span><br><span class="line">            left ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (source[right] &gt; pivot) &#123;</span><br><span class="line">            right --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左右查找到不合规则的数据时，进行交换</span></span><br><span class="line">        swap(source,left, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当left &gt;= right时说明，左右的数均已划分好了</span></span><br><span class="line">    source[left] = pivot;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] source, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = source[left];</span><br><span class="line">    source[left] = source[right];</span><br><span class="line">    source[right] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、优化"><a href="#2、优化" class="headerlink" title="2、优化"></a>2、优化</h3><ol>
<li>选取合适的基准点</li>
<li>小数组时使用插入排序</li>
<li>尾递归优化</li>
</ol>
<h2 id="8-8-小结"><a href="#8-8-小结" class="headerlink" title="8.8 小结"></a>8.8 小结</h2><p><img src="/pics/image-20200910203208775.png" alt="image-20200910203208775"></p>
<p><img src="/pics/image-20200910203220494.png" alt="image-20200910203220494"></p>
]]></content>
      <categories>
        <category>Alg</category>
      </categories>
  </entry>
  <entry>
    <title>ALG_05_回溯</title>
    <url>/2021/05/14/Notes/Algorithm/ALG_05_%E5%9B%9E%E6%BA%AF/</url>
    <content><![CDATA[<h1 id="ALG-05-回溯"><a href="#ALG-05-回溯" class="headerlink" title="ALG_05_回溯"></a>ALG_05_回溯</h1><span id="more"></span>

<h2 id="什么是回溯？"><a href="#什么是回溯？" class="headerlink" title="什么是回溯？"></a>什么是回溯？</h2><p>回溯法也可以叫做回溯搜索法，它是一种搜索的方式。</p>
<p>回溯算法是一种暴力穷举算法，穷举的过程就是遍历一颗多叉树的过程。</p>
<p>回溯算法框架和多叉树遍历框架非常类似。</p>
<p><img src="/pics/image-20210508121313006.png" alt="image-20210508121313006"></p>
<p>回溯是递归的副产品，只要有递归就会有回溯。<strong>回溯函数也就是递归函数，指的都是一个函数</strong>。</p>
<h2 id="回溯法的效率"><a href="#回溯法的效率" class="headerlink" title="回溯法的效率"></a>回溯法的效率</h2><p>回溯法的性能如何呢，这里要和大家说清楚了，<strong>虽然回溯法很难，很不好理解，但是回溯法并不是什么高效的算法</strong>。</p>
<p><strong>因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案</strong>，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。</p>
<p>那么既然回溯法并不高效为什么还要用它呢？</p>
<p>因为没得选，一些问题能暴力搜出来就不错了，撑死了再剪枝一下，还没有更高效的解法。</p>
<p>此时大家应该好奇了，都什么问题，这么牛逼，只能暴力搜索。</p>
<h2 id="回溯法解决的问题"><a href="#回溯法解决的问题" class="headerlink" title="回溯法解决的问题"></a>回溯法解决的问题</h2><p>回溯法，一般可以解决如下几种问题：</p>
<ul>
<li>组合问题：N个数里面按一定规则找出k个数的集合</li>
<li>切割问题：一个字符串按一定规则有几种切割方式</li>
<li>子集问题：一个N个数的集合里有多少符合条件的子集</li>
<li>排列问题：N个数按一定规则全排列，有几种排列方式</li>
<li>棋盘问题：N皇后，解数独等等</li>
</ul>
<h2 id="如何理解回溯法"><a href="#如何理解回溯法" class="headerlink" title="如何理解回溯法"></a>如何理解回溯法</h2><p><strong>回溯法解决的问题都可以抽象为树形结构</strong>，是的，我指的是所有回溯法的问题都可以抽象为树形结构！</p>
<p>因为回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成了树的宽度，递归的深度，都构成的树的深度</strong>。</p>
<p>递归就要有终止条件，所以必然是一颗高度有限的树（N叉树）。</p>
<p><img src="/pics/image-20210508120928447.png" alt="image-20210508120928447"></p>
<h2 id="回溯法模板"><a href="#回溯法模板" class="headerlink" title="回溯法模板"></a>回溯法模板</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;<span class="comment">// 收集数据</span></span><br><span class="line">        backtracking(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><h4 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><a href="https://leetcode-cn.com/problems/combinations/">77. 组合</a></h4><blockquote>
<p>给定两个整数 <em>n</em> 和 <em>k</em>，返回 1 … <em>n</em> 中所有可能的 <em>k</em> 个数的组合。</p>
</blockquote>
<p>注意组合的话 [1,2] , [2,1] 是相同的，决定了startIndex的起始位置是下一个，同时也排除了 [1,1] 这种情况。同时限制了组合的长度为2，&gt;2 的没有必要在遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="comment">// 1.结果集</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 2.收集路径</span></span><br><span class="line">    Deque&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    dfs(n, k, <span class="number">1</span>, path, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> startIndex, Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; list)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;dfs &quot;</span> + startIndex);</span><br><span class="line">    <span class="keyword">if</span> (path.size() == k) &#123; <span class="comment">// 终止条件</span></span><br><span class="line">        list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt;= n; i++) &#123;</span><br><span class="line">        path.push(i); <span class="comment">// 收集数据</span></span><br><span class="line">        <span class="comment">//System.out.println(&quot;push &quot; + i);</span></span><br><span class="line">        <span class="comment">// 1 走到这后开启一个for循环 ，k=2时，2，3，4 的dfs只能走一次然后就退出 ，接着就到 2开始</span></span><br><span class="line">        <span class="comment">//// startIndex参数用来记录本层递归的中，集合从哪里开始遍历（集合就是[1,...,n] ）。</span></span><br><span class="line">        dfs(n, k, i + <span class="number">1</span>, path, list); <span class="comment">// 递归</span></span><br><span class="line">        <span class="keyword">int</span> x = path.pop(); <span class="comment">// 回溯</span></span><br><span class="line">        <span class="comment">//System.out.println(&quot;pop =&gt; &quot; + x);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剪枝优化"><a href="#剪枝优化" class="headerlink" title="剪枝优化"></a>剪枝优化</h3><p>假设 n = 4， k =3， startIndex = 1; </p>
<ol>
<li><p>假设当前已经搜索的节点为个数<code>path.size == 0</code>，也就是从头开始搜索；</p>
</li>
<li><p>剩余要搜索的节点数目为 <code>k - path.size = 3</code></p>
</li>
<li><p>那么至多开始搜索的位置是 <code>end = n - (k - path.size()) + 1 == 2</code>，也就是说<code>startIndex &lt;= end</code>，为什么有个 +1 呢，因为包括起始位置，我们要是一个左闭的集合，以上情况下从2开始搜索都是合理的。所以优化之后的for循环是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt;= n - (k - path.size()) + <span class="number">1</span>; i++) <span class="comment">// i为本次搜索的起始位置</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a></h4><blockquote>
<p>给定一个<strong>无重复</strong>元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的数字可以无限制重复被选取。</p>
</blockquote>
<p>重点 ：1.  递归的退出条件发生了变化<code>（target值）</code></p>
<p>​             2.  可重复读取当前值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Deque&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	<span class="comment">// target 目标值，</span></span><br><span class="line">    dfs(target, candidates, <span class="number">0</span>, path, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[] candidates, <span class="keyword">int</span> startIndex, Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target &lt; <span class="number">0</span>) &#123; <span class="comment">// 剪枝1</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> size = candidates.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = candidates[i];</span><br><span class="line">        path.push(tmp);</span><br><span class="line">        target -= tmp; <span class="comment">// target </span></span><br><span class="line">        dfs(target, candidates, i, path, list); <span class="comment">// 不用i+1了，表示可以重复读取当前的数</span></span><br><span class="line">        target += tmp;</span><br><span class="line">        path.pop(); <span class="comment">// 回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.md">对应剪枝优化</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先排序</span></span><br><span class="line">Arrays.sort(candidates); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 剪枝优化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; size &amp;&amp; target &gt;= candidates[i]; i++)<span class="comment">// &gt;i 或&gt;startIndex 均可，再理解下区别</span></span><br></pre></td></tr></table></figure>

<p><strong>对总集合排序之后，只有下一层的剩余的值target 小于candidates[i] ，就可以结束本轮for循环。</strong></p>
<h4 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a><a href="https://leetcode-cn.com/problems/combination-sum-iii/">216. 组合总和 III</a></h4><blockquote>
<p>找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p>
<p>说明：</p>
<p>所有数字都是正整数。<br>解集不能包含重复的组合。 </p>
</blockquote>
<p>是前面2题的结合体，取值范围是 1- 9， 退出条件是target。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Deque&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    dfs(n, k, <span class="number">1</span>, path, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> targetNum, <span class="keyword">int</span> k, <span class="keyword">int</span> starIndex, Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = path.size();</span><br><span class="line">  	<span class="keyword">if</span> (targetNum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      	<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  	</span><br><span class="line">    <span class="keyword">if</span> (size == k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (targetNum == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = starIndex; i &lt;= <span class="number">9</span> - (k - size) + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        path.push(i);</span><br><span class="line">        targetNum -= i; </span><br><span class="line">        dfs(targetNum, k, i + <span class="number">1</span>, path, res);</span><br><span class="line">        targetNum += i; <span class="comment">// 回溯</span></span><br><span class="line">        path.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可进行的剪枝优化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = starIndex; i &lt;= <span class="number">9</span> - (k - size) + <span class="number">1</span> &amp;&amp; targetNum &gt;= starIndex<span class="comment">/** 或i **/</span>; i++)</span><br></pre></td></tr></table></figure>

<p><strong>剩余大于了有序列表第一个值，才可以进入循环中。</strong></p>
<h4 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a href="https://leetcode-cn.com/problems/combination-sum-ii/">40. 组合总和 II</a></h4><blockquote>
<p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的每个数字在每个组合中只能使用一次。</p>
<p><strong>说明：</strong></p>
<ul>
<li>所有数字（包括目标数）都是正整数。</li>
<li>解集不能包含重复的组合。 </li>
</ul>
</blockquote>
<p>candidates 可能有重复数据，所以需增加去重逻辑，并且要先对集合进行排序。去重时判断相邻2数是否相等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i &gt; startIndex &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>这里其实也涉及到树层去重和树枝去重的概念，但是由于startIndex每次都要 + 1，我们将到全排列时再细说。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Deque&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Arrays.sort(candidates);</span><br><span class="line">    dfs(candidates, target, path, res, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res, <span class="keyword">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> length = candidates.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; length &amp;&amp; target &gt;= candidates[i]; i++) &#123; <span class="comment">// 剪枝操作</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; startIndex <span class="comment">// 这里也是容易出错的位置</span></span><br><span class="line">            &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.push(candidates[i]);</span><br><span class="line">        <span class="comment">// target -= candidates[i]; 优化为</span></span><br><span class="line">        dfs(candidates, target - candidates[i], path, res, i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// target += candidates[i];</span></span><br><span class="line">        path.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h4><blockquote>
<p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
</blockquote>
<p><img src="/pics/image-20210510194236110.png" alt="image-20210510194236110"></p>
<p>这道题要去理解横向for循环和纵向递归的以及startIndex不同的含义。对于数组集合来说当次的横向for循环就是[startIndex , end]；而下一次递归或说下一次for 循环就要从 startIndex + 1 开始；而对于本题来说，startIndex 代表的要循环的字符串数组的起始位置。体会下[77](#<a href="https://leetcode-cn.com/problems/combinations/">77. 组合</a>)和当前题目。</p>
<p><img src="/pics/image-20210509113145671.png" alt="image-20210509113145671"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (digits == <span class="keyword">null</span> || digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> length = digits.length();</span><br><span class="line">    String[] arr = <span class="keyword">new</span> String[digits.length()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        arr[i] = letterMap[digits.charAt(i) - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// startIndex 表示的是第几组字符串</span></span><br><span class="line">    dfs(length, <span class="number">0</span>, <span class="string">&quot;&quot;</span>, res, arr);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> length, <span class="keyword">int</span> startIndex, String path, List&lt;String&gt; res, String[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = path.length();</span><br><span class="line">    <span class="keyword">if</span> (size == length) &#123;</span><br><span class="line">        res.add(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (startIndex &gt;= length) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String letter = arr[startIndex];</span><br><span class="line">    <span class="keyword">int</span> letterLength = letter.length();</span><br><span class="line">    <span class="comment">// i 代表的是当前字符串范围 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; letterLength; i++) &#123;</span><br><span class="line">        path += letter.charAt(i);</span><br><span class="line">        <span class="comment">// startIndex + 1 代表取下一个字符串的数据了</span></span><br><span class="line">        dfs(length, startIndex + <span class="number">1</span>, path, res, arr);</span><br><span class="line">        path = path.substring(<span class="number">0</span>, path.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串分割"><a href="#字符串分割" class="headerlink" title="字符串分割"></a>字符串分割</h3><h4 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131. 分割回文串"></a><a href="https://leetcode-cn.com/problems/palindrome-partitioning/">131. 分割回文串</a></h4><blockquote>
<p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回 <code>s</code> 所有可能的分割方案。</p>
<p><strong>回文串</strong> 是正着读和反着读都一样的字符串。</p>
</blockquote>
<p>先考虑下这些字符串能分割成多少个子串。分割的过程描述成树的遍历过程，如下图所示</p>
<p><img src="../pics/image-20210509174331925.png" alt="image-20210509174331925"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Deque&lt;String&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    dfs(s, <span class="number">0</span>, path, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String s, <span class="keyword">int</span> startIndex, Deque&lt;String&gt; path, List&lt;List&lt;String&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = s.length();</span><br><span class="line">    <span class="keyword">if</span> (startIndex == size) &#123;</span><br><span class="line">        <span class="comment">// 切割到最后收集结果</span></span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// startIndex 表示这一层开始切的位置，循环开始的位置</span></span><br><span class="line">    <span class="comment">// [startIndex, i] 代表的是递归过程中子串搜索的范围</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isPalindrome(s, startIndex, i)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String subStr = s.substring(startIndex, i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// System.out.println(&quot;add str = &quot; + subStr + &quot;， startIndex = &quot; + startIndex + &quot;, i= &quot; + i);</span></span><br><span class="line">        path.addLast(subStr);</span><br><span class="line">        <span class="comment">// 继续切割，！！！切割过的地方不能再切割！！！</span></span><br><span class="line">        dfs(s, i + <span class="number">1</span>, path, res);</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (start &gt;= <span class="number">0</span> &amp;&amp; start &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(start) != s.charAt(end)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="93-复原-IP-地址"><a href="#93-复原-IP-地址" class="headerlink" title="93. 复原 IP 地址"></a><a href="https://leetcode-cn.com/problems/restore-ip-addresses/">93. 复原 IP 地址</a></h4><blockquote>
<p>给定一个只包含数字的字符串，用以表示一个 IP 地址，返回所有可能从 s 获得的 有效 IP 地址 。你可以按任何顺序返回答案。</p>
<p>有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p>
<p>例如：”0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “<a href="mailto:&#49;&#57;&#50;&#x2e;&#x31;&#x36;&#x38;&#x40;&#49;&#46;&#49;">&#49;&#57;&#50;&#x2e;&#x31;&#x36;&#x38;&#x40;&#49;&#46;&#49;</a>“ 是 无效 IP 地址。</p>
</blockquote>
<p>此题的难点在于：</p>
<ol>
<li><p>合理ip的判断 </p>
</li>
<li><p>递归退出条件</p>
</li>
</ol>
<p>结合上一题理解<strong>，！！！回头看下 break和continue退出！！！</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(<span class="number">0</span>, s, <span class="string">&quot;&quot;</span>, res, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> startIndex, String s, String path, List&lt;String&gt; res, <span class="keyword">int</span> pointNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = s.length();</span><br><span class="line">        <span class="comment">// 第一种判断方式，index 走到了最后，并且有4个点</span></span><br><span class="line"><span class="comment">//        if (path.split(&quot;\\.&quot;).length == 4 &amp;&amp; startIndex == size) &#123;</span></span><br><span class="line"><span class="comment">//            res.add(path.substring(0, size + 3));</span></span><br><span class="line"><span class="comment">//            return;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对上面的优化</span></span><br><span class="line"><span class="comment">//        if (pointNum == 4 &amp;&amp; startIndex == size ) &#123;</span></span><br><span class="line"><span class="comment">//            res.add(path.substring(0, path.length() -1));</span></span><br><span class="line"><span class="comment">//            return;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">// 再次优化</span></span><br><span class="line">        <span class="keyword">if</span> (pointNum == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isValid(s, startIndex, size - <span class="number">1</span>)) &#123;</span><br><span class="line"><span class="comment">//                System.out.println(path);</span></span><br><span class="line">                res.add(path + s.substring(startIndex, size));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isValid(s, startIndex, i)) &#123;</span><br><span class="line"><span class="comment">//                path += s.substring(startIndex, i + 1)+ &quot;.&quot;; // 增加的长度是 i + 1 - startIndex + 1（.）</span></span><br><span class="line">                pointNum++;</span><br><span class="line">                dfs(i + <span class="number">1</span>, s, path + s.substring(startIndex, i + <span class="number">1</span>) + <span class="string">&quot;.&quot;</span>, res, pointNum);</span><br><span class="line">                pointNum--;</span><br><span class="line"><span class="comment">//                path = path.substring(0, path.length() - (i + 2 - startIndex)); // 剪掉上面增加的长度</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// ？？？</span></span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h3><h4 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a href="https://leetcode-cn.com/problems/subsets/">78. 子集</a></h4><blockquote>
<p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p>
</blockquote>
<p>如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，<strong>「那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！」</strong>所有遍历的<strong>集合都是有意义的解</strong>。</p>
<p>另外子集也是一种组合问题，因为它的集合是无序的，子集{1,2} 和 子集{2,1}是一样的。</p>
<p><img src="/pics/image-20210510195055551.png" alt="image-20210510195055551"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Deque&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    dfs(nums, path, lists, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> lists;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, Deque&lt;Integer&gt; deque, List&lt;List&lt;Integer&gt;&gt; lists, <span class="keyword">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">    lists.add(<span class="keyword">new</span> ArrayList&lt;&gt;(deque)); <span class="comment">// 在这里添加元素的原因是记录所有合理的结果集</span></span><br><span class="line">    <span class="keyword">int</span> size = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (startIndex == size) &#123; <span class="comment">// 这里加不加return都可以，遍历所有</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; size; i++) &#123;</span><br><span class="line">        deque.push(nums[i]);</span><br><span class="line">        dfs(nums, deque, lists, i + <span class="number">1</span>);</span><br><span class="line">        deque.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a><a href="https://leetcode-cn.com/problems/subsets-ii/">90. 子集 II</a></h4><blockquote>
<p>给定一个可能包含<strong>重复元素</strong>的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>
<p><strong>说明：解集不能包含重复的子集。</strong></p>
</blockquote>
<p>此题要考虑去重，所以需要先对数组排序，同一层的元素，用过的不能再用了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; startIndex &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) </span><br></pre></td></tr></table></figure>

<p>还要一种解法是增加used数组来去重（剪枝）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="keyword">false</span>) </span><br></pre></td></tr></table></figure>

<p>本题不需要用used数组来去重，因为递归的时候下一个<code>startIndex</code> 是 i + 1 而不是 0。</p>
<p>如果要是全排列的话，每次要从0开始遍历，为了跳过已入栈的元素，需要使用used，后面再解释。看完排列问题后再回来体会这句话。</p>
<p><img src="../pics/image-20210510163142700.png" alt="image-20210510163142700"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Deque&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// !!! 排序 !!!</span></span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    backtrack(nums, res, path, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, List&lt;List&lt;Integer&gt;&gt; res, Deque&lt;Integer&gt; path, <span class="keyword">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">    res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">    <span class="keyword">int</span> size = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (startIndex == size) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种去重</span></span><br><span class="line">    <span class="comment">// HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; startIndex &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123; <span class="comment">// 去重</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第二种去重 效率不高</span></span><br><span class="line">        <span class="comment">//if (set.contains(nums[i])) &#123;</span></span><br><span class="line">  		<span class="comment">//	continue;</span></span><br><span class="line">		<span class="comment">//&#125;</span></span><br><span class="line">		<span class="comment">//set.add(nums[i]);</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        path.push(nums[i]);</span><br><span class="line">        backtrack(nums, res, path, i + <span class="number">1</span>);</span><br><span class="line">        path.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以使用<strong>set针对同一父节点本层去重，但子集问题一定要排序</strong>，为什么呢？</p>
<p>当不能排序时可以使用set去重，比如[491](#<a href="https://leetcode-cn.com/problems/increasing-subsequences/">491. 递增子序列</a>)。排序了之后1，2就不能再取到1 了。加Set判断也没用，因为 2 ， 1 是同一层的，也就是，取1的时候过滤不了2，一定会出现 [1,2] [2,1]  这种情况。而排序了之后就无此问题，2的时候不可能取到1，这里还受startIndex 的影响。</p>
</blockquote>
<p><img src="../pics/image-20210511163630463.png" alt="image-20210511163630463"></p>
<h4 id="491-递增子序列"><a href="#491-递增子序列" class="headerlink" title="491. 递增子序列"></a><a href="https://leetcode-cn.com/problems/increasing-subsequences/">491. 递增子序列</a></h4><blockquote>
<p>给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是 2 。</p>
</blockquote>
<p>而本题求自增子序列，<strong>是不能对原数组进行排序的</strong>，排完序的数组都是自增子序列了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((path.size() &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt; path.peekLast()) <span class="comment">// 必须是递增的</span></span><br><span class="line">                || set.contains(nums[i])) &#123; <span class="comment">//这一层上不能有重复的</span></span><br></pre></td></tr></table></figure>

<p>由于集合不能排序，所以需要用一个 set记录这个元素在本层用过了，本层后面不能再用了。</p>
<p>这一层这个数搜索过了，也不可清空，体会去重和路径回溯的区别。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; findSubsequences(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Deque&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 不能排序</span></span><br><span class="line">    <span class="comment">// Arrays.sort(nums);</span></span><br><span class="line">    backtrack(nums, res, path, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, List&lt;List&lt;Integer&gt;&gt; res, Deque&lt;Integer&gt; path, <span class="keyword">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (path.size() &gt;= <span class="number">2</span>) &#123; </span><br><span class="line">        System.out.println(path);</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">        <span class="comment">//  这里坚决不能加return, &gt;=2 的都是合法值，要记录下来，return的话，&gt;2的都记录不了了</span></span><br><span class="line">        <span class="comment">//  return;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不能用排序，所以要用set起到used数组的作用，每一层的set都是独立的。</span></span><br><span class="line">    HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="comment">// 序列是递增的，所以</span></span><br><span class="line">        <span class="keyword">if</span> ((path.size() &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt; path.peekLast()) </span><br><span class="line">                <span class="comment">//这一层上不能有重复的</span></span><br><span class="line">                || set.contains(nums[i])) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        set.add(nums[i]); <span class="comment">// 记录这个元素在本层用过了，本层后面不能再用了</span></span><br><span class="line">      </span><br><span class="line">        path.addLast(nums[i]);</span><br><span class="line">        backtrack(nums, res, path, i + <span class="number">1</span>);</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><h4 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a></h4><blockquote>
<p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <strong>所有可能的全排列</strong> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>
</blockquote>
<p>组合和子集问题都要考虑<strong>树层中的相同数字的去重</strong>，也就是横向for循环过程中要注意去重。主要的去重逻辑是：</p>
<ul>
<li><code>startIndex</code> 每次从下一个元素开始</li>
<li>数组排序后， 相邻相同 <code>i &gt; startIndex &amp;&amp; num[i] == num[i-1] </code> 去重</li>
</ul>
<p>[77](#<a href="https://leetcode-cn.com/problems/combinations/">77. 组合</a>) 组合问题，搜集特定长度的<strong>叶子节点</strong></p>
<p>[78](#<a href="https://leetcode-cn.com/problems/subsets/">78. 子集</a>) 子集问题，搜集遍历过程中<strong>树的所有节点</strong></p>
<p>排列问题则不同，由于排列是有序的， 比如[1, 2] 和 [2,1] 就认为是2个不同的元素，所以不需要<code>startIndex</code>。但是去重时需要考虑的<strong>同一个树枝不要出现相同的元素，也就是递归过程中同一个Index不要用多次</strong>。这里就需要通过一个<code>used</code>的集合记录。</p>
<p><img src="/pics/image-20210510165406425.png" alt="image-20210510165406425"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Deque&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">    backtrack(nums, res, path, used);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, List&lt;List&lt;Integer&gt;&gt; res, Deque&lt;Integer&gt; path, <span class="keyword">boolean</span>[] used)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (path.size() == size) &#123;</span><br><span class="line">        System.out.println(path);</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//   这一条树上不能有重复的，解法2， 效率没有used高</span></span><br><span class="line">        <span class="comment">//  if (path.contains(nums[i])) &#123;</span></span><br><span class="line">        <span class="comment">//      continue;</span></span><br><span class="line">        <span class="comment">//  &#125;</span></span><br><span class="line">        <span class="comment">//   这一条树上不能有重复的，解法1</span></span><br><span class="line">        <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        used[i] = <span class="keyword">true</span>;</span><br><span class="line">        path.addLast(nums[i]);</span><br><span class="line">        backtrack(nums, res, path, used);</span><br><span class="line">        path.removeLast();</span><br><span class="line">        used[i] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a><a href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II</a></h4><blockquote>
<p>给定一个可包含重复数字的序列 <code>nums</code> ，<strong>按任意顺序</strong> 返回所有不重复的全排列。</p>
</blockquote>
<p>这道题集合组合、子集、全排列的所有特点。</p>
<ol>
<li><p>首先这是一道排列的题，所以不需要<code>startIndex</code>，联系[40](#<a href="https://leetcode-cn.com/problems/combination-sum-ii/">40. 组合总和 II</a>) 和 [90](<a href="https://leetcode-cn.com/problems/subsets-ii/">90. 子集 II</a>)，并且体会<code>used</code></p>
</li>
<li><p>考察排列我们会想到，**同一树枝上不能用重复的<code>index</code>**，所以要使用<code>used[i]</code> 进行标记</p>
</li>
<li><p>去重，首先想到子集问题，先对序列进行排序，去重条件为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">num[i] == num[i -<span class="number">1</span> ]  &amp;&amp; used[i - <span class="number">1</span>] == <span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode-cn.com/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/">怎么理解，遍历到和前一个数相等的时候如果used[i - 1] 被撤销了选择，说明这次是重复的。</a></p>
<p><img src="/pics/image-20210510220212194.png" alt="image-20210510220212194"></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Deque&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// !!!!排序!!!</span></span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">    backtrack(nums, res, path, used);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, List&lt;List&lt;Integer&gt;&gt; res, Deque&lt;Integer&gt; path, <span class="keyword">boolean</span>[] used)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == size) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="comment">// 这一条树枝上不能有重复的</span></span><br><span class="line">            <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// i &gt; 0 是为了保证 i-1有意义</span></span><br><span class="line">            <span class="comment">// nums[i-1] == nums [i], 表示出现重复</span></span><br><span class="line">            <span class="comment">// used[i - 1] == false ，表示回退中刚刚撤销选择</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="keyword">false</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            used[i] = <span class="keyword">true</span>;</span><br><span class="line">            path.addLast(nums[i]);</span><br><span class="line">            backtrack(nums, res, path, used);</span><br><span class="line">            path.removeLast();</span><br><span class="line">            used[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h3><h4 id="51-N-皇后"><a href="#51-N-皇后" class="headerlink" title="51. N 皇后"></a><a href="https://leetcode-cn.com/problems/n-queens/">51. N 皇后</a></h4><blockquote>
<p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p>
<p>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>
</blockquote>
<p>解题思路：</p>
<ol>
<li>从第一行开始，每一行从第1列放置Q，放置好当前Q之后，再从第二行开始搜索</li>
<li>Q合法的节点规则，在Q的上方，左上方，右上方没有其他的Q</li>
<li><strong>只要搜索到了树的叶子节点，说明就找到了皇后们的合理位置了</strong>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">char</span>[][] chessboard = <span class="keyword">new</span> <span class="keyword">char</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span>[] c : chessboard) &#123;</span><br><span class="line">        Arrays.fill(c, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(n, <span class="number">0</span>, chessboard, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> row, <span class="keyword">char</span>[][] chessboard, List&lt;List&lt;String&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (row == n) &#123;<span class="comment">//搜索到一组合法的解</span></span><br><span class="line">        res.add(Array2List(chessboard));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// col 代表列， depth 代表行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isValid(chessboard, row, col, n)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        chessboard[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        dfs(n, row + <span class="number">1</span>, chessboard, res);</span><br><span class="line">        chessboard[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查[row][col] 是否可以放置元素</span></span><br><span class="line"><span class="comment">//      col</span></span><br><span class="line"><span class="comment">// row  [0,0] [0,1] [0,2] [0,3]</span></span><br><span class="line"><span class="comment">//      [1,0] [1,1] [1,2] [1,3]</span></span><br><span class="line"><span class="comment">//      [2,0] [2,1] [2,2] [2,3]</span></span><br><span class="line"><span class="comment">//      [3,0] [3,1] [3,2] [3,3]</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[][] chessboard, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查上方</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chessboard[i][col] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左上</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右上</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">Array2List</span><span class="params">(<span class="keyword">char</span>[][] chessboard)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span>[] c : chessboard) &#123;</span><br><span class="line">        list.add(String.copyValueOf(c));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="332-重新安排行程"><a href="#332-重新安排行程" class="headerlink" title="332. 重新安排行程"></a><a href="https://leetcode-cn.com/problems/reconstruct-itinerary/">332. 重新安排行程</a></h4><blockquote>
<p>给定一个机票的字符串二维数组 [from, to]，子数组中的两个成员分别表示飞机出发和降落的机场地点，对该行程进行重新规划排序。所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。</p>
<p>提示：</p>
<p>如果存在多种有效的行程，请你按字符自然排序返回最小的行程组合。例如，行程 [“JFK”, “LGA”] 与 [“JFK”, “LGB”] 相比就更小，排序更靠前<br>所有的机场都用三个大写字母表示（机场代码）。<br>假定所有机票至少存在一种合理的行程。<br>所有的机票必须都用一次 且 只能用一次。</p>
</blockquote>
<p>解题思路：</p>
<ol>
<li>所谓的行程就是[起点，终点] 路径，用三个字母表示起点和终点的节点</li>
<li>同一个起点，可以有多个重点，是有优先级的，按字母顺序排序，需要使用TreeMap这样的结构。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findItinerary</span><span class="params">(List&lt;List&lt;String&gt;&gt; tickets)</span> </span>&#123;</span><br><span class="line">    Deque&lt;String&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Map&lt;String, TreeMap&lt;String, Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// HashMap&lt;from, TreeMap&lt;to, count&gt;&gt;</span></span><br><span class="line">    <span class="comment">// t.get(0) = from</span></span><br><span class="line">    <span class="comment">// t.get(1) = to</span></span><br><span class="line">    <span class="comment">// count 票数</span></span><br><span class="line">    <span class="keyword">for</span> (List&lt;String&gt; t : tickets) &#123;</span><br><span class="line">        String from = t.get(<span class="number">0</span>);</span><br><span class="line">        String to = t.get(<span class="number">1</span>);</span><br><span class="line">        map.putIfAbsent(from, <span class="keyword">new</span> TreeMap&lt;&gt;());</span><br><span class="line">        TreeMap&lt;String, Integer&gt; treeMap = map.get(from);</span><br><span class="line">        treeMap.put(to, treeMap.getOrDefault(to, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 起点</span></span><br><span class="line">    path.addLast(<span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">    dfs(tickets.size(), <span class="number">0</span>, path, map);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带返回值表示找到一组就可以结束</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> ticketNum, <span class="keyword">int</span> progress, Deque&lt;String&gt; res, Map&lt;String, TreeMap&lt;String, Integer&gt;&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (progress == ticketNum) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 出发的起点的路径</span></span><br><span class="line">    String from = res.peekLast();</span><br><span class="line">    TreeMap&lt;String, Integer&gt; tos = map.get(from);</span><br><span class="line">    <span class="keyword">if</span> (tos == <span class="keyword">null</span> || tos.isEmpty()) &#123; <span class="comment">// 判空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 还有可以找的目的地</span></span><br><span class="line">    <span class="comment">// &lt;to, count&gt;</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; target : tos.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = target.getValue();</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有票的目的地才能继续找</span></span><br><span class="line">        String key = target.getKey();</span><br><span class="line">        <span class="comment">// 选择</span></span><br><span class="line">        res.addLast(key);</span><br><span class="line">        target.setValue(count - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到一个解就返回</span></span><br><span class="line">        <span class="keyword">if</span> (dfs(ticketNum, progress + <span class="number">1</span>, res, map)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        res.removeLast();</span><br><span class="line">        target.setValue(count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37. 解数独"></a><a href="https://leetcode-cn.com/problems/sudoku-solver/">37. 解数独</a></h4><blockquote>
<p>编写一个程序，通过填充空格来解决数独问题。</p>
<p>数独的解法需 遵循如下规则：</p>
<p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）<br>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p>
</blockquote>
<p>这题的难点是双层for循环，以及何时返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = board.length;</span><br><span class="line"></span><br><span class="line">    dfs(board, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; n; row++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[row][col] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 字符</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">&#x27;1&#x27;</span>; c &lt;= <span class="string">&#x27;9&#x27;</span>; c++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isValid(board, row, col, c, n)) &#123; <span class="comment">// (row, col) 这个位置放k是否合适</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                board[row][col] = c;</span><br><span class="line">                <span class="keyword">if</span> (dfs(board, n)) &#123; <span class="comment">// 如果找到合适一组立刻返回，这里的返回不一定是最终的返回，因为可能是此轮中的正确解。</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                board[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 9个数都试完了，都不行，那么就返回false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 遍历完没有返回false，说明找到了合适棋盘位置了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同行是否重复</span></span><br><span class="line"><span class="comment">//同列是否重复</span></span><br><span class="line"><span class="comment">//9宫格里是否重复</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">char</span> c, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1、判断行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[row][i] == c) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2、判断列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[j][col] == c) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、判断同9宫格</span></span><br><span class="line">    <span class="keyword">int</span> beginX = getBeginIndex(row);</span><br><span class="line">    <span class="keyword">int</span> endX = getEndIndex(row);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> beginY = getBeginIndex(col);</span><br><span class="line">    <span class="keyword">int</span> endY = getEndIndex(col);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = beginX; i &lt; endX; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = beginY; j &lt; endY; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == row || j == col) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == c) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getBeginIndex</span><span class="params">(<span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> beginX;</span><br><span class="line">    <span class="keyword">if</span> (row &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        beginX = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (row &lt; <span class="number">6</span>) &#123;</span><br><span class="line">        beginX = <span class="number">3</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        beginX = <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beginX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getEndIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> end;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        end = <span class="number">3</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; <span class="number">6</span>) &#123;</span><br><span class="line">        end = <span class="number">6</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        end = <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p><strong>关于回溯算法的复杂度分析在网上的资料鱼龙混杂，一些所谓的经典面试书籍不讲回溯算法，算法书籍对这块也避而不谈，感觉就像是算法里模糊的边界</strong>。</p>
<p><strong>所以这块就说一说我个人理解，对内容持开放态度，集思广益，欢迎大家来讨论！</strong></p>
<p>以下在计算空间复杂度的时候我都把系统栈（不是数据结构里的栈）所占空间算进去。</p>
<p>子集问题分析：</p>
<ul>
<li>时间复杂度：O(n * 2^n)，因为每一个元素的状态无外乎取与不取，所以时间复杂度为O(2^n)，构造每一组子集都需要填进数组，又有需要O(n)，最终时间复杂度：O(n * 2^n)</li>
<li>空间复杂度：O(n)，递归深度为n，所以系统栈所用空间为O(n)，每一层递归所用的空间都是常数级别，注意代码里的result和path都是全局变量，就算是放在参数里，传的也是引用，并不会新申请内存空间，最终空间复杂度为O(n)</li>
</ul>
<p>排列问题分析：</p>
<ul>
<li>时间复杂度：O(n!)，这个可以从排列的树形图中很明显发现，每一层节点为n，第二层每一个分支都延伸了n-1个分支，再往下又是n-2个分支，所以一直到叶子节点一共就是 n * n-1 * n-2 * ….. 1 = n!。</li>
<li>空间复杂度：O(n)，和子集问题同理。</li>
</ul>
<p>组合问题分析：</p>
<ul>
<li>时间复杂度：O(n * 2^n)，组合问题其实就是一种子集的问题，所以组合问题最坏的情况，也不会超过子集问题的时间复杂度。</li>
<li>空间复杂度：O(n)，和子集问题同理。</li>
</ul>
<p>N皇后问题分析：</p>
<ul>
<li>时间复杂度：O(n!) ，其实如果看树形图的话，直觉上是O(n^n)，但皇后之间不能见面所以在搜索的过程中是有剪枝的，最差也就是O（n!），n!表示n * (n-1) * …. * 1。</li>
<li>空间复杂度：O(n)，和子集问题同理。</li>
</ul>
<p>解数独问题分析：</p>
<ul>
<li>时间复杂度：O(9^m) , m是’.’的数目。</li>
<li>空间复杂度：O(n^2)，递归的深度是n^2</li>
</ul>
<p><strong>一般说道回溯算法的复杂度，都说是指数级别的时间复杂度，这也算是一个概括吧！</strong></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>回溯主要解决的穷举问题，使用递归和回溯的方法找出所有的case。</p>
<p>回溯的过程可以抽象为一个N叉树的遍历过程，横向维度的for循环过程，表示这一层可能出现的所有情况；纵向递归就是搜集所有出现结果的过程。</p>
<p>如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，<strong>「那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！」</strong>所有遍历的<strong>集合都是有意义的解</strong>。</p>
<p>问题的难点：</p>
<ul>
<li><p>递归的参数？</p>
<p>startIndex（组合 + 子集），used（全排列），path</p>
</li>
<li><p>如何收集节点 + 剪枝？</p>
<p>size（k个数组合），target（组合综合），去重（used）</p>
</li>
<li><p>什么时候返回？</p>
<p>实际上回溯的问题，即使没有return，也不会导致死循环，穷举完毕后自然就会退出。但是为了收集需要的结果，并且让循环更快的退出，会设定退出条件。</p>
</li>
</ul>
<p><a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93.md">回溯总结</a></p>
]]></content>
      <categories>
        <category>Alg</category>
      </categories>
  </entry>
  <entry>
    <title>ALG_06_贪心算法</title>
    <url>/2021/05/14/Notes/Algorithm/ALG_06_%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="ALG-06-贪心算法"><a href="#ALG-06-贪心算法" class="headerlink" title="ALG_06_贪心算法"></a>ALG_06_贪心算法</h1><span id="more"></span>

<p><strong>贪心的本质是选择每一阶段的局部最优，从而达到全局最优。</strong></p>
<h2 id="贪心一般解题步骤"><a href="#贪心一般解题步骤" class="headerlink" title="贪心一般解题步骤"></a>贪心一般解题步骤</h2><p>贪心算法一般分为如下四步：</p>
<ul>
<li>将问题分解为若干个子问题</li>
<li>找出适合的贪心策略</li>
<li>求解每一个子问题的最优解</li>
<li>将局部最优解堆叠成全局最优解</li>
</ul>
<h3 id="lesson1"><a href="#lesson1" class="headerlink" title="lesson1"></a>lesson1</h3><h4 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455. 分发饼干"></a><a href="https://leetcode-cn.com/problems/assign-cookies/">455. 分发饼干</a></h4><blockquote>
<p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p>
<p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
</blockquote>
<p>解法1：<strong>局部最优：大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优：喂饱尽可能多的小孩</strong>。</p>
<p>解法2：<strong>因为用小饼干优先喂饱小胃口的 这样可以尽量保证最后省下来的是大饼干（虽然题目没有这个要求）！</strong></p>
<p>思路：先从小到大排列2个数组，</p>
<p>​           从g 的高位开始倒叙遍历，当s[j] &gt;= g[i] 认为满足条件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="keyword">int</span>[] g, <span class="keyword">int</span>[] s)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="comment">// 大胃口吃到大饼干</span></span><br><span class="line">        <span class="keyword">int</span> gSize = g.length; <span class="comment">// 胃口</span></span><br><span class="line">        <span class="keyword">int</span> sSize = s.length; <span class="comment">// 饼干</span></span><br><span class="line">        <span class="keyword">int</span> index = sSize - <span class="number">1</span>; <span class="comment">// 饼干倒叙</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gSize - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; s[index] &gt;= g[i]) &#123; <span class="comment">// 满足的情况下，找前一个饼干</span></span><br><span class="line">                index--;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用小饼干喂饱小胃口</span></span><br><span class="line"><span class="comment">//        int count = 0;</span></span><br><span class="line"><span class="comment">//        for (int i = 0; i &lt; sSize; i++) &#123;</span></span><br><span class="line"><span class="comment">//            if (count &lt; gSize &amp;&amp; s[i] &gt;= g[count]) &#123; // 满足的情况下找下一个胃口</span></span><br><span class="line"><span class="comment">//                count ++;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        return count;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="376-摆动序列"><a href="#376-摆动序列" class="headerlink" title="376. 摆动序列"></a><a href="https://leetcode-cn.com/problems/wiggle-subsequence/">376. 摆动序列</a></h4><blockquote>
<p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p>
<p>例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。</p>
<p>相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。<br>子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p>
<p>给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。</p>
</blockquote>
<p>核心思想是找到拐点</p>
<p><strong>局部最优</strong>：让序列有尽可能多的局部峰值。</p>
<p><strong>整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> curDiff = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> preDiff = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> size = nums.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// i 从 1开始</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>; <span class="comment">// 默认左边有一个峰值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">        curDiff = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//峰值转峰谷 +  峰谷转峰值</span></span><br><span class="line">        <span class="keyword">if</span> (preDiff &gt;= <span class="number">0</span> &amp;&amp; curDiff &lt; <span class="number">0</span> || preDiff &lt;= <span class="number">0</span> &amp;&amp; curDiff &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            res++;</span><br><span class="line">			<span class="comment">//System.out.println(nums[i]);</span></span><br><span class="line">            preDiff = curDiff;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子序和</a></h4><blockquote>
<p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = nums.length;</span><br><span class="line">    <span class="keyword">int</span> result = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        count += nums[i];</span><br><span class="line">        <span class="keyword">if</span> (count &gt; result) &#123;</span><br><span class="line">            result = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123; <span class="comment">//相当于重置最大子序起始位置，因为遇到负数一定是拉低总和</span></span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="lesson2"><a href="#lesson2" class="headerlink" title="lesson2"></a>lesson2</h3><h4 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h4><blockquote>
<p>给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
</blockquote>
<p>这道题目可能我们只会想，选一个低的买入，在选个高的卖，在选一个低的买入…..循环反复。</p>
<p><strong>如果想到其实最终利润是可以分解的，那么本题就很容易了！</strong></p>
<p>如果分解呢？</p>
<p>假如第0天买入，第3天卖出，那么利润为：prices[3] - prices[0]。</p>
<p>相当于(prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])。</p>
<p><strong>此时就是把利润分解为每天为单位的维度，而不是从0天到第3天整体去考虑！</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt; n ;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> profit = prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (profit &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += profit;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a href="https://leetcode-cn.com/problems/jump-game/">55. 跳跃游戏</a></h4><blockquote>
<p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个下标。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span> cover = nums[<span class="number">0</span>] + <span class="number">0</span>; <span class="comment">// 先走第一步</span></span><br><span class="line">    <span class="keyword">if</span> (cover &gt;= n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意区间是闭区间 []</span></span><br><span class="line">    <span class="comment">// 在覆盖范围进行寻找是否覆盖到尾部，</span></span><br><span class="line">    <span class="comment">// 范围是通过索引进行判断的，所以上限是n-1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cover; i++) &#123;</span><br><span class="line">        cover = Math.max(nums[i] + i, cover);</span><br><span class="line">        <span class="keyword">if</span> (cover &gt;= n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    int cover = 0;</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt;= cover; i++) &#123;</span></span><br><span class="line"><span class="comment">        cover = Math.max(nums[i] + i, cover);</span></span><br><span class="line"><span class="comment">        if (cover &gt;= n - 1) &#123;</span></span><br><span class="line"><span class="comment">            return true;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return false;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a><a href="https://leetcode-cn.com/problems/jump-game-ii/">45. 跳跃游戏 II</a></h4><blockquote>
<p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
<p>假设你总是可以到达数组的最后一个位置。</p>
</blockquote>
<p>局部最优：当前可移动距离尽可能多走，如果还没到终点，步数再加一。</p>
<p>整体最优：一步尽可能多走，从而达到最小步数。</p>
<p>尽量多走，走到头后，在当前范围内找到下一次可移动的最大距离是不是到结尾了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> curDistance = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> nextDistance = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        nextDistance = Math.max(nums[i] + i, nextDistance);  <span class="comment">// 更新下一步能覆盖最远距离下标</span></span><br><span class="line">        <span class="keyword">if</span> (i == curDistance) &#123;<span class="comment">// 遇到当前覆盖最远距离下标</span></span><br><span class="line">            <span class="comment">//if (curDistance != n - 1) &#123; // 用于判断第一步的情况，貌似这个条件是多余的</span></span><br><span class="line">            ans++;                       <span class="comment">// 需要走下一步，</span></span><br><span class="line">            curDistance = nextDistance;  <span class="comment">// 更新当前覆盖最远距离下标（相当于加油了）</span></span><br><span class="line">            <span class="comment">// 下一步的覆盖范围已经可以达到终点，结束循环</span></span><br><span class="line">            <span class="comment">// 这里为什么不是n - i 而是 n-1，因为nexdDistance = nums[i] + i，已经包含了 i。</span></span><br><span class="line">            <span class="comment">/// 当前更好理解覆盖最远距离下标是集合终点，不用做ans++操作了，直接结束          </span></span><br><span class="line">            <span class="keyword">if</span> (curDistance &gt;= n - <span class="number">1</span>) <span class="keyword">break</span>;  </span><br><span class="line">            <span class="comment">//&#125; else break;                  </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1005-K-次取反后最大化的数组和"><a href="#1005-K-次取反后最大化的数组和" class="headerlink" title="1005. K 次取反后最大化的数组和"></a><a href="https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/">1005. K 次取反后最大化的数组和</a></h4><blockquote>
<p>给定一个整数数组 A，我们只能用以下方法修改该数组：我们选择某个索引 i 并将 A[i] 替换为 -A[i]，然后总共重复这个过程 K 次。（我们可以多次选择同一个索引 i。）</p>
<p>以这种方式修改数组后，返回数组可能的最大和。</p>
</blockquote>
<p> 先排序，并把所有的负数变为正数，同时再遍历过程中记录下最小数，再负数变成正数后取反</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestSumAfterKNegations</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(A);</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> n = A.length;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 先排序，并把所有的负数变为正数，同时再遍历过程中记录下最小数，再负数变成正数后取反</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] &lt; <span class="number">0</span> &amp;&amp; K &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            A[i] = -A[i];</span><br><span class="line">            K--;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += A[i];</span><br><span class="line">        min = Math.min(A[i], min);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把所有的负数旋转后，还是大于0，反复旋转最小的正数，判断翻转了奇数还是偶数次，</span></span><br><span class="line">    <span class="keyword">if</span> (K &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 由于不确定min的正负情况，先把min减掉</span></span><br><span class="line">        sum -= min;</span><br><span class="line">        <span class="comment">// 偶数的化相当于没有取反，奇数的化取一次反，k % 2 == 1时</span></span><br><span class="line">        <span class="keyword">if</span> (K % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            min = -min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 确定正负后再加回来</span></span><br><span class="line">        <span class="keyword">return</span> sum + min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="lesson3"><a href="#lesson3" class="headerlink" title="lesson3"></a>lesson3</h3><h4 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134. 加油站"></a><a href="https://leetcode-cn.com/problems/gas-station/">134. 加油站</a></h4><blockquote>
<p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p>
<p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p>
<p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p>
</blockquote>
<p><strong>局部最优：当前累加rest[j]的和curSum一旦小于0，起始位置至少要是i+1，因为从i开始一定不行。</strong></p>
<p><strong>全局最优：找到可以跑一圈的起始位置</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> curSum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n = gas.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n;i++) &#123;</span><br><span class="line">    totalSum += gas[i] - cost[i];</span><br><span class="line">   <span class="comment">// 每个加油站的剩余量rest[i]为gas[i] - cost[i]。</span></span><br><span class="line">    <span class="comment">//i从0开始累加rest[i]，和记为curSum，一旦curSum小于零，</span></span><br><span class="line">    <span class="comment">// 说明[0, i]区间都不能作为起始位置，起始位置从i+1算起，再从0计算curSum。</span></span><br><span class="line">    curSum += gas[i] - cost[i];</span><br><span class="line">    <span class="keyword">if</span> (curSum &lt; <span class="number">0</span>) &#123;   <span class="comment">// 当前累加rest[i]和 curSum一旦小于0</span></span><br><span class="line">        start = i + <span class="number">1</span>;  <span class="comment">// 起始位置更新为i+1</span></span><br><span class="line">        curSum = <span class="number">0</span>;     <span class="comment">// curSum从0开始重新加</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 首先如果总油量减去总消耗大于等于零那么一定可以跑完一圈，否则，不能</span></span><br><span class="line"><span class="keyword">if</span> (totalSum &lt;<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> start;</span><br></pre></td></tr></table></figure>

<h4 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135. 分发糖果"></a><a href="https://leetcode-cn.com/problems/candy/">135. 分发糖果</a></h4><blockquote>
<p>老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p>
<p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p>
<p>每个孩子至少分配到 1 个糖果。<br>评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。<br>那么这样下来，老师至少需要准备多少颗糖果呢？</p>
</blockquote>
<p>这道题目一定是要确定一边之后，再确定另一边，例如比较每一个孩子的左边，然后再比较右边，<strong>如果两边一起考虑一定会顾此失彼</strong>。</p>
<p>先确定右边评分大于左边的情况（也就是从前向后遍历）</p>
<ul>
<li>局部最优：只要右边评分比左边大，右边的孩子就多一个糖果，</li>
<li>全局最优：相邻的孩子中，评分高的右孩子获得比左边孩子更多的糖果</li>
</ul>
<p>再确定左孩子大于右孩子的情况（从后向前遍历）</p>
<ul>
<li>局部最优：保证第i个小孩的糖果数量即大于左边的也大于右边的。<strong>注意虽然此时权值左边大于右边，但若此时糖果数左边&gt;右边了，糖果就不需要 + 1了</strong></li>
<li>全局最优：相邻的孩子中，评分高的孩子获得更多的糖果。</li>
</ul>
<p><strong>所以确定左孩子大于右孩子的情况一定要从后向前遍历！</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="keyword">int</span>[] ratings)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = ratings.length;</span><br><span class="line">    <span class="keyword">int</span>[] candys = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="comment">// 所有的孩子先给一颗糖</span></span><br><span class="line">    Arrays.fill(candys, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 从左向右, ratings[i] &gt; ratings[i - 1]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            candys[i] = candys[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从右向左, ratings[i] &gt; ratings[i + 1]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>]) &#123; <span class="comment">// 左边权值小于右边</span></span><br><span class="line">            <span class="keyword">if</span> (candys[i] &lt;= candys[i + <span class="number">1</span>]) &#123; <span class="comment">// 左边的糖数小于右边</span></span><br><span class="line">                candys[i] = candys[i + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//  candys[i] = Math.max(candys[i], candys[i + 1] + 1);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : candys) &#123;</span><br><span class="line">        count += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406. 根据身高重建队列"></a><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">406. 根据身高重建队列</a></h4><blockquote>
<p>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。</p>
<p>请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</p>
</blockquote>
<p>先基于身高 hi 排序，身高相同，ki排序，最后将节点插入到列表ki的位置。</p>
<p><img src="../pics/image-20210513162821787.png" alt="image-20210513162821787"></p>
<p>排序完的people： [[7,0], [7,1], [6,1], [5,0], [5,2]，[4,4]]</p>
<p>插入的过程： 插入[7,0]：[[7,0]] 插入[7,1]：[[7,0],[7,1]] 插入[6,1]：[[7,0],[6,1],[7,1]] 插入[5,0]：[[5,0],[7,0],[6,1],[7,1]] 插入[5,2]：[[5,0],[7,0],[5,2],[6,1],[7,1]] 插入[4,4]：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] reconstructQueue(<span class="keyword">int</span>[][] people) &#123;</span><br><span class="line">    Arrays.sort(people, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o2[<span class="number">0</span>] - o1[<span class="number">0</span>] == <span class="number">0</span> ? o1[<span class="number">1</span>] - o2[<span class="number">1</span>] : o2[<span class="number">0</span>] - o1[<span class="number">0</span>]; <span class="comment">// 先按身高,身高相同，k 小的排前面</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] item : people) &#123; <span class="comment">// 再按照k的索引插入</span></span><br><span class="line">        res.add(item[<span class="number">1</span>], item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][<span class="number">2</span>]); <span class="comment">// 容器转成数组;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="lesson4"><a href="#lesson4" class="headerlink" title="lesson4"></a>lesson4</h3><h4 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452. 用最少数量的箭引爆气球"></a><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">452. 用最少数量的箭引爆气球</a></h4><blockquote>
<p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p>
<p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p>
<p>给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。</p>
</blockquote>
<p> 解法1: 将区间按照右边界从小到大排，在这个区间内的都可以用一只箭，同时更新右区间，由于右区间是按照从小到大排的，后面的一定大于前面，不需要比较取最大值；</p>
<p>解法2：区间按照左边界从小到大排</p>
<p>核心是重叠时的这个有效区间是要取右边界较小的那个，取交集</p>
<p>超过这个区间就再加一枝箭。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解法1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将区间按照右边界从小到大排</span></span><br><span class="line">    <span class="comment">// 最近新增了Test Case， [[-2147483646,-2147483645],[2147483646,2147483647]] 就过不了了，</span></span><br><span class="line">    <span class="comment">// 这是因为差值过大而产生溢出。sort的时候不要用a-b来比较，要用Integer.compare(a, b)!!!</span></span><br><span class="line">    Arrays.sort(points, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(o1[<span class="number">1</span>], o2[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">int</span> n = points.length;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> end = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (end &lt; points[i][<span class="number">0</span>]) &#123; <span class="comment">// 右边界小于下一个左边界，又需要一支箭</span></span><br><span class="line">            count++;</span><br><span class="line">            end = points[i][<span class="number">1</span>]; <span class="comment">// 更新右区间值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(points, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(o1[<span class="number">0</span>], o2[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">int</span> n = points.length;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> end = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (points[i][<span class="number">0</span>] &gt; end) &#123; <span class="comment">// 右边界小于下一个左边界，又需要一支箭</span></span><br><span class="line">            count++;</span><br><span class="line">            end = points[i][<span class="number">1</span>]; <span class="comment">// 更新新的右边界</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            end = Math.min(points[i][<span class="number">1</span>], end); <span class="comment">// 取2个区间中最小的右区间</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">435. 无重叠区间</a></h4><blockquote>
<p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p>
<p>注意:</p>
<p>可以认为区间的终点总是大于它的起点。<br>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</p>
</blockquote>
<p>和上面的题类似，不过是取反的一个逻辑。题目是找交叉区间，我们的思路是找交叉。我们的做法是找不交叉。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">交叉 = 整体 - 不交叉</span><br></pre></td></tr></table></figure>

<p><strong>按照右边界排序，就要从左向右遍历，因为右边界越小越好，只要右边界越小，留给下一个区间的空间就越大，所以从左向右遍历，优先选右边界小的。</strong></p>
<p><strong>按照左边界排序，就要从右向左遍历，因为左边界数值越大越好（越靠右），这样就给前一个区间的空间就越大，所以可以从右向左遍历。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 按结尾index排序,</span></span><br><span class="line">    Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o1[<span class="number">1</span>] - o2[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">/*== 0 ? o2[0] - o1[0] : o1[1] - o2[1]</span></span><br><span class="line"><span class="comment">            * 左边界不需要考虑</span></span><br><span class="line"><span class="comment">            * */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// [1,2] [2,3] [1,3] [3,4]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = intervals.length;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> end = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &gt; end) &#123; <span class="comment">// 必须要用大于</span></span><br><span class="line">            count++; <span class="comment">// 记录非交叉区间的个数</span></span><br><span class="line">            end = intervals[i][<span class="number">1</span>];   <span class="comment">// 由于是按照结尾排序，所以这里的end</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n - count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode-cn.com/problems/merge-intervals/">56. 合并区间</a></h4><blockquote>
<p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p>
</blockquote>
<p>排序非常有讲究，这道题是按照<code>左区间从小到大排</code>，这样最开始我们就可以确定一个最小区间。然后不断的更新end，直到end小于下一个的start，此时重新搜集start和end。</p>
<p>按照右区间从小到大排是很难做的，排序后的右区间不一定的是最小值，也不一定是最大值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并区间的必须要先固定一个极大值或者极小值</span></span><br><span class="line">    <span class="comment">// 固定极小值后，从低到高搜索</span></span><br><span class="line">    Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o1[<span class="number">0</span>] - o2[<span class="number">0</span>] ; <span class="comment">// 排序很重要</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> n = intervals.length;</span><br><span class="line">    <span class="comment">// start 一定这次搜索范围内最小的</span></span><br><span class="line">    <span class="keyword">int</span> start = intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> end = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &gt; end) &#123; <span class="comment">// 边界不重合时, 当前的左 &gt; 上一个右，</span></span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;start, end&#125;);</span><br><span class="line">            start = intervals[i][<span class="number">0</span>]; <span class="comment">// 更新新边界</span></span><br><span class="line">            end = intervals[i][<span class="number">1</span>]; <span class="comment">// 更新新边界</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            end = Math.max(end, intervals[i][<span class="number">1</span>]); <span class="comment">// 边界重合时，扩大右边界</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ！！！收集最后一次的结果！！！</span></span><br><span class="line">    res.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;start, end&#125;);</span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763. 划分字母区间"></a><a href="https://leetcode-cn.com/problems/partition-labels/">763. 划分字母区间</a></h4><blockquote>
<p>字符串 <code>S</code> 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p>
</blockquote>
<p>难点是理解题意思，这是一道map题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">partitionLabels</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="comment">// 记录字符串中每个字符 出现的最晚位置</span></span><br><span class="line">    <span class="comment">// &lt;c, count&gt;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        arr[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        right = Math.max(right, arr[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]); <span class="comment">// 找到字符出现的最远边界</span></span><br><span class="line">        <span class="keyword">if</span> (i == right) &#123; <span class="comment">// 找到已出现字符的最右边界</span></span><br><span class="line">            res.add(right - left + <span class="number">1</span>);<span class="comment">// 找出的区间是闭区间 []</span></span><br><span class="line">            left = right + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="lesson5"><a href="#lesson5" class="headerlink" title="lesson5"></a>lesson5</h3><h4 id="738-单调递增的数字"><a href="#738-单调递增的数字" class="headerlink" title="738. 单调递增的数字"></a><a href="https://leetcode-cn.com/problems/monotone-increasing-digits/">738. 单调递增的数字</a></h4><blockquote>
<p>给定一个非负整数 N，找出小于或等于 N 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。</p>
<p>（当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;= y 时，我们称这个整数是单调递增的。）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        for (int i = n; i &gt; 0; i--) &#123;</span></span><br><span class="line"><span class="comment">//            if (checkNum(i)) return i;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        return 0;</span></span><br><span class="line">        <span class="keyword">char</span>[] chars = String.valueOf(n).toCharArray();</span><br><span class="line">        <span class="keyword">int</span> size = chars.length;</span><br><span class="line">        <span class="keyword">int</span> from = size; <span class="comment">// 找到变9的位置，而不是直接赋值为9，否则像100这种特殊情况没法处理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">2</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[i] &gt; chars[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                chars[i]--;</span><br><span class="line">                from = i + <span class="number">1</span>; <span class="comment">// 后一位变9，记录的都是索引</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = from; i &lt; size; i++) &#123;</span><br><span class="line">            chars[i] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(<span class="keyword">new</span> String(chars));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714. 买卖股票的最佳时机含手续费"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. 买卖股票的最佳时机含手续费</a></h4><blockquote>
<p>给定一个整数数组 <code>prices</code>，其中第 <code>i</code> 个元素代表了第 <code>i</code> 天的股票价格 ；非负整数 <code>fee</code> 代表了交易股票的手续费用。</p>
<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>
<p>返回获得利润的最大值。</p>
<p><strong>注意：</strong>这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p>
</blockquote>
<p>这适合用动态规划来解</p>
<h4 id="968-监控二叉树"><a href="#968-监控二叉树" class="headerlink" title="968. 监控二叉树"></a><a href="https://leetcode-cn.com/problems/binary-tree-cameras/">968. 监控二叉树</a></h4><blockquote>
<p>给定一个二叉树，我们在树的节点上安装摄像头。</p>
<p>节点上的每个摄影头都可以监视<strong>其父对象、自身及其直接子对象。</strong></p>
<p>计算监控树的所有节点所需的最小摄像头数量。</p>
</blockquote>
<p>二叉树的遍历 + 递归的思路，对每一个父节点来说，要确定他是否加摄像头，要考虑左右子节点的情况，每个子节点都有3种状态，2个子节点共有 9种状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCameraCover</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 情况4</span></span><br><span class="line">    <span class="keyword">if</span> (dfs(root) == <span class="number">0</span>) &#123; <span class="comment">// root 无覆盖</span></span><br><span class="line">        result++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0 -&gt; 不可以监视 1-&gt;有摄像头 2-&gt;能监视到</span></span><br><span class="line"><span class="comment">// 父节点有9中情况要考虑</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="comment">// 空节点认为是可覆盖</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = dfs(root.left); <span class="comment">// 左</span></span><br><span class="line">    <span class="keyword">int</span> right = dfs(root.right);<span class="comment">// 右</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 情况1</span></span><br><span class="line">    <span class="comment">// 左右节点都有覆盖</span></span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">2</span> &amp;&amp; right == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 情况2</span></span><br><span class="line">    <span class="comment">// left == 0 &amp;&amp; right == 0 左右节点无覆盖</span></span><br><span class="line">    <span class="comment">// left == 1 &amp;&amp; right == 0 左节点有摄像头，右节点无覆盖</span></span><br><span class="line">    <span class="comment">// left == 0 &amp;&amp; right == 1 左节点有无覆盖，右节点摄像头</span></span><br><span class="line">    <span class="comment">// left == 0 &amp;&amp; right == 2 左节点无覆盖，右节点覆盖</span></span><br><span class="line">    <span class="comment">// left == 2 &amp;&amp; right == 0 左节点覆盖，右节点无覆盖</span></span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">0</span> || right == <span class="number">0</span>) &#123;</span><br><span class="line">        result++;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 情况3</span></span><br><span class="line">    <span class="comment">// left == 1 &amp;&amp; right == 2 左节点有摄像头，右节点有覆盖</span></span><br><span class="line">    <span class="comment">// left == 2 &amp;&amp; right == 1 左节点有覆盖，右节点有摄像头</span></span><br><span class="line">    <span class="comment">// left == 1 &amp;&amp; right == 1 左右节点都有摄像头</span></span><br><span class="line">    <span class="comment">// 其他情况前段代码均已覆盖</span></span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">1</span> || right == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以上代码我没有使用else，主要是为了把各个分支条件展现出来，这样代码有助于读者理解</span></span><br><span class="line">    <span class="comment">// 这个 return -1 逻辑不会走到这里。</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Alg</category>
      </categories>
  </entry>
  <entry>
    <title>ALG_07_动态规划</title>
    <url>/2021/05/21/Notes/Algorithm/ALG_07_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h1 id="ALG-07-动态规划"><a href="#ALG-07-动态规划" class="headerlink" title="ALG_07_动态规划"></a>ALG_07_动态规划</h1><span id="more"></span>

<h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><h3 id="解题套路"><a href="#解题套路" class="headerlink" title="解题套路"></a>解题套路</h3><p><img src="/pics/image-20210514105825201.png" alt="image-20210514105825201"></p>
<h3 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h3><p><strong>对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！</strong></p>
<ol>
<li>第一步要明确两点，「状态」和「选择。</li>
<li>第二步要明确<code>dp</code>数组的定义。</li>
<li><strong>第三步，根据「选择」，思考状态转移的逻辑</strong>。</li>
<li><strong>最后一步，把伪码翻译成代码，处理一些边界情况</strong>。</li>
<li>确定遍历顺序 + 举例推导dp数组</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">basecase :</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> in 状态<span class="number">1</span>的所有取值：</span><br><span class="line">  <span class="keyword">for</span> 状态<span class="number">2</span> in 状态<span class="number">2</span>的所有取值：</span><br><span class="line">     <span class="keyword">for</span> ...</span><br><span class="line">      dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 择优(选择<span class="number">1</span>，选择<span class="number">2.</span>..)</span><br><span class="line"></span><br><span class="line">dp数组中状态是索引，递归函数中状态是参数</span><br></pre></td></tr></table></figure>

<h2 id="题目归纳"><a href="#题目归纳" class="headerlink" title="题目归纳"></a>题目归纳</h2><p><img src="/pics/image-20210521223707519.png" alt="image-20210521223707519"></p>
<p><img src="/pics/image-20210521223906491.png" alt="image-20210521223906491"></p>
<h4 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a><a href="https://leetcode-cn.com/problems/fibonacci-number/">509. 斐波那契数</a></h4><blockquote>
<p>斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>
<p>F(0) = 0，F(1) = 1<br>F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1<br>给你 n ，请计算 F(n) 。</p>
</blockquote>
<p><code>dp[i] = dp[i - 1] + dp[i - 2]</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第i个数的斐波那契数值是dp[i], n的值是 dp[n],所有数组大小是n + 1</span></span><br><span class="line">    <span class="comment">// 递推公式已经确定 dp[i] = dp[i - 1] + dp[i - 2]</span></span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)&#123; </span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="路径问题"><a href="#路径问题" class="headerlink" title="路径问题"></a>路径问题</h2><h4 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a href="https://leetcode-cn.com/problems/unique-paths/">62. 不同路径</a></h4><blockquote>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
</blockquote>
<p><code>dp[i][j] ：表示从（0 ，0）出发，到(i, j) 有dp[i][j]条不同的路径。</code></p>
<p><code>dp[i][j] = dp[i - 1][j] + dp[j - 1][i];</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m ; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[j - <span class="number">1</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a><a href="https://leetcode-cn.com/problems/unique-paths-ii/">63. 不同路径 II</a></h4><blockquote>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p>
</blockquote>
<p><code>dp[i][j] ：表示从（0 ，0）出发，到(i, j) 有dp[i][j]条不同的路径。</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (obstacleGrid[i][j] == 0) &#123; // 当(i, j)没有障碍的时候，再推导dp[i][j]</span><br><span class="line">    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = obstacleGrid.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span>; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n &amp;&amp; obstacleGrid[j][<span class="number">0</span>] == <span class="number">0</span>; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) &#123; <span class="comment">// 障碍的地方置为0</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[j - <span class="number">1</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><blockquote>
<p>给你一个可装载重量为 <code>W</code> 的背包和 <code>N</code> 个物品，每个物品有重量和价值两个属性。其中第 <code>i</code> 个物品的重量为 <code>wt[i]</code>，价值为 <code>val[i]</code>，现在让你用这个背包装物品，最多能装的价值是多少？</p>
</blockquote>
<p><code>dp[i][j]</code>定义：容量为j的情况大小情况，<strong>对于前<code>i</code>个物品，当前背包的容量为<code>w</code>，这种情况下可以装的最大价值是<code>dp[i][j]</code>。</strong></p>
<p>**根据这个定义，我们想求的最终答案就是<code>dp[N][W]</code>。base case 就是<code>dp[0][..] = dp[..][0] = 0</code>**，因为没有物品或者背包没有空间的时候，能装的最大价值就是 0。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[N+<span class="number">1</span>][amount+<span class="number">1</span>]</span><br><span class="line">dp[<span class="number">0</span>][..] = <span class="number">0</span></span><br><span class="line">dp[..][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i in [<span class="number">1.</span>.N]:</span><br><span class="line">    <span class="keyword">for</span> j in [<span class="number">1.</span>.amount]:</span><br><span class="line">        把物品 i 装进背包,</span><br><span class="line">        不把物品 i 装进背包</span><br><span class="line"><span class="keyword">return</span> dp[N][amount]</span><br></pre></td></tr></table></figure>

<p>确定状态转移方程，在装第i个物品时，有2种选择：</p>
<ul>
<li>不放，如果放入背包中，那么背包中物品的最大价值就是 <code>dp[i - 1][j]</code></li>
<li>放入背包，对于前 <code>i - 1</code>个物品，价值是 <code>dp[i - 1][w - weight[i]] + val[i]</code> </li>
</ul>
<p>那么物品的最大价值就是：<code>dp[i][j] = Max(dp[i - 1][j], dp[i - 1][w - weight[i]] + val[i])</code></p>
<p>通常由于物品是从1开始的，所以 第i个物品的重量是 <code>weight[i - 1]]</code>价值是 <code>val[i - 1]</code>，所以最终的递推公式是： <strong><code>dp[i][j] = Max(dp[i - 1][j], dp[i - 1][j - weight[i - 1]] + val[i - 1])</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">backpack</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> w, <span class="keyword">int</span>[] val, <span class="keyword">int</span>[] weight)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dp[i][w] , 重量为w的i件物品的最大价值</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][w + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i][j] = Math.max(dp[i - 1, j], dp[i - 1] [w - weight[i] + value[i]])</span></span><br><span class="line">        <span class="comment">// 数组的索引从0开始，遍历从1开始，所以，递推公式中，所有的 取数组元素的i</span></span><br><span class="line">        <span class="comment">// weight[i] 以及  value[i], 都要减1，相当于 数组向前移动一位</span></span><br><span class="line">        <span class="comment">// dp[i][j] = Math.max(dp[i - 1, j], dp[i - 1] [w - weight[i - i] + value[i - 1]])</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关于二维数组的长度说明</span></span><br><span class="line">        <span class="comment">// w 必须选是数组宽度 而且w &gt;= weight[] 中的任意一个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= weight.length; i++) &#123; <span class="comment">// !!! 容易犯错的地方 &lt;=w.length</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= w; j++) &#123; <span class="comment">// !!! 容易犯错的地方 2, j&lt;=w</span></span><br><span class="line">                <span class="keyword">if</span> (j - weight[i - <span class="number">1</span>] &lt; <span class="number">0</span>) &#123; <span class="comment">// 容量不够时，不能  </span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j]; <span class="comment">// 注意小于 0 时， dp[i][j]=dp[I -1][J]</span></span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(</span><br><span class="line">                            dp[i - <span class="number">1</span>][j], <span class="comment">//</span></span><br><span class="line">                            val[i - <span class="number">1</span>] + dp[i - <span class="number">1</span>][w - weight[i - <span class="number">1</span>]]<span class="comment">// 在装第i个物品的前提下，背包能装的最大价值是多少</span></span><br><span class="line">                    );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// DpUtils.dump(dp);</span></span><br><span class="line">        <span class="keyword">return</span> dp[n][w];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p> 此题先遍历背包，在遍历物品也是可以的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= w; j++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= weight.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j - weight[i - <span class="number">1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][j] = Math.max(</span><br><span class="line">                    dp[i - <span class="number">1</span>][j],</span><br><span class="line">                    val[i - <span class="number">1</span>] + dp[i - <span class="number">1</span>][w - weight[i - <span class="number">1</span>]]</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="滚动数组"><a href="#滚动数组" class="headerlink" title="滚动数组"></a>滚动数组</h4><p>以上的解法我们用的是一个二维数组：</p>
<p> <code>dp[i][j] = Max(dp[i - 1][j], dp[i - 1][j - weight[i - 1]] + val[i - 1])</code>，仔细分析状态转移方程的话，其实我们的状态  <code>dp[i][j]</code> 只与 <code>dp[i - 1] xxx</code>   相关，<code>dp[i - 1]</code>也就是dp 数组的上一个状态。</p>
<p>如果把 <code>i</code> 去掉，只保留 <code>j</code>。那么<code>dp[j]</code> 可以定义为 容量为 <code>j</code> 的背包的最大值。一维的数组状态转移方程是：</p>
<p><strong><code>dp[j] = Max(dp[j], [j - weight[i - 1]] + val[i - 1]) (j[w - &gt;0],逆序)</code></strong> </p>
<p>此时的dp 也称为<strong>滚动数组</strong>。也就是说在不考虑物品搜索范围的情况下，物品的最大价值就是<code>dp[j]</code></p>
<p>对应的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不同容量的背包，放入第一个物品时的价值</span></span><br><span class="line"><span class="comment">// i = 1 , weigh[0] = 1,</span></span><br><span class="line"><span class="comment">// j = 4,  dp[3] = Max(dp[4], dp[4 - 1] + value [0]) = 15</span></span><br><span class="line"><span class="comment">// j = 3,  dp[3] = Max(dp[3], dp[3 - 1] + value [0]) = 15</span></span><br><span class="line"><span class="comment">// j = 2,  dp[2] = Max(dp[2], dp[2 - 1] + value [0]) = 15</span></span><br><span class="line"><span class="comment">// j = 1,  dp[1] = Max(dp[1], dp[1 - 1] + value[0]) = 15</span></span><br><span class="line"><span class="keyword">int</span> nums = weight.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = w; j &gt;= weight[i - <span class="number">1</span>]; j--) &#123; <span class="comment">// ！！！注意逆序</span></span><br><span class="line">        dp[j] = Math.max(dp[j], dp[j - weight[i - <span class="number">1</span>]] + value[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//DpUtils.dump(dp);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有2点要特别说明：</p>
<ul>
<li><p><strong>背包容量必须从大到小遍历</strong></p>
<p><code>dp[j]</code> 是根据<code>dp[j - 1]</code>，只有从后向前遍历才是，才是取上次循环的一个状态，用的是旧数据。若从前向后遍历，取的是当次循环的上一个状态，用的是新数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2、正序遍历</span></span><br><span class="line"><span class="comment">//  i = 1 , weigh[0] = 1</span></span><br><span class="line"><span class="comment">//  不同容量的背包，放入第一个物品时的价值，上一轮的dp，导致传销叠加的情况</span></span><br><span class="line"><span class="comment">//  j = 1,  dp[1] = Max(dp[1], dp[1 - 1] + value[0]) = 15</span></span><br><span class="line"><span class="comment">//  j = 2,  dp[2] = Max(dp[2], dp[2 - 1] + value [0]) = 30</span></span><br><span class="line"><span class="comment">//  j = 3,  dp[3] = Max(dp[3], dp[3 - 1] + value [0]) = 45</span></span><br><span class="line"><span class="comment">//  j = 4,  dp[3] = Max(dp[4], dp[4 - 1] + value [0]) = 60</span></span><br><span class="line"><span class="keyword">int</span> nums = weight.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = weight[i - <span class="number">1</span>]; j &lt;= w; j++) &#123;</span><br><span class="line">        dp[j] = Math.max(dp[j], dp[j - weight[i - <span class="number">1</span>]] + value[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    DpUtils.dump(dp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>先遍历物品再遍历背包容量</strong></p>
<p>不可以，因为一维dp的写法，如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3、先遍历背包, dp只有一个赋值</span></span><br><span class="line"><span class="comment">//   j = 4,</span></span><br><span class="line"><span class="comment">//   i = 1,  weight[0] = 1, dp[4] = Max(dp[4], dp[4 - 1] + value[0]) = 15</span></span><br><span class="line"><span class="comment">//   i = 2,  weight[1] = 3, dp[4] = Max(dp[4], dp[4 - 3] + value [1]) = 20</span></span><br><span class="line"><span class="comment">//   i = 3,  weight[2] = 4, dp[4] = Max(dp[4], dp[4 - 4] + value [2]) = 35</span></span><br><span class="line"><span class="comment">//   dp[4] 只有一个值</span></span><br><span class="line"><span class="keyword">int</span> nums = weight.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = w; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= weight[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            dp[j] = Math.max(dp[j], dp[j - weight[i - <span class="number">1</span>]] + value[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// DpUtils.dump(dp);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="子集背包"><a href="#子集背包" class="headerlink" title="子集背包"></a>子集背包</h3><blockquote>
<h4 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集</a></h4><p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
</blockquote>
<p>子集问题是01背包的变体</p>
<p>假设集合的总数是sum，集合中的数字加起来等于 sum/2。</p>
<p><strong>第一步要明确两点，「状态」和「选择」</strong>。</p>
<p>状态就是「数组数字和」「可选择的物品」，选择就是「取」或者「不取」。</p>
<p><strong>第二步要明确 <code>dp</code> 数组的定义</strong>。</p>
<p>按照背包问题的套路，可以给出如下定义：</p>
<p><strong><code>dp[i][j] = x</code> 表示，对于前 <code>i</code> 个物品，当前背包的容量为 <code>j</code> 时，若 <code>x</code> 为 <code>true</code>，则说明可以恰好将背包装满，若 <code>x</code> 为 <code>false</code>，则说明不能恰好将背包装满。</strong></p>
<p>根据这个定义，我们想求的最终答案就是 <code>dp[N][sum/2]</code>，base case 就是 <code>dp[..][0] = true</code> 和 <code>dp[0][..] = false</code>，<strong>因为背包没有空间的时候，就相当于装满了</strong>，而当没有物品可选择的时候，肯定没办法装满背包。</p>
<p><strong>第三步，根据「选择」，思考状态转移的逻辑</strong>。</p>
<p>如果不把 <code>nums[i]</code> 算入子集，<strong>或者说你不把这第 <code>i</code> 个物品装入背包</strong>，那么是否能够恰好装满背包，取决于上一个状态 <code>dp[i-1][j]</code>，继承之前的结果。</p>
<p>如果把 <code>nums[i]</code> 算入子集，<strong>或者说你把这第 <code>i</code> 个物品装入了背包</strong>，那么是否能够恰好装满背包，取决于状态 <code>dp[i-1][j-nums[i-1]]</code>。(<strong>i 从 1开始，索引从0开始</strong>)</p>
<p>换句话说，如果 <code>j - nums[i-1]</code> 的重量可以被恰好装满，那么只要把第 <code>i</code> 个物品装进去，也可恰好装满 <code>j</code> 的重量；否则的话，重量 <code>j</code> 肯定是装不满的。</p>
<p>最终的状态转移方程为： <code>dp[i][j] = dp[i-1] [j] | dp[i-1][j-nums[i-1]]</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = getSum(nums);</span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//dp[i][j] 能不能由 i 构成 j;</span></span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length + <span class="number">1</span>][target + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// !!! j = 0 因为背包没有空间的时候</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dp[i][j]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= target; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j - nums[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] | dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[nums.length][target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一维数组方程： <code>dp[j] = dp[j] | dp[j-nums[i-1]]</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = getSum(nums);</span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// dp[j] dp 能够构成j</span></span><br><span class="line">    <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[target + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// j = 0,任何数都能构成</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// dp[j] == dp[j] | dp[j - num[i]]</span></span><br><span class="line">    <span class="comment">// i = 1, nums[0] =1</span></span><br><span class="line">    <span class="comment">// j = 6, dp[6] | dp[6 - 1] = false</span></span><br><span class="line">    <span class="comment">// j = 5/4/3/2 -&gt; dp[5/4/3/2] = true</span></span><br><span class="line">    <span class="comment">// j = 1 , dp[1] = true</span></span><br><span class="line">    <span class="comment">// 其实背包问题真正的判断是 j - nums[i - 1] 来确定的。</span></span><br><span class="line">    <span class="comment">// i = 2 ...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = target; j &gt;= nums[i - <span class="number">1</span>]; j--) &#123; <span class="comment">// 倒序遍历</span></span><br><span class="line">            dp[j] = dp[j] | dp[j - nums[i - <span class="number">1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//DpUtils.dump(dp);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a><a href="https://leetcode-cn.com/problems/target-sum/">494. 目标和</a></h4><blockquote>
<p>给你一个整数数组 nums 和一个整数 target 。</p>
<p>向数组中的每个整数前添加 ‘+’ 或 ‘-‘ ，然后串联起所有整数，可以构造一个 表达式 ：</p>
<p>例如，nums = [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-‘ ，然后串联起来得到表达式 “+2-1” 。<br>返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目</p>
</blockquote>
<p>其实，这个问题可以转化为一个子集划分问题，而子集划分问题又是一个典型的背包问题。</p>
<p>首先，如果我们把 <code>nums</code> 划分成两个子集 <code>A</code> 和 <code>B</code>，分别代表分配 <code>+</code> 的数和分配 <code>-</code> 的数，那么他们和 <code>target</code> 存在如下关系：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sum(A) - sum(B) = <span class="function">target</span></span><br><span class="line"><span class="function"><span class="title">sum</span><span class="params">(A)</span> </span>= target + sum(B)</span><br><span class="line">sum(A) + sum(A) = target + sum(B) + sum(A)</span><br><span class="line"><span class="number">2</span> * sum(A) = target + sum(nums)</span><br></pre></td></tr></table></figure>

<p>综上，可以推出 <code>sum(A) = (target + sum(nums)) / 2</code>，也就是把原问题转化成：**<code>nums</code> 中存在几个子集 <code>A</code>，使得 <code>A</code> 中元素的和为 <code>(target + sum(nums)) / 2</code>**</p>
<p><strong>第一步要明确两点，「状态」和「选择」</strong>。</p>
<p>状态就是「数组之和」，选择就是「取或不取」这个数</p>
<p><strong>第二步要明确 <code>dp</code> 数组的定义</strong>。</p>
<p><code>dp[i][j]定义</code>：使用前 i 个数构成j有 <code>dp[i][j]</code>种方式。</p>
<p>basecase：<code>dp[0][j]= 0</code> ，使用前0个数不能构成任意一个j，<code>dp[i][0]=1</code>使用前i个数构成0，因为如果背包的最大载重为 0，「什么都不装」就是唯一的一种装法。</p>
<p><strong>第三步，根据「选择」，思考状态转移的逻辑</strong>。</p>
<p>如果不把 <code>nums[i]</code> 算入子集，<strong>或者说你不把这第 <code>i</code> 个物品装入背包</strong>，那么是否能够恰好装满背包的组合数，取决于上一个状态 <code>dp[i-1][j]</code>。</p>
<p>如果把 <code>nums[i]</code> 算入子集，<strong>或者说你把这第 <code>i</code> 个物品装入了背包</strong>，那么是否能够恰好装满背包，取决于状态 <code>dp[i-1][j-nums[i-1]]</code>。(<strong>i 从 1开始，索引从0开始</strong>)</p>
<p><strong>由于 <code>dp[i][j]</code> 为装满背包的总方法数，所以应该以上两种选择的结果求和，得到状态转移方程</strong>：</p>
<p>最终的状态转移方程为： <code>dp[i][j] = dp[i-1] [j] + dp[i-1][j-nums[i-1]]</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = getSum(nums);</span><br><span class="line">    <span class="keyword">if</span> (sum &lt; target || (sum + target) % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    target = (sum + target) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][target + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= target; j++) &#123; <span class="comment">// 注意遍历范围是[nums[i-1], (sum + target)/2]</span></span><br><span class="line">            <span class="keyword">if</span> (j - nums[i - <span class="number">1</span>] &lt; <span class="number">0</span>) &#123; </span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">// 索引是j dp[j]</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// DpUtils.dump(dp);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一维数组方程： <code>dp[j] = dp[j] | dp[j-nums[i-1]]</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays2</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = getSum(nums);</span><br><span class="line">    <span class="keyword">if</span> (sum &lt; target || (sum + target) % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    target = (sum + target) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line"> 		dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = target; j &gt;= nums[i - <span class="number">1</span>]; j--) &#123; <span class="comment">// ！！！ 必须要倒序遍历 ！！！</span></span><br><span class="line">            dp[j] = dp[j] + dp[j - nums[i - <span class="number">1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><blockquote>
<p>有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品都有无限个（也就是可以放入背包多次）</strong>，求解将哪些物品装入背包里物品价值总和最大。</p>
</blockquote>
<p><strong>完全背包和01背包问题唯一不同的地方就是，每种物品有无限件</strong>。</p>
<p>我们可以考虑将问题转变为01背包来求解，对于第i件物品，我们把它拆解为W/w[i]个相同的物品这样就是01背包了，因为0&lt;=k&lt;=W/w[i]等于(0&lt;= k&lt;=1)*W/w[i]，基于01背包推导状态转移方程为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> nums = weight.length;</span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[w + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = w; j &gt;= weight[i - <span class="number">1</span>]; j--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= j / weight[i - <span class="number">1</span>]; k++) &#123; <span class="comment">// 某个物品可以重复k次</span></span><br><span class="line">            dp[j] = Math.max(dp[j], dp[j - k * weight[i - <span class="number">1</span>]] + k * val[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//DpUtils.dump(dp);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化后台递推公式为：</p>
<p><strong><code>dp[i][j] = Max(dp[i-1][j], dp[i][j - weight[i-1]] + val[i-1])</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">backpackAll2</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> w, <span class="keyword">int</span>[] val, <span class="keyword">int</span>[] weight)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[weight.length + <span class="number">1</span>][w + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= w; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= weight.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j - weight[i - <span class="number">1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] =</span><br><span class="line">                        <span class="comment">//dp[i][j - weight[i - 1]]</span></span><br><span class="line">                        Math.max(dp[i - <span class="number">1</span>][j],</span><br><span class="line">                        dp[i][j - weight[i - <span class="number">1</span>]] + val[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// DpUtils.dump(dp);</span></span><br><span class="line">    <span class="keyword">return</span> dp[n][w];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一维数组：</p>
<p><strong><code>dp[j] = Max(dp[j], [j - weight[i - 1]] + val[i - 1]) (j[w - &gt;0], 正序)</code></strong> </p>
<p>最终代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">backpackAll3</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> w, <span class="keyword">int</span>[] val, <span class="keyword">int</span>[] weight)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[w + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> nums = weight.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums; i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = weight[i - <span class="number">1</span>]; j &lt;=w; j++) &#123; <span class="comment">// 正序遍历重量</span></span><br><span class="line">            dp[j] = Math.max(dp[j], dp[j - weight[i - <span class="number">1</span>]] + val[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// DpUtils.dump(dp);</span></span><br><span class="line">    <span class="keyword">return</span> dp[w];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>遍历物品在外层循环，遍历背包容量在内层循环？</strong></p>
<p>在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序同样无所谓！因为<code>dp[j]</code> 是根据下标<code>j</code>之前所对应的<code>dp[j]</code>计算出来的。 只要保证下标j之前的dp[j]都是经过计算的就可以了。</p>
<p><strong>遍历顺序</strong></p>
<ul>
<li><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</li>
<li><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</li>
</ul>
<p>比较下 01背包和完全背包。</p>
<p><img src="/pics/image-20210518102258489.png" alt="image-20210518102258489"></p>
<h3 id="组合背包"><a href="#组合背包" class="headerlink" title="组合背包"></a>组合背包</h3><blockquote>
<h4 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518. 零钱兑换 II"></a><a href="https://leetcode-cn.com/problems/coin-change-2/">518. 零钱兑换 II</a></h4><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 </p>
</blockquote>
<p><strong>完全背包的变体 求组合数的背包问题</strong></p>
<p><strong><code>dp[i][j]</code> 定义</strong>：只使用 <code>coins</code> 中的前 <code>i</code> 个硬币的面值，若想凑出金额 <code>j</code>，有 <code>dp[i][j]</code> 种凑法。</p>
<p>经过以上的定义，可以得到base case 为 <code>dp[0][..] = 0， dp[..][0] = 1</code>（有点勉强！！！）。</p>
<p>因为如果不使用任何硬币面值，就无法凑出任何金额；如果凑出的目标金额为 0，那么“无为而治”就是唯一的一种凑法。</p>
<p><strong>状态转移的逻辑</strong></p>
<ul>
<li><p><strong>如果你不把这第 <code>i</code> 个物品装入背包</strong>，也就是说你不使用 <code>coins[i]</code> 这个面值的硬币，那么凑出面额 <code>j</code> 的方法数 <code>dp[i][j]</code> 应该等于 <code>dp[i-1][j]</code>，继承之前的结果。</p>
</li>
<li><p><strong>如果你把这第 <code>i</code> 个物品装入了背包</strong>，也就是说你使用 <code>coins[i]</code> 这个面值的硬币，那么 <code>dp[i][j]</code> 应该等于 <code>dp[i][j-coins[i-1]]</code>。</p>
<p>首先由于 <code>i</code> 是从 1 开始的，所以 <code>coins</code> 的索引是 <code>i-1</code> 时表示第 <code>i</code> 个硬币的面值。</p>
<p><code>dp[i][j-coins[i-1]]</code> 也不难理解，<strong>如果你决定使用这个面值的硬币，那么就应该关注如何凑出金额</strong> <code>j - coins[i-1]</code>。比如说，你想用面值为 2 的硬币凑出金额 5，那么如果你知道了凑出金额 3 的方法，再加上一枚面额为 2 的硬币，不就可以凑出 5 了嘛。</p>
</li>
</ul>
<p><strong>综上就是两种选择，而我们想求的 <code>dp[i][j]</code> 是「共有多少种凑法」，所以 <code>dp[i][j]</code> 的值应该是以上两种选择的结果之和</strong></p>
<p>二维数组状态转移方程：**<code>dp[i][j] = dp[i-1][j] + dp[i][j - coins[i-1]]</code>**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = coins.length;</span><br><span class="line">    <span class="comment">// dp 凑成 j 的 前i个数的组合数目</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][amount + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= amount; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; coins[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 注意 ， 这里是dp[i] dp[i][j - coins[i - 1]</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - coins[i - <span class="number">1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//   DpUtils.dump(dp);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一维数组的状态转移方程：</p>
<p><strong><code>dp[j] = dp[j] + dp[j - value[i]]</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change2</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = coins.length;</span><br><span class="line">    <span class="comment">// dp[j] 的组合</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 从dp[i]的含义上来讲就是，凑成总金额0的货币组合数为1。</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = coins[i - <span class="number">1</span>]; j &lt;= amount; j++) &#123; <span class="comment">// ！！！必须是正序遍历 ！！！</span></span><br><span class="line">            dp[j] = dp[j] + dp[j - coins[i - <span class="number">1</span>]];</span><br><span class="line">            <span class="comment">// DpUtils.dump(dp);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="排列背包"><a href="#排列背包" class="headerlink" title="排列背包"></a>排列背包</h3><blockquote>
<h4 id="377-组合总和-Ⅳ"><a href="#377-组合总和-Ⅳ" class="headerlink" title="377. 组合总和 Ⅳ"></a><a href="https://leetcode-cn.com/problems/combination-sum-iv/">377. 组合总和 Ⅳ</a></h4><p>给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。</p>
<p>题目数据保证答案符合 32 位整数范围。</p>
</blockquote>
<p>完全背包的排列问题</p>
<p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p>
<p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum41</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// int[] nums = &#123;1, 2, 3&#125;;</span></span><br><span class="line">        <span class="comment">// dp[j] = dp[j] + dp[j - nums[i - 1]]</span></span><br><span class="line">        <span class="comment">// 组合问题</span></span><br><span class="line">        <span class="comment">// i = 1, nums[0] = 1</span></span><br><span class="line">        <span class="comment">// j = 1 , dp[1] = dp[1] + dp[1-1] = 1</span></span><br><span class="line">        <span class="comment">// j = 2,  dp[2] = dp[2] + dp[2-1] = 1</span></span><br><span class="line">        <span class="comment">// j = 3,  dp[3] = dp[3] + dp[3-1] = 1</span></span><br><span class="line">        <span class="comment">// j = 4,  dp[4] = dp[4] + dp[4-1] = 1</span></span><br><span class="line">        <span class="comment">// [1,1,1,1,1]</span></span><br><span class="line">        <span class="comment">// i = 2, nums[i - 1] = nums[1] = 2</span></span><br><span class="line">        <span class="comment">// j = 1 , j - nums[i - 1] = -1 &lt;= 0 跳过</span></span><br><span class="line">        <span class="comment">// j = 2,  dp[2] = dp[2] + dp[2-2] = 2</span></span><br><span class="line">        <span class="comment">// j = 3,  dp[3] = dp[3] + dp[3-2] = 2</span></span><br><span class="line">        <span class="comment">// j = 4,  dp[4] = dp[4] + dp[4-2] = 3</span></span><br><span class="line">        <span class="comment">// [1,1,2,2,3]</span></span><br><span class="line">        <span class="comment">// i = 3, nums[i - 1] = nums[2] = 3</span></span><br><span class="line">        <span class="comment">// j = 1 , j - nums[i - 1] = -1 &lt;= 0跳过</span></span><br><span class="line">        <span class="comment">// j = 2,  跳过</span></span><br><span class="line">        <span class="comment">// j = 3,  dp[3] = dp[3] + dp[3-3] = 3</span></span><br><span class="line">        <span class="comment">// j = 4,  dp[4] = dp[4] + dp[4-3] = 4</span></span><br><span class="line">        <span class="comment">// [1,1,2,3,4]</span></span><br><span class="line"><span class="comment">//        int n = nums.length;</span></span><br><span class="line"><span class="comment">//        int[] dp = new int[target + 1];</span></span><br><span class="line"><span class="comment">//        dp[0] = 1;</span></span><br><span class="line"><span class="comment">//        for (int i = 1; i &lt;= n; i++) &#123; // 先遍历物品，在遍历背包</span></span><br><span class="line"><span class="comment">//            for (int j = 1; j &lt;= target; j++) &#123;</span></span><br><span class="line"><span class="comment">//                if (j - nums[i - 1] &gt;= 0) &#123;</span></span><br><span class="line"><span class="comment">//                    dp[j] = dp[j] + dp[j - nums[i - 1]];</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            // DpUtils.dump(dp);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        return dp[target];</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 排列问题</span></span><br><span class="line">        <span class="comment">//  dp[j] = dp[j] + dp[j - nums[i - 1]]</span></span><br><span class="line">        <span class="comment">// j= 1</span></span><br><span class="line">        <span class="comment">// i = 1, dp[1] = dp[1] + dp[1-nums[0]] = dp[1] + dp[0] = 1</span></span><br><span class="line">        <span class="comment">// i = 2, dp[1] = dp[1] + dp[1-nums[1]=-1&lt;=0], 跳过；同理3也跳过 dp[j] = 1;</span></span><br><span class="line">        <span class="comment">// dp [1, 1, 0, 0, 0]</span></span><br><span class="line">        <span class="comment">// j = 2</span></span><br><span class="line">        <span class="comment">// i = 1, dp[2] = dp[2] + dp[2-nums[0]] = dp[2] + dp[1] = 1, dp[2]更新了</span></span><br><span class="line">        <span class="comment">// i = 2, dp[2] = dp[2] + dp[2-nums[1]] = dp[2] + dp[0] = 2</span></span><br><span class="line">        <span class="comment">// i = 3, dp[2] = dp[2] + dp[2-nums[3] == -3] = /</span></span><br><span class="line">        <span class="comment">// dp [1, 1, 2, 2, 0]</span></span><br><span class="line">        <span class="comment">// j = 3</span></span><br><span class="line">        <span class="comment">// i = 1, dp[3] = dp[3] + dp[3-nums[0]] = dp[3] + dp[2] = 2</span></span><br><span class="line">        <span class="comment">// i = 2, dp[3] = dp[3] + dp[3-nums[1]] = dp[3] + dp[1] = 3</span></span><br><span class="line">        <span class="comment">// i = 3, dp[3] = dp[3] + dp[3-nums[2]] = dp[3] + dp[0] = 4</span></span><br><span class="line">        <span class="comment">// dp [1, 1, 2, 4, 0]</span></span><br><span class="line">        <span class="comment">// j = 4</span></span><br><span class="line">        <span class="comment">// i = 1, dp[4] = dp[4] + dp[4-nums[0]] = dp[4] + dp[3] = 4</span></span><br><span class="line">        <span class="comment">// i = 2, dp[4] = dp[4] + dp[4-nums[1]] = dp[4] + dp[2] = 6</span></span><br><span class="line">        <span class="comment">// i = 3, dp[4] = dp[4] + dp[4-nums[2]] = dp[4] + dp[1] = 7</span></span><br><span class="line">        <span class="comment">// dp [1, 1, 2, 4, 7]</span></span><br><span class="line">        <span class="comment">// 以上的过程 容量一直 ++；</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= target; j++) &#123; <span class="comment">// 必须要先遍历背包</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123; </span><br><span class="line">                <span class="keyword">if</span> (j - nums[i - <span class="number">1</span>] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[j] = dp[j] + dp[j - nums[i - <span class="number">1</span>]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// DpUtils.dump(dp);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><img src="/pics/image-20210520101953850.png" alt="image-20210520101953850"></p>
<h2 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h2><h4 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍</a></h4><blockquote>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="comment">// dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]。</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="comment">//dp[i] = Max(dp[i - 1], nums[i] + dp[i -2])</span></span><br><span class="line">    <span class="comment">// 如果不偷第i房间，那么dp[i] = dp[i - 1]，即考虑i-1房，（注意这里是考虑，并不是一定要偷i-1房，这是很多同学容易混淆的点）</span></span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = Math.max(dp[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i] = Math.max(dp[i - <span class="number">1</span>], nums[i] + dp[i - <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a><a href="https://leetcode-cn.com/problems/house-robber-ii/">213. 打家劫舍 II</a></h4><blockquote>
<p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">robII</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rob1 = robII(nums, <span class="number">0</span>, nums.length - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> rob2 = robII(nums, <span class="number">1</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> Math.max(rob1, rob2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Solution213</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">robII</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//dp[i] = Max(dp[i - 1], nums[i] + dp[i -2])</span></span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="comment">//dp[i] = Max(dp[i - 1], nums[i] + dp[i -2])</span></span><br><span class="line">    dp[start] = nums[start];</span><br><span class="line">    dp[start + <span class="number">1</span>] = Math.max(dp[start], nums[start + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">2</span>; i &lt;= end; i++) &#123;</span><br><span class="line">        dp[i] = Math.max(dp[i - <span class="number">1</span>], nums[i] + dp[i - <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[end];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="337-打家劫舍-III"><a href="#337-打家劫舍-III" class="headerlink" title="337. 打家劫舍 III"></a><a href="https://leetcode-cn.com/problems/house-robber-iii/">337. 打家劫舍 III</a></h4><blockquote>
<p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p>
<p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p>
</blockquote>
<p>理解递归 + 备忘录就可以了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抢劫root 节点的最大值</span></span><br><span class="line">    <span class="keyword">int</span> sum1 = root.val;</span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sum1 += rob(root.left.left) + rob(root.left.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sum1 += rob(root.right.left) + rob(root.right.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抢劫root 节点的最大值</span></span><br><span class="line">    <span class="keyword">int</span> sum2 = rob(root.left) + rob(root.right);</span><br><span class="line">    <span class="keyword">return</span> Math.max(sum1, sum2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法二</span></span><br><span class="line">HashMap&lt;TreeNode, Integer&gt; res = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">robIII2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res.containsKey(root)) &#123;</span><br><span class="line">        <span class="keyword">return</span> res.get(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抢劫root 节点的最大值</span></span><br><span class="line">    <span class="keyword">int</span> sum1 = root.val;</span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sum1 += rob(root.left.left) + rob(root.left.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sum1 += rob(root.right.left) + rob(root.right.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不抢劫root 节点的最大值</span></span><br><span class="line">    <span class="keyword">int</span> sum2 = rob(root.left) + rob(root.right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = Math.max(sum1, sum2);</span><br><span class="line">    res.put(root, ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法三</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">robIII3</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] res = dp(root);</span><br><span class="line">    <span class="keyword">return</span> Math.max(res[<span class="number">0</span>], res[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回一个大小为 2 的数组 arr</span></span><br><span class="line"><span class="comment">arr[0] 表示不抢 root 的话，得到的最大钱数</span></span><br><span class="line"><span class="comment">arr[1] 表示抢 root 的话，得到的最大钱数 */</span></span><br><span class="line"><span class="keyword">int</span>[] dp(TreeNode root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] left = dp(root.left);</span><br><span class="line">    <span class="keyword">int</span>[] right = dp(root.right);</span><br><span class="line">    <span class="comment">// 抢，下家就不能抢了</span></span><br><span class="line">    <span class="keyword">int</span> rob = root.val + left[<span class="number">0</span>] + right[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 不抢，下家可抢可不抢，取决于收益大小</span></span><br><span class="line">    <span class="keyword">int</span> not_rob = Math.max(left[<span class="number">0</span>], left[<span class="number">1</span>])</span><br><span class="line">            + Math.max(right[<span class="number">0</span>], right[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;not_rob, rob&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="股票买卖"><a href="#股票买卖" class="headerlink" title="股票买卖"></a>股票买卖</h2><blockquote>
<h4 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h4><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p>
<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
</blockquote>
<p><a href="https://www.bilibili.com/video/BV1oy4y127jd?spm_id_from=333.788.b_636f6d6d656e74.10">https://www.bilibili.com/video/BV1oy4y127jd?spm_id_from=333.788.b_636f6d6d656e74.10</a></p>
<p><a href="https://labuladong.gitee.io/algo/3/28/92/">https://labuladong.gitee.io/algo/3/28/92/</a></p>
<p><a href="https://leetcode-cn.com/circle/article/qiAgHn/">https://leetcode-cn.com/circle/article/qiAgHn/</a></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><strong>明确状态与选择</strong></p>
<p>状态：天数 + 交易次数 + 持有状态</p>
<p>选择：天数 [1,N]，交易次数：[1, K]，持有状态[0, 1]</p>
<p><strong>确定dp数组的含义</strong></p>
<p><code>dp[i][k][s]</code>：第i天，交易次数为k的情况下，持有状态为s时的利润</p>
<p>比如说 <code>dp[3][2][1]</code> 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。再比如 <code>dp[2][3][0]</code> 的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易</p>
<p>我们想求的最终答案是<code> dp[n - 1][K][0]</code>，即最后一天，最多允许 K 次交易，最多获得多少利润。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[i][k][<span class="number">0</span> or <span class="number">1</span>]</span><br><span class="line"><span class="number">0</span> &lt;= i &lt;= n-<span class="number">1</span>, <span class="number">1</span> &lt;= k &lt;= K</span><br><span class="line">n 为天数，大 K 为最多交易数</span><br><span class="line">此问题共 n × K × <span class="number">2</span> 种状态，全部穷举就能搞定。</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt;= i &lt; n:</span><br><span class="line">    <span class="keyword">for</span> <span class="number">1</span> &lt;= k &lt;= K:</span><br><span class="line">        <span class="keyword">for</span> s in &#123;<span class="number">0</span>, <span class="number">1</span>&#125;:</span><br><span class="line">            dp[i][k][s] = max(buy, sell, rest)</span><br></pre></td></tr></table></figure>

<p><strong>确定状态转移方程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])</span><br><span class="line">              max(   选择 rest  ,             选择 sell      )</span><br><span class="line"></span><br><span class="line">解释：今天我没有持有股票，有两种可能：</span><br><span class="line">要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；</span><br><span class="line">要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。</span><br><span class="line"></span><br><span class="line">dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])</span><br><span class="line">              max(   选择 rest  ,           选择 buy         )</span><br><span class="line"></span><br><span class="line">解释：今天我持有着股票，有两种可能：</span><br><span class="line">要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；</span><br><span class="line">要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。</span><br></pre></td></tr></table></figure>

<p><strong>k次交易（买 + 卖 算一次交易）而且注意 k 的限制，我们在选择 buy 的时候，把 k 减小了 1</strong>，当然你也可以在 sell 的时候减 1，一样的。</p>
<p><strong>确定basecase</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[-<span class="number">1</span>][k][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">解释：因为 i 是从 <span class="number">0</span> 开始的，所以 i = -<span class="number">1</span> 意味着还没有开始，这时候的利润当然是 <span class="number">0</span> 。</span><br><span class="line">dp[-<span class="number">1</span>][k][<span class="number">1</span>] = -infinity</span><br><span class="line">解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。</span><br><span class="line">dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">解释：因为 k 是从 <span class="number">1</span> 开始的，所以 k = <span class="number">0</span> 意味着根本不允许交易，这时候利润当然是 <span class="number">0</span> 。</span><br><span class="line">dp[i][<span class="number">0</span>][<span class="number">1</span>] = -infinity</span><br><span class="line">解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。</span><br></pre></td></tr></table></figure>

<p>把上面的状态转移方程总结一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">base <span class="keyword">case</span>：</span><br><span class="line"><span class="comment">//s = 1持有的情况下，利润都是 -infinity</span></span><br><span class="line"><span class="comment">//s = 0未持有的情况下，利润都是 0</span></span><br><span class="line">dp[-<span class="number">1</span>][k][<span class="number">0</span>] = dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">dp[-<span class="number">1</span>][k][<span class="number">1</span>] = dp[i][<span class="number">0</span>][<span class="number">1</span>] = -infinity</span><br><span class="line"></span><br><span class="line">状态转移方程：</span><br><span class="line">dp[i][k][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">0</span>], dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][k][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">1</span>], dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure>

<h4 id="第一题，k-1"><a href="#第一题，k-1" class="headerlink" title="第一题，k = 1"></a><strong>第一题，k = 1</strong></h4><p>直接套状态转移方程，根据 base case，可以做一些化简：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[i][<span class="number">1</span>][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] - prices[i]) </span><br><span class="line">            = max(dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], -prices[i])</span><br><span class="line">解释：k = <span class="number">0</span> 的 base <span class="keyword">case</span>，所以 dp[i-<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>。</span><br><span class="line"></span><br><span class="line">现在发现 k 都是 <span class="number">1</span>，不会改变，即 k 对状态转移已经没有影响了。</span><br><span class="line">可以进行进一步化简去掉所有 k：</span><br><span class="line">dp[i][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][<span class="number">1</span>], -prices[i])</span><br></pre></td></tr></table></figure>

<p>显然 i = 0 时 dp[i-1] 是不合法的。这是因为我们没有对 i 的 base case 进行处理。可以这样处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;        </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="comment">// int[][] dp = new int[n][2];</span></span><br><span class="line">    <span class="comment">// // k = 1</span></span><br><span class="line">    <span class="comment">// dp[0][0] = 0;</span></span><br><span class="line">    <span class="comment">// dp[0][1] = -prices[0];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// for(int i = 1; i &lt; n; i++) &#123;</span></span><br><span class="line">    <span class="comment">//     dp[i][0] = Math.max(dp[i - 1][1] + prices[i], dp[i - 1][0]);   </span></span><br><span class="line">    <span class="comment">//     dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);  </span></span><br><span class="line">  	<span class="comment">// 对于这道题，只有一次交易，今天买就是 -prices[i]      </span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// return dp[n - 1][0];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// n 从 1开始</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i - <span class="number">1</span>]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], - prices[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][<span class="number">0</span>];</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<h4 id="第二题，k-infinity"><a href="#第二题，k-infinity" class="headerlink" title="第二题，k = +infinity"></a><strong>第二题，k = +infinity</strong></h4><p>如果 k 为正无穷，那么就可以认为 k 和 k - 1 是一样的。可以这样改写框架：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[i][k][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">0</span>], dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][k][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">1</span>], dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">  						         【k】替换 【k-<span class="number">1</span>】</span><br><span class="line">            = max(dp[i-<span class="number">1</span>][k][<span class="number">1</span>], dp[i-<span class="number">1</span>][k][<span class="number">0</span>] - prices[i])</span><br><span class="line"></span><br><span class="line">我们发现数组中的 k 已经不会改变了，也就是说不需要记录 k 这个状态了：</span><br><span class="line">dp[i][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure>

<p>直接翻译成代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="comment">// int[][] dp = new int[n][2];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// // dp[i][k][0] = max(dp[i - 1][k][0] , dp[i - 1][k][1] + price[i])</span></span><br><span class="line">    <span class="comment">// // dp[i][k][1] = max(dp[i - 1][k][1] , dp[i - 1][k - 1][0] - price[i])</span></span><br><span class="line">    <span class="comment">// dp[0][0] = 0;</span></span><br><span class="line">    <span class="comment">// dp[0][1] = -prices[0];</span></span><br><span class="line">    <span class="comment">// for (int i = 1;i &lt; n; i++) &#123;</span></span><br><span class="line">    <span class="comment">//     dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);</span></span><br><span class="line">    <span class="comment">//     dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// return dp[n - 1][0];</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i - <span class="number">1</span>]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第三题，k-2"><a href="#第三题，k-2" class="headerlink" title="第三题，k = 2"></a><strong>第三题，k = 2</strong></h4><p>k = 2 和前面题目的情况稍微不同，因为上面的情况都和 k 的关系不太大。要么 k 是正无穷，状态转移和 k 没关系了；要么 k = 1，跟 k = 0 这个 base case 挨得近，最后也没有存在感。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">2</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// int[][][] dp = new int[n][k + 1][2];</span></span><br><span class="line">    <span class="comment">// for(int i = 0; i &lt;= k; i++) &#123;</span></span><br><span class="line">    <span class="comment">//     dp[0][i][0] = 0;</span></span><br><span class="line">    <span class="comment">//     dp[0][i][1] = -prices[0];</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// for(int i = 1; i &lt; n; i++) &#123;</span></span><br><span class="line">    <span class="comment">//     for(int j = 1; j &lt;= k; j++) &#123;</span></span><br><span class="line">    <span class="comment">//         dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);</span></span><br><span class="line">    <span class="comment">//         dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i - 1][j - 1][0]    - prices[i]); // 交易次数 j-1</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// return dp[n - 1][k][0];</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][k + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= k; i++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][i][<span class="number">1</span>] = Integer.MIN_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">            dp[i][j][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][j][<span class="number">0</span>], dp[i - <span class="number">1</span>][j][<span class="number">1</span>] + prices[i - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">            dp[i][j][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][j][<span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>] - prices[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][k][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第四题，k-any-integer"><a href="#第四题，k-any-integer" class="headerlink" title="第四题，k = any integer"></a><strong>第四题，k = any integer</strong></h4><p>有了上一题 k = 2 的铺垫，这题应该和上一题的第一个解法没啥区别。但是出现了一个超内存的错误，原来是传入的 k 值会非常大，dp 数组太大了。现在想想，交易次数 k 最多有多大呢？</p>
<p>一次交易由买入和卖出构成，至少需要两天。<strong>所以说有效的限制 k 应该不超过 n/2，如果超过，就没有约束作用了，相当于 k = +infinity</strong>。这种情况是之前解决过的。</p>
<p>直接把之前的代码重用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k &lt; <span class="number">1</span> || prices.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交易次数有上限</span></span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">if</span>(k &gt; n / <span class="number">2</span>) &#123;</span><br><span class="line">        k = n / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// int[][][] dp = new int[n][k + 1][2]; // （0，n）</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// for(int i = 0; i &lt;= k; i++) &#123;</span></span><br><span class="line">    <span class="comment">//     dp[0][i][0] = 0;</span></span><br><span class="line">    <span class="comment">//     dp[0][i][1] = -prices[0];//Integer.MIN_VALUE;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// for(int i = 1; i &lt; n; i++) &#123;</span></span><br><span class="line">    <span class="comment">//     for(int j = 1; j &lt;= k; j++) &#123;</span></span><br><span class="line">    <span class="comment">//         dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);</span></span><br><span class="line">    <span class="comment">//         dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]); // 交易次数 j-1</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// return dp[n - 1][k][0];</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][k + <span class="number">1</span>][<span class="number">2</span>]; <span class="comment">// [0，n]</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][i][<span class="number">1</span>] = Integer.MIN_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">            dp[i][j][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][j][<span class="number">0</span>], dp[i - <span class="number">1</span>][j][<span class="number">1</span>] + prices[i - <span class="number">1</span>]);</span><br><span class="line">            dp[i][j][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][j][<span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>] - prices[i - <span class="number">1</span>]); <span class="comment">// 交易次数 j-1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][k][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第五题，k-infinity-with-cooldown"><a href="#第五题，k-infinity-with-cooldown" class="headerlink" title="第五题，k = +infinity with cooldown"></a><strong>第五题，k = +infinity with cooldown</strong></h4><p>每次 sell 之后要等一天才能继续交易。第 i 天选择 buy 的时候，要从 i-2 的状态转移。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</span><br><span class="line">dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])</span><br><span class="line">解释：第 i 天选择 buy 的时候，要从 i-2 的状态转移，而不是 i-1 。</span><br></pre></td></tr></table></figure>

<p>翻译成代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> n = prices.length;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">		dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">		    dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">		    dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], (i &gt;= <span class="number">2</span> ? dp[i - <span class="number">2</span>][<span class="number">0</span>]: <span class="number">0</span>) - prices[i]); </span><br><span class="line">        <span class="comment">//  不能立刻买</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dp[n-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">		<span class="comment">// int[][] dp = new int[n + 1][2];</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// dp[0][0] = 0;</span></span><br><span class="line">		<span class="comment">// dp[0][1] = Integer.MIN_VALUE;</span></span><br><span class="line">		<span class="comment">// dp[1][0] = 0;</span></span><br><span class="line">		<span class="comment">// dp[1][1] = -prices[0];</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// for(int i = 2; i &lt;= n; i++) &#123;</span></span><br><span class="line">		<span class="comment">//     dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i - 1]);</span></span><br><span class="line">		<span class="comment">//     dp[i][1] = Math.max(dp[i - 1][1], dp[i - 2][0] - prices[i - 1]); </span></span><br><span class="line">  	<span class="comment">//  不能立刻买</span></span><br><span class="line">		<span class="comment">// &#125;</span></span><br><span class="line">		<span class="comment">// return dp[n][0];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第六题，k-infinity-with-fee"><a href="#第六题，k-infinity-with-fee" class="headerlink" title="第六题，k = +infinity with fee"></a><strong>第六题，k = +infinity with fee</strong></h4><p>每次交易要支付手续费，只要把手续费从利润中减去即可。改写方程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</span><br><span class="line">dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i] - fee)</span><br><span class="line">解释：相当于买入股票的价格升高了。</span><br><span class="line">在第一个式子里减也是一样的，相当于卖出股票的价格减小了。</span><br></pre></td></tr></table></figure>

<p>直接翻译成代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> n = prices.length;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">     dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">     dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">         dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i] - fee);</span><br><span class="line">         dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]); </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">     <span class="comment">// int[][] dp = new int[n + 1][2];</span></span><br><span class="line">     <span class="comment">// dp[0][0] = 0;</span></span><br><span class="line">     <span class="comment">// dp[0][1] = Integer.MIN_VALUE / 10; // 特殊处理，否则 值会溢出</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// for(int i = 1; i &lt;= n; i++) &#123;</span></span><br><span class="line">     <span class="comment">//     dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i - 1] - fee); // 注意 i-1</span></span><br><span class="line">     <span class="comment">//     dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i - 1]); </span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// &#125;</span></span><br><span class="line">     <span class="comment">// return dp[n][0];</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>至此，6 道题目通过一个状态转移方程全部解决。</p>
<h3 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a><strong>最后总结</strong></h3><p>股票问题，按照对 k 的限制可以分成3类，</p>
<ol>
<li><p>k = 有限次，题目的通解</p>
</li>
<li><p>k=  1，只能进行一次交易，那么<code>dp[i][k][0] == 0</code>，只能交易一次的话，前面交易的利润比为0 </p>
</li>
<li><p>k = 无穷，进行无数次交易，可以将k的影响消除掉，数组变为2维数组，递推公式如下：</p>
<p><code>dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</code><br><code>dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])</code></p>
</li>
</ol>
<p>按照对交易间隔的限制，可分为2类，一天只能交易一次，或过两天才能交易一次，不限次数。</p>
<p>​           <code>dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i]), i-2&gt;=0 要从2开始</code>。 </p>
<h2 id="子序列问题"><a href="#子序列问题" class="headerlink" title="子序列问题"></a>子序列问题</h2><p>*<strong>涉及两个字符串/数组时</strong>（比如最长公共子序列），dp 数组的含义如下：</p>
<p>**在子数组<code>arr1[0..i]</code>和子数组<code>arr2[0..j]</code>中，我们要求的子序列（最长公共子序列）长度为<code>dp[i][j]</code>**。</p>
<p><strong>只涉及一个字符串/数组时</strong>（比如最长回文子序列），dp 数组的含义如下：</p>
<p>**在子数组<code>array[i..j]</code>中，我们要求的子序列（最长回文子序列）的长度为<code>dp[i][j]</code>**。</p>
<h4 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h4><blockquote>
<p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
</blockquote>
<p><strong><code>dp[i]</code> 表示以 <code>nums[i]</code> 这个数结尾的最长递增子序列的长度。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i :dp) &#123;</span><br><span class="line">        res = Math.max(i, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="674-最长连续递增序列"><a href="#674-最长连续递增序列" class="headerlink" title="674. 最长连续递增序列"></a><a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/">674. 最长连续递增序列</a></h4><blockquote>
<p>给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。</p>
<p>连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;= i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], …, nums[r - 1], nums[r]] 就是连续递增子序列。</p>
</blockquote>
<p>**<code>dp[i]为nums[i]</code> 为结尾的「最大子数组和」为 <code>dp[i]</code>**。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : dp) &#123;</span><br><span class="line">        res = Math.max(i, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="718. 最长重复子数组"></a><a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/">718. 最长重复子数组</a></h4><blockquote>
<p>给两个整数数组 <code>A</code> 和 <code>B</code> ，返回两个数组中公共的、长度最长的子数组的长度。</p>
</blockquote>
<p><code>dp[i][j]， nums1[i] nums2[j] 连续的序列</code>，数组是连续的，所以当值不同时，需要重新计数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length + <span class="number">1</span>][nums2.length + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 初始化 </span></span><br><span class="line">    <span class="comment">// dp[0][j] = 0;</span></span><br><span class="line">    <span class="comment">// dp[i][0] = 0;</span></span><br><span class="line">    <span class="comment">// dp[i][j]， nums1[i] nums2[j] 最长公共序列</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums1.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= nums2.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                res = Math.max(res, dp[i][j]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不一样的时候，重新开始</span></span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143. 最长公共子序列</a></h4><blockquote>
<p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p>
<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p>
</blockquote>
<p><code>dp[i][j]， nums1[i]和nums2[j] 最长公共序列</code></p>
<p><code>当s[i] == t[j]时，最长公共序列自然是 dp[i - 1][j - 1] + 1</code> </p>
<p><code>当s[i]!= t[j]时, 有2种情况，取（s[i-1]，t[j]）以及（s[i],t[j-1])中公共部分的最大值</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[text1.length() + <span class="number">1</span>][text2.length() + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化，其实没必要</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= text1.length(); i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= text2.length(); j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= text1.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= text2.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text1.charAt(i - <span class="number">1</span>) == text2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不同时 取 text1[i - 1] + text2[j] 和 text1[i] + text2[j - 1] 中较小的值，</span></span><br><span class="line">                <span class="comment">// 所以dp[i][j] 一定为最大值</span></span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[text1.length()][text2.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="子序列问题2"><a href="#子序列问题2" class="headerlink" title="子序列问题2"></a>子序列问题2</h2><h4 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392. 判断子序列"></a><a href="https://leetcode-cn.com/problems/is-subsequence/">392. 判断子序列</a></h4><blockquote>
<p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p>
</blockquote>
<p><code>dp[i,j] , s[i], t[j]中相同子序列的长度为dp[i][j]</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubsequence</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length() + <span class="number">1</span>][t.length() + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= t.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == t.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 相当于看前面字符的匹配了多少个</span></span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.length()][t.length()] == s.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="115-不同的子序列"><a href="#115-不同的子序列" class="headerlink" title="115. 不同的子序列"></a><a href="https://leetcode-cn.com/problems/distinct-subsequences/">115. 不同的子序列</a></h4><blockquote>
<p>给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</p>
<p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p>
<p>题目数据保证答案符合 32 位带符号整数范围。</p>
</blockquote>
<p><code>dp[i][j]：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i][j]。</code></p>
<p><strong>s 是较小的序列，t是完整序列</strong></p>
<p>s和t的匹配情况有2种，i，j 分别代表 s 和 t 中要匹配的字符索引。</p>
<p>如果 s[i] == t[j], 当前位置匹配，由于s比t长，此时又有2种情况，s[i - 1] 和 t[i -1] 或者 比较s[ i-1] 和t[j], 相当于将s往前移动一位再和t 比较。</p>
<p>如果 s[i] == t[j], 只能比较 s[i - 1]  和 t[j] </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// dp[i][j]：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i][j]。</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length() + <span class="number">1</span>][t.length() + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; t.length(); j++) dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= t.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == t.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 一部分是用s[i - 1]来匹配，那么个数为dp[i - 1][j - 1]。</span></span><br><span class="line">								<span class="comment">//一部分是不用s[i - 1]来匹配，个数为dp[i - 1][j]。</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.length()][t.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a><a href="https://leetcode-cn.com/problems/edit-distance/">72. 编辑距离</a></h4><blockquote>
<p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<p>插入一个字符<br>删除一个字符<br>替换一个字符</p>
</blockquote>
<p><code>dp[i][j] 返回 s1[0..i] 和 s2[0..j] 的最小编辑距离</code></p>
<p><strong>记住这个定义</strong>之后，先来看这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> s1[i] == s2[j]:</span><br><span class="line">    <span class="keyword">return</span> dp(i - <span class="number">1</span>, j - <span class="number">1</span>)  # 啥都不做</span><br><span class="line"># 解释：</span><br><span class="line"># 本来就相等，不需要任何操作</span><br><span class="line"># s1[<span class="number">0.</span>.i] 和 s2[<span class="number">0.</span>.j] 的最小编辑距离等于</span><br><span class="line"># s1[<span class="number">0.</span>.i-<span class="number">1</span>] 和 s2[<span class="number">0.</span>.j-<span class="number">1</span>] 的最小编辑距离</span><br><span class="line"># 也就是说 dp(i, j) 等于 dp(i-<span class="number">1</span>, j-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>如果 <code>s1[i] != s2[j]</code>，就要对三个操作递归了，稍微需要点思考：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp(i, j - <span class="number">1</span>) + <span class="number">1</span>,    # 插入</span><br><span class="line"># 解释：</span><br><span class="line"># 我直接在 s1[i] 插入一个和 s2[j] 一样的字符</span><br><span class="line"># 那么 s2[j] 就被匹配了，前移 j，继续跟 i 对比</span><br><span class="line"># 别忘了操作数加一</span><br><span class="line"></span><br><span class="line">dp(i - <span class="number">1</span>, j) + <span class="number">1</span>,    # 删除</span><br><span class="line"># 解释：</span><br><span class="line"># 我直接把 s[i] 这个字符删掉</span><br><span class="line"># 前移 i，继续跟 j 对比</span><br><span class="line"># 操作数加一</span><br><span class="line"></span><br><span class="line">dp(i - <span class="number">1</span>, j - <span class="number">1</span>) + <span class="number">1</span> # 替换</span><br><span class="line"># 解释：</span><br><span class="line"># 我直接把 s1[i] 替换成 s2[j]，这样它俩就匹配了</span><br><span class="line"># 同时前移 i，j 继续对比</span><br><span class="line"># 操作数加一</span><br></pre></td></tr></table></figure>

<img src="../pics/image-20210521175518563.png" alt="image-20210521175518563" style="zoom:50%;" />

<p>完整代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = s1.length(), n = s2.length();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// base case </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        dp[<span class="number">0</span>][j] = j;</span><br><span class="line">    <span class="comment">// 自底向上求解</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span> (s1.charAt(i-<span class="number">1</span>) == s2.charAt(j-<span class="number">1</span>))</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span>               </span><br><span class="line">                dp[i][j] = min(</span><br><span class="line">                    dp[i - <span class="number">1</span>][j] + <span class="number">1</span>,</span><br><span class="line">                    dp[i][j - <span class="number">1</span>] + <span class="number">1</span>,</span><br><span class="line">                    dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                );</span><br><span class="line">    <span class="comment">// 储存着整个 s1 和 s2 的最小编辑距离</span></span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.min(a, Math.min(b, c));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="回文串"><a href="#回文串" class="headerlink" title="回文串"></a>回文串</h2><h4 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a></h4><blockquote>
<p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p>
</blockquote>
<p><code>dp[i][j], s[i,j] 是否是否是回文子串，递推公式dp[i][j] = s[i]==s[j] &amp;&amp; dp[i+1][j-1]，注意回文子串是连续的</code>。</p>
<p>根据递推公式可知，<code> dp[i][j] 取决于 dp[i+1][j-1]的值</code>，所以遍历方向为<code>从下到上，从左到右</code>。</p>
<p>初始化时， i ==j 相等时，回文串的长度是1，所以斜对角必为true。同时在遍历时，不再考虑i == j， 所以 j 的取值范围是<code>[i + 1, n - 1]</code></p>
<p>另外[i , j ] 的情况是aa时，即 <code>s[i]==s[j] &amp;&amp; j - i = 2 时，dp[i][j]一定为true。</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">    <span class="comment">// 斜对角为true</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历方向 非常重要</span></span><br><span class="line">    <span class="comment">// [i ,j],区间是前闭后闭的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; max) &#123;</span><br><span class="line">                max = j - i + <span class="number">1</span>;</span><br><span class="line">                start = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// DpUtils.dump(dp);</span></span><br><span class="line">    <span class="keyword">return</span> s.substring(start, start + max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">516. 最长回文子序列</a></h4><blockquote>
<p>给定一个字符串 <code>s</code> ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 <code>s</code> 的最大长度为 <code>1000</code> 。</p>
</blockquote>
<p>次题与上一题的最大区别是<strong>回文子串是要连续的，回文子序列可不是连续的</strong>。对于dp方程来说。</p>
<ul>
<li><p>当<code>s[i] == s[j]时，dp[i][j] = dp[i + 1][j - 1] + 2 </code>，它俩加上<code>s[i+1..j-1]</code>中的最长回文子序列就是<code>s[i..j]</code>的最长回文子序列：</p>
<img src="../pics/image-20210523180435407.png" alt="image-20210523180435407" style="zoom:50%;" /></li>
<li><p>当<code>s[i] != s[j]时，dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1])</code>，说明它俩<strong>不可能同时</strong>出现在<code>s[i..j]</code>的最长回文子序列中，那么把它俩<strong>分别</strong>加入<code>s[i+1..j-1]</code>中，看看哪个子串产生的回文子序列更长即可：</p>
<img src="../pics/image-20210523180348456.png" alt="image-20210523180348456" style="zoom:50%;" /></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// s[i], s[j]不相等时，子序列可以在查找[i, j-1] 和 [i + 1, j]范围的数据</span></span><br><span class="line">                <span class="comment">// 而 子串则不行，直接置为为0或false</span></span><br><span class="line">                dp[i][j] = Math.max(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// i, j 为 0，n-1 时，取到的序列长度是最长的</span></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a><a href="https://leetcode-cn.com/problems/palindromic-substrings/">647. 回文子串</a></h4><blockquote>
<p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>
</blockquote>
<p><code>dp[i][j]：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串。</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> nums = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                nums++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//DpUtils.dump(dp);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Alg</category>
      </categories>
  </entry>
  <entry>
    <title>Java 面试题</title>
    <url>/2022/03/02/Notes/Interview/Java%20%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="面经-02Java-面试题"><a href="#面经-02Java-面试题" class="headerlink" title="面经_02Java 面试题"></a>面经_02Java 面试题</h1><span id="more"></span>

<h1 id="一、HashMap"><a href="#一、HashMap" class="headerlink" title="一、HashMap"></a>一、HashMap</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><strong>数据结构</strong></h2><ul>
<li><p>JDK1.8：数组 + 链表 + 红黑树，红黑树：提高查询的效率（ &lt;= 2logN-1），降低插入和删除的效率</p>
</li>
<li><p>JDK1.7：数组 + 链表</p>
</li>
</ul>
<p><strong>扩容是2的倍数？</strong></p>
<ol>
<li>计算节点的数组索引index，位移的效率比取余高</li>
<li>扩容时计算index，hashcode &amp; （n-1）只要看高位就能确定扩容后的index</li>
<li>2^n -1 高位和低位都能参与计算，hash值分布均匀 </li>
</ol>
<p><strong>扩容因子 0.75？</strong></p>
<ul>
<li>空间利用率高，hash冲突概率低</li>
</ul>
<p><strong>树化阈值8?</strong></p>
<ul>
<li>泊松分布，出现概率低 百万分之6</li>
</ul>
<p><strong>转链表阈值6?</strong></p>
<ul>
<li>避免红黑树和链表的频繁转化</li>
</ul>
<h2 id="Hash规则-1-8"><a href="#Hash规则-1-8" class="headerlink" title="Hash规则(1.8)"></a>Hash规则(1.8)</h2><p><code>hash = hashCode ^ hashCode &gt;&gt;&gt; 16</code></p>
<p>数组索引计算  <code>hash * （n-1）</code>，n 是数组长度</p>
<p>为了数据分布更加均匀，在下一步计算 节点 的数组索引。</p>
<h2 id="简述扩容过程？"><a href="#简述扩容过程？" class="headerlink" title="简述扩容过程？"></a>简述扩容过程？</h2><ol>
<li>计算新数组大小，扩容阈值 </li>
<li>创建新数组</li>
<li>数据迁移 ，将oldTable 数据迁移到newTable，index 有2种情况，1oldIndex ，newIndex = index + oldCap ，移动节点</li>
<li>红黑树转链表（可能）（1.8）</li>
</ol>
<h2 id="hashMap-并发的安全问题？"><a href="#hashMap-并发的安全问题？" class="headerlink" title="hashMap 并发的安全问题？"></a>hashMap 并发的安全问题？</h2><ul>
<li>1.7 链表节点死循环，头擦法</li>
<li>1.8 元素覆盖，尾插法</li>
</ul>
<h1 id="二、ConcurrentHashMap"><a href="#二、ConcurrentHashMap" class="headerlink" title="二、ConcurrentHashMap"></a>二、ConcurrentHashMap</h1><h2 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h2><ul>
<li><p>JDK 1.7 ：Segment 数组 + HashEntry数组 + 链表<code>Segment[HashEntry[cap] ssize]</code></p>
<p>参数说明：</p>
<ol>
<li><p>concurrencyLevel ：Segment 数组长度（并发阈值，影响 segmentShift，segmentMask计算</p>
</li>
<li><p>容量大小 <code>initialCapacity &lt;= cap * ssize</code>，否则的话 cap * 2。</p>
</li>
</ol>
</li>
<li><p>JDK 1.8：数组 + 链表 + 红黑树</p>
</li>
</ul>
<h2 id="Hash-计算规则"><a href="#Hash-计算规则" class="headerlink" title="Hash 计算规则?"></a>Hash 计算规则?</h2><p>JDK1.7:</p>
<p>下边的<code>hash值</code>是通过哈希运算后的hash值，不是hashCode</p>
<ol>
<li><p>计算 Segment 下标 = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask </p>
<p>计算 Segment 数组下标是用的 hash值高几位（这里以高 4 位为例）和掩码做与运算，</p>
</li>
<li><p>计算 HashEntry 数组下标:(tab.length - 1) &amp; hash</p>
</li>
</ol>
<p>   计算 HashEntry 数组下标是直接用的 hash 值和数组长度减1做与运算。</p>
<p>这是为了尽量避免当前 hash 值计算出来的 Segment 数组下标和计算出来的 HashEntry 数组下标趋于相同。<br>简单说，就是为了避免分配到同一个 Segment 中的元素扎堆现象，即避免它们都被分配到同一条链表上，导致链表过长。同时，也是为了减少并发。</p>
<p>JDK1.8：和HashMap 相同</p>
<h2 id="并发设计"><a href="#并发设计" class="headerlink" title="并发设计?"></a>并发设计?</h2><ul>
<li>1.7：ReentrantLock，基于Segment的分段锁设计</li>
<li>1.8：CAS + synchronized 锁头节点</li>
</ul>
<h2 id="扩容规则"><a href="#扩容规则" class="headerlink" title="扩容规则?"></a>扩容规则?</h2><ul>
<li><p>JDK1.7：找到 lastRun 节点，最末尾的几个连续的节点，他们的hash值相同整体移动， 剩余节点从头开始依次<code>复制</code>，头插法插入到新的链表中。</p>
</li>
<li><p>JDK1.8：扩容规则：找到 lastRun 节点，从它到尾结点整体迁移，lastRun前边的节点则单个迁移，头插法插入到新的链表中。有一点和1.7不同，1.7 lastRun前边的节点是复制过去的，而这里是直接迁移的，没有复制操作。</p>
<img src="/pics/image-20220302225438226.png" alt="image-20220302225438226" style="zoom:50%;" /></li>
</ul>
<h1 id="三、JUC"><a href="#三、JUC" class="headerlink" title="三、JUC"></a>三、JUC</h1><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>特性：</p>
<ul>
<li>保证可见性 </li>
<li>保证有序性，禁止指令重排 -&gt; 单例 半初始化问题</li>
<li>不保证原子性（需要借助synchronized或者CAS)</li>
</ul>
<p>底层实现：lock指令 </p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>分类：</p>
<ul>
<li><p>乐观 （CAS）+ 悲观（synchronized）</p>
<p>是否锁定资源</p>
</li>
<li><p>自旋锁 VS 适应性自旋锁</p>
<p>如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p>
</li>
<li><p>公平 + 非公平：是否按照顺序获取锁</p>
</li>
<li><p>重入 + 非可重入：同一个线程多次重入</p>
</li>
<li><p>独占锁 + 共享锁:</p>
</li>
</ul>
<h3 id="CAS（compare-And-swap）"><a href="#CAS（compare-And-swap）" class="headerlink" title="CAS（compare And swap）"></a>CAS（compare And swap）</h3><ol>
<li><p>原理：比较和交换（原子性），cas 的原子性是由底层CPU指令<code>x86(cmpxchg)</code>支持的 </p>
<p>UnSafe类（C 实现） </p>
</li>
<li><p>应用：Atomic XXX</p>
</li>
<li><p>问题：</p>
<ol>
<li> 循环时间长开销大   </li>
<li>对象原子性操作：AtomicStampedReference</li>
<li>ABA 问题（AtomicStampedReference，添加版本号）</li>
</ol>
</li>
<li><p>自旋：不断的进行CAS 操作，通常会配置自旋的次数，防止死循环。</p>
</li>
</ol>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><ul>
<li>原子性</li>
<li>可见性</li>
<li>有序性</li>
</ul>
<p>Java 中每个Object 都拥有一把锁，存放在对象头中。</p>
<h4 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h4><p>8 bytes的倍数，方便CPU读取。</p>
<ul>
<li><p>对象头：KlassPointer + 数组长度 + markWord （锁状态 + 分代年龄，垃圾回收）</p>
<p>markWord （8字节）</p>
</li>
<li><p>数据</p>
</li>
<li><p>对齐</p>
<img src="/pics/image-20220307231703179.png" alt="image-20220307231703179" style="zoom:50%;" /></li>
</ul>
<h4 id="锁状态"><a href="#锁状态" class="headerlink" title="锁状态"></a>锁状态</h4><ul>
<li><p>无锁：没有加锁，</p>
</li>
<li><p>偏向锁：只有一个线程访问资源且没有竞争。</p>
<p>markWord 中记录着偏向线程的id</p>
</li>
<li><p>轻量级锁：多个线程访问锁单没有竞争。</p>
<p>指向Java 栈中锁记录的指针，复制对象头中markRecord到 Java栈中LockRecord，并且生成双向指针。其他线程自旋等待</p>
</li>
<li><p>重量级锁：<code>Object Monitor</code></p>
<ol>
<li>对象的实现：字节码<code>monitorenter/monitorexit </code>  底层实现 <code>ObjectMonitor</code> 对象， <code>entrySet + owner+ waitSet</code></li>
<li>方法的实现：字节码中（ACC_SYNCHRONIZED）</li>
</ol>
</li>
</ul>
<h4 id="volatile-vs-synchronized"><a href="#volatile-vs-synchronized" class="headerlink" title="volatile   vs   synchronized"></a>volatile   vs   synchronized</h4><table>
<thead>
<tr>
<th>volatile</th>
<th>synchronized</th>
</tr>
</thead>
<tbody><tr>
<td>修饰变量</td>
<td>修饰方法 代码段</td>
</tr>
<tr>
<td>可见性/不保证原子性</td>
<td>可见性+原子性+有序性</td>
</tr>
<tr>
<td>不会造成线程阻塞</td>
<td>会造成线程阻塞</td>
</tr>
</tbody></table>
<h4 id="synchrionized-VS-ReentrantLock"><a href="#synchrionized-VS-ReentrantLock" class="headerlink" title="synchrionized VS ReentrantLock"></a>synchrionized VS ReentrantLock</h4><table>
<thead>
<tr>
<th></th>
<th>synchrionized</th>
<th>ReentrantLock</th>
</tr>
</thead>
<tbody><tr>
<td>公平性</td>
<td>非公平</td>
<td>公平/非公平</td>
</tr>
<tr>
<td>支持中断</td>
<td>否</td>
<td>是， lockInterruptibly</td>
</tr>
<tr>
<td>等待队列</td>
<td>1个</td>
<td>多个Condition队列</td>
</tr>
<tr>
<td>实现原理</td>
<td>ObjectMonitor(JVM)</td>
<td>aqs + volatile(JDK)</td>
</tr>
</tbody></table>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>抽象队列同步器，JUC 包的基石，ReentrantLock + ReentrantReadWriteLock + Countdownlaunch + Semaphore等都是基于AQS的；包括线程池 Worker也是继承AQS。</p>
<p><strong>核心思想</strong>：如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。</p>
<p><strong>核心原理</strong>：</p>
<ol>
<li><p>互斥变量的设计和如何保证互斥变量的线程安全性？</p>
<p>通过volatile + cas。ivolatile state值表示锁状态，&gt;0 表示被锁定，=0表示无锁。一个线程获取锁时，如果state=0 ，会被更新为1，表示被占用。</p>
<p>当多个线程同时获取锁时，为保证共享变量更新的原子性，需要CAS机制更新。</p>
</li>
<li><p>线程阻塞和唤醒</p>
<p>多个线程同时获取锁时，没有获取到锁的线程会被阻塞，在锁被释放后再进行竞争。</p>
<p> 线程阻塞和唤醒基于的是同步队列，同步队列是一个FIFO双向队列，当出现资源竞争需要阻塞时，就会将竞争的线程包装成一个Node节点，放入同步队列中。同时会调用UnSafe#park将线程阻塞；当锁被释放后，在通过UnSafe#unpark 会唤醒同步队列中的下一个线程节点，再次获取锁。</p>
</li>
<li><p>公平和非公平性</p>
<p>AQS在获取锁时，公平锁会去判断当前同步队列是不是为空，如果不为空，则需要加入同步队列进行等待；</p>
<p>而非公平锁会不管同步队列中是否有阻塞的线程，都先通过cas获取一下锁，如果获取到了就先执行，否则就加入同步队列。</p>
</li>
<li><p>独占共享：</p>
<p>ReentrantLock 是独占锁，state&gt;0 时判断当前的持有锁线程和要获取锁的线程是不是一个</p>
<p> ReentrantReadWriteLock ：读锁是共享锁获取读锁的时候会判断写锁的状态，如有写锁没有被持有</p>
<p>写锁是排他锁</p>
<p>共享锁：CountDownlaunch + Semaphore</p>
<p> 中断的原理：AQS中，检测到中断时，是否抛异常，自旋获取锁的方法中</p>
</li>
<li><p>超时的原理：UnSafe类park超时返回</p>
</li>
<li><p>等待唤醒机制：condition 队列，await或notify时线程已经获取到锁了。</p>
<p>await：释放Node节点的锁，挂起节点线程（当前线程），创建新节点加入到条件队列中</p>
<p>notify：将条件队列中的节点移动到同步队列中，唤醒节点线程竞争锁。      </p>
</li>
</ol>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>每个Thread 维护一个 <code>ThreadLocalMap</code> 映射表，这个映射表的 key是 ThreadLocal 实例本身，value 是真正需要存储的 Object。<br><code>Thread#ThreadLocalMap&lt;Entry&lt;WeakReference&lt;ThreadLocal&gt;, Object&gt;&gt;</code><br>内存泄露：<br>Threadlocal是弱引用对象，当发生GC时，会被置位null，ThreadLocal中Entry对象的key变为null，但是Object是强引用，不能被回收。<br>当线程生命周期没有被终结的时候，object 就不能被回收。</p>
<ol>
<li>使用完成后，手动调用下remove方法，清除数据。</li>
<li>set 、get方法中也会清除key 为null的数据</li>
<li>使用线程池的情况下，没有及时清理ThreadLocal，可能导致业务逻辑异常。</li>
</ol>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
  </entry>
  <entry>
    <title>非暴力沟通</title>
    <url>/2020/12/07/Notes/Read/0001-%E9%9D%9E%E6%9A%B4%E5%8A%9B%E6%B2%9F%E9%80%9A/</url>
    <content><![CDATA[<h1 id="非暴力沟通"><a href="#非暴力沟通" class="headerlink" title="非暴力沟通"></a>非暴力沟通</h1><span id="more"></span>

<h2 id="一、非暴力沟通模式"><a href="#一、非暴力沟通模式" class="headerlink" title="一、非暴力沟通模式"></a>一、非暴力沟通模式</h2><h2 id="1、诚实的表达自己，而不批评指责"><a href="#1、诚实的表达自己，而不批评指责" class="headerlink" title="1、诚实的表达自己，而不批评指责"></a>1、诚实的表达自己，而不批评指责</h2><h4 id="（1）观察"><a href="#（1）观察" class="headerlink" title="（1）观察"></a>（1）观察</h4><p> 我所观察（看、听、回忆、想）到的有助于（或无助于）我的福祉的具体行为：</p>
<p>“当我看、听、回忆、想到、听到 …”  </p>
<h4 id="（2）感受"><a href="#（2）感受" class="headerlink" title="（2）感受"></a>（2）感受</h4><p>对于这些行为，我有什么感受（情感而非思想）：</p>
<p>“我感到 …”</p>
<h4 id="（3-需要"><a href="#（3-需要" class="headerlink" title="（3)  需要"></a>（3)  需要</h4><p>什么样的需要或者价值（而非偏好或某种具体的行为）导致我那样的感受：</p>
<p>“因为我需要/看重…”</p>
<h4 id="（4）请求"><a href="#（4）请求" class="headerlink" title="（4）请求"></a>（4）请求</h4><p>清楚的请求（而非命令）那些能丰富我生命的具体行为，</p>
<p>“你是否愿意 …?”</p>
<h3 id="2、关切的倾听他人、而不解读为批评或指责"><a href="#2、关切的倾听他人、而不解读为批评或指责" class="headerlink" title="2、关切的倾听他人、而不解读为批评或指责"></a>2、关切的倾听他人、而不解读为批评或指责</h3><h4 id="（1）观察-1"><a href="#（1）观察-1" class="headerlink" title="（1）观察"></a>（1）观察</h4><p>你所观察（看、听、回忆、想）到的有助于（或无助于）我的福祉的具体行为：</p>
<p>“当你看、听、回忆、想到、听到 …”  </p>
<h4 id="（2）感受-1"><a href="#（2）感受-1" class="headerlink" title="（2）感受"></a>（2）感受</h4><p>对于这些行为，你有什么感受（情感而非思想）：</p>
<p>“你感到 …吗？”</p>
<h4 id="（3）需要"><a href="#（3）需要" class="headerlink" title="（3）需要"></a>（3）需要</h4><p>什么样的需要或者价值（而非偏好或某种具体的行为）导致你那样的感受：</p>
<p>“因为你需要/看重…”</p>
<h4 id="（4）需要"><a href="#（4）需要" class="headerlink" title="（4）需要"></a>（4）需要</h4><p>关注倾听那些能丰富你生命的具体请求，而不解读为命令：</p>
<p>“所以，你想..“</p>
<h2 id="二、培育对自己的爱"><a href="#二、培育对自己的爱" class="headerlink" title="二、培育对自己的爱"></a>二、培育对自己的爱</h2><h3 id="非暴力最重要的应用在于培育对自己的爱"><a href="#非暴力最重要的应用在于培育对自己的爱" class="headerlink" title="非暴力最重要的应用在于培育对自己的爱"></a>非暴力最重要的应用在于培育对自己的爱</h3><ol>
<li>评价自己的行为时，专注于尚未满足的需要，不要依赖羞愧，内疚或沮丧的心理来寻求改变的而让爱主导我们的学习和成长。</li>
<li>根据自己的需要和价值观来选择生活。我们的行为不再是为了履行职责、获得回报、逃避惩罚或避免内心愧疚和羞愧。</li>
<li>用选择做代替不得不，我们的生活将变得充满和谐和快乐。</li>
</ol>
<h2 id="三、充分表达愤怒"><a href="#三、充分表达愤怒" class="headerlink" title="三、充分表达愤怒"></a>三、充分表达愤怒</h2><h3 id="（1）停下来，什么都不做"><a href="#（1）停下来，什么都不做" class="headerlink" title="（1）停下来，什么都不做"></a>（1）停下来，什么都不做</h3><h3 id="（2）想一想什么使我们生气了"><a href="#（2）想一想什么使我们生气了" class="headerlink" title="（2）想一想什么使我们生气了"></a>（2）想一想什么使我们生气了</h3><h3 id="（3）体会自己的需要"><a href="#（3）体会自己的需要" class="headerlink" title="（3）体会自己的需要"></a>（3）体会自己的需要</h3><h3 id="（4）表达自己的感受和需要"><a href="#（4）表达自己的感受和需要" class="headerlink" title="（4）表达自己的感受和需要"></a>（4）表达自己的感受和需要</h3><p>在第三和第四步之间，需要先倾听他人。在得到倾听和理解之后，他们就可以静下心来体会我们的感受和需要了。</p>
<h2 id="四、表达感激"><a href="#四、表达感激" class="headerlink" title="四、表达感激"></a>四、表达感激</h2><h4 id="（1）对方做了什么事情使我们的生活得到了改善"><a href="#（1）对方做了什么事情使我们的生活得到了改善" class="headerlink" title="（1）对方做了什么事情使我们的生活得到了改善;"></a>（1）对方做了什么事情使我们的生活得到了改善;</h4><h4 id="（2）我们有哪些需要得到了满足"><a href="#（2）我们有哪些需要得到了满足" class="headerlink" title="（2）我们有哪些需要得到了满足;"></a>（2）我们有哪些需要得到了满足;</h4><h4 id="（3）我们的心情怎么样？"><a href="#（3）我们的心情怎么样？" class="headerlink" title="（3）我们的心情怎么样？"></a>（3）我们的心情怎么样？</h4>]]></content>
      <categories>
        <category>Read</category>
      </categories>
  </entry>
  <entry>
    <title>Design01_设计模式之美</title>
    <url>/2022/12/25/Notes/Design/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/</url>
    <content><![CDATA[<h1 id="设计模式之美"><a href="#设计模式之美" class="headerlink" title="设计模式之美"></a>设计模式之美</h1><span id="more"></span>

<p><img src="/pics/image-20200417165625730.png" alt="image-20200417165625730"></p>
<h2 id="一、面向对象"><a href="#一、面向对象" class="headerlink" title="一、面向对象"></a>一、面向对象</h2><h2 id="1-1-什么是面向对象"><a href="#1-1-什么是面向对象" class="headerlink" title="1.1 什么是面向对象"></a>1.1 什么是面向对象</h2><p><strong>面向对象编程是一种编程范式或编程风格</strong>。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。</p>
<p><strong>面向对象编程语言是支持类或对象的语法机制</strong>，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。</p>
<h4 id="1-面向对象分析（OOA）-amp-面向对象设计（OOD）-amp-面向对象编程（OOP）"><a href="#1-面向对象分析（OOA）-amp-面向对象设计（OOD）-amp-面向对象编程（OOP）" class="headerlink" title="1. 面向对象分析（OOA）&amp; 面向对象设计（OOD）&amp; 面向对象编程（OOP）"></a>1. 面向对象分析（OOA）&amp; 面向对象设计（OOD）&amp; 面向对象编程（OOP）</h4><p>面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做，面向对象编程就是将分析和设计的的结果翻译成代码的过程。</p>
<h4 id="2-如何进行面向对象设计？"><a href="#2-如何进行面向对象设计？" class="headerlink" title="2. 如何进行面向对象设计？"></a>2. 如何进行面向对象设计？</h4><ul>
<li>划分职责进而识别出有哪些类；</li>
<li>定义类及其属性和方法；</li>
<li>定义类与类之间的交互关系；</li>
<li>将类组装起来并提供执行入口。</li>
</ul>
<h4 id="3-类与类之间的交互关系"><a href="#3-类与类之间的交互关系" class="headerlink" title="3. 类与类之间的交互关系"></a>3. 类与类之间的交互关系</h4><p>类与类之间都哪些交互关系呢？UML 统一建模语言中定义了六种类之间的关系。它们分别是：泛化、实现、关联、聚合、组合、依赖。关系比较多，而且有些还比较相近，比如聚合和组合，接下来我就逐一讲解一下。</p>
<p>泛化（Generalization）可以简单理解为继承关系。具体到 Java 代码就是下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>实现（Realization）一般是指接口和实现类之间的关系。具体到 Java 代码就是下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>聚合（Aggregation）是一种包含关系，A 类对象包含 B 类对象，B 类对象的生命周期可以不依赖 A 类对象的生命周期，也就是说可以单独销毁 A 类对象而不影响 B 对象，比如课程与学生之间的关系。具体到 Java 代码就是下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; </span><br><span class="line">	<span class="keyword">private</span> B b; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(B b)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">this</span>.b = b; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组合（Composition）也是一种包含关系。A 类对象包含 B 类对象，B 类对象的生命周期跟依赖 A 类对象的生命周期，B 类对象不可单独存在，比如鸟与翅膀之间的关系。具体到 Java 代码就是下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> B b; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    	<span class="keyword">this</span>.b = <span class="keyword">new</span> B(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关联（Association）是一种非常弱的关系，<strong>包含聚合、组合两种关系</strong>。具体到代码层面，如果 B 类对象是 A 类的成员变量，那 B 类和 A 类就是关联关系。具体到 Java 代码就是下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> B b; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(B b)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">this</span>.b = b; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">this</span>.b = <span class="keyword">new</span> B(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依赖（Dependency）是一种比关联关系更加弱的关系，包含关联关系。不管是 B 类对象是 A 类对象的成员变量，还是 A 类的方法使用 B 类对象作为参数或者返回值、局部变量，只要 B 类对象和 A 类对象有任何使用关系，我们都称它们有依赖关系。具体到 Java 代码就是下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class A &#123; </span><br><span class="line">    private B b; </span><br><span class="line">    public A(B b) &#123;</span><br><span class="line">    	this.b = b; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line">public class A &#123;</span><br><span class="line">    private B b; </span><br><span class="line">    public A() &#123; </span><br><span class="line">    	this.b = new B(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line">public class A &#123;</span><br><span class="line">	public void func(B b) &#123;</span><br><span class="line">		... </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-面向对象的四大特性"><a href="#1-2-面向对象的四大特性" class="headerlink" title="1.2 面向对象的四大特性"></a>1.2 面向对象的四大特性</h2><ul>
<li><p>封装：封装特性存在的意义，一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用性。</p>
</li>
<li><p>抽象：抽象存在的意义，一方面是提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围；另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。</p>
</li>
<li><p>继承：继承主要是用来解决代码复用的问题。</p>
</li>
<li><p>多态：多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础</p>
</li>
</ul>
<h2 id="1-3-面向对象编程-vs-面向过程编程（OPP）"><a href="#1-3-面向对象编程-vs-面向过程编程（OPP）" class="headerlink" title="1.3 面向对象编程 vs 面向过程编程（OPP）"></a>1.3 面向对象编程 vs 面向过程编程（OPP）</h2><h4 id="1-OOP-更加能够应对大规模复杂程序的开发"><a href="#1-OOP-更加能够应对大规模复杂程序的开发" class="headerlink" title="1. OOP 更加能够应对大规模复杂程序的开发"></a>1. OOP 更加能够应对大规模复杂程序的开发</h4><p>面向对象编程是以类为思考对象。在进行面向对象编程的时候，我们并不是一上来就去思考，如何将复杂的流程拆解为一个一个方法，而是采用曲线救国的策略，<strong>先去思考如何给业务建模，如何将需求翻译为类，如何给类之间建立交互关系，而完成这些工作完全不需要考虑错综复杂的处理流程</strong>。当我们有了类的设计之后，然后再像搭积木一样，按照处理流程，将类组装起来形成整个程序。</p>
<h4 id="2-OOP-风格的代码更易复用、易扩展、易维护"><a href="#2-OOP-风格的代码更易复用、易扩展、易维护" class="headerlink" title="2. OOP 风格的代码更易复用、易扩展、易维护"></a>2. OOP 风格的代码更易复用、易扩展、易维护</h4><p>面向对象编程提供的封装、抽象、继承、多态这些特性，能极大地满足复杂的编程需求，能方便我们写出更易 复用、易扩展、易维护的代码。</p>
<h4 id="3-OOP-语言更加人性化、更加高级、更加智能"><a href="#3-OOP-语言更加人性化、更加高级、更加智能" class="headerlink" title="3. OOP 语言更加人性化、更加高级、更加智能"></a>3. OOP 语言更加人性化、更加高级、更加智能</h4><p>跟二进制指令、汇编语言、面向过程编程语言相比，面向对象编程语言的编程套路、思考问题的方式，是完全 不一样的。前三者是一种计算机思维方式，而面向对象是一种人类的思维方式。我们在用前面三种语言编程的时候，我们是在思考，如何设计一组指令，告诉机器去执行这组指令，操作某些数据，帮我们完成某个任务。而<strong>在进行面向对象编程时候，我们是在思考，如何给业务建模，如何将真实的世界映射为类或者对象，这让我们更加能聚焦到业务本身，而不是思考如何跟机器打交道。</strong>可以这么说，越高级的编程语言离机器越“远”，离我们人类越“近”，越“智能”。</p>
<h2 id="1-4-面向对象误区"><a href="#1-4-面向对象误区" class="headerlink" title="1.4 面向对象误区"></a>1.4 面向对象误区</h2><h4 id="1-哪些代码设计看似是面向对象，实际是面向过程的？"><a href="#1-哪些代码设计看似是面向对象，实际是面向过程的？" class="headerlink" title="1. 哪些代码设计看似是面向对象，实际是面向过程的？"></a>1. 哪些代码设计看似是面向对象，实际是面向过程的？</h4><ol>
<li><p>滥用 getter、setter 方法</p>
<p>在设计实现类的时候，除非真的需要，否则尽量不要给属性定义 setter 方法。除此之外，尽管 getter 方法相对 setter 方法要安全些，但是如果返回的是集合容器，那也要防范集合内部数据被修改的风险。</p>
</li>
<li><p>Constants 类、Utils 类的设计问题</p>
<p>对于这两种类的设计，我们尽量能做到职责单一，定义一些细化的小类，比如 RedisConstants、FileUtils，而不是定义一个大而全的 Constants 类、Utils 类。除此之外，如果能将这些类中的属性和方法，划分归并到其他业务类中，那是最好不过的了，能极大地提高类的内聚性和代码的可复用性。</p>
</li>
</ol>
<h4 id="2-在面向对象编程中，为什么容易写出面向过程风格的代码？"><a href="#2-在面向对象编程中，为什么容易写出面向过程风格的代码？" class="headerlink" title="2. 在面向对象编程中，为什么容易写出面向过程风格的代码？"></a>2. 在面向对象编程中，为什么容易写出面向过程风格的代码？</h4><ol>
<li><p>面向过程更符合人类的思考习惯。</p>
<p>你可以联想一下，在生活中，你去完成一个任务，你一般都会思考，应该先做什么、后做什么，如何一步一步地顺序执行一系列操作，最后完成整个任务。面向过程编程风格恰恰符合人的这种流程化思维方式。而面向对象编程风格正好相反。它是一种自底向上的思考方式。它不是先去按照执行流程来分解任务，而是将任务翻译成一个一个的小的模块（也就是类），设计类之间的交互，最后按照流程将类组装起来，完成整个任务。</p>
</li>
<li><p>面向对象编程要比面向过程编程难一些。</p>
<p>在面向对象编程中，类的设计还是挺需要技巧，挺需要一定设计经验的。你要去思考如何封装合适的数据和方法到一个类里，如何设计类之间的关系，如何设计类之间的交互等等诸多设计问题。</p>
</li>
</ol>
<h4 id="3-面向过程编程及面向过程编程语言就真的无用武之地了吗？"><a href="#3-面向过程编程及面向过程编程语言就真的无用武之地了吗？" class="headerlink" title="3. 面向过程编程及面向过程编程语言就真的无用武之地了吗？"></a>3. 面向过程编程及面向过程编程语言就真的无用武之地了吗？</h4><p>实际上，面向过程编程是面向对象编程的基础，面向对象编程离不开基础的面向过程编程。为什么这么说？我们仔细想想，类中每个方法的实现逻辑，不就是面向过程风格的代码吗？</p>
<p>不管使用面向过程还是面向对象哪种风格来写代码，我们最终的目的还是写出易维护、易读、易复用、易扩展的高质量代码。只要我们能避免面向过程编程风格的一些弊端，控制好它的副作用，在掌控范围内为我们所用，我们就大可不用避讳在面向对象编程中写面向过程风格的代码。重点回顾</p>
<h2 id="1-5-接口-vs-抽象类"><a href="#1-5-接口-vs-抽象类" class="headerlink" title="1.5 接口 vs 抽象类"></a>1.5 接口 vs 抽象类</h2><h4 id="1-接口和抽象类的区别"><a href="#1-接口和抽象类的区别" class="headerlink" title="1. 接口和抽象类的区别"></a>1. 接口和抽象类的区别</h4><p>抽象类特性：</p>
<ul>
<li>抽象类不允许被实例化，只能被继承。也就是说，你不能 new 一个抽象类的对象出来。</li>
<li>抽象类可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的方法叫作抽象方法。</li>
<li>子类继承抽象类，必须实现抽象类中的所有抽象方法。</li>
</ul>
<p>相比于普通类，抽象类具有多态的特性，同时明确标记需要子类复写的方法，避免出错。</p>
<p>接口的特性：</p>
<ul>
<li><p>接口不能包含属性（也就是成员变量）。</p>
</li>
<li><p>接口只能声明方法，方法不能包含代码实现。</p>
</li>
<li><p>类实现接口的时候，必须实现接口中声明的所有方法。</p>
</li>
</ul>
<p>抽象类更多的是为了代码复用，而接口就更侧重于解耦。接口是对行为的一种抽象，相当于一组协议或者契约，你可以联想类比一下 API 接口。调用者只需要关注抽象的接口，不需要了解具体的实现，具体的实现代码对调用者透明。接口实现了约定和实现相分离，可以降低代码间的耦合性，提高代码的可扩展性。</p>
<h4 id="2-如何决定该用抽象类还是接口？"><a href="#2-如何决定该用抽象类还是接口？" class="headerlink" title="2. 如何决定该用抽象类还是接口？"></a>2. 如何决定该用抽象类还是接口？</h4><p>实际上，判断的标准很简单。<strong>如果我们要表示一种 is-a 的关系，并且是为了解决代码复用的问题</strong>，我们就用抽象类；<strong>如果我们要表示一种 has-a 关系，并且是为了解决抽象而非代码复用的问题</strong>，那我们就可以使用接口。</p>
<p>从类的继承层次上来看，<strong>抽象类是一种自下而上的设计思路</strong>，先有子类的代码重复，然后再抽象成上层的父类（也就是抽象类）。而接口正好相反，<strong>它是一种自上而下的设计思路</strong>。我们在编程的时候，一般都是先设计接口，再去考虑具体的实现。</p>
<h2 id="1-6-基于接口编程"><a href="#1-6-基于接口编程" class="headerlink" title="1.6 基于接口编程"></a>1.6 基于接口编程</h2><h4 id="1-基于接口而非实现编程"><a href="#1-基于接口而非实现编程" class="headerlink" title="1. 基于接口而非实现编程"></a>1. 基于接口而非实现编程</h4><p>应用这条原则，可以将接口和实现相分离，<strong>封装不稳定的实现，暴露稳定的接口</strong>。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低耦合性，提高扩展性。</p>
<p>“基于接口而非实现编程”这条原则的另一个表述方式，是“基于抽象而非实现编程”。后者的表述方式其实更能体现这条原则的设计初衷。在软件开发中，最大的挑战之一就是需求的不断变化，这也是考验代码设计好坏的一个标准。<strong>越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。</strong>而抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。</p>
<p>“基于接口而非实现编程”的原则，具体来讲，我们需要做到下面这 3 点。</p>
<ol>
<li>函数的命名不能暴露任何实现细节，使用更加抽象的命名方式。与特定实现有关的方法不要定义在接口中。</li>
<li>封装具体的实现细节。</li>
<li>具体的实现类都依赖统一的接口定义，遵从一致的上传功能协议。使用者依赖接口，而不是具体的实现类来编程</li>
</ol>
<h4 id="2-有必要为每个类都定义接口吗？"><a href="#2-有必要为每个类都定义接口吗？" class="headerlink" title="2. 有必要为每个类都定义接口吗？"></a>2. 有必要为每个类都定义接口吗？</h4><p>从这个设计初衷上来看，如果在我们的业务场景中<strong>，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口</strong>，也没有必要基于接口编程，直接使用实现类就可以了。</p>
<h2 id="1-7-组合-vs-继承"><a href="#1-7-组合-vs-继承" class="headerlink" title="1.7 组合 vs 继承"></a>1.7 组合 vs 继承</h2><h4 id="1-为什么不推荐使用继承？"><a href="#1-为什么不推荐使用继承？" class="headerlink" title="1. 为什么不推荐使用继承？"></a>1. 为什么不推荐使用继承？</h4><p>继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。在这种情况下，我们应该尽量少用，甚至不用继承。</p>
<h4 id="2-组合相比继承有哪些优势？"><a href="#2-组合相比继承有哪些优势？" class="headerlink" title="2. 组合相比继承有哪些优势？"></a>2. 组合相比继承有哪些优势？</h4><p>继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用。而这三个作用都可以通过组合、接口、委托三个技术手段来达成。除此之外，利用组合还能解决层次过深、过复杂的继承关系影响代码可维护性的问题。</p>
<h4 id="3-如何判断该用组合还是继承？"><a href="#3-如何判断该用组合还是继承？" class="headerlink" title="3. 如何判断该用组合还是继承？"></a>3. 如何判断该用组合还是继承？</h4><p>尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。在实际的项目开发中，我们还是要根据具体的情况，来选择该用继承还是组合。如果类之间的继承结构稳定，层次比较浅，关系不复杂，我们就可以大胆地使用继承。反之，我们就尽量使用组合来替代继承。除此之外，还有一些设计模式、特殊的应用场景，会固定使用继承或者组合。</p>
<h2 id="二、设计原则与思想"><a href="#二、设计原则与思想" class="headerlink" title="二、设计原则与思想"></a>二、设计原则与思想</h2><p>我们开始学习一些经典的设计原则，其中包括，SOLID、KISS、YAGNI、DRY、LOD 等。 这些设计原则，从字面上理解，都不难。你一看就感觉懂了，一看就感觉掌握了，但真的用到项目中的时候，你会发现，“看懂”和“会用”是两回事，而“用好”更是难上加难。</p>
<h2 id="2-1-SOLID-原则"><a href="#2-1-SOLID-原则" class="headerlink" title="2.1 SOLID 原则"></a>2.1 SOLID 原则</h2><p>实际上，SOLID 原则并非单纯的 1 个原则，而是由 5 个设计原则组成的，它们分别是：单一职责原则、开闭原则、里式替换原则、接口隔离原则和依赖反转原则，依次对应 SOLID 中的 S、O、L、I、D 这 5 个英文字母。</p>
<h3 id="2-1-1-单一职责原则（SRP）"><a href="#2-1-1-单一职责原则（SRP）" class="headerlink" title="2.1.1 单一职责原则（SRP）"></a>2.1.1 单一职责原则（SRP）</h3><p>一个类或者模块只负责完成一个职责（或者功能）。从类的角度来讲，不要设计大而全的类，要设计粒度小、功能单一的类。换个角度来讲就是，一个类包含了两个或者两个以上业务不相干的功能，那我们就说它职责不够单一，应该将它拆分成多个功能更加单一、粒度更细的类。</p>
<h4 id="1-如何理解单一职责原则（SRP-–-Single-Responsibility-Principle）？"><a href="#1-如何理解单一职责原则（SRP-–-Single-Responsibility-Principle）？" class="headerlink" title="1.如何理解单一职责原则（SRP – Single Responsibility Principle）？"></a>1.如何理解单一职责原则（SRP – Single Responsibility Principle）？</h4><p>一个类只负责完成一个职责或者功能。不要设计大而全的类，要设计粒度小、功能单一的类。单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。</p>
<h4 id="2-如何判断类的职责是否足够单一？"><a href="#2-如何判断类的职责是否足够单一？" class="headerlink" title="2.如何判断类的职责是否足够单一？"></a>2.如何判断类的职责是否足够单一？</h4><p>不同的应用场景、不同阶段的需求背景、不同的业务层面，对同一个类的职责是否单一，可能会有不同的判定结果。实际上，一些侧面的判断指标更具有指导意义和可执行性，比如，出现下面这些情况就有可能说明这类的设计不满足单一职责原则：</p>
<ul>
<li><p>类中的代码行数、函数或者属性过多；</p>
</li>
<li><p>类依赖的其他类过多，或者依赖类的其他类过多；</p>
</li>
<li><p>私有方法过多；</p>
</li>
<li><p>比较难给类起一个合适的名字；</p>
</li>
<li><p>类中大量的方法都是集中操作类中的某几个属性。</p>
</li>
</ul>
<h4 id="3-类的职责是否设计得越单一越好？"><a href="#3-类的职责是否设计得越单一越好？" class="headerlink" title="3.类的职责是否设计得越单一越好？"></a>3.类的职责是否设计得越单一越好？</h4><p>单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、低耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。</p>
<h3 id="2-1-2-开闭原则（OCP）"><a href="#2-1-2-开闭原则（OCP）" class="headerlink" title="2.1.2 开闭原则（OCP）"></a>2.1.2 开闭原则（OCP）</h3><p>软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。</p>
<p>这个描述比较简略，如果我们详细表述一下，那就是，添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。</p>
<h4 id="1-如何理解“对扩展开放、对修改关闭”？"><a href="#1-如何理解“对扩展开放、对修改关闭”？" class="headerlink" title="1.如何理解“对扩展开放、对修改关闭”？"></a>1.如何理解“对扩展开放、对修改关闭”？</h4><p>添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。关于定义，我们有两点要注意。</p>
<p>第一点是，开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。</p>
<p>第二点是，同样的代码改动，在粗代码粒度下，可能被认定为“修改”；在细代码粒度下，可能又被认定为“扩展”。</p>
<h4 id="2-如何做到“对扩展开放、修改关闭”？"><a href="#2-如何做到“对扩展开放、修改关闭”？" class="headerlink" title="2.如何做到“对扩展开放、修改关闭”？"></a>2.如何做到“对扩展开放、修改关闭”？</h4><p>我们要时刻具备扩展意识、抽象意识、封装意识。在写代码的时候，我们要多花点时间思考一下，这段代码未来可能有哪些需求变更，如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，在不改动代码整体结构、做到最小代码改动的情况下，将新的代码灵活地插入到扩展点上。</p>
<p>很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的。特别是 23 种经典设计模式，大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的。最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态）。</p>
<h3 id="2-1-3-里式替换（LSP）"><a href="#2-1-3-里式替换（LSP）" class="headerlink" title="2.1.3 里式替换（LSP）"></a>2.1.3 里式替换（LSP）</h3><p>子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且<strong>保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。</strong></p>
<h4 id="1-如何理解“里式替换原则”？"><a href="#1-如何理解“里式替换原则”？" class="headerlink" title="1.如何理解“里式替换原则”？"></a>1.如何理解“里式替换原则”？</h4><p>理解里式替换原则，最核心的就是理解“design by contract，<strong>按照协议来设计</strong>”这几个字。父类定义了函数的“约定”（或者叫协议），那子类可以改变函数的内部实现逻辑，但不能改变函数原有的“约定”。这里的约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。</p>
<h4 id="2-里式替换-vs-多态"><a href="#2-里式替换-vs-多态" class="headerlink" title="2.里式替换 vs 多态"></a>2.里式替换 vs 多态</h4><p>理解这个原则，我们还要弄明白里式替换原则跟多态的区别。虽然从定义描述和代码实现上来看，多态和里式替换有点类似，但它们关注的角度是不一样的。<strong>多态是面向对象编程的一大特性</strong>，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而<strong>里式替换是一种设计原则</strong>，用来指导继承关系中子类该如何设计<strong>，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性</strong>。</p>
<h4 id="3-哪些代码明显违背了-LSP？"><a href="#3-哪些代码明显违背了-LSP？" class="headerlink" title="3.哪些代码明显违背了 LSP？"></a>3.哪些代码明显违背了 LSP？</h4><ol>
<li>子类违背父类声明要实现的功能父类中提供的 sortOrdersByAmount() 订单排序函数，是按照金额从小到大来给订单排序的，而子类重写这个 sortOrdersByAmount() 订单排序函数之后，是按照创建日期来给订单排序的。那子类的设计就违背里式替换原则。</li>
<li>子类违背父类对输入、输出、异常的约定在父类中，某个函数约定：运行出错的时候返回 null；获取数据为空的时候返回空集合（empty collection）。而子类重载函数之后，实现变了，运行出错返回异常（exception），获取不到数据返回 null。那子类的设计就违背里式替换原则。在父类中，某个函数约定，输入数据可以是任意整数，但子类实现的时候，只允许输入数据是正整数，负数就抛出，也就是说，子类对输入的数据的校验比父类更加严格，那子类的设计就违背了里式替换原则。在父类中，某个函数约定，只会抛出 ArgumentNullException 异常，那子类的设计实现中只允许抛出 ArgumentNullException 异常，任何其他异常的抛出，都会导致子类违背里式替换原则。</li>
<li>子类违背父类注释中所罗列的任何特殊说明父类中定义的 withdraw() 提现函数的注释是这么写的：“用户的提现金额不得超过账户余额……”，而子类重写 withdraw() 函数之后，针对 VIP 账号实现了透支提现的功能，也就是提现金额可以大于账户余额，那这个子类的设计也是不符合里式替换原则的。</li>
</ol>
<h3 id="2-1-4-接口隔离原则（ISP）"><a href="#2-1-4-接口隔离原则（ISP）" class="headerlink" title="2.1.4 接口隔离原则（ISP）"></a>2.1.4 接口隔离原则（ISP）</h3><p>客户端不应该被强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者。</p>
<h4 id="1-如何理解“接口隔离原则”？"><a href="#1-如何理解“接口隔离原则”？" class="headerlink" title="1.如何理解“接口隔离原则”？"></a>1.如何理解“接口隔离原则”？</h4><p>理解“接口隔离原则”的重点是理解其中的“接口”二字。这里有三种不同的理解。</p>
<p>如果把“接口”理解为一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口等。<strong>如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。</strong></p>
<p>如果把“接口”理解为单个 API 接口或函数，<strong>部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数</strong>。</p>
<p>如果把“接口”理解为 OOP 中的接口，也可以理解为面向对象编程语言中的接口语法。<strong>那接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数</strong>。</p>
<h4 id="2-接口隔离原则与单一职责原则的区别？"><a href="#2-接口隔离原则与单一职责原则的区别？" class="headerlink" title="2.接口隔离原则与单一职责原则的区别？"></a>2.接口隔离原则与单一职责原则的区别？</h4><p>单一职责原则针对的是模块、类、接口的设计。接口隔离原则相对于单一职责原则，一方面更侧重于接口的设计，另一方面它的思考角度也是不同的。<strong>接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定</strong>。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。</p>
<h3 id="2-1-5-依赖反转原则（DIP）"><a href="#2-1-5-依赖反转原则（DIP）" class="headerlink" title="2.1.5 依赖反转原则（DIP）"></a>2.1.5 依赖反转原则（DIP）</h3><p>高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。</p>
<h4 id="1-控制反转（IOC）"><a href="#1-控制反转（IOC）" class="headerlink" title="1.控制反转（IOC）"></a>1.控制反转（IOC）</h4><p><strong>控制反转并不是一种具体的实现技巧，而是一个比较笼统的设计思想</strong>，一般用来指导框架层面的设计。框架提供了一个可扩展的代码骨架，用来组装对象、管理整个执行流程。程序员利用框架进行开发的时候，只需要往预留的扩展点上，添加跟自己业务相关的代码，就可以利用框架来驱动整个程序流程的执行，比如模板设计模式。</p>
<p>这里的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。<strong>在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员“反转”到了框架。</strong></p>
<h4 id="2-依赖注入（DI）"><a href="#2-依赖注入（DI）" class="headerlink" title="2.依赖注入（DI）"></a>2.依赖注入（DI）</h4><p>依赖注入跟控制反转恰恰相反，它是一种具体的编码技巧。不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。</p>
<p>通过依赖注入的方式来将依赖的类对象传递进来，这样就提高了代码的扩展性，我们可以灵活地替换依赖的类。</p>
<h4 id="3-依赖反转原则"><a href="#3-依赖反转原则" class="headerlink" title="3. 依赖反转原则"></a>3. 依赖反转原则</h4><p>依赖反转原则也叫作依赖倒置原则。这条原则跟控制反转有点类似，<strong>主要用来指导框架层面的设计。高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不要依赖具体实现细节，具体实现细节依赖抽象。</strong></p>
<p>所谓高层模块和低层模块的划分，简单来说就是，在调用链上，调用者属于高层，被调用者属于低层。在平时的业务代码开发中，高层模块依赖底层模块是没有任何问题的。实际上，这条原则主要还是用来指导框架层面的设计，跟前面讲到的控制反转类似。</p>
<p>高层次模块不依赖于低层次模块。看似在要求高层次模块，实际上是在规范低层次模块的设计。低层次模块提供的接口要足够的抽象、通用，在设计时需要考虑高层次模块的使用种类和场景。</p>
<p><strong>明明是高层次模块要使用低层次模块，对低层次模块有依赖性。现在反而低层次模块需要根据高层次模块来设计，出现了「倒置」的显现。</strong></p>
<h2 id="2-2-KISS原则"><a href="#2-2-KISS原则" class="headerlink" title="2.2 KISS原则"></a>2.2 KISS原则</h2><p>Keep It Short and Simple——尽量保持简单。</p>
<p>KISS 原则是保持代码可读和可维护的重要手段。KISS 原则中的“简单”并不是以代码行数来考量的。代码行数越少并不代表代码越简单，我们还要考虑逻辑复杂度、实现难度、代码的可读性等。而且，本身就复杂的问题，用复杂的方法解决，并不违背 KISS 原则。除此之外，同样的代码，在某个业务场景下满足 KISS 原则，换一个应用场景可能就不满足了。</p>
<p>如何写出满足 KISS 原则的代码？</p>
<ol>
<li>不要使用同事可能不懂的技术来实现代码；</li>
<li>不要重复造轮子，要善于使用已经有的工具类库；</li>
<li>不要过度优化。</li>
</ol>
<h2 id="2-3-YAGNI原则"><a href="#2-3-YAGNI原则" class="headerlink" title="2.3 YAGNI原则"></a>2.3 YAGNI原则</h2><p>You Ain’t Gonna Need It ——你不会需要它。</p>
<p>不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：不要做过度设计。</p>
<h2 id="2-4-DRY-原则"><a href="#2-4-DRY-原则" class="headerlink" title="2.4 DRY 原则"></a>2.4 DRY 原则</h2><p>Don’t Repeat Yourself ——不要重复自己。将它应用在编程中，可以理解为：不要写重复的代码。</p>
<h4 id="1-三种代码重复的情况？"><a href="#1-三种代码重复的情况？" class="headerlink" title="1. 三种代码重复的情况？"></a>1. 三种代码重复的情况？</h4><p>实现逻辑重复、功能语义重复、代码执行重复。<strong>实现逻辑重复，但功能语义不重复的代码，并不违反 DRY 原则</strong>。对于包含重复代码的问题，我们可以通过抽象成更细粒度函数的方式来解决。<strong>实现逻辑不重复，但功能语义重复的代码</strong>，也算是违反 DRY 原则。除此之外，代码执行重复也算是违反 DRY 原则。</p>
<h4 id="2-代码的复用性？"><a href="#2-代码的复用性？" class="headerlink" title="2.代码的复用性？"></a>2.代码的复用性？</h4><p>我们首先来区分三个概念：代码复用性（Code Reusability）、代码复用（Code Resue）和 DRY 原则。代码复用表示一种行为：我们在开发新功能的时候，尽量复用已经存在的代码。代码的可复用性表示一段代码可被复用的特性或能力：我们在编写代码的时候，让代码尽量可复用。DRY 原则是一条原则：不要写重复的代码。从定义描述上，它们好像有点类似，但深究起来，三者的区别还是蛮大的。</p>
<p>首先，“不重复”并不代表“可复用”。在一个项目代码中，可能不存在任何重复的代码，但也并不表示里面有可复用的代码，不重复和可复用完全是两个概念。所以，从这个角度来说，DRY 原则跟代码的可复用性讲的是两回事。</p>
<p>其次，“复用”和“可复用性”关注角度不同。<strong>代码“可复用性”是从代码开发者的角度来讲的，“复用”是从代码使用者的角度来讲的</strong>。比如，A 同事编写了一个 UrlUtils 类，代码的“可复用性”很好。B 同事在开发新功能的时候，直接“复用”A 同事编写的 UrlUtils 类。</p>
<h4 id="3-怎么提高代码复用性？"><a href="#3-怎么提高代码复用性？" class="headerlink" title="3.怎么提高代码复用性？"></a>3.怎么提高代码复用性？</h4><ul>
<li>减少代码耦合</li>
<li>满足单一职责原则</li>
<li>模块化业务</li>
<li>与非业务逻辑分离</li>
<li>通用代码下沉</li>
<li>继承、多态、抽象、封装</li>
<li>应用模板等设计模式</li>
</ul>
<h4 id="4-“Rule-of-Three”原则"><a href="#4-“Rule-of-Three”原则" class="headerlink" title="4.“Rule of Three”原则"></a>4.“Rule of Three”原则</h4><p>第一次编写代码的时候，我们不考虑复用性；第二次遇到复用场景的时候，再进行重构使其复用。需要注意的是，“Rule of Three”中的“Three”并不是真的就指确切的“三”，这里就是指“二”。</p>
<h2 id="2-5-迪米特法则（LOD）"><a href="#2-5-迪米特法则（LOD）" class="headerlink" title="2.5 迪米特法则（LOD）"></a>2.5 迪米特法则（LOD）</h2><p>不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口（也就是定义中的“有限知识”）</p>
<h4 id="1-如何理解“高内聚、松耦合”？"><a href="#1-如何理解“高内聚、松耦合”？" class="headerlink" title="1.如何理解“高内聚、松耦合”？"></a>1.如何理解“高内聚、松耦合”？</h4><p>“高内聚、松耦合”是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。</p>
<p>所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中。所谓松耦合指的是，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动也不会或者很少导致依赖类的代码改动。</p>
<h4 id="2-如何理解“迪米特法则”？"><a href="#2-如何理解“迪米特法则”？" class="headerlink" title="2.如何理解“迪米特法则”？"></a>2.如何理解“迪米特法则”？</h4><p><strong>不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。</strong>迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。</p>
<h2 id="2-6-如何做需求分析和设计？"><a href="#2-6-如何做需求分析和设计？" class="headerlink" title="2.6 如何做需求分析和设计？"></a>2.6 如何做需求分析和设计？</h2><h4 id="1-如何做系统设计？"><a href="#1-如何做系统设计？" class="headerlink" title="1.如何做系统设计？"></a>1.如何做系统设计？</h4><ol>
<li>合理地将功能划分到不同模块</li>
<li>设计模块与模块之间的交互关系</li>
<li>设计模块的接口、数据库、业务模型</li>
</ol>
<h4 id="2-为什么要分-MVC-三层开发？"><a href="#2-为什么要分-MVC-三层开发？" class="headerlink" title="2.为什么要分 MVC 三层开发？"></a>2.为什么要分 MVC 三层开发？</h4><p>对于这个问题，我总结了以下 5 点原因。</p>
<ul>
<li>分层能起到代码复用的作用</li>
<li>分层能起到隔离变化的作用</li>
<li>分层能起到隔离关注点的作用</li>
<li>分层能提高代码的可测试性</li>
<li>分层能应对系统的复杂性</li>
</ul>
<h2 id="三、重构"><a href="#三、重构" class="headerlink" title="三、重构"></a>三、重构</h2><h2 id="3-1-什么情况下要重构？到底重构什么？又该如何重构？"><a href="#3-1-什么情况下要重构？到底重构什么？又该如何重构？" class="headerlink" title="3.1 什么情况下要重构？到底重构什么？又该如何重构？"></a>3.1 什么情况下要重构？到底重构什么？又该如何重构？</h2><h4 id="1-重构的目的：为什么重构（why）？"><a href="#1-重构的目的：为什么重构（why）？" class="headerlink" title="1.重构的目的：为什么重构（why）？"></a>1.重构的目的：为什么重构（why）？</h4><p>对于项目来言，重构可以保持代码质量持续处于一个可控状态，不至于腐化到无可救药的地步。对于个人而言，重构非常锻炼一个人的代码能力，并且是一件非常有成就感的事情。它是我们学习的经典设计思想、原则、模式、编程规范等理论知识的练兵场。</p>
<h4 id="2-重构的对象：重构什么（what）？"><a href="#2-重构的对象：重构什么（what）？" class="headerlink" title="2.重构的对象：重构什么（what）？"></a>2.重构的对象：重构什么（what）？</h4><p>按照重构的规模，我们可以将重构大致分为大规模高层次的重构和小规模低层次的重构。</p>
<p>大规模高层次重构包括对代码分层、模块化、解耦、梳理类之间的交互关系、抽象复用组件等等。这部分工作利用的更多的是比较抽象、比较顶层的设计思想、原则、模式。</p>
<p>小规模低层次的重构包括规范命名、注释、修正函数参数过多、消除超大类、提取重复代码等等编程细节问题，主要是针对类、函数级别的重构。小规模低层次的重构更多的是利用编码规范这一理论知识。</p>
<h4 id="3-重构的时机：什么时候重构（when）？"><a href="#3-重构的时机：什么时候重构（when）？" class="headerlink" title="3.重构的时机：什么时候重构（when）？"></a>3.重构的时机：什么时候重构（when）？</h4><p>建立持续重构意识，把重构作为开发必不可少的部分，融入到日常开发中，而不是等到代码出现很大问题的时候，再大刀阔斧地重构。</p>
<h4 id="4-重构的方法：如何重构（how）？"><a href="#4-重构的方法：如何重构（how）？" class="headerlink" title="4.重构的方法：如何重构（how）？"></a>4.重构的方法：如何重构（how）？</h4><p>大规模高层次的重构难度比较大，需要组织、有计划地进行，分阶段地小步快跑，时刻让代码处于一个可运行的状态。而小规模低层次的重构，因为影响范围小，改动耗时短，所以，只要你愿意并且有时间，随时随地都可以去做。</p>
<h2 id="3-2-保证重构质量"><a href="#3-2-保证重构质量" class="headerlink" title="3.2 保证重构质量"></a>3.2 保证重构质量</h2><p><a href="https://juejin.im/entry/5acad0806fb9a028cd456236">Java服务端单元测试指南</a></p>
<h4 id="1-什么是单元测试？"><a href="#1-什么是单元测试？" class="headerlink" title="1.什么是单元测试？"></a>1.什么是单元测试？</h4><p>单元测试是代码层面的测试，由研发自己来编写，用于测试“自己”编写的代码的逻辑的正确性。单元测试顾名思义是测试一个“单元”，有别于集成测试，这个“单元”一般是类或函数，而不是模块或者系统。</p>
<h4 id="2-为什么要写单元测试？"><a href="#2-为什么要写单元测试？" class="headerlink" title="2.为什么要写单元测试？"></a>2.为什么要写单元测试？</h4><p>写单元测试的过程本身就是代码 Code Review 和重构的过程，能有效地发现代码中的 bug 和代码设计上的问题。除此之外，单元测试还是对集成测试的有力补充，还能帮助我们快速熟悉代码，是 TDD 可落地执行的改进方案。</p>
<h4 id="3-如何编写单元测试？"><a href="#3-如何编写单元测试？" class="headerlink" title="3.如何编写单元测试？"></a>3.如何编写单元测试？</h4><p>写单元测试就是针对代码设计各种测试用例，以覆盖各种输入、异常、边界情况，并将其翻译成代码。我们可以利用一些测试框架来简化单元测试的编写。除此之外，对于单元测试，我们需要建立以下正确的认知：编写单元测试尽管繁琐，但并不是太耗时；我们可以稍微放低对单元测试代码质量的要求；覆盖率作为衡量单元测试质量的唯一标准是不合理的；单元测试不要依赖被测代码的具体实现逻辑；单元测试框架无法测试，多半是因为代码的可测试性不好。</p>
<h4 id="4-单元测试为何难落地执行？"><a href="#4-单元测试为何难落地执行？" class="headerlink" title="4.单元测试为何难落地执行？"></a>4.单元测试为何难落地执行？</h4><p>一方面，写单元测试本身比较繁琐，技术挑战不大，很多程序员不愿意去写；另一方面，国内研发比较偏向“快、糙、猛”，容易因为开发进度紧，导致单元测试的执行虎头蛇尾。最后，关键问题还是团队没有建立对单元测试正确的认识，觉得可有可无，单靠督促很难执行得很好。</p>
<h2 id="3-3-重构-解耦"><a href="#3-3-重构-解耦" class="headerlink" title="3.3 重构-解耦"></a>3.3 重构-解耦</h2><h4 id="1-“解耦”为何如此重要？"><a href="#1-“解耦”为何如此重要？" class="headerlink" title="1.“解耦”为何如此重要？"></a>1.“解耦”为何如此重要？</h4><p>过于复杂的代码往往在可读性、可维护性上都不友好。解耦保证代码松耦合、高内聚，是控制代码复杂度的有效手段。代码高内聚、松耦合，也就是意味着，代码结构清晰、分层模块化合理、依赖关系简单、模块或类之间的耦合小，那代码整体的质量就不会差。</p>
<h4 id="2-代码是否需要“解耦”？"><a href="#2-代码是否需要“解耦”？" class="headerlink" title="2. 代码是否需要“解耦”？"></a>2. 代码是否需要“解耦”？</h4><p>间接的衡量标准有很多，比如，看修改代码是否牵一发而动全身。直接的衡量标准是把模块与模块、类与类之间的依赖关系画出来，根据依赖关系图的复杂性来判断是否需要解耦重构。</p>
<h4 id="3-如何给代码“解耦”？"><a href="#3-如何给代码“解耦”？" class="headerlink" title="3. 如何给代码“解耦”？"></a>3. 如何给代码“解耦”？</h4><p>封装与抽象、中间层、模块化，以及一些其他的设计思想与原则，比如：单一职责原则、基于接口而非实现编程、依赖注入、多用组合少用继承、迪米特法则等。当然，还有一些设计模式，比如观察者模式。</p>
<h2 id="3-4-编码规范"><a href="#3-4-编码规范" class="headerlink" title="3.4 编码规范"></a>3.4 编码规范</h2><p>1.关于命名命名的关键是能准确达意。</p>
<ul>
<li>对于不同作用域的命名，我们可以适当地选择不同的长度。</li>
<li>我们可以借助类的信息来简化属性、函数的命名，利用函数的信息来简化函数参数的命名。</li>
<li>命名要可读、可搜索。</li>
<li>不要使用生僻的、不好读的英文单词来命名。命</li>
<li>名要符合项目的统一规范，也不要用些反直觉的命名。</li>
<li>接口有两种命名方式：一种是在接口中带前缀“I”；另一种是在接口的实现类中带后缀“Impl”。</li>
<li>对于抽象类的命名，也有两种方式，一种是带上前缀“Abstract”，一种是不带前缀。这两种命名方式都可以，关键是要在项目中统一。</li>
</ul>
<p>2.关于注释</p>
<ul>
<li>注释的内容主要包含这样三个方面：做什么、为什么、怎么做。对于一些复杂的类和接口，我们可能还需要写明“如何用”。</li>
<li>类和函数一定要写注释，而且要写得尽可能全面详细。函数内部的注释要相对少一些，一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码可读性。</li>
</ul>
<p>3.关于代码风格函数、类多大才合适？</p>
<ul>
<li>函数的代码行数不要超过一屏幕的大小，比如 50 行。类的大小限制比较难确定。</li>
<li>一行代码多长最合适？最好不要超过 IDE 的显示宽度。当然，也不能太小，否则会导致很多稍微长点的语句被折成两行，也会影响到代码的整洁，不利于阅读。</li>
<li>善用空行分割单元块。对于比较长的函数，为了让逻辑更加清晰，可以使用空行来分割各个代码块。</li>
<li>四格缩进还是两格缩进？我个人比较推荐使用两格缩进，这样可以节省空间，尤其是在代码嵌套层次比较深的情况下。不管是用两格缩进还是四格缩进，一定不要用 tab 键缩进。</li>
<li>大括号是否要另起一行？将大括号放到跟上一条语句同一行，可以节省代码行数。但是将大括号另起新的一行的方式，左右括号可以垂直对齐，哪些代码属于哪一个代码块，更加一目了然。</li>
<li>类中成员怎么排列？在 Google Java 编程规范中，依赖类按照字母序从小到大排列。类中先写成员变量后写函数。成员变量之间或函数之间，先写静态成员变量或函数，后写普通变量或函数，并且按照作用域大小依次排列。</li>
</ul>
<p>4.关于编码技巧</p>
<ul>
<li>将复杂的逻辑提炼拆分成函数和类。</li>
<li>通过拆分成多个函数或将参数封装为对象的方式，来处理参数过多的情况。</li>
<li>函数中不要使用参数来做代码执行逻辑的控制。</li>
<li>函数设计要职责单一。</li>
<li>移除过深的嵌套层次，方法包括：去掉多余的 if 或 else 语句，使用 continue、break、return 关键字提前退出嵌套，调整执行顺序来减少嵌套，将部分嵌套逻辑抽象成函数。</li>
<li>用字面常量取代魔法数。</li>
<li>用解释性变量来解释复杂表达式，以此提高代码可读性。</li>
</ul>
<h2 id="3-5-总结"><a href="#3-5-总结" class="headerlink" title="3.5 总结"></a>3.5 总结</h2><p><img src="/pics/34c51d1eb44ffc099d448ad10bcda82b.jpg" alt="34c51d1eb44ffc099d448ad10bcda82b"></p>
<p><img src="/pics/f4ce06502a9782d200e8e10a90bf2ce7.jpg" alt="f4ce06502a9782d200e8e10a90bf2ce7"></p>
<p><img src="/pics/fbf1ae0ce08d4ea890b80944c2b8309f-1593607047324.jpg" alt="fbf1ae0ce08d4ea890b80944c2b8309f"></p>
<p><img src="/pics/fc56f7c2b348d324c93a09dd0dee538a.jpg" alt="fc56f7c2b348d324c93a09dd0dee538a"></p>
<h2 id="3-6-实战课"><a href="#3-6-实战课" class="headerlink" title="3.6 实战课"></a>3.6 实战课</h2><p><a href="https://time.geekbang.org/column/article/179644">https://time.geekbang.org/column/article/179644</a></p>
<p><a href="https://time.geekbang.org/column/article/179673">https://time.geekbang.org/column/article/179673</a></p>
<p><a href="https://time.geekbang.org/column/article/193221">https://time.geekbang.org/column/article/193221</a></p>
<p><a href="https://time.geekbang.org/column/article/193555">https://time.geekbang.org/column/article/193555</a></p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>跟进用途设计模式可分为3种：</p>
<ul>
<li>创建型模式主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。其中，单例模式用来创建全局唯一的对象。工厂模式用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。原型模式针对创建成本比较大的对象，利用对已有对象进行复制的方式进行创建，以达到节省创建时间的目的。</li>
<li>结构型模式主要总结了一些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。结构型模式包括：代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式。</li>
<li>行为型设计模式主要解决的是“类或对象之间的交互”问题。行为型设计模式比较多，有 11 个，几乎占了 23 种经典设计模式的一半。它们分别是：观察者模式、模板模式、策略模式、职责链模式、状态模式、迭代器模式、访问者模式、备忘录模式、命令模式、解释器模式、中介模式。</li>
</ul>
<h2 id="四、创建型设计模式"><a href="#四、创建型设计模式" class="headerlink" title="四、创建型设计模式"></a>四、创建型设计模式</h2><h2 id="4-1-单例设计模式"><a href="#4-1-单例设计模式" class="headerlink" title="4.1 单例设计模式"></a>4.1 单例设计模式</h2><p>一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</p>
<h3 id="1-为什么使用单例？"><a href="#1-为什么使用单例？" class="headerlink" title="1.为什么使用单例？"></a>1.为什么使用单例？</h3><ol>
<li><p>处理资源访问冲突</p>
</li>
<li><p>表示全局唯一类</p>
</li>
</ol>
<h3 id="2-单例的5种写法？"><a href="#2-单例的5种写法？" class="headerlink" title="2.单例的5种写法？"></a>2.单例的5种写法？</h3><h4 id="1-饿汉式"><a href="#1-饿汉式" class="headerlink" title="1.饿汉式"></a>1.饿汉式</h4><p>饿汉式的实现方式，在类加载的期间，就已经将 instance 静态实例初始化好了，所以，instance 实例的创建是线程安全的。不过，这样的实现方式不支持延迟加载实例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class IdGenerator &#123;</span><br><span class="line">    private static final IdGenerator Instance = new IdGenerator();</span><br><span class="line"></span><br><span class="line">    private IdGenerator() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static IdGenerator getInstance() &#123;</span><br><span class="line">        return Instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-懒汉式"><a href="#2-懒汉式" class="headerlink" title="2.懒汉式"></a>2.懒汉式</h4><p>懒汉式相对于饿汉式的优势是支持延迟加载，不过懒汉式的缺点也很明显，我们给 getInstance() 这个方法加了一把大锁（synchronzed），导致性能降低。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class IdGenerator &#123; </span><br><span class="line">  private static IdGenerator instance;</span><br><span class="line">  private IdGenerator() &#123;&#125;</span><br><span class="line">  public static synchronized IdGenerator getInstance() &#123;</span><br><span class="line">    if (instance == null) &#123;</span><br><span class="line">      instance = new IdGenerator();</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-双重检测机制"><a href="#3-双重检测机制" class="headerlink" title="3.双重检测机制"></a>3.双重检测机制</h4><p>假如在某一瞬间线程A和线程B都在调用getInstance()方法，此时instance对象为null值，均能通 过instance == null的判断。由于实现了synchronized加锁机制，线程A进入synchronized锁定的代 码中执行实例创建代码，线程B处于排队等待状态，必须等待线程A执行完毕后才可以进入 synchronized锁定代码。但当A执行完毕时，线程B并不知道实例已经创建，将继续创建新的实例，导致产生多个单例对象，违背单例模式的设计思想，因此需要进行进一步改进，在 synchronized中再进行一次(instance == null)判断，这种方式称为双重检查锁定(Double-Check Locking)。</p>
<p>因为指令重排序，可能会导致 IdGenerator 对象被 new 出来，并且赋值给 instance 之后，还没来得及初始化，就被另一个线程使用了。我们需要给 instance 成员变量加上 volatile 关键字，禁止指令重排序才行。实际上，只有很低版本的 Java 才会有这个问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span>&#123; </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> IdGenerator instance;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">IdGenerator</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(IdGenerator.class) &#123; <span class="comment">// 此处为类级别的锁</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">          instance = <span class="keyword">new</span> IdGenerator();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-静态内部类"><a href="#4-静态内部类" class="headerlink" title="4.静态内部类"></a>4.静态内部类</h4><p>SingletonHolder 是一个静态内部类，当外部类 IdGenerator 被加载的时候，并不会创建 SingletonHolder 实例对象。只有当调用 getInstance() 方法时，SingletonHolder 才会被加载，这个时候才会创建 instance。instance 的唯一性、创建过程的线程安全性，都由 JVM 来保证。所以，这种实现方法既保证了线程安全，又能做到延迟加载。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class IdGenerator &#123; </span><br><span class="line">  private IdGenerator() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  private static class SingletonHolder&#123;</span><br><span class="line">    private static final IdGenerator instance = new IdGenerator();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static IdGenerator getInstance() &#123;</span><br><span class="line">    return SingletonHolder.instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-枚举"><a href="#5-枚举" class="headerlink" title="5.枚举"></a>5.枚举</h4><p>最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public enum IdGenerator &#123;</span><br><span class="line">  INSTANCE;</span><br><span class="line">  private AtomicLong id = new AtomicLong(0);</span><br><span class="line"></span><br><span class="line">  public long getId() &#123; </span><br><span class="line">    return id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-懒汉式比饿汉式更好吗？"><a href="#3-懒汉式比饿汉式更好吗？" class="headerlink" title="3. 懒汉式比饿汉式更好吗？"></a>3. 懒汉式比饿汉式更好吗？</h3><p>有人认为饿汉式的实现方式不好，因为不支持延迟加载，如果实例占用资源多（比如占用内存多）或初始化耗时长（比如需要加载各种配置文件），提前初始化实例是一种浪费资源的行为。最好的方法应该在用到的时候再去初始化。不过，我个人并不认同这样的观点。</p>
<p><strong>如果初始化耗时长，那我们最好不要等到真正要用它的时候，才去执行这个耗时长的初始化过程，这会影响到系统的性能</strong>（比如，在响应客户端接口请求的时候，做这个初始化操作，会导致此请求的响应时间变长，甚至超时）。采用饿汉式实现方式，将耗时的初始化操作，提前到程序启动的时候完成，这样就能避免在程序运行的时候，再去初始化导致的性能问题。</p>
<p><strong>如果实例占用资源多，按照 fail-fast 的设计原则（有问题及早暴露），那我们也希望在程序启动时就将这个实例初始化好</strong>。如果资源不够，就会在程序启动的时候触发报错（比如 Java 中的 PermGen Space OOM），我们可以立即去修复。这样也能避免在程序运行一段时间后，突然因为初始化这个实例占用资源过多，导致系统崩溃，影响系统的可用性。</p>
<h3 id="4-如何理解单例的模式的全局唯一性？"><a href="#4-如何理解单例的模式的全局唯一性？" class="headerlink" title="4. 如何理解单例的模式的全局唯一性？"></a>4. 如何理解单例的模式的全局唯一性？</h3><p>单例模式创建的对象是进程唯一的。“进程唯一”指的是进程内唯一，进程间不唯一；“线程唯一”指的是线程内唯一，线程间可以不唯一。实际上，“进程唯一”就意味着线程内、线程间都唯一，这也是“进程唯一”和“线程唯一”的区别之处。“集群唯一”指的是进程内唯一、进程间也唯一。</p>
<h3 id="5-如何实现线程唯一的单例？"><a href="#5-如何实现线程唯一的单例？" class="headerlink" title="5.如何实现线程唯一的单例？"></a>5.如何实现线程唯一的单例？</h3><p>我们通过一个 HashMap 来存储对象，其中 key 是线程 ID，value 是对象。这样我们就可以做到，不同的线程对应不同的对象，同一个线程只能对应一个对象。实际上，Java 语言本身提供了 <strong>ThreadLocal</strong> 并发工具类，可以更加轻松地实现线程唯一单例。</p>
<h2 id="4-2-工厂模式"><a href="#4-2-工厂模式" class="headerlink" title="4.2 工厂模式"></a>4.2 工厂模式</h2><p>当创建逻辑比较复杂，是一个“大工程”的时候，我们就考虑使用工厂模式。</p>
<h3 id="1-工厂模式的分类？"><a href="#1-工厂模式的分类？" class="headerlink" title="1.工厂模式的分类？"></a>1.工厂模式的分类？</h3><h4 id="1-简单工厂"><a href="#1-简单工厂" class="headerlink" title="1.简单工厂"></a>1.简单工厂</h4><p>又叫静态工厂方法，因为在简单工厂模式中用于创建实例的方法是静态方法。</p>
<p><img src="/pics/image-20200529101403310.png" alt="image-20200529101403310"></p>
<h4 id="2-工厂方法"><a href="#2-工厂方法" class="headerlink" title="2.工厂方法"></a>2.工厂方法</h4><p>简单工厂模式最大的 缺点是当有新产品要加入到系统中时，必须修改工厂类，需要在其中加入必要的业务逻辑， 这违背了“开闭原则”。</p>
<p>当对象的创建逻辑比较复杂，<strong>不只是简单的 new 一下就可以，而是要组合其他类对象，做各种初始化操作的时候，</strong>我们推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。典型UML图如下：</p>
<p><img src="/pics/image-20200506180721332.png" alt="image-20200506180721332"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Client &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        LoggerFactory factory;</span><br><span class="line">        Logger logger;</span><br><span class="line">        factory = new FileLoggerFactory(); //可引入配置文件实现</span><br><span class="line">        logger = factory.createLogger();</span><br><span class="line">        logger.writeLog();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-抽象工厂"><a href="#3-抽象工厂" class="headerlink" title="3.抽象工厂"></a>3.抽象工厂</h4><p>与工厂方法模式相比，抽象工厂模式中的具体工厂不只是创建一种产品，它负责创建一族产品。</p>
<p><img src="/pics/image-20200506201358048.png" alt="image-20200506201358048"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Factory vivoFactory = new VivoFactory();</span><br><span class="line">vivoFactory.createMobile().call();</span><br><span class="line">vivoFactory.createTv().play();</span><br></pre></td></tr></table></figure>

<h3 id="2-工厂模式使用的场景，何谓创建逻辑比较复杂呢？"><a href="#2-工厂模式使用的场景，何谓创建逻辑比较复杂呢？" class="headerlink" title="2.工厂模式使用的场景，何谓创建逻辑比较复杂呢？"></a>2.工厂模式使用的场景，何谓创建逻辑比较复杂呢？</h3><ul>
<li><p>类似规则配置解析的例子，<strong>代码中存在 if-else 分支判断，动态地根据不同的类型创建不同的对象</strong>。针对这种情况，我们就考虑使用工厂模式，将这一大坨 if-else 创建对象的代码抽离出来，放到工厂类中。还有一种情况，尽管我们不需要根据不同的类型创建不同的对象，但是，单个对象本身的创建过程比较复杂，比如前面提到的要组合其他类对象，做各种初始化操作。在这种情况下，我们也可以考虑使用工厂模式，将对象的创建过程封装到工厂类中。</p>
</li>
<li><p>尽管我们不需要根据不同的类型创建不同的对象，但是，<strong>单个对象本身的创建过程比较复杂</strong>，比如前面提到的要组合其他类对象，做各种初始化操作。在这种情况下，我们也可以考虑使用工厂模式，将对象的创建过程封装到工厂类中。</p>
</li>
</ul>
<h2 id="4-3-建造者模式"><a href="#4-3-建造者模式" class="headerlink" title="4.3 建造者模式"></a>4.3 建造者模式</h2><p>建造者模式是让建造者类来负责对象的创建工作。</p>
<h3 id="1-与工厂模式有何区别？"><a href="#1-与工厂模式有何区别？" class="headerlink" title="1. 与工厂模式有何区别？"></a>1. 与工厂模式有何区别？</h3><p>工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。<strong>建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象，同时可在创建时多传入参数进行验证。</strong></p>
<p>举例，顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。</p>
<h3 id="2-建造者模式的应用场景？"><a href="#2-建造者模式的应用场景？" class="headerlink" title="2.建造者模式的应用场景？"></a>2.建造者模式的应用场景？</h3><p>如果一个类中有很多属性，为了避免构造函数的参数列表过长，影响代码的可读性和易用性，我们可以通过构造函数配合 set() 方法来解决。但是，如果存在下面情况中的任意一种，我们就要考虑使用建造者模式了。</p>
<ul>
<li>我们把类的必填属性放到构造函数中，强制创建对象的时候就设置。如果必填的属性有很多，把这些必填属性都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填属性通过 set() 方法设置，那校验这些必填属性是否已经填写的逻辑就无处安放了。</li>
<li><strong>如果类的属性之间有一定的依赖关系或者约束条件，我们继续使用构造函数配合 set() 方法的设计思路，那这些依赖关系或约束条件的校验逻辑就无处安放了</strong>。比如创建一个长方形时同时需要长宽2个参数，否则就是无意义的。</li>
<li><strong>如果我们希望创建不可变对象</strong>，也就是说，对象在创建好之后，就不能再修改内部的属性值，要实现这个功能，我们就不能在类中暴露 set() 方法。构造函数配合 set() 方法来设置属性值的方式就不适用了。</li>
</ul>
<h2 id="4-4-原型模式"><a href="#4-4-原型模式" class="headerlink" title="4.4 原型模式"></a>4.4 原型模式</h2><p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大，在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。</p>
<p>在开发过程中，尽量避免浅拷贝共享对象，可能会导致共享数据被修改的情况，没有充分的理由，不要为了一点点的性能提升而使用浅拷贝。</p>
<h3 id="1-深拷贝vs浅拷贝？"><a href="#1-深拷贝vs浅拷贝？" class="headerlink" title="1.深拷贝vs浅拷贝？"></a>1.深拷贝vs浅拷贝？</h3><p>浅拷贝和深拷贝的区别在于，浅拷贝只会复制图中的索引，不会复制数据本身。相反，深拷贝不仅仅会复制索引，还会复制数据本身。浅拷贝得到的对象跟原始对象共享数据，而深拷贝得到的是一份完完全全独立的对象。</p>
<h3 id="2-深拷贝的2种方式？"><a href="#2-深拷贝的2种方式？" class="headerlink" title="2.深拷贝的2种方式？"></a>2.深拷贝的2种方式？</h3><ul>
<li>第一种方法：递归拷贝对象、对象的引用对象以及引用对象的引用对象，直到要拷贝的对象只包含基本数据类型数据，没有引用对象为止。参考Android Intent的clone方法。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Student implements Cloneable &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public Student(String s) &#123;</span><br><span class="line">        name = s;</span><br><span class="line">        subj = new Subject(sub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object clone() &#123;</span><br><span class="line">        // 深拷贝，创建拷贝类的一个新对象，这样就和原始对象相互独立</span><br><span class="line">        Student s = new Student(name);</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第二种方法：先将对象序列化，然后再反序列化成新的对象。具体的示例代码如下所示：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Object deepCopy(Object object) &#123;</span><br><span class="line">  //将对象写入流中</span><br><span class="line">  ByteArrayOutputStream bo = new ByteArrayOutputStream();</span><br><span class="line">  ObjectOutputStream oo = new ObjectOutputStream(bo);</span><br><span class="line">  oo.writeObject(object);</span><br><span class="line"></span><br><span class="line">  //将对象从流中取出</span><br><span class="line">  ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());</span><br><span class="line">  ObjectInputStream oi = new ObjectInputStream(bi);</span><br><span class="line"></span><br><span class="line">  return oi.readObject();</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<h2 id="五、结构型设计模式"><a href="#五、结构型设计模式" class="headerlink" title="五、结构型设计模式"></a>五、结构型设计模式</h2><p>结构型模式主要总结了一些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。结构型模式包括：代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式。</p>
<h2 id="5-1-代理模式"><a href="#5-1-代理模式" class="headerlink" title="5.1 代理模式"></a>5.1 代理模式</h2><p>当无法直接访问某个对象或访问某个对象存在困难 时可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，所访问的真实对象与 代理对象需要实现相同的接口。</p>
<p>代理模式常用在业务系统中开发一些非功能性需求，比如：<strong>监控、统计</strong>、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类统一处理，让程序员只需要关注业务方面的开发。</p>
<p><img src="/pics/image-20200508201754929.png" alt="image-20200508201754929"></p>
<h3 id="1-静态代理的2种实现方式？"><a href="#1-静态代理的2种实现方式？" class="headerlink" title="1.静态代理的2种实现方式？"></a>1.静态代理的2种实现方式？</h3><ul>
<li>第一种，代理类和原始类实现相同的接口。</li>
<li>第二种，采用继承的方式进行扩展，适用场景：如果原始类并没有定义接口，或者没办法直接修改原始类。</li>
</ul>
<p>这2种方式，一种基于组合一种基于继承，组合模式的优点在于更加灵活，对于接口的所有子类都可以代理，缺点在于不需要扩展的方法也需要进行代理。<br>继承模式的优点在于只需要针对需要扩展的方法进行代理，缺点在于只能针对单一父类进行代理。</p>
<h3 id="2-动态代理？"><a href="#2-动态代理？" class="headerlink" title="2.动态代理？"></a>2.动态代理？</h3><p>动态代理的原理与实现静态代理需要针对每个类都创建一个代理类，<strong>并且每个代理类中的代码都有点像模板式的“重复”代码</strong>，增加了维护成本和开发成本。对于静态代理存在的问题，我们可以通过动态代理来解决。我们不事先为每个原始类编写代理类，而是在运行的时候动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。</p>
<p><a href="https://www.jianshu.com/p/23d3f1a2b3c7">Java动态代理实现及原理分析</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1.定义接口</span><br><span class="line">public interface UserService &#123;</span><br><span class="line">    void select();</span><br><span class="line"></span><br><span class="line">    void update();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserServiceImpl implements UserService&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void select() &#123;</span><br><span class="line">        System.out.println(&quot;查询 selectById&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void update() &#123;</span><br><span class="line">        System.out.println(&quot;更新 update&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2.动态代理对象调用目标对象的任何方法前，都会调用调用处理器类的invoke（）</span><br><span class="line">public class DynamicProxyHandler implements InvocationHandler &#123;</span><br><span class="line">    // 被代理的对象，实际的方法执行者</span><br><span class="line">    Object target;</span><br><span class="line"></span><br><span class="line">    public DynamicProxyHandler(Object target) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        before();</span><br><span class="line">        Object result = method.invoke(target, args);  // 调用 target 的 method 方法</span><br><span class="line">        after();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void before() &#123;</span><br><span class="line">        System.out.println(&quot;before ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void after() &#123;</span><br><span class="line">        System.out.println(&quot;after ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3.绑定代理和handler</span><br><span class="line">public class DynamicProxy &#123;</span><br><span class="line">    public static Object createProxy(Object proxyObject) &#123;</span><br><span class="line">        DynamicProxyHandler handler = new DynamicProxyHandler(proxyObject);</span><br><span class="line">        // 根据指定的类装载器、一组接口 &amp; 调用处理器 生成动态代理类实例，并最终返回</span><br><span class="line">        // 参数说明：</span><br><span class="line">        // 参数1：指定产生代理对象的类加载器，需要将其指定为和目标对象同一个类加载器</span><br><span class="line">        // 参数2：指定目标对象的实现接口</span><br><span class="line">        // 即要给目标对象提供一组什么接口。若提供了一组接口给它，那么该代理对象就默认实现了该接口，这样就能调用这组接口中的方法</span><br><span class="line">        // 参数3：指定InvocationHandler对象。即动态代理对象在调用方法时，会关联到哪个InvocationHandler对象</span><br><span class="line">        return Proxy.newProxyInstance(proxyObject.getClass().getClassLoader(), proxyObject.getClass().getInterfaces(), handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 4.代理类执行</span><br><span class="line">// 4.1 设置变量可以保存动态代理类，默认名称以 $Proxy0 格式命名</span><br><span class="line">System.getProperties().setProperty(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</span><br><span class="line"></span><br><span class="line">UserService proxy = (UserService) DynamicProxy.createProxy(new UserServiceImpl());</span><br><span class="line">proxy.select();</span><br><span class="line">proxy.update();</span><br></pre></td></tr></table></figure>

<h2 id="5-2-桥接模式"><a href="#5-2-桥接模式" class="headerlink" title="5.2  桥接模式"></a>5.2  桥接模式</h2><p>将抽象和实现解耦，让它们可以独立变化。还有另外一种理解方式：<strong>一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展</strong>。通过组合关系来替代继承关系，避免继承层次的指数级爆炸。这种理解方式非常类似于，我们之前讲过的“组合优于继承”设计原则，</p>
<p><img src="/pics/image-20200507195435427.png" alt="image-20200507195435427"></p>
<p>比如饮料有咖啡、茶，这2中饮料都存在苹果味、橘子味。如果顾客要一杯苹果味的咖啡、橘子味的茶；如果反之呢，该如何设计才能满足用户灵活的需求呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 饮料</span><br><span class="line">public abstract class Drink &#123;</span><br><span class="line">    protected Flavor flavor;</span><br><span class="line"></span><br><span class="line">    public Drink(Flavor flavor) &#123;</span><br><span class="line">        this.flavor = flavor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    abstract void make();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 口味</span><br><span class="line">public interface Flavor &#123;</span><br><span class="line">    void make(String drink);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Coffee extends Drink &#123;</span><br><span class="line">    public Coffee(Flavor flavor) &#123;</span><br><span class="line">        super(flavor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void make() &#123;</span><br><span class="line">        flavor.add(&quot;coffee&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Tea extends Drink &#123;</span><br><span class="line">    public Tea(Flavor flavor) &#123;</span><br><span class="line">        super(flavor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void make() &#123;</span><br><span class="line">        flavor.add(&quot;tea&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class AppleFlavor implements Flavor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void add(String drink) &#123;</span><br><span class="line">        System.out.println(&quot;make apple flavor &quot; + drink );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class OrangeFlavor implements Flavor&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void add(String drink) &#123;</span><br><span class="line">        System.out.println(&quot;make orange flavor &quot; + drink );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Flavor flavor = new AppleFlavor();</span><br><span class="line">Drink drink = new Coffee(flavor);</span><br><span class="line">drink.make();</span><br></pre></td></tr></table></figure>

<h2 id="5-3-装饰器模式"><a href="#5-3-装饰器模式" class="headerlink" title="5.3 装饰器模式"></a>5.3 装饰器模式</h2><p><strong>装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承。</strong>它主要的作用是给原始类添加增强功能。</p>
<p>Java IO类就是典型的装饰器模式。</p>
<p><img src="/pics/image-20200507210406322.png" alt="image-20200507210406322"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">InputStream in = new FileInputStream(&quot;/user/wangzheng/test.txt&quot;);</span><br><span class="line">InputStream bin = new BufferedInputStream(in);</span><br><span class="line">byte[] data = new byte[128];</span><br><span class="line">while (bin.read(data) != -1) &#123;</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个特点：<strong>装饰器类和原始类继承同样的父类</strong>，这样我们可以对原始类“嵌套”多个装饰器类。</p>
<p>第二个特点：装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点。和代理模式相比，代理类附加的是跟原始类无关的功能，而在装饰器模式中，装饰器类附加的是跟<strong>原始类相关的增强功能</strong>。</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 父类</span><br><span class="line">public abstract class Person &#123;</span><br><span class="line">    public abstract void dressed();</span><br><span class="line">&#125;</span><br><span class="line">// 原始类，待增强</span><br><span class="line">public class Boy extends Person &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void dressed() &#123;</span><br><span class="line">        System.out.println(&quot;boy dressed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 装饰类</span><br><span class="line">public class CheapPersonCloth extends Person &#123;</span><br><span class="line">    private Person person;</span><br><span class="line"></span><br><span class="line">    public CheapPersonCloth(Person p)&#123;</span><br><span class="line">        this.person = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void dressed() &#123;</span><br><span class="line">        super.dressed();</span><br><span class="line">        dressCheap();// 增强</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void dressCheap() &#123;</span><br><span class="line">        System.out.println(&quot;dress Cheap&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 装饰模式</span><br><span class="line">Person person = new Boy();</span><br><span class="line">CheapPersonCloth cheapCloth = new CheapPersonCloth(person);</span><br><span class="line">cheapCloth.dressed();</span><br></pre></td></tr></table></figure>

<h2 id="5-4-适配器模式"><a href="#5-4-适配器模式" class="headerlink" title="5.4 适配器模式"></a>5.4 适配器模式</h2><p>将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。客户端需要的是A接口，但是现在可提供是b，那么要统一暴露给外部A。</p>
<p>适配器模式通常有2种常见形式，类适配器和对象适配器。</p>
<p><img src="/pics/image-20200507211617343.png" alt="image-20200507211617343"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 类适配器: 基于继承</span><br><span class="line"></span><br><span class="line">public interface ITarget &#123; // 目标抽象类</span><br><span class="line">  void f1();</span><br><span class="line">  void f2();</span><br><span class="line">  void fc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Adaptee &#123; // 适配者类,定义了一个已经存在的接口，这个接口需要适配 </span><br><span class="line">  public void fa() &#123; //... &#125;</span><br><span class="line">  public void fb() &#123; //... &#125;</span><br><span class="line">  public void fc() &#123; //... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Adaptor extends Adaptee implements ITarget &#123;//适配器类</span><br><span class="line">  public void f1() &#123;</span><br><span class="line">    super.fa();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void f2() &#123;</span><br><span class="line">    //...重新实现f2()...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/pics/image-20200507211926651.png" alt="image-20200507211926651"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 对象适配器：基于组合</span><br><span class="line">public interface ITarget &#123;</span><br><span class="line">  void f1();</span><br><span class="line">  void f2();</span><br><span class="line">  void fc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Adaptee &#123;</span><br><span class="line">  public void fa() &#123; //... &#125;</span><br><span class="line">  public void fb() &#123; //... &#125;</span><br><span class="line">  public void fc() &#123; //... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Adaptor implements ITarget &#123;</span><br><span class="line">  private Adaptee adaptee;</span><br><span class="line"></span><br><span class="line">  public Adaptor(Adaptee adaptee) &#123;</span><br><span class="line">    this.adaptee = adaptee;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void f1() &#123;</span><br><span class="line">    adaptee.fa(); //委托给Adaptee</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void f2() &#123;</span><br><span class="line">    //...重新实现f2()...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void fc() &#123;</span><br><span class="line">    adaptee.fc();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-类适配器-vs-对象适配器？"><a href="#1-类适配器-vs-对象适配器？" class="headerlink" title="1. 类适配器 vs 对象适配器？"></a>1. 类适配器 vs 对象适配器？</h3><ul>
<li>如果 Adaptee 接口并不多，那两种实现方式都可以。</li>
<li><strong>如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都相同，</strong>那我们推荐使用类适配器，因为 Adaptor 复用父类 Adaptee 的接口，比起对象适配器的实现方式，Adaptor 的代码量要少一些。</li>
<li>如果 Adaptee 接口很多，而且 <strong>Adaptee 和 ITarget 接口定义大部分都不相同</strong>，那我们推荐使用对象适配器，因为组合结构相对于继承更加灵活。</li>
</ul>
<h3 id="2-那在实际的开发中，什么情况下才会出现接口不兼容呢？"><a href="#2-那在实际的开发中，什么情况下才会出现接口不兼容呢？" class="headerlink" title="2. 那在实际的开发中，什么情况下才会出现接口不兼容呢？"></a>2. 那在实际的开发中，什么情况下才会出现接口不兼容呢？</h3><ul>
<li>封装有缺陷的接口设计</li>
<li>统一多个类的接口设计</li>
<li>替换依赖的外部系统</li>
<li>兼容老版本接口</li>
<li>适配不同格式的数据</li>
</ul>
<h3 id="3-代理、桥接、装饰器、适配器-4-种设计模式的区别"><a href="#3-代理、桥接、装饰器、适配器-4-种设计模式的区别" class="headerlink" title="3. 代理、桥接、装饰器、适配器 4 种设计模式的区别"></a>3. 代理、桥接、装饰器、适配器 4 种设计模式的区别</h3><ul>
<li>代理模式：代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，<strong>主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同</strong>。</li>
<li>桥接模式：桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。</li>
<li>装饰器模式：装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。</li>
<li>适配器模式：适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。</li>
</ul>
<h2 id="5-5-门面（外观）模式"><a href="#5-5-门面（外观）模式" class="headerlink" title="5.5 门面（外观）模式"></a>5.5 门面（外观）模式</h2><p>为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。</p>
<p><img src="/pics/image-20200508204121839.png" alt="image-20200508204121839"></p>
<h3 id="1-门面模式的应用场景"><a href="#1-门面模式的应用场景" class="headerlink" title="1.门面模式的应用场景"></a>1.门面模式的应用场景</h3><ul>
<li><p>解决易用性问题。门面模式可以用来封装系统的底层实现，隐藏系统的复杂性，提供一组更加简单易用、更高层的接口。</p>
</li>
<li><p>解决性能问题。我们通过将多个接口调用替换为一个门面接口调用，减少网络通信成本，提高 App 客户端的响应速度。</p>
</li>
<li><p>解决分布式事务问题。要支持两个接口调用在一个事务中执行，是比较难实现的，这涉及分布式事务问题。虽然我们可以通过引入分布式事务框架或者事后补偿的机制来解决，但代码实现都比较复杂。而最简单的解决方案是，设计一个包裹这两个操作的新接口，让新接口在一个事务中执行两个 SQL 操作。</p>
</li>
</ul>
<h3 id="2-门面-vs-适配器？"><a href="#2-门面-vs-适配器？" class="headerlink" title="2.门面 vs 适配器？"></a>2.门面 vs 适配器？</h3><p>适配器模式注重的是兼容性，解决的是原接口和目标接口不匹配的问题。</p>
<p>而门面模式注重的是易用性，解决的是多接口调用带来的问题。</p>
<h2 id="5-6-组合模式"><a href="#5-6-组合模式" class="headerlink" title="5.6 组合模式"></a>5.6 组合模式</h2><p>将一组对象组织成树形结构，将单个对象和组合对象都看做树中的节点，<strong>以统一处理逻辑，并且它利用树形结构的特点，递归地处理每个子树，依次简化代码实现</strong>。使用组合模式的前提在于，你的业务场景必须能够表示成树形结构。所以，组合模式的应用场景也比较局限，它并不是一种很常用的设计模式。</p>
<p><img src="/pics/image-20200508210024521.png" alt="image-20200508210024521"></p>
<p>假设我们在开发一个 OA 系统（办公自动化系统）。公司的组织结构包含部门和员工两种数据类型。其中，部门又可以包含子部门和员工。在数据库中的表结构如下所示：<img src="/pics/image-20200508210435722.png" alt="image-20200508210435722"></p>
<p>我们希望在内存中构建整个公司的人员架构图（部门、子部门、员工的隶属关系），并且提供接口计算出部门的薪资成本（隶属于这个部门的所有员工的薪资和）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HumanResource</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">countSalary</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> <span class="keyword">implements</span> <span class="title">HumanResource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;HumanResource&gt; humanResources = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">countSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (HumanResource humanResource : humanResources) &#123;</span><br><span class="line">            count += humanResource.countSalary();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(HumanResource humanResource)</span> </span>&#123;</span><br><span class="line">        humanResources.add(humanResource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">HumanResource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(<span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">countSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算部门的薪资</span></span><br><span class="line">Department department = <span class="keyword">new</span> Department();</span><br><span class="line">HumanResource humanResource = <span class="keyword">new</span> Employee(<span class="number">1</span>);</span><br><span class="line">HumanResource humanResource2 = <span class="keyword">new</span> Employee(<span class="number">2</span>);</span><br><span class="line">department.add(humanResource);</span><br><span class="line">System.out.println(department.countSalary());</span><br></pre></td></tr></table></figure>

<h2 id="5-7-享元模式"><a href="#5-7-享元模式" class="headerlink" title="5.7 享元模式"></a>5.7 享元模式</h2><p>所谓“享元”，顾名思义就是被共享的单元。<strong>享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象</strong>。</p>
<p>具体来讲，当一个系统中存在大量重复对象的时候，我们就可以利用享元模式，将对象设计成享元，在内存中只保留一份实例，供多处代码引用，这样可以减少内存中对象的数量，以起到节省内存的目的。实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段），提取出来设计成享元，让这些大量相似对象引用这些享元。</p>
<h3 id="1-享元模式的实现"><a href="#1-享元模式的实现" class="headerlink" title="1.享元模式的实现"></a>1.享元模式的实现</h3><p>享元模式的代码实现非常简单，主要是通过工厂模式，在工厂类中，通过一个 Map 或者 List 来缓存已经创建好的享元对象，以达到复用的目的。</p>
<p>假设我们在开发一个棋牌游戏（比如象棋）。一个游戏厅中有成千上万个“房间”，每个房间对应一个棋局。棋局要保存每个棋子的数据，比如：棋子类型（将、相、士、炮等）、棋子颜色（红方、黑方）、棋子在棋局中的位置。利用这些数据，我们就能显示一个完整的棋盘给玩家。具体的代码如下所示。其中，ChessPiece 类表示棋子，ChessBoard 类表示一个棋局，里面保存了象棋中 30 个棋子的信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 享元类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChessPieceUnit</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">  <span class="keyword">private</span> String text;</span><br><span class="line">  <span class="keyword">private</span> Color color;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ChessPieceUnit</span><span class="params">(<span class="keyword">int</span> id, String text, Color color)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">    <span class="keyword">this</span>.text = text;</span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">enum</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    RED, BLACK</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...省略其他属性和getter方法...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 享元池</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChessPieceUnitFactory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Integer, ChessPieceUnit&gt; pieces = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    pieces.put(<span class="number">1</span>, <span class="keyword">new</span> ChessPieceUnit(<span class="number">1</span>, <span class="string">&quot;車&quot;</span>, ChessPieceUnit.Color.BLACK));</span><br><span class="line">    pieces.put(<span class="number">2</span>, <span class="keyword">new</span> ChessPieceUnit(<span class="number">2</span>,<span class="string">&quot;馬&quot;</span>, ChessPieceUnit.Color.BLACK));</span><br><span class="line">    <span class="comment">//...省略摆放其他棋子的代码...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ChessPieceUnit <span class="title">getChessPiece</span><span class="params">(<span class="keyword">int</span> chessPieceId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pieces.get(chessPieceId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChessPiece</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> ChessPieceUnit chessPieceUnit;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> positionX;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> positionY;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ChessPiece</span><span class="params">(ChessPieceUnit unit, <span class="keyword">int</span> positionX, <span class="keyword">int</span> positionY)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.chessPieceUnit = unit;</span><br><span class="line">    <span class="keyword">this</span>.positionX = positionX;</span><br><span class="line">    <span class="keyword">this</span>.positionY = positionY;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 省略getter、setter方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChessBoard</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;Integer, ChessPiece&gt; chessPieces = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ChessBoard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    chessPieces.put(<span class="number">1</span>, <span class="keyword">new</span> ChessPiece(</span><br><span class="line">            ChessPieceUnitFactory.getChessPiece(<span class="number">1</span>), <span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">    chessPieces.put(<span class="number">1</span>, <span class="keyword">new</span> ChessPiece(</span><br><span class="line">            ChessPieceUnitFactory.getChessPiece(<span class="number">2</span>), <span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//...省略摆放其他棋子的代码...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> chessPieceId, <span class="keyword">int</span> toPositionX, <span class="keyword">int</span> toPositionY)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...省略...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码实现中，我们利用工厂类来缓存 ChessPieceUnit 信息。通过工厂类获取到的 ChessPieceUnit 就是享元。所有的 ChessBoard 对象共享这 30 个 ChessPieceUnit 对象（因为象棋中只有 30 个棋子）。注意：共享的单元是chessPieceUnit而不是ChessPiece（包含位置信息），<strong>享元模式要区分清楚可变和不可变的属性，不可变的属性是可以共享的，可变的不可以。</strong></p>
<h3 id="2-享元模式-VS-单例、缓存、对象池"><a href="#2-享元模式-VS-单例、缓存、对象池" class="headerlink" title="2.享元模式 VS 单例、缓存、对象池"></a>2.享元模式 VS 单例、缓存、对象池</h3><ul>
<li>应用单例模式是为了保证对象全局唯一。</li>
<li>应用享元模式是为了实现对象复用，节省内存。</li>
<li>缓存是为了提高访问效率，而非复用。</li>
<li>池化技术中的“复用”理解为“重复使用”，主要是为了节省时间。</li>
</ul>
<h3 id="3-剖析享元模式在Java-Integer、String中的应用"><a href="#3-剖析享元模式在Java-Integer、String中的应用" class="headerlink" title="3.剖析享元模式在Java Integer、String中的应用"></a><a href="https://time.geekbang.org/column/article/209343">3.剖析享元模式在Java Integer、String中的应用</a></h3><p>理解下面2段代码的输出，基本数据类型的对应包装类型的实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Integer i1 = 56;</span><br><span class="line">Integer i2 = 56;</span><br><span class="line">Integer i3 = 129;</span><br><span class="line">Integer i4 = 129;</span><br><span class="line">System.out.println(i1 == i2); // true </span><br><span class="line">System.out.println(i3 == i4); // false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String s1 = &quot;小争哥&quot;;</span><br><span class="line">String s2 = &quot;小争哥&quot;;</span><br><span class="line">String s3 = new String(&quot;小争哥&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2);//true</span><br><span class="line">System.out.println(s1 == s3);//false</span><br></pre></td></tr></table></figure>

<p><a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html">深入解析String#intern</a></p>
<p><code>String s = new String(&quot;1&quot;);</code> 第一句代码，生成了2个对象。常量池中的“1” 和 JAVA Heap 中的字符串对象。</p>
<p><code>String s2 = &quot;1&quot;;</code> 这句代码是生成一个 s2的引用指向常量池中的“1”对象。</p>
<ul>
<li>直接使用双引号声明出来的<code>String</code>对象会直接存储在常量池中。</li>
<li>如果不是用双引号声明的<code>String</code>对象，可以使用<code>String</code>提供的<code>intern</code>方法。intern 方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中</li>
</ul>
<p>小结：从上述的例子代码可以看出 jdk7 版本对 intern 操作和常量池都做了一定的修改。主要包括2点：</p>
<ul>
<li>将String常量池 从 Perm 区移动到了 Java Heap区</li>
<li><code>String#intern</code> 方法时，如果存在堆中的对象，会直接保存对象的引用，而不会重新创建对象。</li>
</ul>
<h2 id="六、行为型设计模式"><a href="#六、行为型设计模式" class="headerlink" title="六、行为型设计模式"></a>六、行为型设计模式</h2><h2 id="6-1-观察者模式"><a href="#6-1-观察者模式" class="headerlink" title="6.1 观察者模式"></a>6.1 观察者模式</h2><p>在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。</p>
<p><img src="/pics/image-20200520103154468.png" alt="image-20200520103154468"></p>
<h3 id="1-典型代码"><a href="#1-典型代码" class="headerlink" title="1.典型代码"></a>1.典型代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public interface Subject &#123;</span><br><span class="line">  void registerObserver(Observer observer);</span><br><span class="line">  void removeObserver(Observer observer);</span><br><span class="line">  void notifyObservers(Message message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Observer &#123;</span><br><span class="line">  void update(Message message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteSubject implements Subject &#123;</span><br><span class="line">  private List&lt;Observer&gt; observers = new ArrayList&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void registerObserver(Observer observer) &#123;</span><br><span class="line">    observers.add(observer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void removeObserver(Observer observer) &#123;</span><br><span class="line">    observers.remove(observer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void notifyObservers(Message message) &#123;</span><br><span class="line">    for (Observer observer : observers) &#123;</span><br><span class="line">      observer.update(message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteObserverOne implements Observer &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void update(Message message) &#123;</span><br><span class="line">    //TODO: 获取消息通知，执行自己的逻辑...</span><br><span class="line">    System.out.println(&quot;ConcreteObserverOne is notified.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteObserverTwo implements Observer &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void update(Message message) &#123;</span><br><span class="line">    //TODO: 获取消息通知，执行自己的逻辑...</span><br><span class="line">    System.out.println(&quot;ConcreteObserverTwo is notified.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    ConcreteSubject subject = new ConcreteSubject();</span><br><span class="line">    subject.registerObserver(new ConcreteObserverOne());</span><br><span class="line">    subject.registerObserver(new ConcreteObserverTwo());</span><br><span class="line">    subject.notifyObservers(new Message());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-EventBus"><a href="#2-EventBus" class="headerlink" title="2.EventBus"></a>2.EventBus</h3><p>观察者模式。根据应用场景的不同，观察者模式会对应不同的代码实现方式：有同步阻塞的实现方式，也有异步非阻塞的实现方式</p>
<h2 id="6-2-模板模式"><a href="#6-2-模板模式" class="headerlink" title="6.2 模板模式"></a>6.2 模板模式</h2><p>模板方法模式<strong>在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现</strong>。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。</p>
<p>在模板模式经典的实现中，模板方法定义为 final，可以避免被子类重写。需要子类重写的方法定义为 abstract，可以强迫子类去实现。</p>
<p><img src="/pics/image-20200520103312533.png" alt="image-20200520103312533"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class AbstractClass &#123;</span><br><span class="line">  public final void templateMethod() &#123;</span><br><span class="line">    //...</span><br><span class="line">    method1();</span><br><span class="line">    //...</span><br><span class="line">    method2();</span><br><span class="line">    //...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  protected abstract void method1();</span><br><span class="line">  protected abstract void method2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteClass1 extends AbstractClass &#123;</span><br><span class="line">  @Override</span><br><span class="line">  protected void method1() &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  protected void method2() &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteClass2 extends AbstractClass &#123;</span><br><span class="line">  @Override</span><br><span class="line">  protected void method1() &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  protected void method2() &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AbstractClass demo = ConcreteClass1();</span><br><span class="line">demo.templateMethod();</span><br></pre></td></tr></table></figure>

<h3 id="1-模板模式的两大作用"><a href="#1-模板模式的两大作用" class="headerlink" title="1.模板模式的两大作用"></a>1.模板模式的两大作用</h3><p>复用和扩展。其中，复用指的是，所有的子类可以复用父类中提供的模板方法的代码。扩展指的是，框架通过模板模式提供功能扩展点，让框架用户可以在不修改框架源码的情况下，基于扩展点定制化框架的功能。</p>
<h3 id="2-模板模式-VS-回调"><a href="#2-模板模式-VS-回调" class="headerlink" title="2.模板模式 VS 回调"></a>2.模板模式 VS 回调</h3><p>回调可以分为同步回调和异步回调（或者延迟回调）。同步回调指在函数返回之前执行回调函数；异步回调指的是在函数返回之后执行回调函数。同步回调相当于传入了一个方法，在调用者执行到这个方法时被调用，此时是调用者还未执行完毕。异步回调类似于注册监听者的方式，注册方法执行后，可能立刻会有回调，也可能方法执行完才有。</p>
<p>从应用场景上来看，同步回调跟模板模式几乎一致。它们都是在一个大的算法骨架中，自由替换其中的某个步骤，起到代码复用和扩展的目的。<strong>而异步回调跟模板模式有较大差别，更像是观察者模式</strong>。</p>
<p>从代码实现上来看，回调和模板模式完全不同。<strong>回调基于组合关系来实现，把一个对象传递给另一个对象，是一种对象之间的关系；模板模式基于继承关系来实现，子类重写父类的抽象方法，是一种类之间的关系</strong>。</p>
<h2 id="6-3-策略模式"><a href="#6-3-策略模式" class="headerlink" title="6.3  策略模式"></a>6.3  策略模式</h2><p>定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于调用者。</p>
<p><img src="/pics/image-20200521111434498.png" alt="image-20200521111434498"></p>
<h3 id="1-策略的定义"><a href="#1-策略的定义" class="headerlink" title="1.策略的定义"></a>1.策略的定义</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Strategy &#123;</span><br><span class="line">  void algorithmInterface();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteStrategyA implements Strategy &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void  algorithmInterface() &#123;</span><br><span class="line">    //具体的算法...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteStrategyB implements Strategy &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void  algorithmInterface() &#123;</span><br><span class="line">    //具体的算法...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-策略的创建"><a href="#2-策略的创建" class="headerlink" title="2.策略的创建"></a>2.策略的创建</h3><p>因为策略模式会包含一组策略，在使用它们的时候，一般会通过类型（type）来判断创建哪个策略来使用。为了封装创建逻辑，我们需要对客户端代码屏蔽创建细节。我们可以把根据 type 创建策略的逻辑抽离出来，放到工厂类中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class StrategyFactory &#123;</span><br><span class="line">  private static final Map&lt;String, Strategy&gt; strategies = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  static &#123;</span><br><span class="line">    strategies.put(&quot;A&quot;, new ConcreteStrategyA());</span><br><span class="line">    strategies.put(&quot;B&quot;, new ConcreteStrategyB());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static Strategy getStrategy(String type) &#123;</span><br><span class="line">    if (type == null || type.isEmpty()) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;type should not be empty.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return strategies.get(type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>一般来讲，如果策略类是无状态的，不包含成员变量，只是纯粹的算法实现，这样的策略对象是可以被共享使用的，不需要在每次调用 getStrategy() 的时候，都创建一个新的策略对象。</strong>针对这种情况，我们可以使用上面这种工厂类的实现方式，事先创建好每个策略对象，缓存到工厂类中，用的时候直接返回。</p>
<p>相反，<strong>如果策略类是有状态的，根据业务场景的需要，我们希望每次从工厂方法中，获得的都是新创建的策略对象，</strong>而不是缓存好可共享的策略对象，那我们就需要按照如下方式来实现策略工厂类。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class StrategyFactory &#123;</span><br><span class="line">  public static Strategy getStrategy(String type) &#123;</span><br><span class="line">    if (type == null || type.isEmpty()) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;type should not be empty.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (type.equals(&quot;A&quot;)) &#123;</span><br><span class="line">      return new ConcreteStrategyA();</span><br><span class="line">    &#125; else if (type.equals(&quot;B&quot;)) &#123;</span><br><span class="line">      return new ConcreteStrategyB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-策略的使用"><a href="#3-策略的使用" class="headerlink" title="3.策略的使用"></a>3.策略的使用</h3><p>策略模式包含一组可选策略，客户端代码一般如何确定使用哪个策略呢？最常见的是运行时动态确定使用哪种策略，这也是策略模式最典型的应用场景。<strong>这里的“运行时动态”指的是，我们事先并不知道会使用哪个策略，而是在程序运行期间，根据配置、用户输入、计算结果等这些不确定因素，动态决定使用哪种策略</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 策略接口：EvictionStrategy</span></span><br><span class="line"><span class="comment">// 策略类：LruEvictionStrategy、FifoEvictionStrategy、LfuEvictionStrategy...</span></span><br><span class="line"><span class="comment">// 策略工厂：EvictionStrategyFactory</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserCache</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, User&gt; cacheData = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> EvictionStrategy eviction;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UserCache</span><span class="params">(EvictionStrategy eviction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.eviction = eviction;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行时动态确定，根据配置文件的配置决定使用哪种策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    EvictionStrategy evictionStrategy = <span class="keyword">null</span>;</span><br><span class="line">    Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">    props.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;./config.properties&quot;</span>));</span><br><span class="line">    String type = props.getProperty(<span class="string">&quot;eviction_type&quot;</span>);</span><br><span class="line">    evictionStrategy = EvictionStrategyFactory.getEvictionStrategy(type);</span><br><span class="line">    UserCache userCache = <span class="keyword">new</span> UserCache(evictionStrategy);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非运行时动态确定，在代码中指定使用哪种策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    EvictionStrategy evictionStrategy = <span class="keyword">new</span> LruEvictionStrategy();</span><br><span class="line">    UserCache userCache = <span class="keyword">new</span> UserCache(evictionStrategy);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-如何利用策略模式避免分支判断？"><a href="#4-如何利用策略模式避免分支判断？" class="headerlink" title="4.如何利用策略模式避免分支判断？"></a>4.如何利用策略模式避免分支判断？</h3><p>查表法。实际上，能够移除分支判断逻辑的模式不仅仅有策略模式，后面我们要讲的状态模式也可以。对于使用哪种模式，具体还要看应用场景来定。 策略模式适用于根据不同类型的动态，决定使用哪种策略这样一种应用场景。</p>
<p>我们先通过一个例子来看下，if-else 或 switch-case 分支判断逻辑是如何产生的。具体的代码如下所示。在这个例子中，我们没有使用策略模式，而是将策略的定义、创建、使用直接耦合在一起。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">discount</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> discount = <span class="number">0.0</span>;</span><br><span class="line">    OrderType type = order.getType();</span><br><span class="line">    <span class="keyword">if</span> (type.equals(OrderType.NORMAL)) &#123; <span class="comment">// 普通订单</span></span><br><span class="line">      <span class="comment">//...省略折扣计算算法代码</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(OrderType.GROUPON)) &#123; <span class="comment">// 团购订单</span></span><br><span class="line">      <span class="comment">//...省略折扣计算算法代码</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(OrderType.PROMOTION)) &#123; <span class="comment">// 促销订单</span></span><br><span class="line">      <span class="comment">//...省略折扣计算算法代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> discount;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用策略模式对上面的代码重构，将不同类型订单的打折策略设计成策略类，并由工厂类来负责创建策略对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 策略的定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DiscountStrategy</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">calDiscount</span><span class="params">(Order order)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 省略NormalDiscountStrategy、GrouponDiscountStrategy、PromotionDiscountStrategy类代码...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 策略的创建</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscountStrategyFactory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;OrderType, DiscountStrategy&gt; strategies = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    strategies.put(OrderType.NORMAL, <span class="keyword">new</span> NormalDiscountStrategy());</span><br><span class="line">    strategies.put(OrderType.GROUPON, <span class="keyword">new</span> GrouponDiscountStrategy());</span><br><span class="line">    strategies.put(OrderType.PROMOTION, <span class="keyword">new</span> PromotionDiscountStrategy());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DiscountStrategy <span class="title">getDiscountStrategy</span><span class="params">(OrderType type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> strategies.get(type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 策略的使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">discount</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">    OrderType type = order.getType();</span><br><span class="line">    DiscountStrategy discountStrategy = DiscountStrategyFactory.getDiscountStrategy(type);</span><br><span class="line">    <span class="keyword">return</span> discountStrategy.calDiscount(order);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h3><p><strong>策略模式用来解耦策略的定义、创建、使用。</strong>实际上，一个完整的策略模式就是由这三个部分组成的。</p>
<ul>
<li>策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。</li>
<li>策略的创建由工厂类来完成，封装策略创建的细节。</li>
<li>策略模式包含一组策略可选，客户端代码如何选择使用哪个策略，有两种确定方法：编译时静态确定和运行时动态确定。其中，“运行时动态确定”才是策略模式最典型的应用场景。</li>
</ul>
<p>除此之外，我们还可以通过策略模式来移除 if-else 分支判断。实际上，这得益于策略工厂类，更本质上点讲，是借助“查表法”，根据 type 查表替代根据 type 分支判断。</p>
<p>对于 Java 语言来说，我们可以通过反射来避免对策略工厂类的修改。具体是这么做的：我们通过一个配置文件或者自定义的 annotation 来标注都有哪些策略类；策略工厂类读取配置文件或者搜索被 annotation 标注的策略类，然后通过反射动态地加载这些策略类、创建策略对象；当我们新添加一个策略的时候，只需要将这个新添加的策略类添加到配置文件或者用 annotation 标注即可。</p>
<h2 id="6-4-职责链模式"><a href="#6-4-职责链模式" class="headerlink" title="6.4 职责链模式"></a>6.4 职责链模式</h2><p>将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止。</p>
<p><img src="/pics/image-20200523101842144.png" alt="image-20200523101842144"></p>
<h3 id="1-职责链模式的实现：链表-vs-数组"><a href="#1-职责链模式的实现：链表-vs-数组" class="headerlink" title="1.职责链模式的实现：链表 vs 数组"></a>1.职责链模式的实现：链表 vs 数组</h3><p>职责链模式有两种常用的实现。一种是使用链表来存储处理器，另一种是使用数组来存储处理器，后面一种实现方式更加简单。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class Handler &#123;</span><br><span class="line">  protected Handler successor = null;</span><br><span class="line"></span><br><span class="line">  public void setSuccessor(Handler successor) &#123;</span><br><span class="line">    this.successor = successor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public final void handle() &#123;</span><br><span class="line">    boolean handled = doHandle();</span><br><span class="line">    if (successor != null &amp;&amp; !handled) &#123;</span><br><span class="line">      successor.handle();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  protected abstract boolean doHandle();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HandlerA extends Handler &#123;</span><br><span class="line">  @Override</span><br><span class="line">  protected boolean doHandle() &#123;</span><br><span class="line">    boolean handled = false;</span><br><span class="line">    //...</span><br><span class="line">    return handled;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HandlerB extends Handler &#123;</span><br><span class="line">  @Override</span><br><span class="line">  protected boolean doHandle() &#123;</span><br><span class="line">    boolean handled = false;</span><br><span class="line">    //...</span><br><span class="line">    return handled;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HandlerChain &#123;</span><br><span class="line">  private Handler head = null;</span><br><span class="line">  private Handler tail = null;</span><br><span class="line"></span><br><span class="line">  public void addHandler(Handler handler) &#123;</span><br><span class="line">    handler.setSuccessor(null);</span><br><span class="line"></span><br><span class="line">    if (head == null) &#123;</span><br><span class="line">      head = handler;</span><br><span class="line">      tail = handler;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tail.setSuccessor(handler);</span><br><span class="line">    tail = handler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void handle() &#123;</span><br><span class="line">    if (head != null) &#123;</span><br><span class="line">      head.handle();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用举例</span><br><span class="line">public class Application &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    HandlerChain chain = new HandlerChain();</span><br><span class="line">    chain.addHandler(new HandlerA());</span><br><span class="line">    chain.addHandler(new HandlerB());</span><br><span class="line">    chain.handle();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，使用链表的方式，需要每个处理器设置后继节点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface IHandler &#123;</span><br><span class="line">  boolean handle();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HandlerA implements IHandler &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public boolean handle() &#123;</span><br><span class="line">    boolean handled = false;</span><br><span class="line">    //...</span><br><span class="line">    return handled;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HandlerB implements IHandler &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public boolean handle() &#123;</span><br><span class="line">    boolean handled = false;</span><br><span class="line">    //...</span><br><span class="line">    return handled;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HandlerChain &#123;</span><br><span class="line">  private List&lt;IHandler&gt; handlers = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public void addHandler(IHandler handler) &#123;</span><br><span class="line">    this.handlers.add(handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void handle() &#123;</span><br><span class="line">    for (IHandler handler : handlers) &#123;</span><br><span class="line">      boolean handled = handler.handle();</span><br><span class="line">      if (handled) &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用举例</span><br><span class="line">public class Application &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    HandlerChain chain = new HandlerChain();</span><br><span class="line">    chain.addHandler(new HandlerA());</span><br><span class="line">    chain.addHandler(new HandlerB());</span><br><span class="line">    chain.handle();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-变体"><a href="#2-变体" class="headerlink" title="2.变体"></a>2.变体</h3><p>如果处理器链上的某个处理器能够处理这个请求，那就不会继续往下传递请求。实际上，职责链模式还有一种变体，那就是请求会被所有的处理器都处理一遍，不存在中途终止的情况。</p>
<h3 id="3-应用"><a href="#3-应用" class="headerlink" title="3.应用"></a>3.应用</h3><p>职责链模式常用在框架开发中，用来实现框架的<strong>过滤器、拦截器</strong>功能，让框架的使用者在不需要修改框架源码的情况下，添加新的过滤拦截功能。这也体现了之前讲到的对扩展开放、对修改关闭的设计原则。</p>
<h2 id="6-5-状态模式"><a href="#6-5-状态模式" class="headerlink" title="6.5 状态模式"></a>6.5 状态模式</h2><p>状态模式是状态机的一种实现方式即可。状态机又叫有限状态机，它有 3 个部分组成：状态、事件、动作。其中，事件也称为转移条件。事件触发状态的转移及动作的执行。不过，动作不是必须的，也可能只转移状态，不执行任何动作。</p>
<p>“超级马里奥”游戏不知道你玩过没有？在游戏中，马里奥可以变身为多种形态，比如小马里奥（Small Mario）、超级马里奥（Super Mario）、火焰马里奥（Fire Mario）、斗篷马里奥（Cape Mario）等等。在不同的游戏情节下，各个形态会互相转化，并相应的增减积分。比如，初始形态是小马里奥，吃了蘑菇之后就会变成超级马里奥，并且增加 100 积分。</p>
<p>实际上，马里奥形态的转变就是一个状态机。其中，马里奥的不同形态就是状态机中的“状态”，游戏情节（比如吃了蘑菇）就是状态机中的“事件”，加减积分就是状态机中的“动作”。比如，吃蘑菇这个事件，会触发状态的转移：从小马里奥转移到超级马里奥，以及触发动作的执行（增加 100 积分）。</p>
<p>为了方便接下来的讲解，我对游戏背景做了简化，只保留了部分状态和事件。简化之后的状态转移如下图所示：</p>
<p><img src="/pics/image-20200523110010170.png" alt="image-20200523110010170"></p>
<h3 id="1-分支逻辑法"><a href="#1-分支逻辑法" class="headerlink" title="1.分支逻辑法"></a>1.分支逻辑法</h3><p>利用 if-else 或者 switch-case 分支逻辑，参照状态转移图，将每一个状态转移原模原样地直译成代码。对于简单的状态机来说，这种实现方式最简单、最直接，是首选。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">  SMALL(<span class="number">0</span>),</span><br><span class="line">  SUPER(<span class="number">1</span>),</span><br><span class="line">  FIRE(<span class="number">2</span>),</span><br><span class="line">  CAPE(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">State</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MarioStateMachine</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line">  <span class="keyword">private</span> State currentState;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MarioStateMachine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.score = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.currentState = State.SMALL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainMushRoom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (currentState.equals(State.SMALL)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.currentState = State.SUPER;</span><br><span class="line">      <span class="keyword">this</span>.score += <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainCape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) &#123;</span><br><span class="line">      <span class="keyword">this</span>.currentState = State.CAPE;</span><br><span class="line">      <span class="keyword">this</span>.score += <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainFireFlower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) &#123;</span><br><span class="line">      <span class="keyword">this</span>.currentState = State.FIRE;</span><br><span class="line">      <span class="keyword">this</span>.score += <span class="number">300</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">meetMonster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (currentState.equals(State.SUPER)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.currentState = State.SMALL;</span><br><span class="line">      <span class="keyword">this</span>.score -= <span class="number">100</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentState.equals(State.CAPE)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.currentState = State.SMALL;</span><br><span class="line">      <span class="keyword">this</span>.score -= <span class="number">200</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentState.equals(State.FIRE)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.currentState = State.SMALL;</span><br><span class="line">      <span class="keyword">this</span>.score -= <span class="number">300</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.score;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> State <span class="title">getCurrentState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.currentState;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MarioStateMachine mario = <span class="keyword">new</span> MarioStateMachine();</span><br><span class="line">    mario.obtainMushRoom();</span><br><span class="line">    <span class="keyword">int</span> score = mario.getScore();</span><br><span class="line">    State state = mario.getCurrentState();</span><br><span class="line">    System.out.println(<span class="string">&quot;mario score: &quot;</span> + score + <span class="string">&quot;; state: &quot;</span> + state);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-查表法"><a href="#2-查表法" class="headerlink" title="2.查表法"></a>2.查表法</h3><p>对于状态很多、状态转移比较复杂的状态机来说，查表法比较合适。通过二维数组来表示状态转移图，能极大地提高代码的可读性和可维护性。</p>
<p>实际上，除了用状态转移图来表示之外，状态机还可以用二维表来表示，如下所示。在这个二维表中，第一维表示当前状态，第二维表示事件，值表示当前状态经过事件之后，转移到的新状态及其执行的动作。</p>
<p><img src="/pics/image-20200523110337991.png" alt="image-20200523110337991"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123; </span><br><span class="line">    SMALL(<span class="number">0</span>), </span><br><span class="line">    SUPER(<span class="number">1</span>), </span><br><span class="line">    FIRE(<span class="number">2</span>), </span><br><span class="line">    CAPE(<span class="number">3</span>); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">State</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.value = value; </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   		 <span class="keyword">return</span> <span class="keyword">this</span>.value; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">  GOT_MUSHROOM(<span class="number">0</span>),</span><br><span class="line">  GOT_CAPE(<span class="number">1</span>),</span><br><span class="line">  GOT_FIRE(<span class="number">2</span>),</span><br><span class="line">  MET_MONSTER(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Event</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MarioStateMachine</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line">  <span class="keyword">private</span> State currentState;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 状态转移的二维数组</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> State[][] transitionTable = &#123;</span><br><span class="line">          &#123;SUPER, CAPE, FIRE, SMALL&#125;,</span><br><span class="line">          &#123;SUPER, CAPE, FIRE, SMALL&#125;,</span><br><span class="line">          &#123;CAPE, CAPE, CAPE, SMALL&#125;,</span><br><span class="line">          &#123;FIRE, FIRE, FIRE, SMALL&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 触发事件的结果二维数组</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[][] actionTable = &#123;</span><br><span class="line">          &#123;+<span class="number">100</span>, +<span class="number">200</span>, +<span class="number">300</span>, +<span class="number">0</span>&#125;,</span><br><span class="line">          &#123;+<span class="number">0</span>, +<span class="number">200</span>, +<span class="number">300</span>, -<span class="number">100</span>&#125;,</span><br><span class="line">          &#123;+<span class="number">0</span>, +<span class="number">0</span>, +<span class="number">0</span>, -<span class="number">200</span>&#125;,</span><br><span class="line">          &#123;+<span class="number">0</span>, +<span class="number">0</span>, +<span class="number">0</span>, -<span class="number">300</span>&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MarioStateMachine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.score = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.currentState = State.SMALL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainMushRoom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    executeEvent(Event.GOT_MUSHROOM);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainCape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    executeEvent(Event.GOT_CAPE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainFireFlower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    executeEvent(Event.GOT_FIRE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">meetMonster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    executeEvent(Event.MET_MONSTER);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">executeEvent</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> stateValue = currentState.getValue();</span><br><span class="line">    <span class="keyword">int</span> eventValue = event.getValue();</span><br><span class="line">    <span class="keyword">this</span>.currentState = transitionTable[stateValue][eventValue];</span><br><span class="line">    <span class="keyword">this</span>.score += actionTable[stateValue][eventValue];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.score;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> State <span class="title">getCurrentState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.currentState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-状态模式"><a href="#3-状态模式" class="headerlink" title="3.状态模式"></a>3.状态模式</h3><p>对于状态并不多、状态转移也比较简单，<strong>但事件触发执行的动作包含的业务逻辑</strong>可能比较复杂的状态机来说，我们首选这种实现方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMario</span> </span>&#123; <span class="comment">//所有状态类的接口</span></span><br><span class="line">  <span class="function">State <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">//以下是定义的事件</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">obtainMushRoom</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">obtainCape</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">obtainFireFlower</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">meetMonster</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmallMario</span> <span class="keyword">implements</span> <span class="title">IMario</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> MarioStateMachine stateMachine;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SmallMario</span><span class="params">(MarioStateMachine stateMachine)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.stateMachine = stateMachine;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> State <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> State.SMALL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainMushRoom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stateMachine.setCurrentState(<span class="keyword">new</span> SuperMario(stateMachine));</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() + <span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainCape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stateMachine.setCurrentState(<span class="keyword">new</span> CapeMario(stateMachine));</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() + <span class="number">200</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainFireFlower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stateMachine.setCurrentState(<span class="keyword">new</span> FireMario(stateMachine));</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() + <span class="number">300</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">meetMonster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do nothing...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperMario</span> <span class="keyword">implements</span> <span class="title">IMario</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> MarioStateMachine stateMachine;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SuperMario</span><span class="params">(MarioStateMachine stateMachine)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.stateMachine = stateMachine;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> State <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> State.SUPER;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainMushRoom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do nothing...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainCape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stateMachine.setCurrentState(<span class="keyword">new</span> CapeMario(stateMachine));</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() + <span class="number">200</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainFireFlower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stateMachine.setCurrentState(<span class="keyword">new</span> FireMario(stateMachine));</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() + <span class="number">300</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">meetMonster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stateMachine.setCurrentState(<span class="keyword">new</span> SmallMario(stateMachine));</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() - <span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略CapeMario、FireMario类...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MarioStateMachine</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line">  <span class="keyword">private</span> IMario currentState; <span class="comment">// 不再使用枚举来表示状态</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MarioStateMachine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.score = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.currentState = <span class="keyword">new</span> SmallMario(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainMushRoom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.currentState.obtainMushRoom();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainCape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.currentState.obtainCape();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainFireFlower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.currentState.obtainFireFlower();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">meetMonster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.currentState.meetMonster();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.score;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> State <span class="title">getCurrentState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.currentState.getName();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.score = score;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCurrentState</span><span class="params">(IMario currentState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.currentState = currentState;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>MarioStateMachine 和各个状态类之间是双向依赖关系</strong>。MarioStateMachine 依赖各个状态类是理所当然的，但是，反过来，各个状态类为什么要依赖 <code>MarioStateMachine</code> 呢？这是因为，各个状态类需要更新 MarioStateMachine 中的两个变量，score 和 currentState。</p>
<h2 id="6-6-迭代器模式"><a href="#6-6-迭代器模式" class="headerlink" title="6.6 迭代器模式"></a>6.6 迭代器模式</h2><p>用来遍历集合对象。这里说的“集合对象”也可以叫“容器”“聚合对象”，实际上就是包含一组对象的对象，比如数组、链表、树、图、跳表。迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一。</p>
<p><img src="/pics/image-20200525115550212.png" alt="image-20200525115550212"></p>
<h3 id="1-迭代器来遍历有下面三个优势"><a href="#1-迭代器来遍历有下面三个优势" class="headerlink" title="1.迭代器来遍历有下面三个优势"></a>1.迭代器来遍历有下面三个优势</h3><p>遍历集合一般有三种方式：for 循环、foreach 循环、迭代器遍历。后两种本质上属于一种，都可以看作迭代器遍历。</p>
<p>相对于 for 循环遍历，利用迭代器来遍历有下面三个优势：</p>
<ul>
<li>迭代器模式封装集合内部的复杂数据结构，开发者不需要了解如何遍历，直接使用容器提供的迭代器即可；</li>
<li>迭代器模式<strong>将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一</strong>；</li>
<li>迭代器模式让<strong>添加新的遍历算法更加容易，更符合开闭原则</strong>。</li>
</ul>
<p>除此之外，因为迭代器都实现自相同的接口，在开发中，基于接口而非实现编程，替换迭代器也变得更加容易。</p>
<h3 id="2-迭代器和集合元素删除"><a href="#2-迭代器和集合元素删除" class="headerlink" title="2.迭代器和集合元素删除"></a>2.迭代器和集合元素删除</h3><p>在通过迭代器来遍历集合元素的同时，增加或者删除集合中的元素，有可能会导致某个元素被重复遍历或遍历不到。不过，并不是所有情况下都会遍历出错，有的时候也可以正常遍历，所以，这种行为称为结果不可预期行为或者未决行为。实际上，“不可预期”比直接出错更加可怕，有的时候运行正确，有的时候运行错误，一些隐藏很深、很难 debug 的 bug 就是这么产生的。</p>
<p>有两种比较干脆利索的解决方案，来避免出现这种不可预期的运行结果。一种是遍历的时候不允许增删元素，另一种是增删元素之后让遍历报错。第一种解决方案比较难实现，因为很难确定迭代器使用结束的时间点。第二种解决方案更加合理。Java 语言就是采用的这种解决方案。增删元素之后，我们选择 fail-fast 解决方式，让遍历操作直接抛出运行时异常。</p>
<p>像 Java 语言，迭代器类中除了前面提到的几个最基本的方法之外，还定义了一个 remove() 方法，能够在遍历集合的同时，安全地删除集合中的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    Itr() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      checkForComodification();</span><br><span class="line">      <span class="keyword">int</span> i = cursor;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">      Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">      cursor = i + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">      checkForComodification();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">        cursor = lastRet;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代器类新增了一个 lastRet 成员变量，用来记录游标指向的前一个元素。通过迭代器去删除这个元素的时候，我们可以更新迭代器中的cursor值为lastRet 值，来保证不会因为删除元素而导致某个元素遍历不到。</p>
<h3 id="3-“快照”迭代器"><a href="#3-“快照”迭代器" class="headerlink" title="3.“快照”迭代器"></a>3.“快照”迭代器</h3><h4 id="解决方案一："><a href="#解决方案一：" class="headerlink" title="解决方案一："></a>解决方案一：</h4><p>在迭代器类中定义一个成员变量 snapshot 来存储快照。每当创建迭代器的时候，都拷贝一份容器中的元素到快照中，后续的遍历操作都基于这个迭代器自己持有的快照来进行。具体的代码实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SnapshotArrayIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> cursor;</span><br><span class="line">  <span class="keyword">private</span> ArrayList&lt;E&gt; snapshot;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SnapshotArrayIterator</span><span class="params">(ArrayList&lt;E&gt; arrayList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cursor = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.snapshot = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">this</span>.snapshot.addAll(arrayList);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cursor &lt; snapshot.size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    E currentItem = snapshot.get(cursor);</span><br><span class="line">    cursor++;</span><br><span class="line">    <span class="keyword">return</span> currentItem;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解决方案二："><a href="#解决方案二：" class="headerlink" title="解决方案二："></a>解决方案二：</h4><p>我们可以在容器中，为每个元素保存两个时间戳，一个是添加时间戳 addTimestamp，一个是删除时间戳 delTimestamp。当元素被加入到集合中的时候，我们将 addTimestamp 设置为当前时间，将 delTimestamp 设置成最大长整型值（Long.MAX_VALUE）。当元素被删除时，我们将 delTimestamp 更新为当前时间，表示已经被删除。</p>
<p>注意，这里只是标记删除，而非真正将它从容器中删除。</p>
<p>同时，每个迭代器也保存一个迭代器创建时间戳 snapshotTimestamp，也就是迭代器对应的快照的创建时间戳。当使用迭代器来遍历容器的时候，只有满足 addTimestamp&lt; snapshotTimestamp&lt; delTimestamp的元素，才是属于这个迭代器的快照。如果元素的 addTimestamp&gt;snapshotTimestamp，说明元素在创建了迭代器之后才加入的，不属于这个迭代器的快照；如果元素的 delTimestamp&lt; snapshotTimestamp，说明元素在创建迭代器之前就被删除掉了，也不属于这个迭代器的快照。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> actualSize; <span class="comment">//不包含标记删除元素</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> totalSize; <span class="comment">//包含标记删除元素</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Object[] elements;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span>[] addTimestamps;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span>[] delTimestamps;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elements = <span class="keyword">new</span> Object[DEFAULT_CAPACITY];</span><br><span class="line">    <span class="keyword">this</span>.addTimestamps = <span class="keyword">new</span> <span class="keyword">long</span>[DEFAULT_CAPACITY];</span><br><span class="line">    <span class="keyword">this</span>.delTimestamps = <span class="keyword">new</span> <span class="keyword">long</span>[DEFAULT_CAPACITY];</span><br><span class="line">    <span class="keyword">this</span>.totalSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.actualSize = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E obj)</span> </span>&#123;</span><br><span class="line">    elements[totalSize] = obj;</span><br><span class="line">    addTimestamps[totalSize] = System.currentTimeMillis();</span><br><span class="line">    delTimestamps[totalSize] = Long.MAX_VALUE;</span><br><span class="line">    totalSize++;</span><br><span class="line">    actualSize++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalSize; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (elements[i].equals(obj)) &#123;</span><br><span class="line">        delTimestamps[i] = System.currentTimeMillis();</span><br><span class="line">        actualSize--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">actualSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.actualSize;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.totalSize;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= totalSize) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (E)elements[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getAddTimestamp</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= totalSize) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> addTimestamps[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelTimestamp</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= totalSize) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> delTimestamps[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SnapshotArrayIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> snapshotTimestamp;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> cursorInAll; <span class="comment">// 在整个容器中的下标，而非快照中的下标</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> leftCount; <span class="comment">// 快照中还有几个元素未被遍历</span></span><br><span class="line">  <span class="keyword">private</span> ArrayList&lt;E&gt; arrayList;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SnapshotArrayIterator</span><span class="params">(ArrayList&lt;E&gt; arrayList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.snapshotTimestamp = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">this</span>.cursorInAll = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.leftCount = arrayList.actualSize();;</span><br><span class="line">    <span class="keyword">this</span>.arrayList = arrayList;</span><br><span class="line"></span><br><span class="line">    justNext(); <span class="comment">// 先跳到这个迭代器快照的第一个元素</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.leftCount &gt;= <span class="number">0</span>; <span class="comment">// 注意是&gt;=, 而非&gt;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    E currentItem = arrayList.get(cursorInAll);</span><br><span class="line">    justNext();</span><br><span class="line">    <span class="keyword">return</span> currentItem;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">justNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cursorInAll &lt; arrayList.totalSize()) &#123;</span><br><span class="line">      <span class="keyword">long</span> addTimestamp = arrayList.getAddTimestamp(cursorInAll);</span><br><span class="line">      <span class="keyword">long</span> delTimestamp = arrayList.getDelTimestamp(cursorInAll);</span><br><span class="line">      <span class="keyword">if</span> (snapshotTimestamp &gt; addTimestamp &amp;&amp; snapshotTimestamp &lt; delTimestamp) &#123;</span><br><span class="line">        leftCount--;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      cursorInAll++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-7-访问者模式"><a href="#6-7-访问者模式" class="headerlink" title="6.7 访问者模式"></a>6.7 访问者模式</h2><p>允许一个或者多个操作应用到一组对象上，解耦操作和对象本身。</p>
<p><img src="/pics/image-20200528103452763.png" alt="image-20200528103452763"></p>
<h3 id="1-范例"><a href="#1-范例" class="headerlink" title="1.范例"></a>1.范例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class ResourceFile &#123;</span><br><span class="line">  protected String filePath;</span><br><span class="line">  public ResourceFile(String filePath) &#123;</span><br><span class="line">    this.filePath = filePath;</span><br><span class="line">  &#125;</span><br><span class="line">  abstract public void accept(Visitor vistor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PdfFile extends ResourceFile &#123;</span><br><span class="line">  public PdfFile(String filePath) &#123;</span><br><span class="line">    super(filePath);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void accept(Visitor visitor) &#123;</span><br><span class="line">    visitor.visit(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//...PPTFile、WordFile跟PdfFile类似，这里就省略了...</span><br><span class="line">public interface Visitor &#123;</span><br><span class="line">  void visit(PdfFile pdfFile);</span><br><span class="line">  void visit(PPTFile pdfFile);</span><br><span class="line">  void visit(WordFile pdfFile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Extractor implements Visitor &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void visit(PPTFile pptFile) &#123;</span><br><span class="line">    //...</span><br><span class="line">    System.out.println(&quot;Extract PPT.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void visit(PdfFile pdfFile) &#123;</span><br><span class="line">    //...</span><br><span class="line">    System.out.println(&quot;Extract PDF.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void visit(WordFile wordFile) &#123;</span><br><span class="line">    //...</span><br><span class="line">    System.out.println(&quot;Extract WORD.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Compressor implements Visitor &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void visit(PPTFile pptFile) &#123;</span><br><span class="line">    //...</span><br><span class="line">    System.out.println(&quot;Compress PPT.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void visit(PdfFile pdfFile) &#123;</span><br><span class="line">    //...</span><br><span class="line">    System.out.println(&quot;Compress PDF.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void visit(WordFile wordFile) &#123;</span><br><span class="line">    //...</span><br><span class="line">    System.out.println(&quot;Compress WORD.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ToolApplication &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    Extractor extractor = new Extractor();</span><br><span class="line">    List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[0]);</span><br><span class="line">    for (ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class="line">      resourceFile.accept(extractor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Compressor compressor = new Compressor();</span><br><span class="line">    for(ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class="line">      resourceFile.accept(compressor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static List&lt;ResourceFile&gt; listAllResourceFiles(String resourceDirectory) &#123;</span><br><span class="line">    List&lt;ResourceFile&gt; resourceFiles = new ArrayList&lt;&gt;();</span><br><span class="line">    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)</span><br><span class="line">    resourceFiles.add(new PdfFile(&quot;a.pdf&quot;));</span><br><span class="line">    resourceFiles.add(new WordFile(&quot;b.word&quot;));</span><br><span class="line">    resourceFiles.add(new PPTFile(&quot;c.ppt&quot;));</span><br><span class="line">    return resourceFiles;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般来说，访问者模式针对的是一组类型不同的对象（PdfFile、PPTFile、WordFile）。不过，尽管这组对象的类型是不同的，但是，它们继承相同的父类（ResourceFile）或者实现相同的接口。在不同的应用场景下，我们需要对这组对象进行一系列不相关的业务操作（抽取文本、压缩等），但为了避免不断添加功能导致类（PdfFile、PPTFile、WordFile）不断膨胀，职责越来越不单一，以及避免频繁地添加功能导致的频繁代码修改，我们使用访问者模式，<strong>将对象与操作解耦，</strong>将这些业务操作抽离出来，定义在独立细分的访问者类（Extractor、Compressor）中。</p>
<h3 id="2-Single-Dispatch-和-Double-Dispatch"><a href="#2-Single-Dispatch-和-Double-Dispatch" class="headerlink" title="2.Single Dispatch 和 Double Dispatch"></a>2.Single Dispatch 和 Double Dispatch</h3><p>所谓 Single Dispatch，指的是执行<strong>哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的编译时类型来决定</strong>。所谓 Double Dispatch，指的是<strong>执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的运行时类型来决定</strong>。</p>
<p>具体到编程语言的语法机制，Single Dispatch 和 Double Dispatch 跟多态和函数重载直接相关。当前主流的面向对象编程语言（比如，Java、C++、C#）都只支持 Single Dispatch，不支持 Double Dispatch。</p>
<h3 id="3-访问者模式的替代"><a href="#3-访问者模式的替代" class="headerlink" title="3.访问者模式的替代"></a>3.访问者模式的替代</h3><p>开发这个工具有很多种代码设计和实现思路。为了讲解访问者模式，上节课我们选择了用访问者模式来实现。实际上，我们还有其他的实现方法，比如，我们还可以利用工厂模式来实现，定义一个包含 extract2txt() 接口函数的 Extractor 接口。PdfExtractor、PPTExtractor、WordExtractor 类实现 Extractor 接口，并且在各自的 extract2txt() 函数中，分别实现 Pdf、PPT、Word 格式文件的文本内容抽取。ExtractorFactory 工厂类根据不同的文件类型，返回不同的 Extractor。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class ResourceFile &#123;</span><br><span class="line">  protected String filePath;</span><br><span class="line">  public ResourceFile(String filePath) &#123;</span><br><span class="line">    this.filePath = filePath;</span><br><span class="line">  &#125;</span><br><span class="line">  public abstract ResourceFileType getType();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PdfFile extends ResourceFile &#123;</span><br><span class="line">  public PdfFile(String filePath) &#123;</span><br><span class="line">    super(filePath);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public ResourceFileType getType() &#123;</span><br><span class="line">    return ResourceFileType.PDF;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//...PPTFile/WordFile跟PdfFile代码结构类似，此处省略...</span><br><span class="line"></span><br><span class="line">public interface Extractor &#123;</span><br><span class="line">  void extract2txt(ResourceFile resourceFile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PdfExtractor implements Extractor &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void extract2txt(ResourceFile resourceFile) &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//...PPTExtractor/WordExtractor跟PdfExtractor代码结构类似，此处省略...</span><br><span class="line"></span><br><span class="line">public class ExtractorFactory &#123;</span><br><span class="line">  private static final Map&lt;ResourceFileType, Extractor&gt; extractors = new HashMap&lt;&gt;();</span><br><span class="line">  static &#123;</span><br><span class="line">    extractors.put(ResourceFileType.PDF, new PdfExtractor());</span><br><span class="line">    extractors.put(ResourceFileType.PPT, new PPTExtractor());</span><br><span class="line">    extractors.put(ResourceFileType.WORD, new WordExtractor());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static Extractor getExtractor(ResourceFileType type) &#123;</span><br><span class="line">    return extractors.get(type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ToolApplication &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[0]);</span><br><span class="line">    for (ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class="line">      Extractor extractor = ExtractorFactory.getExtractor(resourceFile.getType());</span><br><span class="line">      extractor.extract2txt(resourceFile);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static List&lt;ResourceFile&gt; listAllResourceFiles(String resourceDirectory) &#123;</span><br><span class="line">    List&lt;ResourceFile&gt; resourceFiles = new ArrayList&lt;&gt;();</span><br><span class="line">    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)</span><br><span class="line">    resourceFiles.add(new PdfFile(&quot;a.pdf&quot;));</span><br><span class="line">    resourceFiles.add(new WordFile(&quot;b.word&quot;));</span><br><span class="line">    resourceFiles.add(new PPTFile(&quot;c.ppt&quot;));</span><br><span class="line">    return resourceFiles;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-8-备忘录模式"><a href="#6-8-备忘录模式" class="headerlink" title="6.8 备忘录模式"></a>6.8 备忘录模式</h2><p>在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。</p>
<p><img src="/pics/image-20200528205840204.png" alt="image-20200528205840204"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//象棋棋子类：原发器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chessman</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String label;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chessman</span><span class="params">(String label, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.label = label;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略get set</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChessmanMemento <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ChessmanMemento(<span class="keyword">this</span>.label, <span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//恢复状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restore</span><span class="params">(ChessmanMemento memento)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.label = memento.getLabel();</span><br><span class="line">        <span class="keyword">this</span>.x = memento.getX();</span><br><span class="line">        <span class="keyword">this</span>.y = memento.getY();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//象棋棋子备忘录类：备忘录</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChessmanMemento</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String label;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChessmanMemento</span><span class="params">(String label, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.label = label;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 省略get set</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//象棋棋子备忘录管理类：负责人</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MementoCaretaker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ChessmanMemento memento;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChessmanMemento <span class="title">getMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> memento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMemento</span><span class="params">(ChessmanMemento memento)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.memento = memento;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编写如下客户端测试代码：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        MementoCaretaker mc = <span class="keyword">new</span> MementoCaretaker();</span><br><span class="line">        Chessman chess = <span class="keyword">new</span> Chessman(<span class="string">&quot;车&quot;</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        display(chess);</span><br><span class="line">        mc.setMemento(chess.save()); <span class="comment">//保存状态</span></span><br><span class="line">        chess.setY(<span class="number">4</span>);</span><br><span class="line">        display(chess);</span><br><span class="line">        mc.setMemento(chess.save()); <span class="comment">//保存状态</span></span><br><span class="line">        display(chess);</span><br><span class="line">        chess.setX(<span class="number">5</span>);</span><br><span class="line">        display(chess);</span><br><span class="line">        System.out.println(<span class="string">&quot;******悔棋******&quot;</span>);</span><br><span class="line">        chess.restore(mc.getMemento()); <span class="comment">//恢复状态</span></span><br><span class="line">        display(chess);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Chessman chess)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;棋子&quot;</span> + chess.getLabel() + <span class="string">&quot;当前位置为：&quot;</span> + <span class="string">&quot;第&quot;</span> + chess.getX() + <span class="string">&quot;行&quot;</span> + <span class="string">&quot;第&quot;</span> + chess.getY() + <span class="string">&quot;列。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>备忘录模式也叫快照模式，具体来说，就是在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。这个模式的定义表达了两部分内容：一部分是，存储副本以便后期恢复；另一部分是，要在不违背封装原则的前提下，进行对象的备份和恢复。这个设计模式的核心在于将类和状态区分开，通过类去维护类状态。</p>
<h2 id="6-9-命令模式"><a href="#6-9-命令模式" class="headerlink" title="6.9 命令模式"></a>6.9 命令模式</h2><p>命令模式将请求（命令）封装为一个对象，这样可以使用不同的请求参数化其他对象（将不同请求依赖注入到其他对象），并且能够支持请求（命令）的排队执行、记录日志、撤销等（附加控制）功能。</p>
<h3 id="1-命令模式的实战讲解"><a href="#1-命令模式的实战讲解" class="headerlink" title="1.命令模式的实战讲解"></a>1.命令模式的实战讲解</h3><p>假设我们正在开发一个类似《天天酷跑》或者《QQ 卡丁车》这样的手游，整个手游后端服务器轮询获取客户端发来的请求，获取到请求之后，借助命令模式，把请求包含的数据和处理逻辑封装为命令对象，并存储在内存队列中。然后，再从队列中取出一定数量的命令来执行。执行完成之后，再重新开始新的一轮轮询。具体的示例代码如下所示，你可以结合着一块看下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Command &#123;</span><br><span class="line">  void execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class GotDiamondCommand implements Command &#123;</span><br><span class="line">  // 省略成员变量</span><br><span class="line"></span><br><span class="line">  public GotDiamondCommand(/*数据*/) &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void execute() &#123;</span><br><span class="line">    // 执行相应的逻辑</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//GotStartCommand/HitObstacleCommand/ArchiveCommand类省略</span><br><span class="line"></span><br><span class="line">public class GameApplication &#123;</span><br><span class="line">  private static final int MAX_HANDLED_REQ_COUNT_PER_LOOP = 100;</span><br><span class="line">  private Queue&lt;Command&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public void mainloop() &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">      List&lt;Request&gt; requests = new ArrayList&lt;&gt;();</span><br><span class="line">      </span><br><span class="line">      //省略从epoll或者select中获取数据，并封装成Request的逻辑，</span><br><span class="line">      //注意设置超时时间，如果很长时间没有接收到请求，就继续下面的逻辑处理。</span><br><span class="line">      </span><br><span class="line">      for (Request request : requests) &#123;</span><br><span class="line">        Event event = request.getEvent();</span><br><span class="line">        Command command = null;</span><br><span class="line">        if (event.equals(Event.GOT_DIAMOND)) &#123;</span><br><span class="line">          command = new GotDiamondCommand(/*数据*/);</span><br><span class="line">        &#125; else if (event.equals(Event.GOT_STAR)) &#123;</span><br><span class="line">          command = new GotStartCommand(/*数据*/);</span><br><span class="line">        &#125; else if (event.equals(Event.HIT_OBSTACLE)) &#123;</span><br><span class="line">          command = new HitObstacleCommand(/*数据*/);</span><br><span class="line">        &#125; else if (event.equals(Event.ARCHIVE)) &#123;</span><br><span class="line">          command = new ArchiveCommand(/*数据*/);</span><br><span class="line">        &#125; // ...一堆else if...</span><br><span class="line"></span><br><span class="line">        queue.add(command);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      int handledCount = 0;</span><br><span class="line">      while (handledCount &lt; MAX_HANDLED_REQ_COUNT_PER_LOOP) &#123;</span><br><span class="line">        if (queue.isEmpty()) &#123;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        Command command = queue.poll();</span><br><span class="line">        command.execute();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-命令模式-VS-策略模式"><a href="#2-命令模式-VS-策略模式" class="headerlink" title="2.命令模式 VS 策略模式"></a>2.命令模式 VS 策略模式</h3><p>实际上，每个设计模式都应该由两部分组成：<strong>第一部分是应用场景，即这个模式可以解决哪类问题；第二部分是解决方案，即这个模式的设计思路和具体的代码实现。</strong>不过，代码实现并不是模式必须包含的。如果你单纯地只关注解决方案这一部分，甚至只关注代码实现，就会产生大部分模式看起来都很相似的错觉。实际上，设计模式之间的主要区别还是在于设计意图，也就是应用场景。单纯地看设计思路或者代码实现，有些模式确实很相似，比如策略模式和工厂模式。</p>
<p>策略模式中，不同的策略具有相同的目的、不同的实现、互相之间可以替换。比如，BubbleSort、SelectionSort 都是为了实现排序的，只不过一个是用冒泡排序算法来实现的，另一个是用选择排序算法来实现的。而在命令模式中，不同的命令具有不同的目的，对应不同的处理逻辑，并且互相之间不可替换。</p>
<h2 id="6-10-解释器模式"><a href="#6-10-解释器模式" class="headerlink" title="6.10 解释器模式"></a>6.10 解释器模式</h2><p>解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法。</p>
<p>解释器的使用有3步：</p>
<ol>
<li>明确规则</li>
<li>创建规则对应的解释器</li>
<li>将输入转化成规则</li>
</ol>
<p>假设我们定义了一个新的加减乘除计算“语言”，语法规则如下：运算符只包含加、减、乘、除，并且没有优先级的概念；表达式（也就是前面提到的“句子”）中，先书写数字，后书写运算符，空格隔开；按照先后顺序，取出两个数字和一个运算符计算结果，结果重新放入数字的最头部位置，循环上述过程，直到只剩下一个数字，这个数字就是表达式最终的计算结果。</p>
<p>我们举个例子来解释一下上面的语法规则。比如“ 8 3 2 4 - + * ”这样一个表达式，我们按照上面的语法规则来处理，取出数字“8 3”和“-”运算符，计算得到 5，于是表达式就变成了“ 5 2 4 + * ”。然后，我们再取出“ 5 2 ”和“ + ”运算符，计算得到 7，表达式就变成了“ 7 4 * ”。最后，我们取出“ 7 4”和“ * ”运算符，最终得到的结果就是 28。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">interpret</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> number;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NumberExpression</span><span class="params">(<span class="keyword">long</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.number = number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NumberExpression</span><span class="params">(String number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.number = Long.parseLong(number);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">interpret</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.number;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdditionExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Expression exp1;</span><br><span class="line">  <span class="keyword">private</span> Expression exp2;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AdditionExpression</span><span class="params">(Expression exp1, Expression exp2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.exp1 = exp1;</span><br><span class="line">    <span class="keyword">this</span>.exp2 = exp2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">interpret</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> exp1.interpret() + exp2.interpret();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SubstractionExpression/MultiplicationExpression/DivisionExpression与AdditionExpression代码结构类似，这里就省略了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpressionInterpreter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Deque&lt;Expression&gt; numbers = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">interpret</span><span class="params">(String expression)</span> </span>&#123;</span><br><span class="line">    String[] elements = expression.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> length = elements.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (length+<span class="number">1</span>)/<span class="number">2</span>; ++i) &#123;</span><br><span class="line">      numbers.addLast(<span class="keyword">new</span> NumberExpression(elements[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (length+<span class="number">1</span>)/<span class="number">2</span>; i &lt; length; ++i) &#123;</span><br><span class="line">      String operator = elements[i];</span><br><span class="line">      <span class="keyword">boolean</span> isValid = <span class="string">&quot;+&quot;</span>.equals(operator) || <span class="string">&quot;-&quot;</span>.equals(operator)</span><br><span class="line">              || <span class="string">&quot;*&quot;</span>.equals(operator) || <span class="string">&quot;/&quot;</span>.equals(operator);</span><br><span class="line">      <span class="keyword">if</span> (!isValid) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Expression is invalid: &quot;</span> + expression);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Expression exp1 = numbers.pollFirst();</span><br><span class="line">      Expression exp2 = numbers.pollFirst();</span><br><span class="line">      Expression combinedExp = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (operator.equals(<span class="string">&quot;+&quot;</span>)) &#123;</span><br><span class="line">        combinedExp = <span class="keyword">new</span> AdditionExpression(exp1, exp2);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operator.equals(<span class="string">&quot;-&quot;</span>)) &#123;</span><br><span class="line">        combinedExp = <span class="keyword">new</span> AdditionExpression(exp1, exp2);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operator.equals(<span class="string">&quot;*&quot;</span>)) &#123;</span><br><span class="line">        combinedExp = <span class="keyword">new</span> AdditionExpression(exp1, exp2);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operator.equals(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">        combinedExp = <span class="keyword">new</span> AdditionExpression(exp1, exp2);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">long</span> result = combinedExp.interpret();</span><br><span class="line">      numbers.addFirst(<span class="keyword">new</span> NumberExpression(result));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (numbers.size() != <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Expression is invalid: &quot;</span> + expression);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> numbers.pop().interpret();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-11-中介者模式"><a href="#6-11-中介者模式" class="headerlink" title="6.11 中介者模式"></a>6.11 中介者模式</h2><p>中介模式定义了一个单独的（中介）对象，来封装一组对象之间的交互。将这组对象之间的交互委派给与中介对象交互，来避免对象之间的直接交互。</p>
<p>提到中介模式，有一个比较经典的例子不得不说，那就是航空管制。为了让飞机在飞行的时候互不干扰，每架飞机都需要知道其他飞机每时每刻的位置，这就需要时刻跟其他飞机通信。飞机通信形成的通信网络就会无比复杂。这个时候，我们通过引入“塔台”这样一个中介，让每架飞机只跟塔台来通信，发送自己的位置给塔台，由塔台来负责每架飞机的航线调度。这样就大大简化了通信网络。</p>
<p><img src="/pics/image-20200528214630390.png" alt="image-20200528214630390"></p>
<p>中介模式的设计思想跟中间层很像，通过引入中介这个中间层，将一组对象之间的交互关系（或者依赖关系）从多对多（网状关系）转换为一对多（星状关系）。原来一个对象要跟 n 个对象交互，现在只需要跟一个中介对象交互，从而最小化对象之间的交互关系，降低了代码的复杂度，提高了代码的可读性和可维护性。</p>
<p>观察者模式和中介模式都是为了实现参与者之间的解耦，简化交互关系。两者的不同在于应用场景上。在观察者模式的应用场景中，参与者之间的交互比较有条理，一般都是单向的，一个参与者只有一个身份，要么是观察者，要么是被观察者。而在中介模式的应用场景中，参与者之间的交互关系错综复杂，既可以是消息的发送者、也可以同时是消息的接收者。</p>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>原型模式vs享元模式</p>
<p>原型模式关注的是如何拷贝一个对象</p>
<p>享元模式关注的是避免创建重复对象，减少内存占用，提出不可变的部分，作为享元。</p>
]]></content>
      <categories>
        <category>Design</category>
      </categories>
  </entry>
  <entry>
    <title>认知觉醒</title>
    <url>/2022/12/04/Notes/Read/0002-%E8%AE%A4%E7%9F%A5%E8%A7%89%E9%86%92/</url>
    <content><![CDATA[<h1 id="认知觉醒"><a href="#认知觉醒" class="headerlink" title="认知觉醒"></a>认知觉醒</h1><span id="more"></span>
]]></content>
      <categories>
        <category>Read</category>
      </categories>
  </entry>
  <entry>
    <title>base_01_Activity生命周期和启动模式</title>
    <url>/2021/10/26/Notes/Android/01%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6/base_01_Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="base-01-Activity生命周期和启动模式"><a href="#base-01-Activity生命周期和启动模式" class="headerlink" title="base_01_Activity生命周期和启动模式"></a>base_01_Activity生命周期和启动模式</h1><span id="more"></span>

<h1 id="一、生命周期"><a href="#一、生命周期" class="headerlink" title="一、生命周期"></a>一、生命周期</h1><h2 id="1-正常情况下生命周期分析"><a href="#1-正常情况下生命周期分析" class="headerlink" title="1.正常情况下生命周期分析"></a>1.正常情况下生命周期分析</h2><p><img src="https://leanote.com/api/file/getImage?fileId=594635f1ab64413c78001121" alt="Activity的生命周期"><br>完整生命周期：onCreate -&gt; onDestroy<br>可见生命周期：onStart -&gt; onStop<br>前台生命周期: onResume -&gt; onPause</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="2-常见生命周期的区别"><a href="#2-常见生命周期的区别" class="headerlink" title="2.常见生命周期的区别"></a>2.常见生命周期的区别</h2><h3 id="1-onCreate-和-onStart"><a href="#1-onCreate-和-onStart" class="headerlink" title="1. onCreate 和 onStart"></a>1. onCreate 和 onStart</h3><p>（1）可见与不可见的区别。前者不可见，后者可见。<br>（2）onCreate方法只在Activity创建时执行一次，而onStart方法在Activity的切换以及按Home键返回桌面再切回应用的过程中被多次调用。</p>
<h3 id="2-onStart-和-onRestart"><a href="#2-onStart-和-onRestart" class="headerlink" title="2.onStart 和 onRestart"></a>2.onStart 和 onRestart</h3><p>如果一个activity第一次创建，那么只会走onStart，如果是切换应用或者桌面，那么就会走onRestart<br>If it’s destroyed onCreate(.) &gt;  onStart(.) &gt; onResume(.) is called(variables are lost, redraw).<br>If it’s stopped onRestart(.) &gt; onStart(.) &gt; onResume(.) is called(variables are not lost, redraw)</p>
<h3 id="3-onStart-和-onResume"><a href="#3-onStart-和-onResume" class="headerlink" title="3.onStart 和 onResume"></a>3.onStart 和 onResume</h3><p>onStart activity 可见，不在前台<br>onResume activity 可见，前台且可与用户交互<br>这2个的主要区别就是Activity此时是否可以与用户交互</p>
<h3 id="4-onPause-和-onStop"><a href="#4-onPause-和-onStop" class="headerlink" title="4.onPause 和 onStop"></a>4.onPause 和 onStop</h3><p>这2个状态通常是配对执行的，<br>有一种情况是特殊的，新启动的Activity是一个透明的界面，那么第一个Activity执行onPause后，onStop是不会调用的</p>
<pre><code>&lt;activity android:name=&quot;.SecondActivity&quot;
    android:theme=&quot;@style/Theme.AppCompat.Dialog&quot; /&gt;
</code></pre>
<h3 id="5-onStop-amp-onDestroy"><a href="#5-onStop-amp-onDestroy" class="headerlink" title="5.onStop &amp; onDestroy"></a>5.onStop &amp; onDestroy</h3><p>onStop阶段Activity还没有被销毁，对象还在内存中，此时可以通过切换Activity再次回到该Activity，而onDestroy阶段Activity被销毁</p>
<h3 id="tips："><a href="#tips：" class="headerlink" title="tips："></a>tips：</h3><p>不同的生命周期适合不同的资源初始化或者释放工作，实践和工作中多总结。<a href="http://www.jianshu.com/p/fb44584daee3">http://www.jianshu.com/p/fb44584daee3</a></p>
<h2 id="3-常见操作的生命周期"><a href="#3-常见操作的生命周期" class="headerlink" title="3.常见操作的生命周期"></a>3.常见操作的生命周期</h2><h3 id="1-Launcher点击启动"><a href="#1-Launcher点击启动" class="headerlink" title="1.Launcher点击启动"></a>1.Launcher点击启动</h3><pre><code>01-16 10:57:22.429 26845-26845/? I/ActivityLife: onCreate...
01-16 10:57:22.429 26845-26845/? I/ActivityLife: onStart...
01-16 10:57:22.429 26845-26845/? I/ActivityLife: onResume...
</code></pre>
<h3 id="2-back键退出"><a href="#2-back键退出" class="headerlink" title="2.back键退出"></a>2.back键退出</h3><pre><code>01-16 10:58:58.139 26845-26845/? I/ActivityLife: onPause...
01-16 10:58:58.459 26845-26845/? I/ActivityLife: onStop...
01-16 10:58:58.459 26845-26845/? I/ActivityLife: onDestroy...
</code></pre>
<h3 id="3-HOME键退出然后再次点击启动"><a href="#3-HOME键退出然后再次点击启动" class="headerlink" title="3.HOME键退出然后再次点击启动"></a>3.HOME键退出然后再次点击启动</h3><pre><code>01-16 10:59:49.019 26845-26845/? I/ActivityLife: onPause...
01-16 10:59:49.309 26845-26845/? I/ActivityLife: onStop...
01-16 11:00:06.519 26845-26845/? I/ActivityLife: onRestart...
01-16 11:00:06.519 26845-26845/? I/ActivityLife: onStart...
01-16 11:00:06.519 26845-26845/? I/ActivityLife: onResume...
</code></pre>
<h3 id="4-锁屏解锁"><a href="#4-锁屏解锁" class="headerlink" title="4.锁屏解锁"></a>4.锁屏解锁</h3><pre><code>01-16 11:02:33.739 26845-26845/? I/ActivityLife: onPause...
01-16 11:02:33.779 26845-26845/? I/ActivityLife: onStop...
01-16 11:02:35.509 26845-26845/? I/ActivityLife: onRestart...
01-16 11:02:35.529 26845-26845/? I/ActivityLife: onStart...
01-16 11:02:35.529 26845-26845/? I/ActivityLife: onResume...
</code></pre>
<h1 id="2-异常情况下的生命周期分析"><a href="#2-异常情况下的生命周期分析" class="headerlink" title="2.异常情况下的生命周期分析"></a>2.异常情况下的生命周期分析</h1><h2 id="1-触发情况："><a href="#1-触发情况：" class="headerlink" title="1.触发情况："></a>1.触发情况：</h2><p>1.系统资源相关的配置发生变化导致Activity被杀死和重建<br>2.系统内存资源不足，lmk</p>
<h2 id="2-执行的特殊生命周期："><a href="#2-执行的特殊生命周期：" class="headerlink" title="2.执行的特殊生命周期："></a>2.执行的特殊生命周期：</h2><pre><code>onSaveInstanceState &amp; onRestoreInstanceState
</code></pre>
<p>1.onSaveInstanceState 通常在onStop之前，用于保存Activity数据<br>2.onRestoreInstanceState 通常在onStart之后，恢复Activity数据 </p>
<h3 id="tips：-1"><a href="#tips：-1" class="headerlink" title="tips："></a>tips：</h3><p>在onCreate和onRestoreInstanceState中都有一个参数savedInstanceState，二者的区别是：onRestoreInstanceState的参数是一定有值的，我们不用额外的判断它是否为空，但是onCreate不行，onCreate如果正常启动的话，savedInstanceState的值是null</p>
<h2 id="3-典型示例，系统配置变化，屏幕旋转"><a href="#3-典型示例，系统配置变化，屏幕旋转" class="headerlink" title="3.典型示例，系统配置变化，屏幕旋转"></a>3.典型示例，系统配置变化，屏幕旋转</h2><pre><code>public class MainActivity extends AppCompatActivity &#123;

    private static final String TAG = &quot;ActivityLife&quot;;

    private static final String EDIT_TAG = &quot;edit_tag&quot;;
    private EditText editText;

    @Override
    protected void onSaveInstanceState(Bundle outState) &#123;
        Log.i(TAG, &quot;onSaveInstanceState...&quot;);
        super.onSaveInstanceState(outState);
        String s = editText.getText().toString();
        outState.putString(EDIT_TAG,s);
    &#125;

    @Override
    protected void onRestoreInstanceState(Bundle savedInstanceState) &#123;
        super.onRestoreInstanceState(savedInstanceState);
        Log.i(TAG, &quot;onRestoreInstanceState...&quot;);
        //onCreate 或者这里恢复数据均可
        editText.setText(savedInstanceState.getString(EDIT_TAG));
    &#125;

    @Override
    protected void onCreate(Bundle savedInstanceState) &#123;
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Log.i(TAG, &quot;onCreate...&quot;);
        editText = (EditText) findViewById(R.id.edit_content);
        if (savedInstanceState != null)&#123;
            Log.i(TAG, &quot;onCreate savedInstanceState is not null&quot;);
            editText.setText(savedInstanceState.getString(EDIT_TAG));
        &#125;
    &#125;
&#125;
</code></pre>
<p>从Lanucher启动并且旋转一次屏幕，生命周期如下：</p>
<pre><code>01-16 11:59:30.459 29726-29726/? I/ActivityLife: onCreate...
01-16 11:59:30.459 29726-29726/? I/ActivityLife: onStart...
01-16 11:59:30.459 29726-29726/? I/ActivityLife: onResume...
01-16 11:59:38.609 29726-29726/? I/ActivityLife: onPause...
01-16 11:59:38.609 29726-29726/? I/ActivityLife: onSaveInstanceState...
01-16 11:59:38.619 29726-29726/? I/ActivityLife: onStop...
01-16 11:59:38.619 29726-29726/? I/ActivityLife: onDestroy...
01-16 11:59:38.669 29726-29726/? I/ActivityLife: onCreate...
01-16 11:59:38.669 29726-29726/? I/ActivityLife: onCreate savedInstanceState is not null
01-16 11:59:38.669 29726-29726/? I/ActivityLife: onStart...
01-16 11:59:38.669 29726-29726/? I/ActivityLife: onRestoreInstanceState...
01-16 11:59:38.669 29726-29726/? I/ActivityLife: onResume...
</code></pre>
<h2 id="4-onConfigurationChanged"><a href="#4-onConfigurationChanged" class="headerlink" title="4.onConfigurationChanged"></a>4.onConfigurationChanged</h2><p>当系统配置发生变化，如果不希望Activity重新创建，可以在AndroidManifest文件中给Activity加上属性，以屏幕旋转为例</p>
<pre><code>android:configChanges=&quot;orientation|screenSize&quot;
</code></pre>
<p>注意：从 Android 3.2（API 级别 13）开始，当设备在纵向和横向之间切换时，“屏幕尺寸”也会发生变化。因此，在开发针对 API 级别 13 或更高版本（正如 minSdkVersion 和 targetSdkVersion 属性中所声明）的应用时，若要避免由于设备方向改变而导致运行时重启，则除了 “orientation” 值以外，您还必须添加 “screenSize” 值。 也就是说，您必须声明 android:configChanges=”orientation|screenSize”。</p>
<h3 id="configChanges相关属性"><a href="#configChanges相关属性" class="headerlink" title="configChanges相关属性"></a>configChanges相关属性</h3><p><img src="https://leanote.com/api/file/getImage?fileId=59464bb1ab64413e9800127c" alt="config_changes"></p>
<h1 id="二、Activity的启动模式"><a href="#二、Activity的启动模式" class="headerlink" title="二、Activity的启动模式"></a>二、Activity的启动模式</h1><h2 id="1-Activity的四种启动模式"><a href="#1-Activity的四种启动模式" class="headerlink" title="1.Activity的四种启动模式"></a>1.Activity的四种启动模式</h2><p>standard:标准模式，每次启动一个Activity都会重新创建一个新的实例，不管这个实例是否已经存在<br>singleTop:栈顶复用模式，如果新的Activity已经位于任务栈的栈顶，那么此Activity就不会被重新创建,同时他的onNewIntent方法会被回调<br>singleTask:栈内复用模式，如果一个Activity在一个任务栈内存在，那么多次启动这个Activity都不会重新创建实例，它的onNewIntent方法也会被回调<br>singleInstance：单实例模式，具有此种模式的Activity只能单独的位于一个任务栈中</p>
<p>standard 和 singleTop都比较好理解，下面主要分析下singleTask和singleInstance的特点。会用到的调试命令：</p>
<pre><code>adb shell dumpsys activity | grep com.example.sven.activitydemo
</code></pre>
<h2 id="2-singleTask的特点"><a href="#2-singleTask的特点" class="headerlink" title="2.singleTask的特点"></a>2.singleTask的特点</h2><p>​    </p>
<h3 id="1-singleTask-和-taskAffinity"><a href="#1-singleTask-和-taskAffinity" class="headerlink" title="1.singleTask 和 taskAffinity"></a>1.singleTask 和 taskAffinity</h3><p><strong>1.launchMode=singleTask 的应用启动时是否会创建新的任务和taskAffinity属性有关</strong></p>
<p>设置了”singleTask”启动模式的Activity，它在启动的时候，会先在系统中查找属性值affinity等于它的属值taskAffinity的任务存在；如果存在这样的任务，它就会在这个任务中启动，否则就会在新任务中启动。因此如果我们想要设置了”singleTask”启动模式的Activity在新的任务中启动，就要为它设置一个唯一的taskAffinity属性值。</p>
<p>示例：A应用中，A0（表示启动界面，A1跳转的第二个界面，依次类推）A0-A1<br>(1)设置SecondActivity launchMode=”singleTask”，但不指定taskAffinity</p>
<pre><code>TaskRecord&#123;576dbde #53 A=com.example.sven.activitydemo U=0 sz=2&#125;
    Run #5: ActivityRecord&#123;dc04be8 u0 com.example.sven.activitydemo/.SecondActivity t53&#125;
    Run #4: ActivityRecord&#123;bebf9d2 u0 com.example.sven.activitydemo/.MainActivity t53&#125;
</code></pre>
<p>可以看到，虽然设置了singleTask的lanuchModel，但是MainActivity和SecondActivity还是在同一个任务栈中</p>
<p>(2)设置SecondActivity launchMode=”singleTask” ，同时指定taskAffinity = “com.example.sven.activitydemo.second”</p>
<pre><code>TaskRecord&#123;705495 #55 A=com.example.sven.activitydemo.second U=0 sz=1&#125;
    Run #5: ActivityRecord&#123;5a9b163 u0 com.example.sven.activitydemo/.SecondActivity t55&#125;
TaskRecord&#123;9d799aa #54 A=com.example.sven.activitydemo U=0 sz=1&#125;
    Run #4: ActivityRecord&#123;5e9adf5 u0 com.example.sven.activitydemo/.MainActivity t54&#125;
</code></pre>
<p>可以看到，设置了taskAffinity后，新的Activity就运行在新的任务栈里了</p>
<h3 id="tips：-2"><a href="#tips：-2" class="headerlink" title="tips："></a>tips：</h3><p>默认情况下，所有Activity的所需任务栈名均为包名，所以说如果将上面的taskAffinity属性设置为包名，SecondActivity也是不会在新的任务栈中启动的</p>
<p><strong>2.在同一个任务栈中具有唯一性</strong><br>    如果设置了”singleTask”启动模式的Activity不是在新的任务中启动时，它会在已有的任务中查看是否已经存在对应的Activity实例，如果存在，就会把位于这个Activity实例上面的Activity全部结束掉，最终这个Activity实例位于任务的堆栈顶端中。<br>示例：<br>MainActity SecondActivty ThirdActivty（以上3个Activity用A、B、C代表）在2种条件下执行如下过程 A -&gt; B -&gt;C -&gt; A -&gt;B</p>
<p>(1) SecondActivty launchMode=”singleTask”，taskAffinity=包名，最终栈中的结果如下</p>
<pre><code>TaskRecord&#123;8d620aa #62 A=com.example.sven.activitydemo U=0 sz=2&#125;
    Run #5: ActivityRecord&#123;ab051c1 u0 com.example.sven.activitydemo/.SecondActivity t62&#125;
    Run #4: ActivityRecord&#123;56fcc63 u0 com.example.sven.activitydemo/.MainActivity t62&#125;
</code></pre>
<p>(2) 设置SecondActivty 指定 taskAffinity = “com.example.sven.activitydemo.second”</p>
<pre><code>  TaskRecord&#123;4e4a3bc #61 A=com.example.sven.activitydemo.second U=0 sz=1&#125;
    Run #5: ActivityRecord&#123;f48dc2b u0 com.example.sven.activitydemo/.SecondActivity t61&#125;
  TaskRecord&#123;ea52f45 #60 A=com.example.sven.activitydemo U=0 sz=1&#125;
    Run #4: ActivityRecord&#123;9e4ab1 u0 com.example.sven.activitydemo/.MainActivity t60&#125;
</code></pre>
<p>   可以看到在2种情况下， 不论是否设定taskAffinity，在SecondActivity栈顶的实例都被清掉了</p>
<p><strong>3.任务（Task）不仅可以跨应用（Application），还可以跨进程（Process）</strong></p>
<p>示例：<br>    2个应用中A,B中，2个ActivityA1,B1的singleTask的Activity的taskAffinity设置为相同，执行如下过程 A0-&gt;A1，B0-&gt;B1</p>
<pre><code>android:launchMode=&quot;singleTask&quot;
android:taskAffinity=&quot;com.example.sven.activitydemo.second&quot;

TaskRecord&#123;a412e6e #71 A=com.example.sven.activitydemo.second U=0 sz=2&#125;
    Run #5: ActivityRecord&#123;12bc505 u0 com.example.sven.activitydemo2/.SecondActivityCopy t71&#125;
  TaskRecord&#123;fa790f #72 A=com.example.sven.activitydemo2 U=0 sz=1&#125;
    Run #4: ActivityRecord&#123;2610bd9 u0 com.example.sven.activitydemo2/.MainActivityCopy t72&#125;
  TaskRecord&#123;a412e6e #71 A=com.example.sven.activitydemo.second U=0 sz=2&#125;
    Run #3: ActivityRecord&#123;ca0064a u0 com.example.sven.activitydemo/.SecondActivity t71&#125;
  TaskRecord&#123;c224d9c #70 A=com.example.sven.activitydemo U=0 sz=1&#125;
    Run #2: ActivityRecord&#123;4257b8e u0 com.example.sven.activitydemo/.MainActivity t70&#125;
</code></pre>
<p>可以看到相同taskAffinity的Run#5和Run#3是在同一个任务栈a412e6e中的。</p>
<h3 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h3><p>Application，Task和Process的区别与联系<br>application翻译成中文时一般称为“应用”或“应用程序”，在android中，总体来说一个应用就是一组组件的集合。<br>task是在程序运行时，只针对activity的概念。说白了，task是一组相互关联的activity的集合，它是存在于framework层的一个概念，控制界面的跳转和返回。这个task存在于一个称为backstack的数据结构中，也就是说，framework是以栈的形式管理用户开启的activity。这个栈的基本行为是，当用户在多个activity之间跳转时，执行压栈操作，当用户按返回键时，执行出栈操作。<br>process一般翻译成进程，进程是操作系统内核中的一个概念，表示直接受内核调度的执行单位。在应用程序的角度看，我们用java编写的应用程序，运行在dalvik虚拟机中，可以认为一个运行中的dalvik虚拟机实例占有一个进程，所以，在默认情况下，一个应用程序的所有组件运行在同一个进程中。但是这种情况也有例外，即，应用程序中的不同组件可以运行在不同的进程中。只需要在manifest中用process属性指定组件所运行的进程的名字。如下所示：</p>
<pre><code> &lt;activity
        android:name=&quot;.SecondActivityCopy&quot;
       android:process=&quot;:remote&quot;
        android:allowTaskReparenting=&quot;true&quot; /&gt;
</code></pre>
<p><strong>4.allowTaskReparenting</strong><br>    一个应用A启动另一个应用B的B1（standard模式）Activity，如果这个Activity的allowTaskReparenting属性为true的话，那么B启动后B1直接会转移到B的任务栈中。现象就是A启动B1，在启动B时，显示的就是B1，而不是B0</p>
<pre><code>A -&gt; B1：

TaskRecord&#123;fc84b0d #46 A=com.example.sven.activitydemo2 U=0 sz=1&#125;
    Run #1: ActivityRecord&#123;8ebbcf3 u0 com.example.sven.activitydemo2/.SecondActivityCopy t46&#125;
  TaskRecord&#123;137b068 #45 A=com.example.sven.activitydemo U=0 sz=1&#125;
    Run #0: ActivityRecord&#123;b7827ad u0 com.example.sven.activitydemo/.MainActivity t45&#125;
</code></pre>
<p>​<br>​<br>​    启动B<br>​    TaskRecord{fc84b0d #46 A=com.example.sven.activitydemo2 U=0 sz=1}<br>​        Run #1: ActivityRecord{8ebbcf3 u0 com.example.sven.activitydemo2/.SecondActivityCopy t46}<br>​      TaskRecord{137b068 #45 A=com.example.sven.activitydemo U=0 sz=1}<br>​        Run #0: ActivityRecord{b7827ad u0 com.example.sven.activitydemo/.MainActivity t45}</p>
<h2 id="4-SingleInstance的特点"><a href="#4-SingleInstance的特点" class="headerlink" title="4.SingleInstance的特点"></a>4.SingleInstance的特点</h2><p><strong>1.singleInstance模式启动的Activity具有全局唯一性</strong><br>    整个系统中只会存在一个这样的实例，如果在启动这样的Activity时，已经存在了一个实例，那么会把它所在的任务调度到前台，重用这个实例。</p>
<p>示例：<br>2 个应用A，B，设置**B1 launchMode=”singleInstance”**， 执行如下过程，先B -&gt; B1， 再A0 -&gt;B1</p>
<pre><code>TaskRecord&#123;9b9bb06 #108 A=com.example.sven.activitydemo2 U=0 sz=1&#125;
    Run #3: ActivityRecord&#123;5520232 u0 com.example.sven.activitydemo2/.SecondActivityCopy t108&#125;
TaskRecord&#123;7b4a5c7 #107 A=com.example.sven.activitydemo2 U=0 sz=1&#125;
    Run #2: ActivityRecord&#123;6cf92f7 u0 com.example.sven.activitydemo2/.MainActivityCopy t107&#125;

TaskRecord&#123;9b9bb06 #108 A=com.example.sven.activitydemo2 U=0 sz=1&#125;
    Run #4: ActivityRecord&#123;5520232 u0 com.example.sven.activitydemo2/.SecondActivityCopy t108&#125;
TaskRecord&#123;3cccdb5 #109 A=com.example.sven.activitydemo U=0 sz=1&#125;
    Run #3: ActivityRecord&#123;facfdb u0 com.example.sven.activitydemo/.MainActivity t109&#125;
TaskRecord&#123;7b4a5c7 #107 A=com.example.sven.activitydemo2 U=0 sz=1&#125;
    Run #2: ActivityRecord&#123;6cf92f7 u0 com.example.sven.activitydemo2/.MainActivityCopy t107&#125;
</code></pre>
<p>可以看到 2 个过程中B1 的Taskrecord没有发生变化</p>
<p><strong>2.singleInstance模式启动的Activity具有独占性</strong><br>它会独自占用一个任务，被它开启的任何activity都会运行在其他任务中，但是否能够开启一个新任务，要看当前系统中是不是已经有了一个和要开启的Activity的taskAffinity属性相同的任务。<br>示例：<br>   B0-&gt;B1 B1-&gt;A3（B0和B1又因为上个原则，所以是在不同的任务栈中）</p>
<pre><code>  TaskRecord&#123;94de3cf #69 A=com.example.sven.activitydemo U=0 sz=1&#125;
    Run #2: ActivityRecord&#123;89ba288 u0 com.example.sven.activitydemo/.ThirdActivity t69&#125;
  TaskRecord&#123;2ad415c #68 A=com.example.sven.activitydemo2 U=0 sz=1&#125;
    Run #1: ActivityRecord&#123;73d6ca u0 com.example.sven.activitydemo2/.SecondActivityCopy t68&#125;
  TaskRecord&#123;6d70c65 #67 A=com.example.sven.activitydemo2 U=0 sz=1&#125;
    Run #0: ActivityRecord&#123;3941c44 u0 com.example.sven.activitydemo2/.MainActivityCopy t67&#125;
</code></pre>
<p>先启动A0（A3和A0是运行在同一个栈中）  B0-&gt;B1 B1-&gt;A3</p>
<pre><code>TaskRecord&#123;5db49f9 #71 A=com.example.sven.activitydemo U=0 sz=2&#125;
  Run #3: ActivityRecord&#123;dfea174 u0 com.example.sven.activitydemo/.ThirdActivity t71&#125;
TaskRecord&#123;e7e8d3e #73 A=com.example.sven.activitydemo2 U=0 sz=1&#125;
  Run #2: ActivityRecord&#123;cb12857 u0 com.example.sven.activitydemo2/.SecondActivityCopy t73&#125;
TaskRecord&#123;3f750ec #72 A=com.example.sven.activitydemo2 U=0 sz=1&#125;
  Run #1: ActivityRecord&#123;2efad8b u0 com.example.sven.activitydemo2/.MainActivityCopy t72&#125;
TaskRecord&#123;5db49f9 #71 A=com.example.sven.activitydemo U=0 sz=2&#125;
  Run #0: ActivityRecord&#123;c39fdab u0 com.example.sven.activitydemo/.MainActivity t71&#125;
</code></pre>
<p>可以看到A3（Run #2）会在A0 （Run #5）的任务栈中46bac8a</p>
<h3 id="tips：-3"><a href="#tips：-3" class="headerlink" title="tips："></a>tips：</h3><p>启动时是否开启任务栈，考虑3个点：1.被启动的Activity的launchModel，如果是singleTask要同时考虑它的taskAffinity<br>                                 2.启动Activity的launchmode(singleInstance)<br>                                 3.当前是否有被启动应用的任务栈</p>
<h2 id="4-Activity的flag"><a href="#4-Activity的flag" class="headerlink" title="4.Activity的flag"></a>4.Activity的flag</h2><h3 id="1-Intent-FLAG-ACTIVITY-NEW-TASK"><a href="#1-Intent-FLAG-ACTIVITY-NEW-TASK" class="headerlink" title="1.Intent.FLAG_ACTIVITY_NEW_TASK"></a>1.Intent.FLAG_ACTIVITY_NEW_TASK</h3><p>等价于 launchMode = singleTask</p>
<h3 id="2-Intent-FLAG-ACTIVITY-SINGLE-TOP"><a href="#2-Intent-FLAG-ACTIVITY-SINGLE-TOP" class="headerlink" title="2.Intent.FLAG_ACTIVITY_SINGLE_TOP"></a>2.Intent.FLAG_ACTIVITY_SINGLE_TOP</h3><p>等价于 launchMode = singleTop 设置singleTop 和一起使用taskAffinity ，只有singleTop的效果</p>
<h3 id="3-Intent-FLAG-ACTIVITY-CLEAR-TOP"><a href="#3-Intent-FLAG-ACTIVITY-CLEAR-TOP" class="headerlink" title="3.Intent.FLAG_ACTIVITY_CLEAR_TOP"></a>3.Intent.FLAG_ACTIVITY_CLEAR_TOP</h3><p>检查目标栈中是否有对应的实例，如果有就会将该实例之上的所有栈都清掉<br>    A-&gt;B（正常启动）-&gt;C-&gt;A-&gt;B(clearTop方式启动)<br>    (1) B的launchmode 是standard</p>
<pre><code>TaskRecord&#123;fec37c7 #134 A=com.example.sven.activitydemo U=0 sz=4&#125;
    Run #5: ActivityRecord&#123;91e286b u0 com.example.sven.activitydemo/.MainActivity t134&#125;
    Run #4: ActivityRecord&#123;775d8ae u0 com.example.sven.activitydemo/.ThirdActivity t134&#125;
    Run #3: ActivityRecord&#123;20304d6 u0 com.example.sven.activitydemo/.SecondActivity t134&#125;
    Run #2: ActivityRecord&#123;b049afa u0 com.example.sven.activitydemo/.MainActivity t134&#125;
 
TaskRecord&#123;fec37c7 #134 A=com.example.sven.activitydemo U=0 sz=2&#125;
   Run #3: ActivityRecord&#123;4fdc1db u0 com.example.sven.activitydemo/.SecondActivity t134&#125;
    Run #2: ActivityRecord&#123;b049afa u0 com.example.sven.activitydemo/.MainActivity t134&#125;
</code></pre>
<p>可以看到，如果被启动的SecondActivity的启动模式是standard，那么B会重新创建新的实例并且之前的实例及实例之上的Activity都会出栈，recordid 发生了变化 20304d6 -&gt; 4fdc1db</p>
<pre><code>(2) B的launchmode是singleTask

TaskRecord&#123;249ecaa #135 A=com.example.sven.activitydemo U=0 sz=4&#125;
    Run #5: ActivityRecord&#123;1116cb u0 com.example.sven.activitydemo/.MainActivity t135&#125;
    Run #4: ActivityRecord&#123;92b068e u0 com.example.sven.activitydemo/.ThirdActivity t135&#125;
    Run #3: ActivityRecord&#123;96bd6b6 u0 com.example.sven.activitydemo/.SecondActivity t135&#125;
    Run #2: ActivityRecord&#123;44bf730 u0 com.example.sven.activitydemo/.MainActivity t135&#125;

TaskRecord&#123;249ecaa #135 A=com.example.sven.activitydemo U=0 sz=2&#125;
    Run #3: ActivityRecord&#123;96bd6b6 u0 com.example.sven.activitydemo/.SecondActivity t135&#125;
    Run #2: ActivityRecord&#123;44bf730 u0 com.example.sven.activitydemo/.MainActivity t135&#125;
</code></pre>
<p>可以看到，如果被启动的SecondActivity的启动模式是SingleTask，那么B会清除实例之上的Activity，并且调用onNewIntent方法</p>
<p><strong>总结：主要2个点，清除被启动Activity之上的实例，是否创建新的实例和被启动Activity的lanuchMode有关</strong></p>
<h3 id="4-Intent-FLAG-ACTIVITY-EXCLUDE-FROM-RECENTS"><a href="#4-Intent-FLAG-ACTIVITY-EXCLUDE-FROM-RECENTS" class="headerlink" title="4. Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS"></a>4. Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS</h3><p>具有这个标记的Activity不会出现在历史Activity的记录中，和android:excludeFromRecents作用相同</p>
<h3 id="tips：启动模式有2种设置方法，通过设置Intent的FLAG-和-AndroidManifest-xml-，第一种方式的优先级大于第二种方式"><a href="#tips：启动模式有2种设置方法，通过设置Intent的FLAG-和-AndroidManifest-xml-，第一种方式的优先级大于第二种方式" class="headerlink" title="tips：启动模式有2种设置方法，通过设置Intent的FLAG 和 AndroidManifest.xml ，第一种方式的优先级大于第二种方式"></a>tips：启动模式有2种设置方法，通过设置Intent的FLAG 和 AndroidManifest.xml ，第一种方式的优先级大于第二种方式</h3><h1 id="三、IntentFilter的匹配规则"><a href="#三、IntentFilter的匹配规则" class="headerlink" title="三、IntentFilter的匹配规则"></a>三、IntentFilter的匹配规则</h1><p>Activity的显示调用和隐式调用：<a href="http://blog.csdn.net/xiao__gui/article/details/11392987">http://blog.csdn.net/xiao__gui/article/details/11392987</a></p>
<p>一个activity可以有多个过滤器，每个过滤器均可以有多个action，category和data</p>
<h2 id="1-action的匹配规则"><a href="#1-action的匹配规则" class="headerlink" title="1.action的匹配规则"></a>1.action的匹配规则</h2><p><strong>Intent 中的 action 只要有一个与过滤器（manifest中的intent-filter）的匹配，就可调用这个过滤器所在的组件。</strong></p>
<h2 id="2-category的匹配规则"><a href="#2-category的匹配规则" class="headerlink" title="2.category的匹配规则"></a>2.category的匹配规则</h2><p>category 表示类别，最常见就是这2个</p>
<pre><code>&lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
 &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;
</code></pre>
<p><strong>1. 隐式启动时intent会自动的添加一个默认的category，所以隐式启动时，过滤器中默认的category必须要加</strong></p>
<pre><code> &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;
</code></pre>
<p><strong>2. 隐式启动时，intent中添加的category必须包含在过滤器中</strong></p>
<h2 id="3-data的匹配规则"><a href="#3-data的匹配规则" class="headerlink" title="3.data的匹配规则"></a>3.data的匹配规则</h2><p><strong>data 表示该组件可以支持的数据格式与类型，intent 至少可以匹配过滤器中的一个</strong></p>
<p>主要由两部分组成：1.mimeType 2.URI ，语法如下：</p>
<pre><code>&lt;data android:scheme=&quot;string&quot;
    android:host=&quot;string&quot;
    android:port=&quot;string&quot;
    android:path=&quot;string&quot;
    android:pathPattern=&quot;string&quot;
    android:pathPrefix=&quot;string&quot;
    android:mimeType=&quot;string&quot; /&gt;
</code></pre>
<p>(1) mimeType 指的是支持的数据类型与格式<br>    常见的有：1.text/plain 2.image/jpeg 3.video/* 4.audio/*<br>    / 号前面的是数据类型，后面是具体格式。</p>
<p>(2) URI 格式：</p>
<pre><code>&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;]|[&lt;pathPrefix&gt;]|[pathPattern]
</code></pre>
<p>1.scheme、host、port、path分别表示URI的模式、主机名和端口号和路径</p>
<pre><code>例如：http://www.baidu.com:80/search/info
</code></pre>
<p>2.如果scheme或者host未指定那么URI就无效</p>
<p>3.URI 是有默认值的，content 和 file，这里不是很理解，不过发现这样一种情况：</p>
<p>在intent-filter 中添加任意一种mimeType，不指定URI</p>
<pre><code>&lt;data android:mimeType=&quot;image/jpeg&quot;/&gt;
</code></pre>
<p>intent启动时，设置URI为 content:.* 或 file:.* 均可启动</p>
<pre><code>intent.setDataAndType(Uri.parse(&quot;content://abc&quot;), &quot;image/jpeg&quot;);
</code></pre>
<p>4.data 是有如下2种写法的，效果是一样的</p>
<pre><code>&lt;data android:scheme=&quot;file&quot;
      android:host=&quot;abc&quot;
      android:mimeType=&quot;text/plain&quot;/&gt;

&lt;data android:scheme=&quot;file&quot;/&gt;
&lt;data android:host=&quot;abc&quot;/&gt;
&lt;data android:mimeType=&quot;text/plain&quot;/&gt;
</code></pre>
<p>如果一个intent-filter 中有多个data 并且他们的URI均不同，建议用第一种。</p>
<p>data 的匹配规则这里只列举的常用的一部分，还有些情况类似与如下，也可以匹配到，可以将URI 和MIMETYPE的关系理解为action和category的关系</p>
<pre><code>&lt;data android:scheme=&quot;http&quot; android:host=&quot;abc&quot; android:mimeType=&quot;text/plain&quot;/&gt;
&lt;data android:scheme=&quot;http&quot; android:host=&quot;abc2&quot; android:mimeType=&quot;image/png&quot;/&gt;

intent.setDataAndType(Uri.parse(&quot;http://abc&quot;), &quot;image/png&quot;);
</code></pre>
<p>只能理解为 URI 和MIMETYPE 其实类似于 action 和 category的关系，采用如下的写法更能表现两者的关系，具体大家在实践中多多理解</p>
<pre><code>  &lt;data android:scheme=&quot;file&quot; android:host=&quot;abc&quot; /&gt;
  &lt;data android:scheme=&quot;file&quot; android:host=&quot;abc2&quot; /&gt;
  &lt;data android:mimeType=&quot;text/plain&quot; /&gt;
  &lt;data android:mimeType=&quot;image/png&quot; /&gt;
</code></pre>
<h3 id="tips-1"><a href="#tips-1" class="headerlink" title="tips:"></a>tips:</h3><p>1.如果要为Intent指定完整的data，必须要调用setDataAndType方法，不能先调用setData然后调用setType，因为这两个方法会彼此清除对方的值。<br>2.当我们启动Activity可以通过resolveActivity判断是否有对应的Activity</p>
<pre><code>if(this.getPackageManager().resolveActivity(intent, 0) != null)&#123;
    startActivity(intent);
&#125;
</code></pre>
<p>3.特殊的一组action和category，标记应用启动时打开的Activity，少了任何一个都没有意义</p>
<pre><code>&lt;intent-filter&gt;
    &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
    &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
&lt;/intent-filter&gt;
</code></pre>
<p>4.显示Component调用也是可以跨应用的，需要显示指定Activity属性 android:exported=”true” 或者添加一个intent-Filter，否则会报AndroidRuntime异常，通过Tip 2是不能检查出intent是否正常。</p>
<p>以上这些自己写了个Demo，方便大家调试和学习：</p>
<p><strong>问题：</strong></p>
<ol>
<li>onSaveInstanceState 为何会在跳转到别的Activity、Home键以及锁屏时调用？</li>
<li>category 和 data 的更多用法？</li>
</ol>
<p><strong>参考资料：</strong><br><a href="https://developer.android.com/reference/android/app/Activity.html">https://developer.android.com/reference/android/app/Activity.html</a><br><a href="https://developer.android.com/guide/topics/manifest/activity-element.html?hl=zh-cn#config">https://developer.android.com/guide/topics/manifest/activity-element.html?hl=zh-cn#config</a><br><a href="http://blog.csdn.net/u011240877/article/details/71305797">http://blog.csdn.net/u011240877/article/details/71305797</a><br>《Android 开发艺术之旅》</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>base_03_BroadcastReceiver基础</title>
    <url>/2021/02/22/Notes/Android/01%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6/base_03_BroadcastReceiver%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="base-03-BroadcastReceiver基础"><a href="#base-03-BroadcastReceiver基础" class="headerlink" title="base_03_BroadcastReceiver基础"></a>base_03_BroadcastReceiver基础</h1><span id="more"></span>

<p>BroadcastReceiver 四大组件之一，主要用于监听手机状态的变以及不同组件和应用间的通信。</p>
<h2 id="一-注册广播"><a href="#一-注册广播" class="headerlink" title="一.注册广播"></a>一.注册广播</h2><h3 id="1-静态注册："><a href="#1-静态注册：" class="headerlink" title="1.静态注册："></a>1.静态注册：</h3><ol>
<li><p>在AndroidMainfest中添加receiver</p>
<pre><code> &lt;receiver android:name=&quot;.MyReceiver&quot;&gt;
     &lt;intent-filter&gt;
         &lt;action android:name=&quot;android.intent.action.myreceiver&quot; /&gt;
     &lt;/intent-filter&gt;
 &lt;/receiver&gt;
</code></pre>
</li>
<li><p>创建类继承BroadcastReceiver的，并且复写onReceive()方法</p>
<pre><code> public class MyReceiver extends BroadcastReceiver &#123;
     @Override
     public void onReceive(Context context, Intent intent) &#123;
         Log.i(TAG, &quot;receive action &quot;);
     &#125;
 &#125;
</code></pre>
</li>
</ol>
<h3 id="2-动态注册"><a href="#2-动态注册" class="headerlink" title="2. 动态注册"></a>2. 动态注册</h3><ol>
<li><p>创建广播类和实例</p>
</li>
<li><p>创建intentFilter并且添加需要接收的action</p>
</li>
<li><p>调用registerReceiver方法注册</p>
</li>
<li><p>可以通过unregisterReceiver取消</p>
<pre><code> public class MainActivity extends Activity &#123;
     private BroadcastReceiver mBroadcastReceiver;
 
     @Override
     protected void onCreate(Bundle savedInstanceState) &#123;
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_main);
 
         mBroadcastReceiver = new MyBroadcastReceiver();
         IntentFilter intentFilter = new IntentFilter();
         intentFilter.addAction(&quot;MyIntent&quot;);
         registerReceiver(mBroadcastReceiver, intentFilter);
     &#125;
     @Override
     protected void onDestroy() &#123;
         super.onDestroy();
         unregisterReceiver(mBroadcastReceiver);
     &#125;
 &#125;
</code></pre>
</li>
</ol>
<p>###Tips：</p>
<ol>
<li>action的注册和解注册成对出现在context对应的生命周期中，例如onCreate和onDestroy，以及onResume和onPause</li>
<li>同一个receiver可以同时接收动态注册和静态注册的广播</li>
<li>动态广播在应用没有启动时，是无法接收到的，即使加了Intent.FLAG_INCLUDE_STOPPED_PACKAGES（测试失败）</li>
</ol>
<h2 id="二、广播的类型"><a href="#二、广播的类型" class="headerlink" title="二、广播的类型"></a>二、广播的类型</h2><p>###1. 系统广播<br>   系统广播，当手机状态发生变化时，都会发出相应的系统广播。如：网络状态，解锁等。注意：有些系统广播必须态注册才有效：SCREEN_ON，SCREEN_OFF<br>###2. 普通广播<br>   自定义的广播，通常用于应用内或应用间通信。<br>###3. 有序广播</p>
<ol>
<li>多个具当前已经注册且有效的BroadcastReceiver接收有序广播时，是按照先后顺序接收的，先后顺序判定标准为：将当前系统中所有有效的动态注册和静态注册的BroadcastReceiver按照priority属性值从大到小排序，对于具有相同的priority的动态广播和静态广播，动态广播会排在前面。<pre><code> &lt;receiver android:name=&quot;.OrderedReceiver1&quot;&gt;
     &lt;intent-filter android:priority=&quot;100&quot;&gt;
         &lt;action android:name=&quot;com.sven.action.my.receiver.orderd.receiver&quot; /&gt;
     &lt;/intent-filter&gt;
 &lt;/receiver&gt;
 &lt;receiver android:name=&quot;.OrderedReceiver2&quot;&gt;
     &lt;intent-filter android:priority=&quot;1000&quot;&gt;
         &lt;action android:name=&quot;com.sven.action.my.receiver.orderd.receiver&quot; /&gt;
     &lt;/intent-filter&gt;
 &lt;/receiver&gt;
</code></pre>
</li>
</ol>
<p> 当然动态注册时也可以设置优先级：</p>
<pre><code>    intentFilter.setPriority(1000);
</code></pre>
<ol start="2">
<li><p>先接收的BroadcastReceiver可以对此有序广播进行截断，使后面的BroadcastReceiver不再接收到此广播，</p>
<pre><code> public class OrderedReceiver2 extends BroadcastReceiver &#123;
     private static final String TAG = &quot;OrderedReceiver2&quot;;
     @Override
     public void onReceive(Context context, Intent intent) &#123;
         Log.i(TAG, &quot;action = &quot;+intent.getAction());
         abortBroadcast();
     &#125;
 &#125;
</code></pre>
</li>
<li><p>receiver之间的通信<br>优先接收到Broadcast的Receiver可通过setResultExtras(Bundle)方法将处理结果存入Broadcast中，下一个Receiver 可通过getResultExtras(true)方法获取上一个 Receiver传来的数据。</p>
<pre><code> //修改
 public class OrderedReceiver2 extends BroadcastReceiver &#123;
     private static final String TAG = &quot;OrderedReceiver2&quot;;
     @Override
     public void onReceive(Context context, Intent intent) &#123;
         Log.i(TAG, &quot;action = &quot;+intent.getAction());
         Bundle b = new Bundle();
         b.putInt(&quot;value&quot;, 101);
         setResultExtras(b);
     &#125;
 &#125;
 
 //接收    
 public class OrderedReceiver1 extends BroadcastReceiver &#123;
     private static final String TAG = &quot;OrderedReceiver1&quot;;
     @Override
     public void onReceive(Context context, Intent intent) &#123;
         Log.i(TAG, &quot;action = &quot;+intent.getAction());
         Bundle b = getResultExtras(true);
         Log.i(TAG,&quot;value = &quot;+b.get(&quot;value&quot;));
     &#125;
 &#125;
</code></pre>
</li>
</ol>
<p>##三、广播和权限</p>
<h3 id="1-谁有权限接收-和安装的顺序有关-需要先装发送者"><a href="#1-谁有权限接收-和安装的顺序有关-需要先装发送者" class="headerlink" title="1. 谁有权限接收 (和安装的顺序有关 需要先装发送者)"></a>1. 谁有权限接收 (和安装的顺序有关 需要先装发送者)</h3><ol>
<li>发送者的manifest声明权限<pre><code> &lt;permission android:name=&quot;com.sven.permission.my.receiver.RECEIVE&quot;/&gt;
</code></pre>
</li>
<li>发送时添加权限<pre><code> public void sendBroadcast(View view) &#123;
     sendBroadcast(new Intent(&quot;com.sven.action.my.receiver&quot;),
             &quot;com.sven.permission.my.receiver.RECEIVE&quot;);
 &#125;
</code></pre>
</li>
<li>接收app的manifest要添加对应的权限<pre><code> &lt;uses-permission android:name=&quot;com.sven.permission.my.receiver.RECEIVE&quot;/&gt;
</code></pre>
</li>
</ol>
<h3 id="2-谁有权限发送-（和安装顺序有关，先安装接收者）"><a href="#2-谁有权限发送-（和安装顺序有关，先安装接收者）" class="headerlink" title="2. 谁有权限发送 （和安装顺序有关，先安装接收者）"></a>2. 谁有权限发送 （和安装顺序有关，先安装接收者）</h3><ol>
<li><p>接收者的manifest文件中声明权限</p>
<pre><code>    &lt;permission android:name=&quot;com.sven.permission.my.receiver.SEND&quot;/&gt;
</code></pre>
</li>
<li><p>接收者的receiver节点中添加</p>
<pre><code>     &lt;receiver
         android:name=&quot;.MyReceiverWithPermission&quot;
         android:permission=&quot;com.sven.permission.my.receiver.SEND&quot;&gt;
         &lt;intent-filter&gt;
         ....
         &lt;/intent-filter&gt;
     &lt;/receiver&gt;
</code></pre>
</li>
<li><p>发送者的manifest文件中使用</p>
<pre><code> &lt;uses-permission android:name=&quot;com.sven.permission.my.receiver.SEND&quot;/&gt;
</code></pre>
</li>
</ol>
<h3 id="Tips："><a href="#Tips：" class="headerlink" title="Tips："></a>Tips：</h3><p>自定义的权限最好在2个app中同时声明，（测试出现了比较奇怪的情况，声明权限的app，必须先安装，否则还是会报权限问题），使用系统权限不会不存在以上问题</p>
<h3 id="四、安全高效地使用广播的一些原则："><a href="#四、安全高效地使用广播的一些原则：" class="headerlink" title="四、安全高效地使用广播的一些原则："></a>四、安全高效地使用广播的一些原则：</h3><ol>
<li><p>如果不需要发送到应用外，同一个应用内的广播尽量使用LocalBroadcastManager</p>
</li>
<li><p>尽量使用动态注册的广播，而且有些系统广播，比如说 CONNECTIVITY_ACTION 在7.0之后只能通过动态注册接收</p>
</li>
<li><p>发送广播时明确广播的接受者：<br> (1)发送时添加权限<br> (2)通过setPackage 指定应用<br> (3)使用LocalBroadcastManager</p>
</li>
<li><p>广播的命名尽量保证唯一</p>
</li>
<li><p>注册一个广播时，限制广播的接收者：</p>
<p> (1)添加一个权限, mainfest 中指定，动态注册可以使用该接口添加权限</p>
<pre><code> public abstract Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler);
</code></pre>
<p> (2)仅仅只是应用内使用时，可以使用设置 android:exported=”false”。这样就不会接收应用外的广播了<br> (3)使用LocalBroadcastManager</p>
</li>
<li><p>onReceive方法运行在主线程中，所以不能执行耗时任务</p>
</li>
<li><p>不要通过广播启动activity，可以使用通知替代</p>
</li>
</ol>
<p>五、onReceive<br>系统执行onReceive方法时，receiver会被当成前台进程，不会被杀，但是当onReceive()方法返回后，会被当成一个低优先级的程序，很容易被系统杀掉，在onReceive执行耗时异步任务时，最好通过goAsync防止执行过程中被系统杀掉。<br>onReceive 的context是Application的context？？？</p>
<pre><code>public class MyBroadcastReceiver extends BroadcastReceiver &#123;
    private static final String TAG = &quot;MyBroadcastReceiver&quot;;
    @Override
    public void onReceive(final Context context, final Intent intent) &#123;
        final PendingResult pendingResult = goAsync();
        AsyncTask&lt;String, Integer, String&gt; asyncTask = new AsyncTask&lt;String, Integer, String&gt;() &#123;
            @Override
            protected String doInBackground(String... params) &#123;
                StringBuilder sb = new StringBuilder();
                sb.append(&quot;Action: &quot; + intent.getAction() + &quot;\n&quot;);
                sb.append(&quot;URI: &quot; + intent.toUri(Intent.URI_INTENT_SCHEME).toString() + &quot;\n&quot;);
                Log.d(TAG, log);
                // Must call finish() so the BroadcastReceiver can be recycled.
                pendingResult.finish();
                return data;
            &#125;
        &#125;;
        asyncTask.execute(); 
&#125;
</code></pre>
<p>}<br>###Tips:<br>可以在通过一下这种方法让onReceive执行在handlerThread中。</p>
<pre><code>private Handler handler; // Handler for the separate Thread
HandlerThread handlerThread = new HandlerThread(&quot;MyNewThread&quot;);
handlerThread.start();
// Now get the Looper from the HandlerThread so that we can create a Handler that is  attached to the HandlerThread
// NOTE: This call will block until the HandlerThread gets control and initializes its Looper
Looper looper = handlerThread.getLooper();
// Create a handler for the service
handler = new Handler(looper);
// Register the broadcast receiver to run on the separate Thread
registerReceiver (myReceiver, intentFilter, broadcastPermission, handler);
</code></pre>
<p><a href="https://stackoverflow.com/questions/10682241/register-a-broadcast-receiver-from-a-service-in-a-new-thread">https://stackoverflow.com/questions/10682241/register-a-broadcast-receiver-from-a-service-in-a-new-thread</a></p>
<h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><ol>
<li>有哪些静态广播可以启动进程，是否有其他要求？</li>
<li>上文提到的发送及接收时permission的问题？</li>
<li>BroadcastReceiver 耗时任务通过开启service执行和异步执行各有什么应用场景？</li>
</ol>
<p>参考资料：<br><a href="https://developer.android.com/guide/components/broadcasts.html#security_considerations_and_best_practices">https://developer.android.com/guide/components/broadcasts.html#security_considerations_and_best_practices</a><br><a href="http://www.cnblogs.com/lwbqqyumidi/p/4168017.html">http://www.cnblogs.com/lwbqqyumidi/p/4168017.html</a></p>
<p>Demo：<br><a href="http://download.csdn.net/detail/time_traveller14/9892205">http://download.csdn.net/detail/time_traveller14/9892205</a><br><a href="http://download.csdn.net/detail/time_traveller14/9892207">http://download.csdn.net/detail/time_traveller14/9892207</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>base_02_Service 基础知识</title>
    <url>/2021/02/22/Notes/Android/01%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6/base_02_Service%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="base-02-Service-基础知识"><a href="#base-02-Service-基础知识" class="headerlink" title="base_02_Service 基础知识"></a>base_02_Service 基础知识</h1><span id="more"></span>

<p>Service 作为android 四大组件之一，主要用于再后台处理一些耗时的逻辑或者去执行一些长期运行的任务。</p>
<h1 id="一、startService-和-bindService"><a href="#一、startService-和-bindService" class="headerlink" title="一、startService 和 bindService"></a>一、startService 和 bindService</h1><h2 id="1-生命周期和启动方式："><a href="#1-生命周期和启动方式：" class="headerlink" title="1. 生命周期和启动方式："></a>1. 生命周期和启动方式：</h2><p><img src="https://leanote.com/api/file/getImage?fileId=595288b4ab6441560e001f51" alt="service_lifecircle"><br>1.1 启动<br>通过startService启动服务时，如果是第一次启动，会调用onCreate-&gt;onStartCommand，但是多次启动时不会再调用onCreate，只有onStartCommand会被调用多次。<br>通过bindService绑定服务时，如果服务还未启动，会调用onCreate-&gt;onBind，创建并且绑定服务，多次调用bindService并不会多次调用onBind()，除非是多个客户端来绑定服务。</p>
<p>1.2 销毁<br>如果组件通过调用 startService() 启动服务，则服务将一直运行，直到服务使用 stopSelf()自行停止运行，或由其他组件通过调用 stopService() 停止它为止。无论服务被启动了多少次，只要调用一次stopService，便可终止（不考虑被绑定过的情况）。</p>
<p>如果组件是通过调用 bindService()来创建服务（且未调用onStartCommand()），则服务只会在该组件与其绑定时运行。一旦该服务与所有客户端之间的绑定全部取消，系统便会销毁它。</p>
<h2 id="2-starService和bindService一起使用："><a href="#2-starService和bindService一起使用：" class="headerlink" title="2. starService和bindService一起使用："></a>2. starService和bindService一起使用：</h2><p>如果一个Service又被启动又被绑定，则该Service会一直在后台运行。首先不管如何调用，onCreate始终只会调用一次。startService调用多少次，Service的onStartCommand方法便会调用多少次。Service的终止，需要unbindService和stopService同时调用才行。不管startService与bindService的调用顺序，如果先调用unbindService，此时服务不会自动终止，再调用stopService之后，服务才会终止；如果先调用stopService，此时服务也不会终止，再次调用unbindService或者<strong>之前调用bindService的Context不存在了</strong>（如Activity被finish的时候）之后，服务才会停止。</p>
<h2 id="3-使用场景："><a href="#3-使用场景：" class="headerlink" title="3. 使用场景："></a>3. 使用场景：</h2><p>   startService 主要用于开启服务，例如后台下载和播放音乐<br>   bindService 主要为了使用服务中的一些功能或者与服务进行交互<br>   这2种模式不是完全分离的。你可以可以绑定到一个通过startService()启动的服务。如一个intent想要播放音乐，通过startService启动后台播放音乐的service。然后，也许用户想要操作播放器或者获取当前正在播放的乐曲的信息，一个activity就会通过bindService建立一个到此service的连接. 这种情况下 stopService() 在全部的连接关闭后才会真正停止service。</p>
<h3 id="Tips："><a href="#Tips：" class="headerlink" title="Tips："></a>Tips：</h3><ol>
<li>服务的onCreate和onDestroy在一个生命周期中只会执行一次</li>
<li>service的stopself方法的功能是，当完成所有功能之后，将service停掉</li>
<li>Service中onRebind方法被调用的时机，需要满足2个条件：<br>(1)服务中onUnBind方法返回值为true<br>(2)服务对象被解绑后没有被销毁，之后再次被绑定</li>
</ol>
<h2 id="2-onStartCommand的返回值："><a href="#2-onStartCommand的返回值：" class="headerlink" title="2. onStartCommand的返回值："></a>2. onStartCommand的返回值：</h2><p>请注意，onStartCommand() 方法必须返回整型数。整型数是一个值，用于描述系统应该如何在服务终止的情况下继续运行服务（如上所述，IntentService 的默认实现将为您处理这种情况，不过您可以对其进行修改）。从onStartCommand()返回的值必须是以下常量之一：</p>
<h2 id="1-START-NOT-STICKY"><a href="#1-START-NOT-STICKY" class="headerlink" title="1. START_NOT_STICKY"></a>1. START_NOT_STICKY</h2><p>如果系统在 onStartCommand() 返回后终止服务，则除非有挂起 Intent 要传递，否则系统不会重建服务。这是最安全的选项，可以避免在不必要时以及应用能够轻松重启所有未完成的作业时运行服务。</p>
<h2 id="2-START-STICKY"><a href="#2-START-STICKY" class="headerlink" title="2. START_STICKY"></a>2. START_STICKY</h2><p>如果系统在 onStartCommand() 返回后终止服务，则会重建服务并调用 onStartCommand()，但不会重新传递最后一个 Intent。相反，除非有挂起 Intent 要启动服务（在这种情况下，将传递这些 Intent ），否则系统会通过空 Intent 调用 onStartCommand()。这适用于不执行命令、但无限期运行并等待作业的媒体播放器（或类似服务）。</p>
<h2 id="3-START-REDELIVER-INTENT"><a href="#3-START-REDELIVER-INTENT" class="headerlink" title="3. START_REDELIVER_INTENT"></a>3. START_REDELIVER_INTENT</h2><p>如果系统在 onStartCommand() 返回后终止服务，则会重建服务，并通过传递给服务的最后一个 Intent 调用 onStartCommand()。任何挂起 Intent 均依次传递。这适用于主动执行应该立即恢复的作业（例如下载文件）的服务。</p>
<h1 id="二、前台服务"><a href="#二、前台服务" class="headerlink" title="二、前台服务"></a>二、前台服务</h1><p>Service几乎都是在后台运行的，一直以来它都是默默地做着辛苦的工作。但是Service的系统优先级还是比较低的，当系统出现内存不足情况时，就有可能会回收掉正在后台运行的Service。如果你希望Service可以一直保持运行状态，而不会由于系统内存不足的原因导致被回收，就可以考虑使用前台Service。前台Service和普通Service最大的区别就在于，它会一直有一个正在运行的图标在系统的状态栏显示，下拉状态栏后可以看到更加详细的信息，非常类似于通知的效果。当然有时候你也可能不仅仅是为了防止Service被回收才使用前台Service，有些项目由于特殊的需求会要求必须使用前台Service，比如说墨迹天气。</p>
<pre><code>    Intent intent = new Intent(this, MainActivity.class);
    //需要让Activity运行在新的任务栈中
    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    Notification.Builder builder = new Notification.Builder(this);
    Notification notification = builder.setSmallIcon(R.mipmap.ic_launcher)
            .setContentText(&quot;this is a notify&quot;)
            .setContentTitle(&quot;notify!!!&quot;).setTicker(&quot;notify&quot;)
            .setContentIntent(PendingIntent.
                    getActivity(ServiceB.this, 0, intent, PendingIntent.FLAG_CANCEL_CURRENT))
            .build();
    startForeground(1, notification);
</code></pre>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips:"></a>Tips:</h3><ol>
<li>startForeground让服务变成前台服务并显示通知，这时必须要setSmallIcon，否则会显示默认的通知，不显示自定义通知</li>
<li>如何让服务一直存活 <a href="http://zhoujianghua.com/2015/07/28/black_technology_in_alipay/">http://zhoujianghua.com/2015/07/28/black_technology_in_alipay/</a></li>
</ol>
<h1 id="三、Service-和-Thread"><a href="#三、Service-和-Thread" class="headerlink" title="三、Service 和 Thread"></a>三、Service 和 Thread</h1><p>之所以有不少人会把它们联系起来，主要就是因为Service的后台概念。Thread我们大家都知道，是用于开启一个子线程，在这里去执行一些耗时操作就不会阻塞主线程的运行。而Service我们最初理解的时候，总会觉得它是用来处理一些后台任务的，一些比较耗时的操作也可以放在这里运行，这就会让人产生混淆了。但其实Service其实是运行在主线程里的，所以说service的主进程中不能执行耗时的任务，需要另外启动线程执行，例如IntentService的内部就是使用了HandlerThread的实现。</p>
<h1 id="四、IntentService"><a href="#四、IntentService" class="headerlink" title="四、IntentService"></a>四、IntentService</h1><p>IntentService是Service 的子类，它使用工作线程逐一处理所有启动请求。如果不要求服务同时处理多个请求，这是最好的选择。只需实现 onHandleIntent() 方法即可，该方法会接收每个启动请求的Intent，能够执行后台工作。由于大多数启动服务都不必同时处理多个请求，因此使用 IntentService 类实现服务也许是最好的选择。</p>
<p>IntentService的特点：</p>
<ol>
<li>IntentService 会创建一个线程，来处理所有传给onStartCommand()的Intent请求</li>
<li>创建一个请求队列，用于将 Intent 逐一传递给 onHandleIntent() 实现，不必担心多线程问题</li>
<li>在所有的请求执行完毕后结束Service</li>
<li>提供 onBind() 的默认实现（返回 null）</li>
<li>提供默认的 onStartCommand() 实现，将intent传入等待队列中，然后到onHandleIntent()的实现。所以如果需要重写onStartCommand() 方法一定要调用父类的实现。</li>
</ol>
<h3 id="Tips-1"><a href="#Tips-1" class="headerlink" title="Tips:"></a>Tips:</h3><ol>
<li>IntentService是针对StarteService设计的，由于它默认实现的onBind()方法返回值是null，所以不适合bindService()</li>
<li>多次startService请求执行耗时任务，不会并发执行onHandleIntent()方法，而是一个一个顺序执行。当所有的任务执行完成，IntentService会自动销毁</li>
</ol>
<p>问题：onStartCommand的返回值的具体应用场景？</p>
<p>Demo：</p>
<p>参考资料：<br><a href="https://developer.android.com/guide/components/services.html">https://developer.android.com/guide/components/services.html</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/11952435">http://blog.csdn.net/guolin_blog/article/details/11952435</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>base_05_Fragment基础</title>
    <url>/2021/02/22/Notes/Android/01%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6/base_05_Fragment%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="base-05-Fragment-基础"><a href="#base-05-Fragment-基础" class="headerlink" title="base_05_Fragment 基础"></a>base_05_Fragment 基础</h1><span id="more"></span>

<p>本文主要介绍下Android Fragment的生命周期，相关的API以及和Activity通信的简单实践</p>
<h1 id="一、生命周期："><a href="#一、生命周期：" class="headerlink" title="一、生命周期："></a>一、生命周期：</h1><p><img src="https://leanote.com/api/file/getImage?fileId=5936c722ab64410e79001e16" alt="fragment生命周期"><br>Fragment创建销毁时，fragment和所依赖的activity生命周期的执行顺序，<strong>注意看log的TAG</strong></p>
<h2 id="1-创建时"><a href="#1-创建时" class="headerlink" title="1.创建时"></a>1.创建时</h2><pre><code>01-12 17:57:24.823 28028-28028/? I/ActivityLife: onCreate...
01-12 17:57:24.843 28028-28028/? I/FragmentLife: onAttach...
01-12 17:57:24.843 28028-28028/? I/FragmentLife: onCreate...
01-12 17:57:24.843 28028-28028/? I/FragmentLife: onCreateView...
01-12 17:57:24.843 28028-28028/? I/FragmentLife: onActivityCreated...
01-12 17:57:24.843 28028-28028/? I/ActivityLife: onStart...
01-12 17:57:24.843 28028-28028/? I/FragmentLife: onStart...
01-12 17:57:24.843 28028-28028/? I/ActivityLife: onResume...
01-12 17:57:24.843 28028-28028/? I/FragmentLife: onResume...
</code></pre>
<h2 id="2-销毁时"><a href="#2-销毁时" class="headerlink" title="2.销毁时"></a>2.销毁时</h2><pre><code>01-12 17:57:40.583 28028-28028/? I/FragmentLife: onPause...
01-12 17:57:40.583 28028-28028/? I/ActivityLife: onPause...
01-12 17:57:40.883 28028-28028/? I/FragmentLife: onStop...
01-12 17:57:40.883 28028-28028/? I/ActivityLife: onStop...
01-12 17:57:40.883 28028-28028/? I/FragmentLife: onDestroyView...
01-12 17:57:40.883 28028-28028/? I/FragmentLife: onDestroy...
01-12 17:57:40.883 28028-28028/? I/FragmentLife: onDetach...
01-12 17:57:40.883 28028-28028/? I/ActivityLife: onDestroy...
</code></pre>
<h1 id="二、Activity中，Fragment的2种加载方法"><a href="#二、Activity中，Fragment的2种加载方法" class="headerlink" title="二、Activity中，Fragment的2种加载方法"></a>二、Activity中，Fragment的2种加载方法</h1><h2 id="1-静态加载"><a href="#1-静态加载" class="headerlink" title="1.静态加载"></a>1.静态加载</h2><h3 id="（1）创建Fragment类和布局文件-fragment1-xml"><a href="#（1）创建Fragment类和布局文件-fragment1-xml" class="headerlink" title="（1）创建Fragment类和布局文件(fragment1.xml)"></a>（1）创建Fragment类和布局文件(fragment1.xml)</h3><pre><code>public class Fragment1 extends Fragment &#123;
    @Override
    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) &#123;
       return inflater.inflate(R.layout.fragment1, container, false);
    &#125;
&#125;

&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:background=&quot;#00ff00&quot; &gt;
    &lt;TextView
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;This is fragment 1&quot;
        android:textColor=&quot;#000000&quot;
        android:textSize=&quot;25sp&quot; /&gt;
&lt;/LinearLayout&gt; 
</code></pre>
<h3 id="（2）在activity布局文件（activity-main-xml）中添加fragment布局"><a href="#（2）在activity布局文件（activity-main-xml）中添加fragment布局" class="headerlink" title="（2）在activity布局文件（activity_main.xml）中添加fragment布局"></a>（2）在activity布局文件（activity_main.xml）中添加fragment布局</h3><pre><code>...
&lt;fragment
android:id=&quot;@+id/fragment1&quot;
android:name=&quot;com.example.sven.fragementdemo.Fragment1&quot;
android:layout_width=&quot;0dip&quot;
android:layout_height=&quot;match_parent&quot;
android:layout_weight=&quot;1&quot; /&gt;
...
</code></pre>
<h2 id="2-动态加载"><a href="#2-动态加载" class="headerlink" title="2.动态加载"></a>2.动态加载</h2><h3 id="1-在activity布局文件中添加FragmentLayout节点"><a href="#1-在activity布局文件中添加FragmentLayout节点" class="headerlink" title="(1) 在activity布局文件中添加FragmentLayout节点"></a>(1) 在activity布局文件中添加FragmentLayout节点</h3><pre><code>...
  &lt;FrameLayout
        android:id=&quot;@+id/fragment_container&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;&gt;
    &lt;/FrameLayout&gt;
...
</code></pre>
<h3 id="2-java代码中动态加载"><a href="#2-java代码中动态加载" class="headerlink" title="(2) java代码中动态加载"></a>(2) java代码中动态加载</h3><pre><code>...
  1.获取fragmentManager
FragmentManager fragmentManager = getFragmentManager();
  2.获取FragmentTransaction
FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();
  3.创建需要的Fragment
Fragment fragment = new Fragment1();
  4.动态添加fragment
    将创建的fragment添加到Activity布局文件中定义的占位符中（FrameLayout）
fragmentTransaction.add(R.id.fragment_container,fragment).commit();
...
</code></pre>
<h1 id="三、FragmentTransaction方法解析结合Fragment的生命周期"><a href="#三、FragmentTransaction方法解析结合Fragment的生命周期" class="headerlink" title="三、FragmentTransaction方法解析结合Fragment的生命周期"></a>三、FragmentTransaction方法解析结合Fragment的生命周期</h1><p>对Fragment的操作主要是通过调用FragmentTransaction类的方法进行的，FragmentTransaction的对象通常是通过getFragmentManager().beginTransaction()获取的</p>
<h2 id="1-add-amp-remove-replace"><a href="#1-add-amp-remove-replace" class="headerlink" title="1.add &amp; remove / replace"></a>1.add &amp; remove / replace</h2><h3 id="1-add-往Activity中添加一个Fragment，对应的fragment的生命周期如下："><a href="#1-add-往Activity中添加一个Fragment，对应的fragment的生命周期如下：" class="headerlink" title="(1) add 往Activity中添加一个Fragment，对应的fragment的生命周期如下："></a>(1) add 往Activity中添加一个Fragment，对应的fragment的生命周期如下：</h3><pre><code>06-13 12:01:43.406 1986-1986/? I/Fragment3: onAttach
06-13 12:01:43.406 1986-1986/? I/Fragment3: onCreate
06-13 12:01:43.406 1986-1986/? I/Fragment3: onCreateView
06-13 12:01:43.406 1986-1986/? I/Fragment3: onActivityCreated
06-13 12:01:43.406 1986-1986/? I/Fragment3: onStart
06-13 12:01:43.406 1986-1986/? I/Fragment3: onResume  
</code></pre>
<h3 id="2-remove-从Activity中移除一个Fragment，和add配对使用，通常是直接用replace"><a href="#2-remove-从Activity中移除一个Fragment，和add配对使用，通常是直接用replace" class="headerlink" title="(2) remove 从Activity中移除一个Fragment，和add配对使用，通常是直接用replace"></a>(2) remove 从Activity中移除一个Fragment，和add配对使用，通常是直接用replace</h3><pre><code>06-13 12:07:54.046 8765-8765/com.example.sven.fragementdemo I/Fragment3: onPause
06-13 12:07:54.046 8765-8765/com.example.sven.fragementdemo I/Fragment3: onStop
06-13 12:07:54.046 8765-8765/com.example.sven.fragementdemo I/Fragment3: onDestroyView
06-13 12:07:54.046 8765-8765/com.example.sven.fragementdemo I/Fragment3: onDestroy
06-13 12:07:54.046 8765-8765/com.example.sven.fragementdemo I/Fragment3: onDetach
</code></pre>
<h3 id="3-replace-使用另一个fragment替换当前的，先remove掉当前的再add新的，参考add和remove的过程"><a href="#3-replace-使用另一个fragment替换当前的，先remove掉当前的再add新的，参考add和remove的过程" class="headerlink" title="(3) replace 使用另一个fragment替换当前的，先remove掉当前的再add新的，参考add和remove的过程"></a>(3) replace 使用另一个fragment替换当前的，先remove掉当前的再add新的，参考add和remove的过程</h3><h2 id="2-attach-amp-detach"><a href="#2-attach-amp-detach" class="headerlink" title="2.attach &amp; detach"></a>2.attach &amp; detach</h2><h3 id="1-attach-重建view视图，添加到UI上并显示，和detach配合使用，显示一个被detach的fragment"><a href="#1-attach-重建view视图，添加到UI上并显示，和detach配合使用，显示一个被detach的fragment" class="headerlink" title="(1) attach 重建view视图，添加到UI上并显示，和detach配合使用，显示一个被detach的fragment"></a>(1) attach 重建view视图，添加到UI上并显示，和detach配合使用，显示一个被detach的fragment</h3><pre><code>06-13 11:57:46.376 29992-29992/com.example.sven.fragementdemo I/Fragment3: onCreateView
06-13 11:57:46.376 29992-29992/com.example.sven.fragementdemo I/Fragment3: onActivityCreated
06-13 11:57:46.376 29992-29992/com.example.sven.fragementdemo I/Fragment3: onStart
06-13 11:57:46.376 29992-29992/com.example.sven.fragementdemo I/Fragment3: onResume
</code></pre>
<h3 id="2-detach-会将view从UI中移除-和remove-不同-此时fragment的状态依然由FragmentManager维护，fragment的实例还存在，但是视图被销毁了"><a href="#2-detach-会将view从UI中移除-和remove-不同-此时fragment的状态依然由FragmentManager维护，fragment的实例还存在，但是视图被销毁了" class="headerlink" title="(2) detach 会将view从UI中移除,和remove()不同,此时fragment的状态依然由FragmentManager维护，fragment的实例还存在，但是视图被销毁了"></a>(2) detach 会将view从UI中移除,和remove()不同,此时fragment的状态依然由FragmentManager维护，fragment的实例还存在，但是视图被销毁了</h3><pre><code>06-13 11:58:13.486 29992-29992/com.example.sven.fragementdemo I/Fragment3: onPause
06-13 11:58:13.486 29992-29992/com.example.sven.fragementdemo I/Fragment3: onStop
06-13 11:58:13.486 29992-29992/com.example.sven.fragementdemo I/Fragment3: onDestroyView
</code></pre>
<h2 id="3-hide-amp-show"><a href="#3-hide-amp-show" class="headerlink" title="3.hide &amp; show"></a>3.hide &amp; show</h2><p>不涉及fragment生命周期，调试过程中没有看到想象中onPause、onStop、onResume函数的调用过程，hide时fragment的视图和实例都不会被销毁，只是视图可见与不可见的变化。账号登陆界面应该用的比较多，能够保存用户的输入，和detach区别就是detach不能够的保存界面的信息（例如EditText的输入），每次detach，attch时界面都会重绘</p>
<h2 id="4-commit"><a href="#4-commit" class="headerlink" title="4.commit"></a>4.commit</h2><p>提交对fragment的一系列操作。注意每一次对fragment的操作都要开一次事务，commit一次。commit和FragmentManager.beginTransaction()要配对使用。（很像数据库，暂时没深入研究）</p>
<h2 id="5-addToBackStack-String"><a href="#5-addToBackStack-String" class="headerlink" title="5.addToBackStack(String)"></a>5.addToBackStack(String)</h2><p>把当前事务的变化情况添加到回退栈,下节详细讲下</p>
<h2 id="tips："><a href="#tips：" class="headerlink" title="tips："></a>tips：</h2><h3 id="1-以上这些方法通常是在Activity中使用，依附于同一个Activity的多个fragment的各种切换"><a href="#1-以上这些方法通常是在Activity中使用，依附于同一个Activity的多个fragment的各种切换" class="headerlink" title="1.以上这些方法通常是在Activity中使用，依附于同一个Activity的多个fragment的各种切换"></a>1.以上这些方法通常是在Activity中使用，依附于同一个Activity的多个fragment的各种切换</h3><h3 id="2-fragment真正的实例其实是要通过FragmentTransaction-add，只有在add时才会执行onCreate，new的时候拿到只是一个引用-并没有执行生命周期函数"><a href="#2-fragment真正的实例其实是要通过FragmentTransaction-add，只有在add时才会执行onCreate，new的时候拿到只是一个引用-并没有执行生命周期函数" class="headerlink" title="2.fragment真正的实例其实是要通过FragmentTransaction.add，只有在add时才会执行onCreate，new的时候拿到只是一个引用 并没有执行生命周期函数"></a>2.fragment真正的实例其实是要通过FragmentTransaction.add，只有在add时才会执行onCreate，new的时候拿到只是一个引用 并没有执行生命周期函数</h3><h3 id="3-使用attach-detach-或者-hide-show-都需要new出对象，并且执行add"><a href="#3-使用attach-detach-或者-hide-show-都需要new出对象，并且执行add" class="headerlink" title="3.使用attach/detach 或者 hide/show 都需要new出对象，并且执行add"></a>3.使用attach/detach 或者 hide/show 都需要new出对象，并且执行add</h3><h3 id="4-add-remove-replace-hide-show后都要commit其效果才会在屏幕上显示出来"><a href="#4-add-remove-replace-hide-show后都要commit其效果才会在屏幕上显示出来" class="headerlink" title="4.add/remove/replace/hide/show后都要commit其效果才会在屏幕上显示出来"></a>4.add/remove/replace/hide/show后都要commit其效果才会在屏幕上显示出来</h3><h1 id="四、Fragment的回退栈"><a href="#四、Fragment的回退栈" class="headerlink" title="四、Fragment的回退栈"></a>四、Fragment的回退栈</h1><p>Fragment回退栈是用来保存每一次Fragment事务发生的变化，如果你将Fragment任务添加到回退栈，当点击back键时，将看到上一次的保存的Fragment，一旦Fragment完全从后退栈中弹出，用户再次点击后退键，则退出当前Activity，如果被移除的Fragment没有添加到回退栈，例如执行remove或者replace时，这个Fragment实例将会被销毁</p>
<p>理解以下3种情况 在同一个Actity中，fragment1 跳转到fragment2，然后按back退出时的不同情况</p>
<pre><code>public void jump2fragment2()&#123;
    FragmentTransaction fragmentTransaction = getFragmentManager().beginTransaction();
    fragment之间跳转时
    1.只采用replace 实例会被销毁 back键一次
    fragmentTransaction.replace(R.id.fragment_container,new Fragment2());
    fragmentTransaction.addToBackStack(null);

    2.把当前事务的变化情况添加到回退栈,视图会被销毁但是实例还在(back 2次)
    fragmentTransaction.replace(R.id.fragment_container,new Fragment2());
    fragmentTransaction.addToBackStack(null);

    3.采用hide方式 实例不会被销毁,视图也不会被销毁(back 2次)
    fragmentTransaction.hide(this);
    fragmentTransaction.add(R.id.fragment_container, new Fragment2());
    fragmentTransaction.addToBackStack(null);
    fragmentTransaction.commit();
&#125;
</code></pre>
<h1 id="五、Fragment与Activity之间的通信"><a href="#五、Fragment与Activity之间的通信" class="headerlink" title="五、Fragment与Activity之间的通信"></a>五、Fragment与Activity之间的通信</h1><h2 id="1-一般Fragment依附于Activity存在，因此与Activity之间的通信可以归纳为以下3点："><a href="#1-一般Fragment依附于Activity存在，因此与Activity之间的通信可以归纳为以下3点：" class="headerlink" title="1.一般Fragment依附于Activity存在，因此与Activity之间的通信可以归纳为以下3点："></a>1.一般Fragment依附于Activity存在，因此与Activity之间的通信可以归纳为以下3点：</h2><h3 id="（1）Fragment中可以通过getActivity得到当前绑定的Activity的实例，然后进行操作"><a href="#（1）Fragment中可以通过getActivity得到当前绑定的Activity的实例，然后进行操作" class="headerlink" title="（1）Fragment中可以通过getActivity得到当前绑定的Activity的实例，然后进行操作"></a>（1）Fragment中可以通过getActivity得到当前绑定的Activity的实例，然后进行操作</h3><p>例如你在想在某个fragment中通过activity拿到fragment1的数据可以这样做</p>
<pre><code>public void getfragment1text() &#123;
    getActivity().findViewById(R.id.fragment1_text)
&#125;
</code></pre>
<h3 id="2-如果你Activity中包含自己管理的Fragment的引用，可以通过引用直接访问所有的Fragment的public方法"><a href="#2-如果你Activity中包含自己管理的Fragment的引用，可以通过引用直接访问所有的Fragment的public方法" class="headerlink" title="(2) 如果你Activity中包含自己管理的Fragment的引用，可以通过引用直接访问所有的Fragment的public方法"></a>(2) 如果你Activity中包含自己管理的Fragment的引用，可以通过引用直接访问所有的Fragment的public方法</h3><h3 id="3-如果Activity中未保存任何Fragment的引用，那么没关系，每个Fragment都有一个唯一的TAG或者ID-可以通过getFragmentManager-findFragmentByTag-或者findFragmentById-获得任何Fragment实例，然后进行操作-fragment的id其实是无法设置的，add或replace时设置的id是其实要插入fragment所在ViewGroup的id，tag可以在add或replace时设置。https-stackoverflow-com-questions-9363072-android-set-fragment-id"><a href="#3-如果Activity中未保存任何Fragment的引用，那么没关系，每个Fragment都有一个唯一的TAG或者ID-可以通过getFragmentManager-findFragmentByTag-或者findFragmentById-获得任何Fragment实例，然后进行操作-fragment的id其实是无法设置的，add或replace时设置的id是其实要插入fragment所在ViewGroup的id，tag可以在add或replace时设置。https-stackoverflow-com-questions-9363072-android-set-fragment-id" class="headerlink" title="(3) 如果Activity中未保存任何Fragment的引用，那么没关系，每个Fragment都有一个唯一的TAG或者ID,可以通过getFragmentManager.findFragmentByTag()或者findFragmentById()获得任何Fragment实例，然后进行操作 fragment的id其实是无法设置的，add或replace时设置的id是其实要插入fragment所在ViewGroup的id，tag可以在add或replace时设置。https://stackoverflow.com/questions/9363072/android-set-fragment-id"></a>(3) 如果Activity中未保存任何Fragment的引用，那么没关系，每个Fragment都有一个唯一的TAG或者ID,可以通过getFragmentManager.findFragmentByTag()或者findFragmentById()获得任何Fragment实例，然后进行操作 fragment的id其实是无法设置的，add或replace时设置的id是其实要插入fragment所在ViewGroup的id，tag可以在add或replace时设置。<a href="https://stackoverflow.com/questions/9363072/android-set-fragment-id">https://stackoverflow.com/questions/9363072/android-set-fragment-id</a></h3><pre><code>public class MainActivity extends AppCompatActivity &#123;
    private static final String TAG = &quot;ActivityLife&quot;;
    private Fragment1 fragment = new Fragment1();
    @Override
    protected void onCreate(Bundle savedInstanceState) &#123;
        super.onCreate(savedInstanceState);
        printLog(&quot;onCreate...&quot;);
        setContentView(R.layout.activity_main);

        // 1.获取fragmentManager
        FragmentManager fragmentManager = getFragmentManager();
        // 2.获取FragmentTransaction
        FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();
        // 3.创建需要的Fragment
        // Fragment fragment = new Fragment1();
        // 4.动态添加fragment
        // 将创建的fragment添加到Activity布局文件中定义的占位符中（FrameLayout）
        fragmentTransaction.add(R.id.fragment_container, fragment, &quot;fragment1&quot;).commit();
    &#125;

    public void getFragmentMessage(View view)&#123;
        //1.针对第2种情况
        fragment.printSth();
        //2.针对第3种情况
        Fragment fragment = getFragmentManager().findFragmentByTag(&quot;fragment1&quot;);
        printLog(fragment.toString());
        fragment.onResume();
    &#125;
&#125;

public class Fragment1 extends Fragment &#123;
    ...
    public void printSth() &#123;
        Log.i(TAG,&quot;fragment3 printSth&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="（4）更复杂的用法参考："><a href="#（4）更复杂的用法参考：" class="headerlink" title="（4）更复杂的用法参考："></a>（4）更复杂的用法参考：</h3><p><a href="http://blog.csdn.net/lmj623565791/article/details/37992017">http://blog.csdn.net/lmj623565791/article/details/37992017</a></p>
<h2 id="2-应用场景主要就是通过Activity去管理多个Fragment的状态"><a href="#2-应用场景主要就是通过Activity去管理多个Fragment的状态" class="headerlink" title="2.应用场景主要就是通过Activity去管理多个Fragment的状态"></a>2.应用场景主要就是通过Activity去管理多个Fragment的状态</h2><h2 id="思路如下："><a href="#思路如下：" class="headerlink" title="思路如下："></a>思路如下：</h2><h3 id="1-让各个Fragment注册一个监听接口，让Activity去implements这个监听接口"><a href="#1-让各个Fragment注册一个监听接口，让Activity去implements这个监听接口" class="headerlink" title="(1) 让各个Fragment注册一个监听接口，让Activity去implements这个监听接口"></a>(1) 让各个Fragment注册一个监听接口，让Activity去implements这个监听接口</h3><h3 id="2-在Activity中new出各个Fragment的对象，获取引用"><a href="#2-在Activity中new出各个Fragment的对象，获取引用" class="headerlink" title="(2) 在Activity中new出各个Fragment的对象，获取引用"></a>(2) 在Activity中new出各个Fragment的对象，获取引用</h3><h3 id="3-将Fragment中的事件通过listener传递到Activity中，在Fragment中通过getActivity去调用监听方法"><a href="#3-将Fragment中的事件通过listener传递到Activity中，在Fragment中通过getActivity去调用监听方法" class="headerlink" title="(3) 将Fragment中的事件通过listener传递到Activity中，在Fragment中通过getActivity去调用监听方法"></a>(3) 将Fragment中的事件通过listener传递到Activity中，在Fragment中通过getActivity去调用监听方法</h3><h2 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h2><h3 id="Fragment中的按钮的事件响应时不能通过在配置文件中加onClick属性找到的，必须注册onClickListenr-有2种方式"><a href="#Fragment中的按钮的事件响应时不能通过在配置文件中加onClick属性找到的，必须注册onClickListenr-有2种方式" class="headerlink" title="Fragment中的按钮的事件响应时不能通过在配置文件中加onClick属性找到的，必须注册onClickListenr(有2种方式)"></a>Fragment中的按钮的事件响应时不能通过在配置文件中加onClick属性找到的，必须注册onClickListenr(有2种方式)</h3><p>原因参考：<a href="http://blog.csdn.net/Zafir6453/article/details/51383915">http://blog.csdn.net/Zafir6453/article/details/51383915</a></p>
<h2 id="3-以上这些自己写了个Demo，方便大家调试和学习"><a href="#3-以上这些自己写了个Demo，方便大家调试和学习" class="headerlink" title="3.以上这些自己写了个Demo，方便大家调试和学习"></a>3.以上这些自己写了个Demo，方便大家调试和学习</h2><p><a href="http://download.csdn.net/detail/time_traveller14/9870932">http://download.csdn.net/detail/time_traveller14/9870932</a></p>
<h3 id="1-生命周期，回退栈，参考fragment1-fragment2-MainActivity"><a href="#1-生命周期，回退栈，参考fragment1-fragment2-MainActivity" class="headerlink" title="1.生命周期，回退栈，参考fragment1,fragment2,MainActivity"></a>1.生命周期，回退栈，参考fragment1,fragment2,MainActivity</h3><h3 id="2-FragmentTransaction及和Activity通信（fragment中不同的按钮事件响应）-参考fragment3-fragment4-Main2Activity"><a href="#2-FragmentTransaction及和Activity通信（fragment中不同的按钮事件响应）-参考fragment3-fragment4-Main2Activity" class="headerlink" title="2.FragmentTransaction及和Activity通信（fragment中不同的按钮事件响应） 参考fragment3,fragment4, Main2Activity"></a>2.FragmentTransaction及和Activity通信（fragment中不同的按钮事件响应） 参考fragment3,fragment4, Main2Activity</h3><h1 id="六-还未理解问题："><a href="#六-还未理解问题：" class="headerlink" title="六.还未理解问题："></a>六.还未理解问题：</h1><h3 id="1-回退栈的使用场景，有了hide和detach为何还要加这个，仅仅是为了多按一次back键？"><a href="#1-回退栈的使用场景，有了hide和detach为何还要加这个，仅仅是为了多按一次back键？" class="headerlink" title="1.回退栈的使用场景，有了hide和detach为何还要加这个，仅仅是为了多按一次back键？"></a>1.回退栈的使用场景，有了hide和detach为何还要加这个，仅仅是为了多按一次back键？</h3><h3 id="2-hide和show为何没有onPause和onResume的过程，hide为何不执行onPause，onStop呢？"><a href="#2-hide和show为何没有onPause和onResume的过程，hide为何不执行onPause，onStop呢？" class="headerlink" title="2.hide和show为何没有onPause和onResume的过程，hide为何不执行onPause，onStop呢？"></a>2.hide和show为何没有onPause和onResume的过程，hide为何不执行onPause，onStop呢？</h3><h3 id="3-remove-的真正含义销毁还是出栈，看许多资料解释是销毁掉，但为何remove掉，commit完fragment-null，还能够通过tag获取到，但是去寻找fragment的视图元素会报错？"><a href="#3-remove-的真正含义销毁还是出栈，看许多资料解释是销毁掉，但为何remove掉，commit完fragment-null，还能够通过tag获取到，但是去寻找fragment的视图元素会报错？" class="headerlink" title="3.remove 的真正含义销毁还是出栈，看许多资料解释是销毁掉，但为何remove掉，commit完fragment!=null，还能够通过tag获取到，但是去寻找fragment的视图元素会报错？"></a>3.remove 的真正含义销毁还是出栈，看许多资料解释是销毁掉，但为何remove掉，commit完fragment!=null，还能够通过tag获取到，但是去寻找fragment的视图元素会报错？</h3><h3 id="4-屏幕旋转时，已经判断了onSavedInstance-null，为何还会继续，log中-onCreate-onCreateView会执行，要结合activity？"><a href="#4-屏幕旋转时，已经判断了onSavedInstance-null，为何还会继续，log中-onCreate-onCreateView会执行，要结合activity？" class="headerlink" title="4.屏幕旋转时，已经判断了onSavedInstance==null，为何还会继续，log中 onCreate onCreateView会执行，要结合activity？"></a>4.屏幕旋转时，已经判断了onSavedInstance==null，为何还会继续，log中 onCreate onCreateView会执行，要结合activity？</h3><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a href="https://developer.android.com/guide/components/fragments.html">https://developer.android.com/guide/components/fragments.html</a><br>郭霖大神 <a href="http://blog.csdn.net/guolin_blog/article/details/8881711">http://blog.csdn.net/guolin_blog/article/details/8881711</a><br>鸿洋大神 <a href="http://blog.csdn.net/lmj623565791/article/details/37970961">http://blog.csdn.net/lmj623565791/article/details/37970961</a></p>
<h3 id="自己的第一篇技术博客，请大家多多指教，最后不理解的问题，欢迎讨论！"><a href="#自己的第一篇技术博客，请大家多多指教，最后不理解的问题，欢迎讨论！" class="headerlink" title="自己的第一篇技术博客，请大家多多指教，最后不理解的问题，欢迎讨论！"></a>自己的第一篇技术博客，请大家多多指教，最后不理解的问题，欢迎讨论！</h3>]]></content>
      <categories>
        <category>Android</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>base_06_IntentService 源码分析</title>
    <url>/2021/02/24/Notes/Android/01%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6/base_06_IntentService%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="base-06-IntentService-源码分析"><a href="#base-06-IntentService-源码分析" class="headerlink" title="base_06_IntentService 源码分析"></a>base_06_IntentService 源码分析</h1><span id="more"></span>

<p>IntentService 可以用来顺序执行一些优先级较高的耗时后台任务，例如后台下载。</p>
<h3 id="一、启动初始化"><a href="#一、启动初始化" class="headerlink" title="一、启动初始化"></a>一、启动初始化</h3><p>在onCreate中：创建HandlerThread，内部封装了 Looper，在这里创建HandlerThread并启动，所以启动 IntentService 不需要新建线程。</p>
<pre><code>@Override
public void onCreate() &#123;
    // TODO: It would be nice to have an option to hold a partial wakelock
    // during processing, and to have a static startService(Context, Intent)
    // method that would launch the service &amp; hand off a wakelock.

    super.onCreate();
    HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;);
    thread.start();

    mServiceLooper = thread.getLooper();
    mServiceHandler = new ServiceHandler(mServiceLooper);
&#125;
</code></pre>
<h3 id="二、调用过程"><a href="#二、调用过程" class="headerlink" title="二、调用过程"></a>二、调用过程</h3><p>每次启动Service时，都会调用一次onStartCommand，处理每个后台任务的intent，最后通过mServiceHandler发送消息去处理</p>
<pre><code>@Override
public int onStartCommand(@Nullable Intent intent, int flags, int startId) &#123;
    onStart(intent, startId);
    return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;
&#125;
​    @Override
​    public void onStart(@Nullable Intent intent, int startId) &#123;
​        Message msg = mServiceHandler.obtainMessage();
​        msg.arg1 = startId;
​        msg.obj = intent;
​        mServiceHandler.sendMessage(msg);
​    &#125;
</code></pre>
<h3 id="三、处理后台任务"><a href="#三、处理后台任务" class="headerlink" title="三、处理后台任务"></a>三、处理后台任务</h3><p>在ServiceHandler 的 handleMessage中，<br>1.onHandleIntent，处理外界启动时传递进来的intent，需要子类去复写，根据不同的intent做相应的处理<br>2.stopSelf(int startId)，停止服务，在停止服务时会去判断最近的启动的服务次数是否和startId相同，如果相同就会立即停止，否则不会停止服务，最终就是在执行完最后一个任务后才停止服务</p>
<pre><code>private final class ServiceHandler extends Handler &#123;
    public ServiceHandler(Looper looper) &#123;
        super(looper);
    &#125;

    @Override
    public void handleMessage(Message msg) &#123;
        onHandleIntent((Intent)msg.obj);
        stopSelf(msg.arg1);
    &#125;
&#125;

@WorkerThread
protected abstract void onHandleIntent(@Nullable Intent intent);
​    public final void stopSelf(int startId) &#123;
​        if (mActivityManager == null) &#123;
​            return;
​        &#125;
​        try &#123;
​            mActivityManager.stopServiceToken(
​                    new ComponentName(this, mClassName), mToken, startId);
​        &#125; catch (RemoteException ex) &#123;
​        &#125;
​    &#125;
</code></pre>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>1.IntentService 可用于执行可用来执行一些优先限比较高的后台任务耗时任务，当任务执行完成后会自动停止<br>2.IntentService 内部封装了HandlerThread和Handler，每次调用startService就会传递一个intent进来，相当于添加一个任务，执行时是按照启动的顺序执行</p>
<p>参考资料：<br><a href="http://www.jianshu.com/p/332b6daf91f0">http://www.jianshu.com/p/332b6daf91f0</a><br><a href="http://blog.csdn.net/mingli198611/article/details/8782772">http://blog.csdn.net/mingli198611/article/details/8782772</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>base_04_ContentProvider 基础</title>
    <url>/2021/02/22/Notes/Android/01%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6/base_04_ContentProvider%20%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="base-04-ContentProvider-基础"><a href="#base-04-ContentProvider-基础" class="headerlink" title="base_04_ContentProvider 基础"></a>base_04_ContentProvider 基础</h1><span id="more"></span>

<p>ContentProvider 用户跨进程访问数据，通常和数据库以及ContentResolver配合使用，可以保证数据的安全性。</p>
<h2 id="一、ContentResolver"><a href="#一、ContentResolver" class="headerlink" title="一、ContentResolver"></a>一、ContentResolver</h2><p>对于每一个应用程序来说，如果想要访问内容提供器中共享的数据，就一定要借助ContentResolver类，可以通过Context中的getContentResolver()方法获取到该类的实例。 ContentResolver中提供了一系列的方法用于对数据进行CRUD操作，其中insert()方法用于添加数据，update()方法用于更新数据，delete()方法用于删除数据，query()方法用于查询数据。有没有似曾相识的感觉？没错，SQLiteDatabase中也是使用的这几个方法来进行 CRUD 操作的，只不过它们在方法参数上稍微有一些区别。不同于SQLiteDatabase，ContentResolver中的增删改查方法都是不接收表名参数的，而是使用一个 Uri参数代替，这个参数被称为内容 URI，下面会详细介绍它的格式定义。在得到了内容URI字符串之后，我们还需要将它解析成Uri对象才可以作为参数传入。 只需要调用 Uri.parse()方法，就可以将内容URI字符串解析成 Uri对象： </p>
<pre><code>Uri uri = Uri.parse(&quot;content://com.example.app.provider/table1&quot;) 
</code></pre>
<p>再调用contentResolver的CURD方法就可完成对应的操作。</p>
<pre><code>Cursor cursor = context.getContentResolver().query(uri, null, null, null, null);
</code></pre>
<h2 id="二、内容-URI"><a href="#二、内容-URI" class="headerlink" title="二、内容 URI"></a>二、内容 URI</h2><p>无论是通过ContentResolver访问数据，还是实现自定义的ContentProvider都需要内容URI才能够通信。URI给内容提供器中的数据建立了唯一标志符，基本格式如下：</p>
<pre><code>content://Authority/Path/Id
</code></pre>
<p>content:// 固定格式<br>Authority：权限，用于对不同的应用程序进行区分，一般为了避免冲突，都会采用包名.provider<br>Path: 路径，用于对同一个程序中的不同表做区分<br>Id: 数据Id，用于区分表中的不同数据<br>URI的格式主要有如下2种：</p>
<pre><code>   content://com.example.app.provider/table 
   content://com.example.app.provider/table1/1 
</code></pre>
<p>以路径结尾表示期望访问该表中所有的数据， 以 id结尾就表示期望访问该表中拥有相应 id的数据。我们可以使用通配符的方式来分别匹 配这两种格式的内容 URI，规则如下。</p>
<ol>
<li><p>*：表示匹配任意长度的任意字符 </p>
</li>
<li><p>#：表示匹配任意长度的数字<br>所以，一个能够匹配任意表的内容 URI格式就可以写成：</p>
<p> content://com.example.app.provider/* </p>
</li>
</ol>
<p>而一个能够匹配 table1表中任意一行数据的内容 URI格式就可以写成</p>
<pre><code>content://com.example.app.provider/table1/#
</code></pre>
<p>我们再借助UriMatcher这个类就可以轻松地实现匹配内容URI的功能。UriMatcher中提供了一个addURI()方法，这个方法接收三个参数，可以分别把权限、路径和一个自定义代码传进去。这样，当调用UriMatcher的match()方法时，就可以将一个 Uri对象传入，返回值是某个能够匹配这个Uri对象所对应的自定义代码，利用这个代码，我们就可以判断出调用方期望访问的是哪张表中的数据了。</p>
<h2 id="三、ContentProvider方法介绍"><a href="#三、ContentProvider方法介绍" class="headerlink" title="三、ContentProvider方法介绍"></a>三、ContentProvider方法介绍</h2><p>通过继承ContentProvider，并且实现抽象方法就可完成自定义的ContentProvider共享数据了。</p>
<h3 id="1-onCreate"><a href="#1-onCreate" class="headerlink" title="1.onCreate()"></a>1.onCreate()</h3><p>初始化内容提供器的时候调用。通常会在这里完成对数据库的创建和升级等操作，返回true表示内容提供器初始化成功，返回false 则表示失败。注意，只有当存在 ContentResolver尝试访问我们程序中的数据时，内容提供器才会被初始化。</p>
<h3 id="2-query"><a href="#2-query" class="headerlink" title="2.query()"></a>2.query()</h3><p>从内容提供器中查询数据。使用uri参数来确定查询哪张表，projection参数用于确定查询哪些列，selection和selectionArgs参数用于约束查询哪些行，sortOrder参数用于对结果进行排序，查询的结果存放在Cursor对象中返回。 </p>
<h3 id="3-insert"><a href="#3-insert" class="headerlink" title="3.insert()"></a>3.insert()</h3><p>向内容提供器中添加一条数据。使用uri参数来确定要添加到的表，待添加的数据保存在values参数中。添加完成后，返回一个用于表示这条新记录的 URI。</p>
<h3 id="4-update"><a href="#4-update" class="headerlink" title="4.update()"></a>4.update()</h3><p>更新内容提供器中已有的数据。使用uri参数来确定更新哪一张表中的数据，新数据保存在values参数中，selection和selectionArgs参数用于约束更新哪些行，受影响的 行数将作为返回值返回。</p>
<h3 id="5-delete"><a href="#5-delete" class="headerlink" title="5.delete()"></a>5.delete()</h3><p>从内容提供器中删除数据。使用uri参数来确定删除哪一张表中的数据，selection和selectionArgs参数用于约束删除哪些行，被删除的行数将作为返回值返回。</p>
<h3 id="6-getType"><a href="#6-getType" class="headerlink" title="6.getType()"></a>6.getType()</h3><p>根据传入的内容 URI来返回相应的 MIME类型。它是所有的内容提供器都必须提供的一个方法，用于获取Uri对象所对应的MIME类型。一个内容URI所对应的MIME字符串主要由三部分组分，Android对这三个部分做了如下格式规定。<br>    1. 必须以vnd开头。<br>    2. 如果内容URI以路径结尾，则后接android.cursor.dir/，如果内容URI以id结尾，则后接android.cursor.item/<br>    3. 最后接上 vnd.authority.path</p>
<p>所以，对于 content://com.example.app.provider/table1这个内容 URI，它所对应的 MIME 类型就可以写成：</p>
<pre><code>vnd.android.cursor.dir/vnd.com.example.app.provider.table1 
</code></pre>
<p>对于 content://com.example.app.provider/table1/1这个内容 URI，它所对应的 MIME类型 就可以写成：</p>
<pre><code> vnd.android.cursor.item/vnd.com.example.app.provider.table1
</code></pre>
<h2 id="四、call-方法"><a href="#四、call-方法" class="headerlink" title="四、call 方法"></a>四、call 方法</h2><p>上面的方法都是访问或修改数据库的，如果需要跨进程访问里一个应用其他数据，例如sharePreference数据，可以通过call方法来调用自定义的函数。</p>
<h3 id="1-provider中复写call-方法，并且添加自定义的方法"><a href="#1-provider中复写call-方法，并且添加自定义的方法" class="headerlink" title="1.provider中复写call 方法，并且添加自定义的方法"></a>1.provider中复写call 方法，并且添加自定义的方法</h3><pre><code>@Override
public Bundle call(@NonNull String method, @Nullable String arg, @Nullable Bundle extras) &#123;
    switch (method)&#123;
        case &quot;getData&quot;:
            return getData();
        default:
            break;
    &#125;
    return null;
&#125;

//自定义函数
public Bundle getData()&#123;
    Bundle b = new Bundle();
    b.putString(&quot;name&quot;,&quot;call getData&quot;);
    return b;
&#125;
</code></pre>
<h3 id="2-查询方传入要调用的provider的自定义方法名和参数"><a href="#2-查询方传入要调用的provider的自定义方法名和参数" class="headerlink" title="2.查询方传入要调用的provider的自定义方法名和参数"></a>2.查询方传入要调用的provider的自定义方法名和参数</h3><pre><code>// uri格式最后一定要带一个 /
Uri uriCall = Uri.parse(&quot;content://&quot; + AUTHORITY + &quot;/&quot;);
Bundle b = getContentResolver().call(uriCall, &quot;getData&quot;, null, null);
Log.i(TAG, &quot;&quot;+b.get(&quot;name&quot;));
</code></pre>
<h2 id="五、MatrixCursor"><a href="#五、MatrixCursor" class="headerlink" title="五、MatrixCursor"></a>五、MatrixCursor</h2><p>ContentProvider的Query方法返回的是一个cursor，如果要对cursor中的数据做处理后再返回给查询的一方，可以通过MatrixCursor 对现有数据封装后返回。</p>
<pre><code>Cursor cursor1 = db.query(&quot;users&quot;, null, &quot;id = ?&quot;, new String[]&#123;&quot;1&quot;&#125;,null, null, null);
MatrixCursor m = new MatrixCursor(new String[]&#123;&quot;c1&quot;, &quot;c2&quot;, &quot;c3&quot;&#125;);
while(cursor1.moveToNext()) &#123;
    String name = cursor1.getString(1);
    int age = cursor1.getInt(2);
    String address = cursor1.getString(3);
    Log.i(TAG, name + &quot;age = &quot;+age + &quot;address = &quot;+address);
    m.addRow(new Object[]&#123;name, age, address&#125;);
&#125;
return m
</code></pre>
<p>Demo：</p>
<p>参考资料：<br>第一行代码——Android 郭霖<br><a href="https://stackoverflow.com/questions/17224766/what-is-getcontentresolver-call-and-how-to-use-it">https://stackoverflow.com/questions/17224766/what-is-getcontentresolver-call-and-how-to-use-it</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>base_07_AsyncTask</title>
    <url>/2021/02/24/Notes/Android/01%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6/base_07_AsyncTask%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="base-07-AsyncTask-源码分析"><a href="#base-07-AsyncTask-源码分析" class="headerlink" title="base_07_AsyncTask 源码分析"></a>base_07_AsyncTask 源码分析</h1><span id="more"></span>

<h2 id="一、用法"><a href="#一、用法" class="headerlink" title="一、用法"></a>一、用法</h2><h3 id="1-类定义："><a href="#1-类定义：" class="headerlink" title="1.类定义："></a>1.类定义：</h3><p>三种泛型类型分别代表“启动任务执行的输入参数”、“后台任务执行的进度”、“后台计算结果的类型”。在特定场合下，并不是所有类型都被使用，如果没有被使用，可以用Java.lang.Void类型代替。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTask</span>&lt;<span class="title">Params</span>, <span class="title">Progress</span>, <span class="title">Result</span>&gt; </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-方法说明"><a href="#2-方法说明" class="headerlink" title="2.方法说明"></a>2.方法说明</h3><p>除了doInBackground是在线程池中执行，其他方法均在主线程执行。<br>1.execute(Params… params)，执行一个异步任务，需要我们在代码中调用此方法，触发异步任务的执行。</p>
<p>2.onPreExecute()，在execute(Params… params)被调用后立即执行，一般用来在执行后台任务前对UI做一些标记。</p>
<p>3.doInBackground(Params… params)，在onPreExecute()完成后立即执行，用于执行较为费时的操作，此方法将接收输入参数和返回计算结果。在执行过程中可以调用publishProgress(Progress… values)来更新进度信息。</p>
<p>4.onProgressUpdate(Progress… values)，在调用publishProgress(Progress… values)时，此方法被执行，直接将进度信息更新到UI组件上。</p>
<p>5.onPostExecute(Result result)，当后台操作结束时，此方法将会被调用，计算结果将做为参数传递到此方法中，直接将结果显示到UI组件上。</p>
<p>6.onCancelled() 异步任务被取消时执行。</p>
<h3 id="3-注意"><a href="#3-注意" class="headerlink" title="3.注意"></a>3.注意</h3><p>1.异步任务的实例必须在UI线程中创建。</p>
<p>2.execute(Params… params)方法必须在UI线程中调用。</p>
<p>3.不要手动调用onPreExecute()，doInBackground(Params… params)，onProgressUpdate(Progress… values)，onPostExecute(Result result)这几个方法。</p>
<p>4.不能在doInBackground(Params… params)中更改UI组件的信息，一般都是通过publishProgress(i)，在onProgressUpdate中操作UI线程的变化，或者doInBackground结束后，在onPostExecute中返回结果</p>
<p>5.一个任务实例只能执行一次，如果执行第二次将会抛出异常。</p>
<p>6.多个任务默认是线性执行的，保证提交的任务确实是按照先后顺序执行的。它的内部有一个队列用来保存所提交的任务，保证当前只运行一个，这样就可以保证任务是完全按照顺序执行的，默认的execute()使用的就是这个，也就是executeOnExecutor(AsyncTask.SERIAL_EXECUTOR)与execute()是一样的。<br>默认还提供了一个并发执行的线程池<br>THREAD_POOL_EXECUTOR是一个有限制数目的线程池 （8 核 9个，看具体逻辑）的线程池，也就是说最多只有5个线程同时运行，超过的就要等待。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CPU_COUNT = Runtime.getRuntime().availableProcessors();</span><br><span class="line"><span class="comment">// We want at least 2 threads and at most 4 threads in the core pool,</span></span><br><span class="line"><span class="comment">// preferring to have 1 less than the CPU count to avoid saturating</span></span><br><span class="line"><span class="comment">// the CPU with background work</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = Math.max(<span class="number">2</span>, Math.min(CPU_COUNT - <span class="number">1</span>, <span class="number">4</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_POOL_SIZE = CPU_COUNT * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An &#123;<span class="doctag">@link</span> Executor&#125; that can be used to execute tasks in parallel.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor THREAD_POOL_EXECUTOR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,</span><br><span class="line">            sPoolWorkQueue, sThreadFactory);</span><br><span class="line">    threadPoolExecutor.allowCoreThreadTimeOut(<span class="keyword">true</span>);</span><br><span class="line">    THREAD_POOL_EXECUTOR = threadPoolExecutor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你想让所有的任务都能并发同时运行，那就创建一个没有限制的线程池(Executors.newCachedThreadPool())，并提供给AsyncTask。这样这个AsyncTask实例就有了自己的线程池而不必使用AsyncTask默认的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Task().executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);</span><br></pre></td></tr></table></figure>
<h2 id="二、源码分析"><a href="#二、源码分析" class="headerlink" title="二、源码分析"></a>二、源码分析</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">重要变量：</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Executor sDefaultExecutor 用于任务排队的线程池</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor THREAD_POOL_EXECUTOR 具体执行任务的线程池</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> InternalHandler sHandler 从线程池切换到主线程</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> WorkerRunnable&lt;Params, Result&gt; mWorker 实现了Callable接口，这里的Param和Result是AsyncTask定义的泛型类型</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> FutureTask&lt;Result&gt; mFuture </span><br><span class="line">FutureTask类其实是实现了Future和Runnable接口，具备了这两个接口的功能</span><br></pre></td></tr></table></figure>


<h3 id="1-从new-AsyncTask-execute-开始说起"><a href="#1-从new-AsyncTask-execute-开始说起" class="headerlink" title="1.从new AsyncTask().execute()开始说起"></a>1.从new AsyncTask().execute()开始说起</h3><p>执行Async通常有2个方法供我们开启异步任务，分别是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execute(Params... params)</span><br><span class="line">executeOnExecutor(Executor exec, Params... params)</span><br></pre></td></tr></table></figure>
<p>这个2个方法的区别就在于是否使用默认的线程池执行，使用者可根据实际的业务需求定义合适的线程池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">execute</span><span class="params">(Params... params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> executeOnExecutor(sDefaultExecutor, params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">executeOnExecutor</span><span class="params">(Executor exec,</span></span></span><br><span class="line"><span class="params"><span class="function">        Params... params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mStatus != Status.PENDING) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (mStatus) &#123;</span><br><span class="line">            <span class="keyword">case</span> RUNNING:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Cannot execute task:&quot;</span></span><br><span class="line">                        + <span class="string">&quot; the task is already running.&quot;</span>);</span><br><span class="line">            <span class="keyword">case</span> FINISHED:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Cannot execute task:&quot;</span></span><br><span class="line">                        + <span class="string">&quot; the task has already been executed &quot;</span></span><br><span class="line">                        + <span class="string">&quot;(a task can be executed only once)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mStatus = Status.RUNNING;</span><br><span class="line"></span><br><span class="line">    onPreExecute();</span><br><span class="line"></span><br><span class="line">    mWorker.mParams = params;</span><br><span class="line">    exec.execute(mFuture);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在代码第9-21行：判断当前的任务是不是在队列里，如果不是再去判断是不是正在执行或者已经执行完了，保证同一个任务实例只会执行一次，如果是第一次执行，那么就将它的状态置为running。<br>22行 执行 onPreExecute 中的操作<br>23行 将传入的参数Params赋值给mWorker的mParams，真正的执行会调用到mWorker<br>26行 通过Executor执行mFuture，在代码的第3行可以看到默认使用的Executor是sDefaultExecutor</p>
<h3 id="2-sDefaultExecutor-execute？"><a href="#2-sDefaultExecutor-execute？" class="headerlink" title="2. sDefaultExecutor.execute？"></a>2. sDefaultExecutor.execute？</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An &#123;<span class="doctag">@link</span> Executor&#125; that executes tasks one at a time in serial</span></span><br><span class="line"><span class="comment"> * order.  This serialization is global to a particular process.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor SERIAL_EXECUTOR = <span class="keyword">new</span> SerialExecutor();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Executor sDefaultExecutor = SERIAL_EXECUTOR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ArrayDeque&lt;Runnable&gt; mTasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();</span><br><span class="line">    Runnable mActive;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</span><br><span class="line">        mTasks.offer(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    r.run();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    scheduleNext();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (mActive == <span class="keyword">null</span>) &#123;</span><br><span class="line">            scheduleNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((mActive = mTasks.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            THREAD_POOL_EXECUTOR.execute(mActive);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>12行，exce方法会将传入的mFuture的run方法在封装到一个Runnable对象中，并且将这个对象通过mTasks.offer加入到类型为ArrayDeque的任务队列mTask中，</p>
<pre><code> /**
 * Inserts the specified element at the end of this deque.
 *
public boolean offer(E e) &#123;
    return offerLast(e);
&#125;
</code></pre>
<p>22行，第一次执行时，mActive一定为空，那么scheduleNext一定会被执行，最终会执行29行THREAD_POOL_EXECUTOR.execute(mActive)，在线程池中执行该任务</p>
<p>总结下，到这里我们已经知道2个重要的点：<br>    1.传入的参数是被封装到mWorker里<br>    2.THREAD_POOL_EXECUTOR 执行的其实是mFuture的run方法</p>
<h3 id="3-mFuture-和-mWorker？"><a href="#3-mFuture-和-mWorker？" class="headerlink" title="3.mFuture 和 mWorker？"></a>3.mFuture 和 mWorker？</h3><p>mFuture是个什么呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> FutureTask&lt;Result&gt; mFuture;</span><br></pre></td></tr></table></figure>

<p>这是一个实现了Runnable接的类,那么我们先看下它的run方法吧</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !U.compareAndSwapObject(<span class="keyword">this</span>, RUNNER, <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            <span class="keyword">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">                ran = <span class="keyword">false</span>;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">        <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">        runner = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">        <span class="comment">// leaked interrupts</span></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码第6-12行，我们可以看到执行了一个callable.call()方法，并且在第19行将返回值set(result);<br>这个callable个什么呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.callable = callable;</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来是构造函数传递进来的值，那么是在什么时候别初始化的呢？请看AsyncTask()的构造函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new asynchronous task. This constructor must be invoked on the UI thread.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            mTaskInvoked.set(<span class="keyword">true</span>);</span><br><span class="line">            Result result = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">                <span class="comment">//noinspection unchecked</span></span><br><span class="line">                result = doInBackground(mParams);</span><br><span class="line">                Binder.flushPendingCommands();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable tr) &#123;</span><br><span class="line">                mCancelled.set(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">throw</span> tr;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                postResult(result);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                postResultIfNotInvoked(get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                android.util.Log.w(LOG_TAG, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;An error occurred while executing doInBackground()&quot;</span>,</span><br><span class="line">                        e.getCause());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</span><br><span class="line">                postResultIfNotInvoked(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第24行， 哦！原来在我们new AsyncTask的时候我们就初始化了一个mWorker对象，并且将该参数传递给了mFuture，callable原来就是mWorker，<br>第12行， result = doInBackground(mParams); mWorker.call方法原来会调用到doInBackground，原来我们所有传递过来的参数都是通过mWorker传递到doInBackground中的<br>第18行， 将返回值通过post到主线程，这里就用到了InternalHandler</p>
<p>##4. InternalHandler线程池到主线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Result <span class="title">postResult</span><span class="params">(Result result)</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,</span><br><span class="line">            <span class="keyword">new</span> AsyncTaskResult&lt;Result&gt;(<span class="keyword">this</span>, result));</span><br><span class="line">    message.sendToTarget();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Handler <span class="title">getHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (AsyncTask.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sHandler = <span class="keyword">new</span> InternalHandler();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sHandler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InternalHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Looper.getMainLooper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> MESSAGE_POST_RESULT:</span><br><span class="line">                <span class="comment">// There is only one result</span></span><br><span class="line">                result.mTask.finish(result.mData[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MESSAGE_POST_PROGRESS:</span><br><span class="line">                result.mTask.onProgressUpdate(result.mData);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，到这里一个AsyncTask的执行就介绍完了，下面介绍下任务的进度更新和取消</p>
<h3 id="5-publishProgress"><a href="#5-publishProgress" class="headerlink" title="5. publishProgress"></a>5. publishProgress</h3><p>我们知道可以通过在doinBackground中调用publishProgress来实时更新UI，那么是如何实现的呢？</p>
<pre><code>protected final void publishProgress(Progress... values) &#123;
    if (!isCancelled()) &#123;
        getHandler().obtainMessage(MESSAGE_POST_PROGRESS,
                new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget();
    &#125;
&#125;
</code></pre>
<p>原来它也是通过InternalThread发送消息，结合InternalHandler中的代码，可知最终通过onProgressUpdate方法实现ui更新</p>
<h3 id="6-关于任务取消"><a href="#6-关于任务取消" class="headerlink" title="6.关于任务取消"></a>6.关于任务取消</h3><p>boolean cancel(boolean mayInterruptIfRunning)：试图取消对此任务的执行。如果任务已完成、或已取消，或者由于某些其<br>他原因而无法取消，则此尝试将失败。当调用 cancel 时，如果调用成功，而此任务尚未启动，则此任务将永不运行。如果任务已经<br>启动，则 mayInterruptIfRunning 参数确定是否应该以试图停止任务的方式来中断执行此任务的线程。此方法返回后，对 isDone() 的后续调用将始终返回 true。如果此方法返回 true，则对 isCancelled() 的后续调用将始终返回 true。 </p>
<p>问题：<br>1.正常执行过程中，在mFuture中的set(result)方法吗？到底做了什么事情呢？感觉像是将task和对应的future标记为已经执行了的。</p>
<p>2.mfuture 内部涉及的原理？</p>
<p>参考：<br><a href="http://blog.csdn.net/liuhe688/article/category/790276">http://blog.csdn.net/liuhe688/article/category/790276</a><br><a href="http://blog.csdn.net/jiangwei0910410003/article/details/40113055">http://blog.csdn.net/jiangwei0910410003/article/details/40113055</a></p>
<p>​    </p>
]]></content>
      <categories>
        <category>Android</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>base_09_RecyclerView</title>
    <url>/2021/02/24/Notes/Android/01%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6/base_09_RecyclerView/</url>
    <content><![CDATA[<h1 id="base-09-RecyclerView"><a href="#base-09-RecyclerView" class="headerlink" title="base_09_RecyclerView"></a>base_09_RecyclerView</h1><span id="more"></span>

<p>RecyclerView 作为增强版的ListView，RecycleView可以实现listView 和GridView的所有功能。本文主要讲解RecyclerView一些基本用法。</p>
<p>##一、基本用法<br>  1.导入依赖，app build.gradle 文件中导入依赖</p>
<pre><code>compile &#39;com.android.support:recyclerview-v7:25.3.1&#39;
</code></pre>
<p>  2.布局文件 item文件和上面的ListView相同</p>
<pre><code>  &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
  &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
      android:layout_width=&quot;match_parent&quot;
      android:layout_height=&quot;match_parent&quot;&gt;
      &lt;android.support.v7.widget.RecyclerView
          android:id=&quot;@+id/recycler_view&quot;
          android:layout_width=&quot;match_parent&quot;
          android:layout_height=&quot;match_parent&quot;/&gt;
  &lt;/LinearLayout&gt;
</code></pre>
<p>  3.适配器<br>    1.继承RecyclerView.Adapter<br>    2.创建adapter的内部类ViewHolder继承RecyclerView.ViewHolder<br>    3.复写onCreateViewHolder和onBindViewHolder<br>         onCreateViewHolder 创建viewHolder实例<br>         onBindViewHolder 滑动时到屏幕里时绑定viewHolder的数据  </p>
<pre><code>public class RecyclerAdapter extends RecyclerView.Adapter&lt;RecyclerAdapter.ViewHolder&gt; &#123;
    private static final String TAG = &quot;RecyclerAdapter&quot;;
    private List&lt;FruitBean&gt; mFruitBeanList;
    private Context mContext;
    private RecyclerItemClickListener mItemListener;
    private boolean isLoadImage = true;

    public RecyclerAdapter(List&lt;FruitBean&gt; fruitBeanList, Context context) &#123;
        this.mFruitBeanList = fruitBeanList;
        this.mContext = context;
    &#125;

    public void setLoadImage(boolean loadImage) &#123;
        isLoadImage = loadImage;
    &#125;

    public void setItemListener(RecyclerItemClickListener itemListener) &#123;
        this.mItemListener = itemListener;
    &#125;

    @Override
    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123;
//        Log.i(TAG, &quot;onCreateViewHolder: &quot;);
        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.fruit_item, parent, false);
        return new ViewHolder(view);
    &#125;

    @Override
    public void onBindViewHolder(final ViewHolder holder, final int position) &#123;
//        Log.i(TAG, &quot;onBindViewHolder: &quot;);
        FruitBean fruitBean = mFruitBeanList.get(position);
        Log.i(TAG, &quot;onBindViewHolder: &quot; + isLoadImage);
        if (isLoadImage) &#123;
            Glide.with(mContext).load(fruitBean.getUrl()).into(holder.iv_pic);
        &#125;
        holder.tv_id.setText(fruitBean.getId());
        holder.tv_name.setText(fruitBean.getName());
        holder.bt_download.setText(&quot;recycler&quot;);
    &#125;

    @Override
    public int getItemCount() &#123;
        return mFruitBeanList.size();
    &#125;

    static class ViewHolder extends RecyclerView.ViewHolder &#123;

        ImageView iv_pic;
        TextView tv_id;
        TextView tv_name;
        Button bt_download;

        public ViewHolder(View itemView) &#123;
            super(itemView);
            iv_pic = (ImageView) itemView.findViewById(R.id.iv_pic);
            tv_id = (TextView) itemView.findViewById(R.id.tv_id);
            tv_name = (TextView) itemView.findViewById(R.id.tv_name);
            bt_download = (Button) itemView.findViewById(R.id.bt_download);
        &#125;
    &#125;
&#125;
</code></pre>
<p>  4.调用显示</p>
<pre><code>public class RecyclerActivity extends AppCompatActivity &#123;

    private static final String TAG = &quot;RecyclerActivity&quot;;

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_recycler);
        RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view);
        LinearLayoutManager layoutManager = new LinearLayoutManager(this);
        recyclerView.setLayoutManager(layoutManager);
        final RecyclerAdapter adapter = new RecyclerAdapter(Utils.initData(), this);
        recyclerView.setAdapter(adapter);
    &#125;
&#125;
</code></pre>
<p>##二、为itemView添加事件监听</p>
<h3 id="1-在viewHolder-itemview-setonClickListener添加回调"><a href="#1-在viewHolder-itemview-setonClickListener添加回调" class="headerlink" title="1.在viewHolder.itemview setonClickListener添加回调"></a>1.在viewHolder.itemview setonClickListener添加回调</h3><p>###(1)添加一个监听的接口，可以添加到Adapter中</p>
<pre><code>public interface RecyclerItemClickListener &#123;
    void onItemClickListener(View view, int position);
    void onItemLongClickListener(View view, int position);
&#125;
</code></pre>
<p>###(2)在onBindViewHolder 方法中，为viewHolder.itemview添加监听时，调用自定义的方法</p>
<pre><code>public void onBindViewHolder(final ViewHolder holder, final int position) &#123;
    ...
    if (mItemListener != null) &#123;
        Log.i(TAG, &quot;onBindViewHolder: here&quot;);
        holder.itemView.setOnClickListener(new View.OnClickListener() &#123;
            @Override
            public void onClick(View v) &#123;
                mItemListener.onItemClickListener(holder.itemView, position);
            &#125;
        &#125;);
        holder.itemView.setOnLongClickListener(new View.OnLongClickListener() &#123;
            @Override
            public boolean onLongClick(View v) &#123;
                mItemListener.onItemLongClickListener(holder.itemView, position);
                return true;
            &#125;
        &#125;);
    &#125;
&#125;
</code></pre>
<h3 id="3-Adapter中添加一个对接口的引用，并且在调用时传入接口的方法"><a href="#3-Adapter中添加一个对接口的引用，并且在调用时传入接口的方法" class="headerlink" title="(3)Adapter中添加一个对接口的引用，并且在调用时传入接口的方法"></a>(3)Adapter中添加一个对接口的引用，并且在调用时传入接口的方法</h3><pre><code>adapter.setItemListener(new RecyclerAdapter.RecyclerItemClickListener() &#123;
  @Override
  public void onItemClickListener(View view, int position) &#123;
      Log.i(TAG, &quot;onItemClickListener: RecyclerItemClickListener&quot;);
  &#125;
  
  @Override
  public void onItemLongClickListener(View view, int position) &#123;
      Log.i(TAG, &quot;onItemLongClickListener: RecyclerItemClickListener&quot;);
  &#125;
&#125;);
</code></pre>
<p>这样就可以在传入时控制接口的操作。</p>
<h3 id="2-采用官方提供的addOnItemTouchListener"><a href="#2-采用官方提供的addOnItemTouchListener" class="headerlink" title="2.采用官方提供的addOnItemTouchListener"></a>2.采用官方提供的addOnItemTouchListener</h3><p>这种方式涉及到3个类：RecyclerView.OnItemTouchListener，GestureDetector（GestureDetectorCompat兼容），SimpleOnGestureListener，通过一个手势探测器 GestureDetectorCompat来探测屏幕事件，然后通过手势监听器SimpleOnGestureListener来识别手势事件的种类，然后调用我们设置的对应的回调方法。这里值得说的是：当获取到了RecyclerView的点击事件和触摸事件数据MotionEvent，那么如何才能知道点击的是哪一个item呢？RecyclerView已经为我们提供了这样的方法：在onInterceptTouchEvent中通过findChildViewUnder()获取对应的view。我们可以通过这个方法获得点击的 item ，同时我们调用 RecyclerView的另一个方法getChildViewHolder()，可以获得该item的ViewHolder，最后再回调我们定义的虚方法 onItemClick() 就ok了，这样我们就可以在外部实现该方法来获得 item 的点击事件了。</p>
<pre><code>public abstract class RecyclerTouchListener implements RecyclerView.OnItemTouchListener&#123;
    private View childView;
    private RecyclerView touchView;
    private GestureDetector mGestureDetector;

    public RecyclerTouchListener(Context context)&#123;
        mGestureDetector = new GestureDetector(context, new InternalGestureListener());
    &#125;

    @Override
    public boolean onInterceptTouchEvent(RecyclerView rv, MotionEvent e) &#123;
        childView = rv.findChildViewUnder(e.getX(), e.getY());
        touchView = rv;
        mGestureDetector.onTouchEvent(e);
        return false;
    &#125;

    @Override
    public void onTouchEvent(RecyclerView rv, MotionEvent e) &#123;

    &#125;

    @Override
    public void onRequestDisallowInterceptTouchEvent(boolean disallowIntercept) &#123;

    &#125;

    public abstract void onItemClickListener(RecyclerView.ViewHolder viewHolder);
    public abstract void onItemLongClickListener(RecyclerView.ViewHolder viewHolder);

    class InternalGestureListener extends GestureDetector.SimpleOnGestureListener&#123;
        @Override
        public boolean onSingleTapUp(MotionEvent e) &#123;
            if (childView != null) &#123;
                onItemClickListener(touchView.getChildViewHolder(childView));
            &#125;
            return true;
        &#125;

        @Override
        public void onLongPress(MotionEvent e) &#123;
            if (childView != null) &#123;
                onItemLongClickListener(touchView.getChildViewHolder(childView));
            &#125;
        &#125;
    &#125;
&#125;   
</code></pre>
<p>调用</p>
<pre><code>recyclerView.addOnItemTouchListener(new RecyclerTouchListener(this) &#123;
     @Override
     public void onItemClickListener(RecyclerView.ViewHolder viewHolder) &#123;
         Log.i(TAG, &quot;addOnItemTouchListener: onItemClickListener&quot;);
     &#125;
     @Override
     public void onItemLongClickListener(RecyclerView.ViewHolder viewHolder) &#123;
         Log.i(TAG, &quot;addOnItemTouchListener: onItemLongClickListener&quot;);
     &#125;
 &#125;);
</code></pre>
<p>第一种相对第二种来说，更加简便，实现起来也方便，也比较好理解。第二种还能用于更加复杂的手势监听，我们可以利用 GestureDetector 类来实现更加复杂的事件监听回调，而第一种监听的事件比较有限。</p>
<h2 id="三、拖曳排序和滑动删除"><a href="#三、拖曳排序和滑动删除" class="headerlink" title="三、拖曳排序和滑动删除"></a>三、拖曳排序和滑动删除</h2><p>主要涉及到2个类：ItemTouchHelper 和 ItemTouchHelper.Callback<br>1.自定义一个接口ItemTouchHelperAdapter用来操作Adapter中的数据</p>
<pre><code>public interface ItemTouchHelperAdapter &#123;
    //数据交换
    void onItemMove(int fromPosition,int toPosition);
    //数据删除
    void onItemDismiss(int position);
&#125;
</code></pre>
<p>2.adapter 实现该接口ItemTouchHelperAdapter，用于处理数据</p>
<pre><code>@Override
public void onItemMove(int fromPosition, int toPosition) &#123;
    //交换位置
    Collections.swap(mFruitBeanList,fromPosition,toPosition);
    notifyItemMoved(fromPosition,toPosition);
&#125;

@Override
public void onItemDismiss(int position) &#123;
    mFruitBeanList.remove(position);
    notifyItemRemoved(position);
&#125;
</code></pre>
<p>3.构建需要的ItemTouchHelper.Callback</p>
<pre><code>public class SimpleItemTouchHelperCallback extends ItemTouchHelper.Callback&#123;
    private ItemTouchHelperAdapter mAdapter;

    public SimpleItemTouchHelperCallback(ItemTouchHelperAdapter adapter)&#123;
        this.mAdapter = adapter;
    &#125;

    @Override
    public int getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) &#123;
        int dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN;
        int swipeFlags = ItemTouchHelper.LEFT;
        return makeMovementFlags(dragFlags,swipeFlags);
    &#125;

    @Override
    public boolean isLongPressDragEnabled() &#123;
        return true;
    &#125;

    @Override
    public boolean isItemViewSwipeEnabled() &#123;
        return true;
    &#125;

    @Override
    public boolean onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target) &#123;
        mAdapter.onItemMove(viewHolder.getAdapterPosition(),target.getAdapterPosition());
        return true;
    &#125;

    @Override
    public void onSwiped(RecyclerView.ViewHolder viewHolder, int direction) &#123;
        mAdapter.onItemDismiss(viewHolder.getAdapterPosition());
    &#125;
&#125;
</code></pre>
<p>4.调用</p>
<pre><code>//先实例化Callback
 ItemTouchHelper.Callback callback = new SimpleItemTouchHelperCallback(adapter);
 //用Callback构造ItemtouchHelper
 ItemTouchHelper touchHelper = new ItemTouchHelper(callback);
 //调用ItemTouchHelper的attachToRecyclerView方法建立联系
 touchHelper.attachToRecyclerView(recyclerView);
</code></pre>
<h2 id="四、网格布局和瀑布流"><a href="#四、网格布局和瀑布流" class="headerlink" title="四、网格布局和瀑布流"></a>四、网格布局和瀑布流</h2><pre><code>GridLayoutManager gridLayoutManager = new GridLayoutManager(this,3);
StaggeredGridLayoutManager layoutManager = new StaggeredGridLayoutManager(3, StaggeredGridLayoutManager.VERTICAL);
</code></pre>
<p>More：<br>1.分割线addItemDecoration<br>2.删除添加的动画 ItemAnimator<br>3.HeaderView 和 FooterView<br><a href="http://blog.csdn.net/lmj623565791/article/details/51854533">http://blog.csdn.net/lmj623565791/article/details/51854533</a></p>
<p>参考资料：<br><a href="http://www.jianshu.com/p/70788a7a5547">http://www.jianshu.com/p/70788a7a5547</a><br><a href="http://blog.csdn.net/lmj623565791/article/details/45059587">http://blog.csdn.net/lmj623565791/article/details/45059587</a><br><a href="http://blog.csdn.net/lmj623565791/article/details/51854533">http://blog.csdn.net/lmj623565791/article/details/51854533</a></p>
<p>Demo：<a href="https://github.com/zhaoxiaowen-sven/VariousViews.git">https://github.com/zhaoxiaowen-sven/VariousViews.git</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>base_10_WebView</title>
    <url>/2021/02/24/Notes/Android/01%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6/base_10_ViewPager/</url>
    <content><![CDATA[<h1 id="base-10-WebView"><a href="#base-10-WebView" class="headerlink" title="base_10_WebView"></a>base_10_WebView</h1><span id="more"></span>

<p>WebView是一个基于webkit引擎、展现web页面的控件。主要用于显示和渲染Web页面，直接使用html文件（网络上或本地assets中）作布局，可和JavaScript交互调用。</p>
<h2 id="一、webView的一些方法"><a href="#一、webView的一些方法" class="headerlink" title="一、webView的一些方法"></a>一、webView的一些方法</h2><h2 id="1-1-加载url"><a href="#1-1-加载url" class="headerlink" title="1.1 加载url"></a>1.1 加载url</h2><p>加载方式根据资源分为三种</p>
<pre><code>//1. 加载一个网页：
webView.loadUrl(&quot;http://www.baidu.com&quot;);

//2：加载apk包中的html页面
webView.loadUrl(&quot;file:///android_asset/test.html&quot;);

//3：加载手机本地的html页面
webView.loadUrl(&quot;content://com.android.htmlfileprovider/sdcard/test.html&quot;);
</code></pre>
<h2 id="1-2-WebView的状态"><a href="#1-2-WebView的状态" class="headerlink" title="1.2 WebView的状态"></a>1.2 WebView的状态</h2><pre><code>//激活WebView为活跃状态，能正常执行网页的响应
webView.onResume() ；

//当页面被失去焦点被切换到后台不可见状态，需要执行onPause
//通过onPause动作通知内核暂停所有的动作，比如DOM的解析、plugin的执行、JavaScript执行。
webView.onPause()；

//当应用程序(存在webview)被切换到后台时，这个方法不仅仅针对当前的webview而是全局的全应用程序的webview
//它会暂停所有webview的layout，parsing，javascripttimer。降低CPU功耗。
webView.pauseTimers()
//恢复pauseTimers状态
webView.resumeTimers()；

//销毁Webview
//在关闭了Activity时，如果Webview的音乐或视频，还在播放。就必须销毁Webview
//但是注意：webview调用destory时,webview仍绑定在Activity上
//这是由于自定义webview构建时传入了该Activity的context对象
//因此需要先从父容器中移除webview,然后再销毁webview:
rootLayout.removeView(webView); 
webView.destroy();
</code></pre>
<h2 id="1-3-前进后退"><a href="#1-3-前进后退" class="headerlink" title="1.3 前进后退"></a>1.3 前进后退</h2><pre><code>Webview.canGoBack() 
Webview.canGoForward()

Webview.goBack()
Webview.goForward()
Webview.goBackOrForward(intsteps)
</code></pre>
<h2 id="1-4-清除缓存："><a href="#1-4-清除缓存：" class="headerlink" title="1.4 清除缓存："></a>1.4 清除缓存：</h2><pre><code>//清除网页访问留下的缓存
//由于内核缓存是全局的因此这个方法不仅仅针对webview而是针对整个应用程序.
Webview.clearCache(true);

//清除当前webview访问的历史记录
//只会webview访问历史记录里的所有记录除了当前访问记录
Webview.clearHistory()；

//这个api仅仅清除自动完成填充的表单数据，并不会清除WebView存储到本地的数据
Webview.clearFormData()；
</code></pre>
<h2 id="二、WebSettings"><a href="#二、WebSettings" class="headerlink" title="二、WebSettings"></a>二、WebSettings</h2><pre><code>WebSettings webSettings = webView.getSettings();
</code></pre>
<h3 id="2-1-自适应屏幕"><a href="#2-1-自适应屏幕" class="headerlink" title="2.1 自适应屏幕"></a>2.1 自适应屏幕</h3><pre><code>webSettings.setUseWideViewPort(true);
webSettings.setLoadWithOverviewMode(true);
</code></pre>
<h3 id="2-2-缩放"><a href="#2-2-缩放" class="headerlink" title="2.2 缩放"></a>2.2 缩放</h3><pre><code>webSettings.setSupportZoom(true);
webSettings.setBuiltInZoomControls(true);
webSettings.setDisplayZoomControls(false);
</code></pre>
<h3 id="2-3-缓存"><a href="#2-3-缓存" class="headerlink" title="2.3 缓存"></a>2.3 缓存</h3><pre><code>webSettings.setCacheMode(WebSettings.LOAD_DEFAULT);
webSettings.setAppCachePath(getFilesDir().getAbsolutePath()+&quot;mywebs&quot;);
</code></pre>
<h3 id="2-4-缓存设置"><a href="#2-4-缓存设置" class="headerlink" title="2.4 缓存设置"></a>2.4 缓存设置</h3><pre><code>LOAD_CACHE_ONLY: 不使用网络，只读取本地缓存数据
LOAD_DEFAULT: （默认）根据cache-control决定是否从网络上取数据。
LOAD_NO_CACHE: 不使用缓存，只从网络获取数据.
LOAD_CACHE_ELSE_NETWORK，只要本地有，无论是否过期，或者no-cache，都使用缓存中的数据。
</code></pre>
<h3 id="2-5-其他"><a href="#2-5-其他" class="headerlink" title="2.5 其他"></a>2.5 其他</h3><pre><code>webSettings.setAllowFileAccess(true);
webSettings.setLoadsImagesAutomatically(true);
webSettings.setDefaultTextEncodingName(&quot;utf-8&quot;);
webSettings.setJavaScriptCanOpenWindowsAutomatically(true);
</code></pre>
<h2 id="三、WebViewClient"><a href="#三、WebViewClient" class="headerlink" title="三、WebViewClient"></a>三、WebViewClient</h2><p>用于处理各种通知 &amp; 请求事件<br>shouldOverrideUrlLoading()<br>onPageStarted()<br>onPageFinished()<br>onLoadResource()<br>onReceivedError()<br>onReceivedSslError()</p>
<h2 id="四、WebChromeClient"><a href="#四、WebChromeClient" class="headerlink" title="四、WebChromeClient"></a>四、WebChromeClient</h2><p>辅助 WebView 处理 Javascript 的对话框,网站图标,网站标题等等。<br>onProgressChanged()<br>onReceivedTitle()<br>onJsAlert()<br>onJsConfirm()<br>onJsPrompt()</p>
<h2 id="五、JS交互"><a href="#五、JS交互" class="headerlink" title="五、JS交互"></a>五、JS交互</h2><h3 id="1-Android-调用Js"><a href="#1-Android-调用Js" class="headerlink" title="1.Android 调用Js"></a>1.Android 调用Js</h3><p>对于Android调用JS代码的方法有2种：<br>1.1 通过WebView的loadUrl()<br>1.2 通过WebView的evaluateJavascript(), 使用时需进行版本判断(&gt;=Android 4.4) </p>
<pre><code>//需要先加载网页
webView.loadUrl(&quot;file:///android_asset/javascript1.html&quot;);
...
if (version &lt; 18) &#123;
    mWebView.loadUrl(&quot;javascript:callJS()&quot;);
&#125; else &#123;
    mWebView.evaluateJavascript（&quot;javascript:callJS()&quot;, new ValueCallback&lt;String&gt;() &#123;
        @Override
        public void onReceiveValue(String value) &#123;
            //此处为 js 返回的结果
        &#125;
    &#125;);
&#125;
</code></pre>
<p><img src="https://leanote.com/api/file/getImage?fileId=59e0e569ab64412997001f6e" alt="pic1"></p>
<p>特别注意：JS代码调用一定要在 onPageFinished（） 回调之后才能调用，否则不会调用</p>
<h3 id="2-Js-调用Android"><a href="#2-Js-调用Android" class="headerlink" title="2.Js 调用Android"></a>2.Js 调用Android</h3><p>2.1 通过WebView的addJavascriptInterface()进行对象映射</p>
<p>2.2 在Android通过WebViewClient复写shouldOverrideUrlLoading()</p>
<p>2.3 通过 WebChromeClient 的onJsAlert()、onJsConfirm()、onJsPrompt（）方法回调拦截JS对话框alert()、confirm()、prompt() 消息</p>
<p><img src="https://leanote.com/api/file/getImage?fileId=59e0e86eab64412997001fb1" alt="pic2"></p>
<h2 id="六、内存泄漏"><a href="#六、内存泄漏" class="headerlink" title="六、内存泄漏"></a>六、内存泄漏</h2><p>参考：<br><a href="http://www.jianshu.com/p/3c94ae673e2a">http://www.jianshu.com/p/3c94ae673e2a</a><br><a href="http://www.jianshu.com/p/345f4d8a5cfa">http://www.jianshu.com/p/345f4d8a5cfa</a><br><a href="http://www.jianshu.com/p/3a345d27cd42">http://www.jianshu.com/p/3a345d27cd42</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>base_08_ListView</title>
    <url>/2021/02/24/Notes/Android/01%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6/base_08_ListView/</url>
    <content><![CDATA[<h1 id="base-08-ListView"><a href="#base-08-ListView" class="headerlink" title="base_08_ListView"></a>base_08_ListView</h1><span id="more"></span>

<p>ListView作为android 中最常用的控件之一，几乎所有的应用程序都会用到它。ListView的使用关键又在于Adapter的使用，常见的adapter有以下几种：ArrayAdapter，SimpleAdapter，SimpleCursorAdapterListView以及BaseAdapter。虽然BaseAdapter使用起来有些复杂，但是开发中使用最多的还是它。本文主要介绍下BaseAdapter的用法及优化，加载图片时用到了Glide库，完全是为了方便不用太多关心。<br>##一、基本用法<br>   1.定义布局文件</p>
<p>   (1)activity的布局 activity_list.xml</p>
<pre><code>   &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
   &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
       xmlns:tools=&quot;http://schemas.android.com/tools&quot;
       android:layout_width=&quot;match_parent&quot;
       android:layout_height=&quot;match_parent&quot;
       tools:context=&quot;com.sven.variousviews.activities.ListActivity&quot;&gt;
   
       &lt;ListView
           android:id=&quot;@+id/list_view&quot;
           android:layout_width=&quot;match_parent&quot;
           android:layout_height=&quot;match_parent&quot; /&gt;
   
   &lt;/LinearLayout&gt;
</code></pre>
<p>   (2)item的布局 fruit_item.xml</p>
<pre><code>   &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
   &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
       android:layout_width=&quot;match_parent&quot;
       android:layout_height=&quot;wrap_content&quot;
       android:layout_gravity=&quot;center_vertical&quot;
       android:descendantFocusability=&quot;blocksDescendants&quot;
       android:orientation=&quot;horizontal&quot;&gt;
   
       &lt;ImageView  
           android:id=&quot;@+id/iv_pic&quot;
           android:layout_width=&quot;100dp&quot;
           android:layout_height=&quot;80dp&quot;
           android:layout_marginStart=&quot;10dp&quot; /&gt;
   
       &lt;RelativeLayout
           android:layout_width=&quot;0dp&quot;
           android:layout_height=&quot;80dp&quot;
           android:layout_marginStart=&quot;10dp&quot;
           android:layout_weight=&quot;1&quot;&gt;
   
           &lt;TextView
               android:id=&quot;@+id/tv_id&quot;
               android:layout_width=&quot;match_parent&quot;
               android:layout_height=&quot;50dp&quot;
               android:layout_alignParentStart=&quot;true&quot;
               android:layout_alignParentTop=&quot;true&quot;
               android:gravity=&quot;center_vertical&quot; /&gt;
   
           &lt;TextView
               android:id=&quot;@+id/tv_name&quot;
               android:layout_width=&quot;match_parent&quot;
               android:layout_height=&quot;30dp&quot;
               android:layout_alignParentBottom=&quot;true&quot;
               android:layout_alignStart=&quot;@+id/tv_id&quot;
               android:gravity=&quot;center_vertical&quot; /&gt;
       &lt;/RelativeLayout&gt;
   
       &lt;Button
           android:id=&quot;@+id/bt_download&quot;
           android:layout_width=&quot;100dp&quot;
           android:layout_height=&quot;60dp&quot;
           android:layout_gravity=&quot;center_vertical&quot;
           android:layout_marginEnd=&quot;10dp&quot;
           android:layout_marginStart=&quot;10dp&quot;
           style=&quot;@style/bt_style&quot;
           /&gt;
   &lt;/LinearLayout&gt;
</code></pre>
<p>   2.创建适配器</p>
<pre><code>public class ListAdapter extends BaseAdapter &#123;
 
     private static final String TAG = &quot;ListAdapter&quot;;
     private Context mContext;
     private List&lt;FruitBean&gt; mFruitBeanList;
 
     public ListAdapter(Context context, List&lt;FruitBean&gt; list) &#123;
         this.mContext = context;
         this.mFruitBeanList = list;
     &#125;
 
     @Override
     public void notifyDataSetChanged() &#123;
         super.notifyDataSetChanged();
     &#125;
 
     @Override
     public int getCount() &#123;
         return mFruitBeanList.size();
     &#125;
 
     @Override
     public Object getItem(int position) &#123;
         return mFruitBeanList.get(position);
     &#125;
 
     @Override
     public long getItemId(int position) &#123;
         return position;
     &#125;
 
     @Override
     public View getView(final int position, View convertView, ViewGroup parent) &#123;
 
         ViewHolder viewHolder;
         if (convertView == null) &#123;
             convertView = View.inflate(mContext, R.layout.fruit_item, null);
             viewHolder = new ViewHolder();
             viewHolder.tv_id = (TextView) convertView.findViewById(R.id.tv_id);
             viewHolder.tv_name = (TextView) convertView.findViewById(R.id.tv_name);
             viewHolder.iv_pic = (ImageView) convertView.findViewById(R.id.iv_pic);
             viewHolder.bt_download = (Button) convertView.findViewById(R.id.bt_download);
             convertView.setTag(viewHolder);
         &#125;else&#123;
             viewHolder = (ViewHolder) convertView.getTag();
         &#125;
 
         final FruitBean fruitBean = mFruitBeanList.get(position);
         if (fruitBean != null) &#123;
             Glide.with(mContext).load(fruitBean.getUrl()).into(viewHolder.iv_pic);
             viewHolder.tv_id.setText(fruitBean.getId());
             viewHolder.tv_name.setText(fruitBean.getName());
             viewHolder.bt_download.setText(&quot;delete&quot;);
             convertView.setOnClickListener(new View.OnClickListener() &#123;
                 @Override
                 public void onClick(View v) &#123;
                     Log.i(TAG, &quot;onClick: convertView clicked&quot;);
                 &#125;
             &#125;);
             
             viewHolder.bt_download.setOnClickListener(new View.OnClickListener() &#123;
                 @Override
                 public void onClick(View v) &#123;
                     Log.i(TAG, &quot;onClick: bt_download&quot;);
 //                    Toast.makeText(mContext, &quot;onclick bt_down&quot;, Toast.LENGTH_SHORT).show();
                     mFruitBeanList.remove(position);
 //                    mFruitBeanList.add(fruitBean);
                     notifyDataSetChanged();
                 &#125;
             &#125;);
 
             viewHolder.tv_name.setOnClickListener(new View.OnClickListener() &#123;
                 @Override
                 public void onClick(View v) &#123;
                     Toast.makeText(mContext, &quot;onclick tv_name &quot; + fruitBean.getId(), Toast.LENGTH_SHORT).show();
                 &#125;
             &#125;);
         &#125;
         return convertView;
     &#125;
 
     static class ViewHolder &#123;
         public ImageView iv_pic;
         public TextView tv_id;
         public TextView tv_name;
         public Button bt_download;
     &#125;
 &#125;
</code></pre>
<p>   3.调用</p>
<pre><code>public class ListActivity extends AppCompatActivity &#123;

    private static final String TAG = &quot;ListActivity2&quot;;
    private ListView listView;
</code></pre>
<p>​<br>​        @Override<br>​        protected void onCreate(Bundle savedInstanceState) {<br>​            super.onCreate(savedInstanceState);<br>​            setContentView(R.layout.activity_list);<br>​<br>​            listView = (ListView) findViewById(R.id.list_view);<br>​            ListAdapter adapter = new ListAdapter(ListActivity.this, Utils.initData());<br>​    //        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {<br>​    //            @Override<br>​    //            public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) {<br>​    //                Log.i(TAG, “onItemClick: “ + position);<br>​    //                Toast.makeText(ListActivity.this, “onItemClick: “ + position, Toast.LENGTH_SHORT).show();<br>​    //            }<br>​    //        });<br>​            listView.setAdapter(adapter);<br>​        }</p>
<p>##二、优化<br>对ListView进行优化一般有2种方式<br>1.convertView：<br>通过缓存convertView,这种利用缓存contentView的方式可以判断如果缓存中不存在View才创建View，如果已经存在可以利用缓存中的View，提升性能。</p>
<p>2.viewHolder：<br>通过convertView+ViewHolder来实现，ViewHolder就是一个静态类，使用ViewHolder的关键好处是缓存了显示数据的视图（View），加快了 UI 的响应速度。当我们判断 convertView == null  的时候，如果为空，就会根据设计好的List的Item布局（XML），来为convertView赋值，并生成一个viewHolder来绑定convertView里面的各个View控件（XML布局里面的那些控件）。再用convertView的setTag将viewHolder设置到Tag中，以便系统第二次绘制ListView时从Tag中取出。</p>
<p>##三、事件监听<br>为ListView的条目设置监听有2种方式：<br>1.通过listView.setOnItemClickListener，注意这种方式可能会出现点击事件冲突的情况，比如你的item里包含Button，解决方法有三种：<br>    (1)将ListView中的Item布局中的子控件focusable属性设置为false<br>    (2)在getView方法中设置button.setFocusable(false)<br>    (3)设置item的根布局的属性Android:descendantFocusability=”blocksDescendant”</p>
<p>2.在adapter中为convertView设置监听setOnClickListener</p>
<p>##四、实现多种样式的ListView布局样式<br>    getItemViewType和getViewTypeCount</p>
<p>##五、添加HeaderView 和 FooterView<br>添加header时调用的 addHeaderView方法必须放在listview.setadapter前面，和Android的版本有关，不会再低版本有兼容问题。</p>
<pre><code>headerView = LayoutInflater.from(this).inflate(R.layout.list_header_view, null);
footerView = LayoutInflater.from(this).inflate(R.layout.list_footer_view, null);
headerButton = (Button) headerView.findViewById(R.id.header_bt);
headerButton.setOnClickListener(new View.OnClickListener() &#123;
    @Override
    public void onClick(View v) &#123;
        Log.i(TAG, &quot;onClick: header_bt&quot;);
        Toast.makeText(ListActivity.this, &quot;headerButton clicked&quot; , Toast.LENGTH_SHORT).show();
    &#125;
&#125;);
footerButton = footerView.findViewById(R.id.footer_bt);
footerButton.setOnClickListener(new View.OnClickListener() &#123;
    @Override
    public void onClick(View v) &#123;
        Log.i(TAG, &quot;onClick: footer_bt&quot;);
        Toast.makeText(ListActivity.this, &quot;footerButton clicked&quot;, Toast.LENGTH_SHORT).show();
    &#125;
&#125;);
listView.addHeaderView(headerView, null, false);
listView.addFooterView(footerView);
listView.setAdapter(adapter);
</code></pre>
<p>##六、进阶使用：</p>
<p>1.滑动优化加载图片</p>
<p>2.局部更新</p>
<p>   未完待续，尽请期待！</p>
<p>参考资料：<br>   《第一行代码》 郭霖<br>   <a href="http://blog.csdn.net/zhaokaiqiang1992/article/details/28430607">http://blog.csdn.net/zhaokaiqiang1992/article/details/28430607</a><br>   <a href="http://www.cnblogs.com/RGogoing/p/5872217.html">http://www.cnblogs.com/RGogoing/p/5872217.html</a><br>   <a href="http://892848153.iteye.com/blog/1923680">http://892848153.iteye.com/blog/1923680</a><br>Demo：<a href="https://github.com/zhaoxiaowen-sven/VariousViews.git">https://github.com/zhaoxiaowen-sven/VariousViews.git</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>base_11_ViewPager</title>
    <url>/2021/02/24/Notes/Android/01%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6/base_11_ViewPager/</url>
    <content><![CDATA[<h1 id="base-11-ViewPager"><a href="#base-11-ViewPager" class="headerlink" title="base_11_ViewPager"></a>base_11_ViewPager</h1><span id="more"></span>

<p>ViewPager作为广泛使用的控件，本文主要介绍他的各种使用方式。</p>
<h2 id="1-viewPager-基本使用"><a href="#1-viewPager-基本使用" class="headerlink" title="1. viewPager 基本使用"></a>1. viewPager 基本使用</h2><p>   1.导入依赖<br>   2.新建Adapter文件继承自PagerAdapter<br>   3.添加view<br>1.1 布局中加入viewpager</p>
<pre><code>&lt;android.support.v4.view.ViewPager
    android:id=&quot;@+id/vp2&quot;
    android:layout_weight=&quot;1&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;0dp&quot; /&gt;
</code></pre>
<p>1.2 添加view 创建Adapter</p>
<pre><code>class MyPagerAdapter extends PagerAdapter &#123;
    private List&lt;View&gt; mViewList;
    public MyPagerAdapter(List&lt;View&gt; viewList) &#123;
        this.mViewList = viewList;
    &#125;
    @Override
    public int getCount() &#123;
        return mViewList == null ? 0 : mViewList.size();
    &#125;
    @Override
    public boolean isViewFromObject(View view, Object object) &#123;
        return view == object;
    &#125;
    @Override
    public Object instantiateItem(ViewGroup container, int position) &#123;
        container.addView(mViewList.get(position));
        return mViewList.get(position);
    &#125;
    @Override
    public void destroyItem(ViewGroup container, int position, Object object) &#123;
        container.removeView(mViewList.get(position));
    &#125;
&#125;
</code></pre>
<p>1.3 调用</p>
<pre><code>protected void onCreate(Bundle savedInstanceState) &#123;
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_vp2);
    mViewPager = (ViewPager) findViewById(R.id.vp2);
    bindViews();
&#125;
private void bindViews() &#123;
    LayoutInflater layoutInflater = getLayoutInflater();
    view1 = layoutInflater.inflate(R.layout.page1, null);
    view2 = layoutInflater.inflate(R.layout.page2, null);
    view3 = layoutInflater.inflate(R.layout.page3, null);
    List&lt;View&gt; viewList = new ArrayList&lt;&gt;();
    viewList = new ArrayList&lt;&gt;();
    viewList.add(view1);
    viewList.add(view2);
    viewList.add(view3);
&#125;
</code></pre>
<h2 id="2-ViewPager标题栏，PagerTitleStrip和PagerTabStrip"><a href="#2-ViewPager标题栏，PagerTitleStrip和PagerTabStrip" class="headerlink" title="2. ViewPager标题栏，PagerTitleStrip和PagerTabStrip"></a>2. ViewPager标题栏，PagerTitleStrip和PagerTabStrip</h2><p>2.1 将它作为子控件添加在ViewPager中</p>
<pre><code>&lt;android.support.v4.view.ViewPager
    android:id=&quot;@+id/vp2&quot;
    android:layout_weight=&quot;1&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;0dp&quot;&gt;
    &lt;android.support.v4.view.PagerTabStrip
        android:id=&quot;@+id/vp_strip&quot;
        android:layout_gravity=&quot;top&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;&gt;
    &lt;/android.support.v4.view.PagerTabStrip&gt;
&lt;/android.support.v4.view.ViewPager&gt;
</code></pre>
<p>2.2 重写适配器的getPageTitle(int)函数来获取标题</p>
<pre><code>mPagerTabStrip = (PagerTabStrip) findViewById(R.id.vp_strip);

class MyPagerAdapter extends PagerAdapter &#123;
...
    @Override
    public CharSequence getPageTitle(int position) &#123;
        return mTitleList.get(position);
    &#125;
&#125;
</code></pre>
<p>2.3 区别：<br>    1.PagerTabStrip在当前页面下，会有一个下划线条来提示当前页面的Tab是哪个。<br>    2.PagerTabStrip的Tab是可以点击的，当用户点击某一个Tab时，当前页面就会跳转到这个页面，而PagerTitleStrip则没这个功能。   </p>
<h2 id="3-ViewPager-Fragment"><a href="#3-ViewPager-Fragment" class="headerlink" title="3.ViewPager + Fragment"></a>3.ViewPager + Fragment</h2><h3 id="3-1-Fragment的滑动切换"><a href="#3-1-Fragment的滑动切换" class="headerlink" title="3.1 Fragment的滑动切换"></a>3.1 Fragment的滑动切换</h3><pre><code>fragmentList.add(new Fragment1());
fragmentList.add(new Fragment2());
fragmentList.add(new Fragment3());
mViewPager.setAdapter(new FragPagerAdapter(getSupportFragmentManager(), fragmentList));
for (int i = 0; i &lt; titleList.size(); i++)&#123;
    mTabLayout.addTab(mTabLayout.newTab().setText(titleList.get(i)));
&#125;
</code></pre>
<h3 id="3-2-FragmentPagerAdapter-和-FragmentStatePagerAdapter"><a href="#3-2-FragmentPagerAdapter-和-FragmentStatePagerAdapter" class="headerlink" title="3.2 FragmentPagerAdapter 和 FragmentStatePagerAdapter"></a>3.2 FragmentPagerAdapter 和 FragmentStatePagerAdapter</h3><pre><code>class FragPagerAdapter extends FragmentStatePagerAdapter &#123;
    private List&lt;Fragment&gt; mFragmentList;
    public FragPagerAdapter(FragmentManager fm , List&lt;Fragment&gt; fragmentList)&#123;
        super(fm);
        this.mFragmentList = fragmentList;
    &#125;
    @Override
    public Fragment getItem(int position) &#123;
        return mFragmentList.get(position);
    &#125;
    @Override
    public int getCount() &#123;
        return mFragmentList.size();
    &#125;
&#125;
</code></pre>
<p>使用 FragmentPagerAdapter 时，ViewPager 中的所有 Fragment 实例常驻内存，当 Fragment 变得不可见时仅仅是视图结构的销毁，即调用了 onDestroyView 方法。由于 FragmentPagerAdapter 内存消耗较大，所以适合少量静态页面的场景。</p>
<p>使用 FragmentStatePagerAdapter 时，当 Fragment 变得不可见，不仅视图层次销毁，实例也被销毁，即调用了 onDestroyView 和 onDestroy 方法，仅仅保存 Fragment 状态。相比而言， FragmentStatePagerAdapter 内存占用较小，所以适合大量动态页面，比如我们常见的新闻列表类应用。<br><a href="http://yifeng.studio/2016/12/23/android-fragment-and-viewpager-attentions/">http://yifeng.studio/2016/12/23/android-fragment-and-viewpager-attentions/</a></p>
<h2 id="4-ViewPager和Tablayout联动"><a href="#4-ViewPager和Tablayout联动" class="headerlink" title="4. ViewPager和Tablayout联动"></a>4. ViewPager和Tablayout联动</h2><p>viewPager 和 tablayout关联的3种方式：</p>
<h3 id="4-1-addOnTabSelectedListener-addOnPageChangeListener"><a href="#4-1-addOnTabSelectedListener-addOnPageChangeListener" class="headerlink" title="4.1.addOnTabSelectedListener + addOnPageChangeListener"></a>4.1.addOnTabSelectedListener + addOnPageChangeListener</h3><pre><code>mTabLayout.addOnTabSelectedListener(new TabLayout.OnTabSelectedListener() &#123;
        @Override
        public void onTabSelected(TabLayout.Tab tab) &#123;
            mViewPager.setCurrentItem(tab.getPosition());
        &#125;
        @Override
        public void onTabUnselected(TabLayout.Tab tab) &#123;
        &#125;
        @Override
        public void onTabReselected(TabLayout.Tab tab) &#123;
        &#125;
    &#125;);

mViewPager.addOnPageChangeListener(new ViewPager.OnPageChangeListener() &#123;
        @Override
        public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123;
        &#125;
        @Override
        public void onPageSelected(int position) &#123;
            mTabLayout.getTabAt(position).select();
        &#125;
        @Override
        public void onPageScrollStateChanged(int state) &#123;
        &#125;
    &#125;);
</code></pre>
<h3 id="4-2-setupWithViewPager-复写-getPageTitle"><a href="#4-2-setupWithViewPager-复写-getPageTitle" class="headerlink" title="4.2 setupWithViewPager + 复写 getPageTitle"></a>4.2 setupWithViewPager + 复写 getPageTitle</h3><p>通过setupWithViewPager将TabLayout和ViewPager建立关联，会发现之前设置的tab消失了，需要复写VpAdapter的getPageTitle</p>
<pre><code>mTabLayout.setupWithViewPager(mViewPager);
@Override
public CharSequence getPageTitle(int position) &#123;
   return mTitleList.get(position);
&#125;
</code></pre>
<p><a href="https://www.jianshu.com/p/d83f10c1a765">https://www.jianshu.com/p/d83f10c1a765</a></p>
<h3 id="4-3-addOnPageChangeListener-复写addOnTabSelectedListener"><a href="#4-3-addOnPageChangeListener-复写addOnTabSelectedListener" class="headerlink" title="4.3 addOnPageChangeListener + 复写addOnTabSelectedListener"></a>4.3 addOnPageChangeListener + 复写addOnTabSelectedListener</h3><pre><code>mViewPager.addOnPageChangeListener(new TabLayout.TabLayoutOnPageChangeListener(mTabLayout));
mTabLayout.addOnTabSelectedListener(new TabLayout.OnTabSelectedListener() &#123;
    @Override
    public void onTabSelected(TabLayout.Tab tab) &#123;
        mViewPager.setCurrentItem(tab.getPosition());
    &#125;
    @Override
    public void onTabUnselected(TabLayout.Tab tab) &#123;
    &#125;
    @Override
    public void onTabReselected(TabLayout.Tab tab) &#123;
    &#125;
&#125;);
</code></pre>
<h2 id="5-ViewPager-轮播图"><a href="#5-ViewPager-轮播图" class="headerlink" title="5. ViewPager 轮播图"></a>5. ViewPager 轮播图</h2><p>有2种方法：<br>5.1 Integer.MAX_VALUE ???<br>再在初始化时设置当前页面为几千页(如：ViewPager.setCurrentItem(1000*data.size)),其实就是障眼法，大爷心情好的话，向前滑动几千页也不是不可能的;</p>
<p>5.2 滑动到最左或最右时，设置滑动的index 为<br>   1，2，3 -&gt; 3, 1, 2, 3, 1</p>
<pre><code>class MyPagerAdapter extends PagerAdapter &#123;
    private List&lt;View&gt; mViewList;
    public MyPagerAdapter(List&lt;View&gt; viewList) &#123;
        this.mViewList = viewList;
    &#125;
    @Override
    public int getCount() &#123;
        return mViewList == null ? 0 : mViewList.size();
    &#125;
    @Override
    public boolean isViewFromObject(View view, Object object) &#123;
        return view == object;
    &#125;
    @Override
    public Object instantiateItem(ViewGroup container, int position) &#123;
        View view = mViewList.get(position);
        container.addView(view);
        return view;
    &#125;
    @Override
    public void destroyItem(ViewGroup container, int position, Object object) &#123;
        container.removeView(mViewList.get(position));
    &#125;
&#125;
</code></pre>
<p>5.3 自动循环,触摸停止<br>通过handler postdelay实现：<br>    private Runnable autoScrollRunnable = new Runnable() {</p>
<pre><code>    @Override
    public void run() &#123;
        if (!stopAutoScroll) &#123;
            int currentItem = viewPager.getCurrentItem();
            viewPager.setCurrentItem(currentItem + 1, true);
            handler.postDelayed(autoScrollRunnable, 4000);
        &#125;
    &#125;
&#125;;


handler.postDelayed(autoScrollRunnable, 4000);
viewPager.setOnTouchListener(new View.OnTouchListener() &#123;

   @Override
   public boolean onTouch(View v, MotionEvent event) &#123;
       switch (event.getAction()) &#123;
       case MotionEvent.ACTION_DOWN:
           stopAutoScroll = true;
           handler.removeCallbacks(autoScrollRunnable);
           break;

       case MotionEvent.ACTION_UP:
       case MotionEvent.ACTION_CANCEL:
           stopAutoScroll = false;
           handler.postDelayed(autoScrollRunnable, 4000);
           break;
       &#125;
       return false;
   &#125;
&#125;)
</code></pre>
<p>3.自动循环</p>
<p>遇到的问题：<br>java.lang.IllegalStateException: The specified child already has a parent. You must call removeView() on the child’s parent first.<br>解决：<a href="http://blog.csdn.net/qibanxuehua/article/details/47253299">http://blog.csdn.net/qibanxuehua/article/details/47253299</a></p>
<h2 id="6-切换动画"><a href="#6-切换动画" class="headerlink" title="6.切换动画"></a>6.切换动画</h2><p><a href="http://blog.csdn.net/shedoor/article/details/78957852">http://blog.csdn.net/shedoor/article/details/78957852</a><br>Q:<br>The application’s PagerAdapter changed the adapter’s contents without calling PagerAdapter#notifyDataSetChanged!</p>
<p>mTabLayout.setupWithViewPager 和 mViewPager.addOnPageChangeListener</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>Jetpack_02_ViewModel</title>
    <url>/2021/02/24/Notes/Android/03Jetpack/Jetpack_02_ViewModel/</url>
    <content><![CDATA[<h1 id="Jetpack-02-ViewModel"><a href="#Jetpack-02-ViewModel" class="headerlink" title="Jetpack_02_ViewModel"></a>Jetpack_02_ViewModel</h1><span id="more"></span>

<h1 id="一、为什么使用ViewModel"><a href="#一、为什么使用ViewModel" class="headerlink" title="一、为什么使用ViewModel"></a>一、为什么使用ViewModel</h1><p>我们先来看下官方文档中对<code>ViewModel</code>的定义：</p>
<p><a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel"><code>ViewModel</code></a> 类旨在以注重生命周期的方式存储和管理界面相关的数据。<a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel"><code>ViewModel</code></a> 类让数据可在发生屏幕旋转等配置更改后继续留存。 </p>
<p>也就是说viewModel有2个作用：</p>
<ul>
<li><p><strong>存放应用程序页面（<code>Activity</code>和<code>Fragment</code>）所需的数据</strong></p>
<p>将页面所需的数据从页面中剥离出来，页面只需要处理用户交互，以及负责展示数据的工作。可以结合<code>ViewBinding</code>和<code>LivdData</code>对<code>view</code>和 <code>Model</code> 进行<strong>双向绑定</strong>。即<code>view</code>事件绑定到<code>ViewModel</code>，当数据更新时通过<code>LiveData</code> 绑定到<code>ViewModel</code>。</p>
</li>
<li><p><strong>解决资源配置导致的销毁重建问题</strong>。</p>
<p>如果资源配置发生变更，我们需要考虑数据的存储与恢复，若不进行存储，则需要重新获取数据。而<code>ViewModel</code>独立于资源配置变化，即使资源配置变化导致Activity页面重建，也不会影响<code>ViewModel</code>的生命周期。</p>
</li>
</ul>
<h1 id="二、基本使用"><a href="#二、基本使用" class="headerlink" title="二、基本使用"></a>二、基本使用</h1><blockquote>
<p>本文Demo基于<code>Lifecycle 2.4.1</code>版本源码，程序demo基于<code>sdk 31</code></p>
</blockquote>
<p><strong>引入依赖</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="keyword">def</span> lifecycle_version = <span class="string">&quot;2.4.1&quot;</span></span><br><span class="line">    <span class="comment">// ViewModel</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycle_version&quot;</span></span><br><span class="line">    <span class="comment">// LiveData</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.lifecycle:lifecycle-livedata-ktx:$lifecycle_version&quot;</span></span><br><span class="line">    <span class="comment">// Lifecycles only (without ViewModel or LiveData)</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.lifecycle:lifecycle-runtime-ktx:$lifecycle_version&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Saved state module for ViewModel</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.lifecycle:lifecycle-viewmodel-savedstate:$lifecycle_version&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Annotation processor</span></span><br><span class="line">    kapt <span class="string">&quot;androidx.lifecycle:lifecycle-compiler:$lifecycle_version&quot;</span></span><br><span class="line">    <span class="comment">// alternately - if using Java8, use the following instead of lifecycle-compiler</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.lifecycle:lifecycle-common-java8:$lifecycle_version&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-1、简单使用"><a href="#2-1、简单使用" class="headerlink" title="2.1、简单使用"></a>2.1、简单使用</h2><p><code>ViewModel</code>类主要负责为界面准备数据，并在配置更改期间自动保留<code>ViewModel</code>对象。</p>
<p>例如：在<code>ViewModel</code>中获取和存储用户信息</p>
<p>定义一个<code>User</code>数据类</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">var</span> age:<span class="built_in">Int</span>,<span class="keyword">var</span> name:String)</span><br></pre></td></tr></table></figure>

<p>实现<code>ViewModel</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserModel</span>:<span class="type">ViewModel</span></span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> mUserLiveData:MutableLiveData&lt;User&gt; = MutableLiveData()</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化给值</span></span><br><span class="line">        mUserLiveData.postValue(User(<span class="number">1</span>,<span class="string">&quot;name1&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">val</span> user = mUserLiveData.value</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>)&#123;</span><br><span class="line">            user.age = <span class="number">15</span></span><br><span class="line">            user.name = <span class="string">&quot;name15&quot;</span></span><br><span class="line">            mUserLiveData.value = user</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>Activity</code>中使用<code>ViewModel</code>，获取<code>User</code>信息</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewModelActivity</span> : <span class="type">FragmentActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> bt02 : Button</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> bt03 : Button</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_viewmodel)</span><br><span class="line">        bt02 = findViewById(R.id.bt02)</span><br><span class="line">        bt03 = findViewById(R.id.bt03)</span><br><span class="line">        <span class="comment">// viewModel</span></span><br><span class="line">        <span class="keyword">val</span> userModel: UserModel = ViewModelProvider(<span class="keyword">this</span>)[UserModel::<span class="keyword">class</span>.java]</span><br><span class="line">        userModel.mUserLiveData.observe(<span class="keyword">this</span>)&#123;</span><br><span class="line">            bt02.text = it.toString()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bt02.setOnClickListener&#123;</span><br><span class="line">            userModel.doSomething()</span><br><span class="line">            bt03.text = User(<span class="number">99</span>, <span class="string">&quot;zxw&quot;</span>).toString()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点击按钮 <code>Bt02</code>，数据更新为<code>AGE = 15, NAME = 15</code>之后旋转屏幕，<code>Bt02</code>中内容不会变化，<code>Bt03</code> 则还原到初始值。</p>
<img src="/pics/viewmodel.gif" alt="viewmodel" style="zoom:53%;" />

<p><code>viewModel</code>使用注意事项：</p>
<ul>
<li><code>ViewModel</code>绝不能引用外部的<code>Context(View/Fragment/Actvity)</code>或可能存储 <code>Context</code> 的任何类，否则可能会导致内存泄漏，因为<code>ViewModel</code>中有在<code>Activity</code>销毁之后才会自动销毁。</li>
<li><code>ViewModel</code>对象存在的时间比视图或<code>LifecycleOwner</code>的特定实例存在的时间长。如果<code>ViewModel</code>需要<code>Application</code>上下文，可以扩展<code>AndroidViewModel</code>类并设置用于接收<code>Application</code>的构造函数。</li>
<li><a href="https://www.youtube.com/watch?v=5qlIPTDE274&t=30s">ViewModel 不可以替代 onSaveInstanceState。</a></li>
</ul>
<h2 id="2-2、Fragment间通信"><a href="#2-2、Fragment间通信" class="headerlink" title="2.2、Fragment间通信"></a>2.2、Fragment间通信</h2><p><code>Activity</code> 中的两个或更多 <code>Fragment</code> 需要相互通信是一种很常见的现象。<code>Activity</code>和<code>Fragment</code>可以通过共享一个<code>ViewModel</code>解决这一通信问题，因为<code>Fragment</code>是依附在<code>Activity</code>上。</p>
<p>实例化<code>ViewModel</code>时，将该<code>Activity</code>传入<code>ViewModelProvider</code>，会给你一个该Activity创建好的<code>ViewModel</code>。两个 <code>Fragment</code> 可以使用其 <code>Activity</code> 范围共享 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel?hl=zh-cn"><code>ViewModel</code></a> 来处理此类通信。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharedViewModel</span>: <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> selected: MutableLiveData&lt;<span class="built_in">Int</span>&gt; = MutableLiveData(<span class="number">1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        selected.value = selected.value?.plus(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">()</span></span>: LiveData&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> selected</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> bt : Button ?= <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> model: SharedViewModel? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        <span class="comment">//获取依附的Activity的ViewModel</span></span><br><span class="line">        model = activity?.let &#123; ViewModelProvider(it)[SharedViewModel::<span class="keyword">class</span>.java] &#125;</span><br><span class="line">        model?.<span class="keyword">get</span>()?.observe(<span class="keyword">this</span>,&#123;</span><br><span class="line">            <span class="comment">//更新UI</span></span><br><span class="line">            bt?.setText(<span class="string">&quot;新的值是 &quot;</span> + it)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        inflater: <span class="type">LayoutInflater</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        container: <span class="type">ViewGroup</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">        savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: View? &#123;</span><br><span class="line">        <span class="keyword">val</span> view = inflater.inflate(R.layout.fragment_main, container, <span class="literal">false</span>);</span><br><span class="line">        bt = view.findViewById(R.id.main_bt)</span><br><span class="line">        bt?.setOnClickListener &#123;</span><br><span class="line">            model?.add()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetailFragment</span>: <span class="type">Fragment</span></span>()&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> model:SharedViewModel? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> bt : Button ?= <span class="literal">null</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        <span class="comment">//获取依附的Activity的ViewModel</span></span><br><span class="line">        model = activity?.let &#123; ViewModelProvider(it)[SharedViewModel::<span class="keyword">class</span>.java] &#125;</span><br><span class="line">        model?.<span class="keyword">get</span>()?.observe(<span class="keyword">this</span>,&#123;</span><br><span class="line">            <span class="comment">//更新UI</span></span><br><span class="line">            bt?.setText(<span class="string">&quot;新的值是 &quot;</span> + it)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        inflater: <span class="type">LayoutInflater</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        container: <span class="type">ViewGroup</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">        savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: View? &#123;</span><br><span class="line">        <span class="keyword">val</span> view = inflater.inflate(R.layout.fragment_detail, container, <span class="literal">false</span>);</span><br><span class="line">        bt = view.findViewById(R.id.detailButton)</span><br><span class="line">        bt?.setOnClickListener &#123;</span><br><span class="line">            model?.add()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前述<code>MasterFragment</code>和<code>DetailFragment</code>都可以拿到<code>Activity</code>的<code>ViewModel</code>，拿到了该<code>ViewModel</code>就可以拿到里面的数据，相当于间接通过<code>ViewModel</code>通信</p>
<p>通过<code>ViewModel</code>实现Fragment通信的优势：</p>
<ol>
<li><code>Activity</code> 不需要执行任何操作，也不需要对此通信有任何了解。</li>
<li>除了 <code>SharedViewModel</code> 约定之外，<code>Fragment</code> 不需要相互了解</li>
<li>每个 <code>Fragment</code> 都有自己的生命周期，而不受另一个 <code>Fragment</code> 的生命周期的影响。</li>
</ol>
<h1 id="三、原理分析"><a href="#三、原理分析" class="headerlink" title="三、原理分析"></a>三、原理分析</h1><p><strong>先了解一下ViewModel的几个核心角色</strong></p>
<ul>
<li><p><code>ViewModelProvider</code></p>
<p><code>ViewModel</code>的使用工具类，封装了一系列作用方法，用于创建<code>ViewModel</code></p>
</li>
<li><p><code>ViewModelStore</code></p>
<p>存储多个<code>ViewModel</code>的存储类</p>
</li>
<li><p><code>ViewModelStoreOwner</code></p>
<p><code>ViewModel</code>存储器的拥有者，<code>Activity</code>、<code>Fragment</code>都是其实现者</p>
</li>
<li><p><code>ViewModelFactory</code></p>
<p>用于创建ViewModel</p>
</li>
</ul>
<h2 id="3-1、ViewModel构造过程"><a href="#3-1、ViewModel构造过程" class="headerlink" title="3.1、ViewModel构造过程"></a>3.1、<code>ViewModel</code>构造过程</h2><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a1e4f77918f4d9c8163d0aab501e4bf~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" style="zoom:70%;" />

<p>我们先从<code>ViewModelProvider</code>入手</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> userModel: UserModel = ViewModelProvider(<span class="keyword">this</span>)[UserModel::<span class="keyword">class</span>.java]</span><br></pre></td></tr></table></figure>

<h3 id="3-1-1、创建ViewModelProvider"><a href="#3-1-1、创建ViewModelProvider" class="headerlink" title="3.1.1、创建ViewModelProvider"></a>3.1.1、创建ViewModelProvider</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewModelProvider</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> store: ViewModelStore,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> factory: Factory</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">constructor</span>(</span><br><span class="line">      owner: ViewModelStoreOwner </span><br><span class="line">                                 <span class="comment">// 1.获取工厂类</span></span><br><span class="line">  ) : <span class="keyword">this</span>(owner.viewModelStore, defaultFactory(owner))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">defaultFactory</span><span class="params">(owner: <span class="type">ViewModelStoreOwner</span>)</span></span>: Factory =</span><br><span class="line">          <span class="comment">// 2.返回具体的工厂类，有2种类型 HasDefaultViewModelProviderFactory</span></span><br><span class="line">          <span class="comment">// 和 NewInstanceFactory</span></span><br><span class="line">          <span class="comment">// ComponentActivity与Fragment类已经实现了HasDefaultViewModelProviderFactory</span></span><br><span class="line">          <span class="keyword">if</span> (owner <span class="keyword">is</span> HasDefaultViewModelProviderFactory)</span><br><span class="line">              owner.defaultViewModelProviderFactory <span class="keyword">else</span> instance</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><code>ComponentActivity</code>与<code>Fragment</code>类已经实现了<code>ViewModelStoreOwner</code>和<code>HasDefaultViewModelProviderFactory</code>接口。下面我们以<code>ComponentActivity</code>为例，看下Factory 如何构建Factory的。</p>
<h3 id="3-1-2、创建Factory"><a href="#3-1-2、创建Factory" class="headerlink" title="3.1.2、创建Factory"></a>3.1.2、创建Factory</h3><h4 id="1、ComponentActivity-getDefaultViewModelProviderFactory"><a href="#1、ComponentActivity-getDefaultViewModelProviderFactory" class="headerlink" title="1、ComponentActivity#getDefaultViewModelProviderFactory"></a>1、<code>ComponentActivity#getDefaultViewModelProviderFactory</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HasDefaultViewModelProviderFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    ViewModelProvider.<span class="function">Factory <span class="title">getDefaultViewModelProviderFactory</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ViewModelProvider.<span class="function">Factory <span class="title">getDefaultViewModelProviderFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getApplication() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Your activity is not yet attached to the &quot;</span></span><br><span class="line">                + <span class="string">&quot;Application instance. You can&#x27;t request ViewModel before onCreate call.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mDefaultFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 构建 SavedStateViewModelFactory</span></span><br><span class="line">        mDefaultFactory = <span class="keyword">new</span> SavedStateViewModelFactory(</span><br><span class="line">                getApplication(),</span><br><span class="line">                <span class="keyword">this</span>,</span><br><span class="line">                getIntent() != <span class="keyword">null</span> ? getIntent().getExtras() : <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mDefaultFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、SavedStateViewModelFactory"><a href="#2、SavedStateViewModelFactory" class="headerlink" title="2、SavedStateViewModelFactory"></a>2、<code>SavedStateViewModelFactory</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SavedStateViewModelFactory</span><span class="params">(<span class="meta">@Nullable</span> Application application,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@NonNull</span> SavedStateRegistryOwner owner,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Nullable</span> Bundle defaultArgs)</span> </span>&#123;</span><br><span class="line">    mSavedStateRegistry = owner.getSavedStateRegistry();</span><br><span class="line">    mLifecycle = owner.getLifecycle();</span><br><span class="line">    mDefaultArgs = defaultArgs;</span><br><span class="line">    mApplication = application;</span><br><span class="line">    mFactory = application != <span class="keyword">null</span></span><br><span class="line">      				<span class="comment">// 根据Application来判断是通过NewInstanceFactory或AndroidViewModelFactory来创建ViewModel实例</span></span><br><span class="line">            ? ViewModelProvider.AndroidViewModelFactory.getInstance(application)</span><br><span class="line">            : ViewModelProvider.NewInstanceFactory.getInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ComponentActivity</code>中最终也是根据<code>Application</code>来判断是通过<code>NewInstanceFactory</code>或<code>AndroidViewModelFactory</code>来创建<code>ViewModel</code>实例。这2个类都是<code>ViewModelProvider#Factory</code>的子类。</p>
<h4 id="3、ViewModelProvider-Factory"><a href="#3、ViewModelProvider-Factory" class="headerlink" title="3、ViewModelProvider#Factory"></a>3、<code>ViewModelProvider#Factory</code></h4><p><code>ViewModelProvider#Factory</code>只有一个接口，实现类用于构建<code>ViewModel</code>实例</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 构建ViewModel 实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ViewModel&gt;</span> <span class="title">create</span><span class="params">(modelClass: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span>: T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面来看下<code>NewInstanceFactory</code>和<code>AndroidViewModelFactory</code>的具体实现。</p>
<h4 id="4、AndroidViewModelFactory"><a href="#4、AndroidViewModelFactory" class="headerlink" title="4、AndroidViewModelFactory"></a>4、<code>AndroidViewModelFactory</code></h4><p><code>AndroidViewModelFactory</code>专门用来实例化<code>ViewModel</code>中带<code>Context</code>的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> open class <span class="title">AndroidViewModelFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">private</span> val application: Application</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> : <span class="title">NewInstanceFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Suppress(&quot;DocumentExceptions&quot;)</span></span><br><span class="line">    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (AndroidViewModel::class.java.isAssignableFrom(modelClass)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;<span class="comment">//1、通过构造方法向ViewModel 中注入Application，Application是APP全局的,那么不存在内存泄露的问题。							</span></span><br><span class="line">             modelClass.getConstructor(Application::class.java).newInstance(application)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: NoSuchMethodException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;Cannot create an instance of $modelClass&quot;</span>, e)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: IllegalAccessException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;Cannot create an instance of $modelClass&quot;</span>, e)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: InstantiationException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;Cannot create an instance of $modelClass&quot;</span>, e)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: InvocationTargetException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;Cannot create an instance of $modelClass&quot;</span>, e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">super</span>.create(modelClass)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> companion object &#123;</span><br><span class="line">        <span class="function">internal fun <span class="title">defaultFactory</span><span class="params">(owner: ViewModelStoreOwner)</span>: Factory </span>=</span><br><span class="line">            <span class="keyword">if</span> (owner is HasDefaultViewModelProviderFactory)</span><br><span class="line">                owner.defaultViewModelProviderFactory <span class="keyword">else</span> instance</span><br><span class="line"></span><br><span class="line">        internal <span class="keyword">const</span> val DEFAULT_KEY = <span class="string">&quot;androidx.lifecycle.ViewModelProvider.DefaultKey&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> sInstance: AndroidViewModelFactory? = <span class="keyword">null</span></span><br><span class="line"> 				</span><br><span class="line">        <span class="comment">// 单例</span></span><br><span class="line">        <span class="meta">@JvmStatic</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> fun <span class="title">getInstance</span><span class="params">(application: Application)</span>: AndroidViewModelFactory </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                sInstance = AndroidViewModelFactory(application)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sInstance!!</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5、NewInstanceFactory"><a href="#5、NewInstanceFactory" class="headerlink" title="5、NewInstanceFactory"></a>5、<code>NewInstanceFactory</code></h4><p><code>NewInstanceFactory</code>是通过反射来初始化构造函数无参数类型的<code>ViewModel</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> open <span class="class"><span class="keyword">class</span> <span class="title">NewInstanceFactory</span> : <span class="title">Factory</span> </span>&#123;</span><br><span class="line">      <span class="meta">@Suppress(&quot;DocumentExceptions&quot;)</span></span><br><span class="line">      override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 反射构建</span></span><br><span class="line">              modelClass.newInstance()</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e: InstantiationException) &#123;</span><br><span class="line">              <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;Cannot create an instance of $modelClass&quot;</span>, e)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e: IllegalAccessException) &#123;</span><br><span class="line">              <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;Cannot create an instance of $modelClass&quot;</span>, e)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> companion object &#123;</span><br><span class="line">          <span class="keyword">private</span> <span class="keyword">var</span> sInstance: NewInstanceFactory? = <span class="keyword">null</span></span><br><span class="line">          <span class="meta">@JvmStatic</span></span><br><span class="line">          <span class="keyword">public</span> val instance: NewInstanceFactory</span><br><span class="line">              <span class="meta">@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)</span></span><br><span class="line">              get() &#123;</span><br><span class="line">                  <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                      sInstance = NewInstanceFactory()</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">return</span> sInstance!!</span><br><span class="line">              &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-3、ViewModelProvider-get"><a href="#3-1-3、ViewModelProvider-get" class="headerlink" title="3.1.3、ViewModelProvider#get"></a>3.1.3、ViewModelProvider#get</h3><p>回到<code>ViewModel</code>最初的入口<code>ViewModelProvider(this)[UserModel::class.java]</code>。</p>
<p><code>ViewModelProvider(this)</code>获取了<code>Factory</code>实例，接下来要调用<code>get()</code>方法，这个方法需要传入<code>Class</code>对象，<code>ViewModelProvider</code> 需要拿到 <code>Class</code> 才能完成反射操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> open operator fun &lt;T : ViewModel&gt; get(modelClass: Class&lt;T&gt;): T &#123;</span><br><span class="line">    val canonicalName = modelClass.canonicalName</span><br><span class="line">        ?: <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;Local and anonymous classes can not be ViewModels&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> get(<span class="string">&quot;$DEFAULT_KEY:$canonicalName&quot;</span>, modelClass)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> open operator fun &lt;T : ViewModel&gt; get(key: String, modelClass: Class&lt;T&gt;): T &#123;</span><br><span class="line">    <span class="comment">// 1、从 ViewModelStore 里获取</span></span><br><span class="line">    <span class="keyword">var</span> viewModel = store[key]</span><br><span class="line">    <span class="comment">// 2、判断该viewModel对象是否可以转成对应类</span></span><br><span class="line">    <span class="keyword">if</span> (modelClass.isInstance(viewModel)) &#123;</span><br><span class="line">        (factory as? OnRequeryFactory)?.onRequery(viewModel)</span><br><span class="line">        <span class="keyword">return</span> viewModel as T</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="meta">@Suppress(&quot;ControlFlowWithEmptyBody&quot;)</span></span><br><span class="line">        <span class="keyword">if</span> (viewModel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> log a warning.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3、通过Factory 构建</span></span><br><span class="line">    viewModel = <span class="keyword">if</span> (factory is KeyedFactory) &#123;</span><br><span class="line">        factory.create(key, modelClass)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        factory.create(modelClass)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4、put 到store 缓存中</span></span><br><span class="line">    store.put(key, viewModel)</span><br><span class="line">    <span class="keyword">return</span> viewModel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>get</code> 逻辑总结下：</p>
<ul>
<li>通过<code>key</code>从<code>ViewModelStore</code>里取<code>ViewModel</code>实例，</li>
<li>如果取不到或者类型不符，则通过<code>mFactory.create()</code>方法来反射初始化<code>ViewModel</code></li>
<li>初始化结果前将它存到 <code>mViewModelStore</code> 中，从而完成<code>ViewModel</code>的初始化流程</li>
</ul>
<h2 id="3-2、ViewModel保存"><a href="#3-2、ViewModel保存" class="headerlink" title="3.2、ViewModel保存"></a>3.2、ViewModel保存</h2><h3 id="3-2-1、ViewModelStore"><a href="#3-2-1、ViewModelStore" class="headerlink" title="3.2.1、ViewModelStore"></a>3.2.1、ViewModelStore</h3><p><code>ViewModelStore</code>主要是用来存储<code>ViewModel</code>，内部使用的数据结构是<code>HashMap</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewModelStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, ViewModel&gt; mMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, ViewModel viewModel)</span> </span>&#123;</span><br><span class="line">        ViewModel oldViewModel = mMap.put(key, viewModel);</span><br><span class="line">        <span class="keyword">if</span> (oldViewModel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            oldViewModel.onCleared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> ViewModel <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Set&lt;String&gt; <span class="title">keys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HashSet&lt;&gt;(mMap.keySet());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Clears internal storage and notifies ViewModels that they are no longer used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (ViewModel vm : mMap.values()) &#123;</span><br><span class="line">            vm.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        mMap.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Activity</code>和<code>Fragment</code>都实现了<code>ViewModelStoreOwner</code>，用来获取<code>ViewModelStore</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface ViewModelStoreOwner &#123;</span><br><span class="line">    @NonNull</span><br><span class="line">    ViewModelStore getViewModelStore();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里以<code>CompontentActivity</code>为例看下<code>ViewModelStore</code>的获取过程</p>
<p><code>CompontentActivity#getViewModelStore</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ViewModelStore <span class="title">getViewModelStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1、activity还没关联Application，即不能在onCreate之前去获取viewModel</span></span><br><span class="line">    <span class="keyword">if</span>(getApplication() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Your activity is not yet attached to the &quot;</span></span><br><span class="line">                + <span class="string">&quot;Application instance. You can&#x27;t request ViewModel before onCreate call.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    ensureViewModelStore();</span><br><span class="line">    <span class="keyword">return</span> mViewModelStore;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;WeakerAccess&quot;)</span> <span class="comment">/* synthetic access */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ensureViewModelStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2、如果存储器是空，就先尝试恢复最近一次配置变更时保存下来的数据</span></span><br><span class="line">    <span class="keyword">if</span> (mViewModelStore == <span class="keyword">null</span>) &#123;</span><br><span class="line">        NonConfigurationInstances nc =</span><br><span class="line">                (NonConfigurationInstances) getLastNonConfigurationInstance();</span><br><span class="line">        <span class="keyword">if</span> (nc != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Restore the ViewModelStore from NonConfigurationInstances</span></span><br><span class="line">            mViewModelStore = nc.viewModelStore;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.如果lastNonConfigurationInstance不存在，就new一个</span></span><br><span class="line">        <span class="keyword">if</span> (mViewModelStore == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mViewModelStore = <span class="keyword">new</span> ViewModelStore();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getViewModelStore</code>的主要逻辑：</p>
<ol>
<li>如果<code>ViewModelStore</code>为空，先尝试从<code>NonConfigurationInstance</code>从获取 <code>ViewModelStore</code>实例</li>
<li>如果<code>NonConfigurationInstance</code>不存在，就<code>new</code>一个<code>ViewModelStore</code>。</li>
</ol>
<h3 id="3-2-2、NonConfigurationInstances"><a href="#3-2-2、NonConfigurationInstances" class="headerlink" title="3.2.2、NonConfigurationInstances"></a>3.2.2、<code>NonConfigurationInstances</code></h3><p><code>NonConfigurationInstances</code>类是<code>ComponentActivity</code>的一个静态内部类，用来存储<code>viewModelStore</code>，实例不会随着配置改变而消失或改变。</p>
<p><code>ViewModel</code>对象不会随着资源配置变化导致<code>Activity</code>/<code>Fragment</code>的销毁重建而改变，其奥秘就在这里。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonConfigurationInstances</span> </span>&#123;</span><br><span class="line">    Object custom;</span><br><span class="line">    <span class="comment">// viewModel</span></span><br><span class="line">    ViewModelStore viewModelStore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-3、ViewModel保存"><a href="#3-2-3、ViewModel保存" class="headerlink" title="3.2.3、ViewModel保存"></a>3.2.3、ViewModel保存</h3><p>我们看下Activity销毁过程中是如何处理<code>ViewModel</code>的。</p>
<h4 id="1、ActivityThread-performDestroyActivity"><a href="#1、ActivityThread-performDestroyActivity" class="headerlink" title="1、ActivityThread #performDestroyActivity"></a>1、<code>ActivityThread #performDestroyActivity</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ActivityClientRecord <span class="title">performDestroyActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finishing,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">int</span> configChanges, <span class="keyword">boolean</span> getNonConfigInstance, String reason)</span> </span>&#123;</span><br><span class="line">             ....</span><br><span class="line">             </span><br><span class="line">            <span class="comment">// 1、注意此时ActivityClientRecord并未从mActivities中移除，只有执行完Destroy才会移除</span></span><br><span class="line">            ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">            performPauseActivityIfNeeded(r, <span class="string">&quot;destroy&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!r.stopped) &#123;</span><br><span class="line">                  <span class="comment">//执行Activity的onStop()方法</span></span><br><span class="line">                callActivityOnStop(r, <span class="keyword">false</span> <span class="comment">/* saveState */</span>, <span class="string">&quot;destroy&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 此时为true，正常退出的为false</span></span><br><span class="line">            <span class="keyword">if</span> (getNonConfigInstance) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//调用对应Activity的retainNonConfigurationInstances方法</span></span><br><span class="line">                    <span class="comment">//2、返回值NonConfigurationInstance赋给ActivityClientRecord内的lastNonConfigurationInstances持有</span></span><br><span class="line">                    r.lastNonConfigurationInstances</span><br><span class="line">                       </span><br><span class="line">                            = r.activity.retainNonConfigurationInstances();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!mInstrumentation.onException(r.activity, e)) &#123;</span><br><span class="line">                      ...</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">          <span class="comment">// 3、最终回调到onDestroy方法</span></span><br><span class="line">          mInstrumentation.callActivityOnDestroy(r.activity);</span><br><span class="line">          ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、Activity-retainNonConfigurationInstances"><a href="#2、Activity-retainNonConfigurationInstances" class="headerlink" title="2、Activity#retainNonConfigurationInstances"></a>2、<code>Activity#retainNonConfigurationInstances</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">NonConfigurationInstances <span class="title">retainNonConfigurationInstances</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用到 ComponentActivity</span></span><br><span class="line">    Object activity = onRetainNonConfigurationInstance();</span><br><span class="line">    HashMap&lt;String, Object&gt; children = onRetainNonConfigurationChildInstances();</span><br><span class="line">    FragmentManagerNonConfig fragments = mFragments.retainNestedNonConfig();</span><br><span class="line">	</span><br><span class="line">    mFragments.doLoaderStart();</span><br><span class="line">    mFragments.doLoaderStop(<span class="keyword">true</span>);</span><br><span class="line">    ArrayMap&lt;String, LoaderManager&gt; loaders = mFragments.retainLoaderNonConfig();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (activity == <span class="keyword">null</span> &amp;&amp; children == <span class="keyword">null</span> &amp;&amp; fragments == <span class="keyword">null</span> &amp;&amp; loaders == <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; mVoiceInteractor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NonConfigurationInstances nci = <span class="keyword">new</span> NonConfigurationInstances();</span><br><span class="line">    nci.activity = activity;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    nci.children = children;</span><br><span class="line">    nci.fragments = fragments;</span><br><span class="line">    nci.loaders = loaders;</span><br><span class="line">    <span class="keyword">if</span> (mVoiceInteractor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mVoiceInteractor.retainInstance();</span><br><span class="line">        nci.voiceInteractor = mVoiceInteractor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nci;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、ComponentActivity-onRetainNonConfigurationInstance"><a href="#3、ComponentActivity-onRetainNonConfigurationInstance" class="headerlink" title="3、ComponentActivity#onRetainNonConfigurationInstance"></a>3、<code>ComponentActivity#onRetainNonConfigurationInstance</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">onRetainNonConfigurationInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// Maintain backward compatibility.</span></span><br><span class="line">     Object custom = onRetainCustomNonConfigurationInstance();</span><br><span class="line"></span><br><span class="line">     ViewModelStore viewModelStore = mViewModelStore;</span><br><span class="line">     <span class="keyword">if</span> (viewModelStore == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// No one called getViewModelStore(), so see if there was an existing</span></span><br><span class="line">         <span class="comment">// ViewModelStore from our last NonConfigurationInstance</span></span><br><span class="line">         NonConfigurationInstances nc =</span><br><span class="line">                 (NonConfigurationInstances) getLastNonConfigurationInstance();</span><br><span class="line">         <span class="keyword">if</span> (nc != <span class="keyword">null</span>) &#123;</span><br><span class="line">             viewModelStore = nc.viewModelStore;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (viewModelStore == <span class="keyword">null</span> &amp;&amp; custom == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">		 <span class="comment">// 保存viewModel 对象到	NonConfigurationInstances中</span></span><br><span class="line">     NonConfigurationInstances nci = <span class="keyword">new</span> NonConfigurationInstances();</span><br><span class="line">     nci.custom = custom;</span><br><span class="line">     nci.viewModelStore = viewModelStore;</span><br><span class="line">     <span class="keyword">return</span> nci;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>总结下：</p>
<p>Activity 销毁时会将<code>ViewModel</code>保存到<code> ActivityClientRecord#lastNonConfigurationInstances</code>中。</p>
<h2 id="3-3、ViewModel恢复"><a href="#3-3、ViewModel恢复" class="headerlink" title="3.3、ViewModel恢复"></a>3.3、ViewModel恢复</h2><h3 id="1、ActivityThread-performLaunchActivity"><a href="#1、ActivityThread-performLaunchActivity" class="headerlink" title="1、ActivityThread#performLaunchActivity"></a>1、<code>ActivityThread#performLaunchActivity</code></h3><p><code>ActivityThread#performLaunchActivity</code>，最终调用到<code>activity#attach</code>，传入了上次保存的<code>ActivityClientRecord#lastNonConfigurationInstances</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">    attach.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</span><br><span class="line">                        r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                                      <span class="comment">// 注意这个参数</span></span><br><span class="line">                        r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                        r.referrer, r.voiceInteractor, window, r.configCallback,</span><br><span class="line">                        r.assistToken);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、Activity-attach"><a href="#2、Activity-attach" class="headerlink" title="2、Activity#attach"></a>2、<code>Activity#attach</code></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final void attach(Context context, ActivityThread aThread,</span><br><span class="line">                 NonConfigurationInstances lastNonConfigurationInstances,</span><br><span class="line">                 ......</span><br><span class="line">                 )&#123;</span><br><span class="line">    ......</span><br><span class="line">    mLastNonConfigurationInstances = lastNonConfigurationInstances;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到<code>CompontentActivity#getViewModelStore</code>中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ViewModelStore <span class="title">getViewModelStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 1、</span></span><br><span class="line">    ensureViewModelStore();</span><br><span class="line">    <span class="keyword">return</span> mViewModelStore;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;WeakerAccess&quot;)</span> <span class="comment">/* synthetic access */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ensureViewModelStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mViewModelStore == <span class="keyword">null</span>) &#123;</span><br><span class="line">        NonConfigurationInstances nc =</span><br><span class="line">                <span class="comment">// 2、如果存储器是空，就先尝试恢复最近一次配置变更时保存下来的数据</span></span><br><span class="line">                (NonConfigurationInstances) getLastNonConfigurationInstance();</span><br><span class="line">        <span class="keyword">if</span> (nc != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Restore the ViewModelStore from NonConfigurationInstances</span></span><br><span class="line">            mViewModelStore = nc.viewModelStore;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.如果lastNonConfigurationInstance不存在，就new一个</span></span><br><span class="line">        <span class="keyword">if</span> (mViewModelStore == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mViewModelStore = <span class="keyword">new</span> ViewModelStore();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Activity#getLastNonConfigurationInstance()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getLastNonConfigurationInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mLastNonConfigurationInstances != <span class="keyword">null</span></span><br><span class="line">        ? mLastNonConfigurationInstances.activity : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结下，为什么资源配置变化不会影响到<code>NonConfigurationInstances</code>实例呢？</p>
<ul>
<li><code>Activity</code>的启动过程中，会将上次保存在<code>ActivityThread#mLastNonConfigurationInstances</code>的获取出来</li>
<li><code>ActivityThread#ActivityClientRecord#lastNonConfigurationInstances</code> 是不受 <code>activity</code> 重建影响，相应的<code>NonConfigurationInstances</code>的<code>viewModelStore</code>不受影响，则其中存储的<code>ViewModel</code>自然也不受影响。</li>
</ul>
<h2 id="3-4、ViewModel-回收"><a href="#3-4、ViewModel-回收" class="headerlink" title="3.4、ViewModel 回收"></a>3.4、ViewModel 回收</h2><h3 id="3-4-1、ViewModel-的生命周期"><a href="#3-4-1、ViewModel-的生命周期" class="headerlink" title="3.4.1、ViewModel 的生命周期"></a>3.4.1、ViewModel 的生命周期</h3><p><a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel"><code>ViewModel</code></a> 对象存在的时间范围是获取 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel"><code>ViewModel</code></a> 时传递给 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModelProvider"><code>ViewModelProvider</code></a> 的 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle"><code>Lifecycle</code></a>。<a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel"><code>ViewModel</code></a> 将一直留在内存中，直到限定其存在时间范围的 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle"><code>Lifecycle</code></a> 永久消失。对于 <code>activity</code>，是在 <code>activity#destroy</code>时；而对于<code> fragment</code>，也会在宿主<code>activity#destroy</code>时销毁。</p>
<p><img src="/pics/viewmodel-lifecycle.png" alt="viewmodel"></p>
<h3 id="3-4-2、回收"><a href="#3-4-2、回收" class="headerlink" title="3.4.2、回收"></a>3.4.2、回收</h3><p>要知道 <code>ViewModel</code> 是在何时回收的，那么就只要看 <code>ViewModelStore</code> 是在什么时候清空 <code>HashMap</code> 就可以。</p>
<p><code>ViewModel</code>实例对象存储在<code>ViewModelStore</code>，则只要确认<code>ViewModelStore</code>中<code>HashMap</code>清理时机，即可确认其回收时机。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ComponentActivity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Lifecycle lifecycle = getLifecycle();</span><br><span class="line">    getLifecycle().addObserver(<span class="keyword">new</span> LifecycleEventObserver() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStateChanged</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner source,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="meta">@NonNull</span> Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (event == Lifecycle.Event.ON_DESTROY) &#123;</span><br><span class="line">                mContextAwareHelper.clearAvailableContext();</span><br><span class="line">               	<span class="comment">// 在配置没发生改变且走到onDestory方法时，清除所有的ViewModel</span></span><br><span class="line">                <span class="keyword">if</span> (!isChangingConfigurations()) &#123;</span><br><span class="line">                    getViewModelStore().clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Activity</code>在收到<code>ON_DESTROY</code>事件</p>
<ul>
<li>如果判断是由于资源配置变更导致的页面销毁，不会调用<code>ViewModelStore</code>的<code>clear()</code>方法；</li>
<li>如果是正常退出或被系统杀死，则就会调用该<code>clear()</code>方法，清空所有缓存的<code>ViewModel</code>实例</li>
</ul>
<h2 id="3-5、Fragment-的ViewModel"><a href="#3-5、Fragment-的ViewModel" class="headerlink" title="3.5、Fragment 的ViewModel"></a>3.5、Fragment 的ViewModel</h2><p>以上所有的流程分析都是基于<code>Activity</code>的，Fragment中创建<code>ViewModel</code>的ViewModel 与 Fragment 的绑定流程比较复杂。</p>
<h3 id="FragmentManagerViewModel"><a href="#FragmentManagerViewModel" class="headerlink" title="FragmentManagerViewModel "></a><code>FragmentManagerViewModel </code></h3><p>每个 Fragment 创建时，都会创建一个 <code>FragmentManagerViewModel</code> 对象，在该对象中主要存储其 <code>子Fragment</code> 的 <code>ViewModelStore</code> 与 <code>FragmentManagerViewMoel</code>。</p>
<ul>
<li>mViewModelStore 是类型为 <code>&lt;String, FragmentManagerViewModel&gt;</code> 的 HashMap</li>
<li>mChildNonConfigs 是类型为 <code>&lt;String, ViewModelStore&gt;</code> 的 HashMap</li>
</ul>
<p>上述两个 Map 对应的 Key 值都为 Fragment 的唯一 <code>UUID</code>。该 UUID 会在 Fragment 对象创建时自动生成。也就是每个 Fragment 对应唯一 UUID。</p>
<p>当出现嵌套的Fragment时，我们在 Activity 中 分别添加了 Fragment A、B、C，并在 Fragment C 中有嵌套了 Fragment D、E、F。</p>
<img src="/pics/17096a7ade13cc34~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="Activity与Fragment嵌套.png" style="zoom:50%;" />

<p>最终会形成一个<code>N叉树的ViewModel</code>结构：</p>
<p><img src="/pics/17096a7af51d4c32~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="嵌套下实际结构.jpg"></p>
<p>从上图中，我们可以看出，当存在嵌套 <code>Fragment</code> 的情况下，<code>ViewModel</code> 总是以<strong>线性</strong>的结构进行存储。在这种结构下，就能让宿主 <code>Activity</code> 良好的统一管理与所有的 <code>ViewModel</code>。</p>
<h1 id="四、自定义ViewModel"><a href="#四、自定义ViewModel" class="headerlink" title="四、自定义ViewModel"></a>四、自定义ViewModel</h1><p><code>ViewModelProvider</code>提供了两个<code>Factory</code>接口实现类</p>
<ul>
<li><code>NewInstanceFactory</code>：通过反射初始化包含无参构造函数的 <code>ViewModel</code></li>
<li><code>AndroidViewModelFactory</code>：通过反射初始化包含参数仅有一个且为 <code>Application</code> 类型的构造函数的 <code>ViewModel</code></li>
</ul>
<p>如果需要通过其他类型的构造函数来初始化<code>ViewModel</code>，需要自己实现<code>ViewModelProvider.factory</code>接口完成初始化逻辑</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span></span>(<span class="keyword">val</span> age: <span class="built_in">Int</span>) : ViewModel() &#123;</span><br><span class="line">    <span class="keyword">val</span> nameLiveData = MutableLiveData&lt;String&gt;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="comment">//创建myViewModelA</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> myViewModelA <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        ViewModelProvider(<span class="keyword">this</span>, <span class="keyword">object</span> : ViewModelProvider.Factory &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ViewModel&gt;</span> <span class="title">create</span><span class="params">(modelClass: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span>: T &#123;</span><br><span class="line">                <span class="keyword">return</span> MyViewModel(<span class="number">10</span>) <span class="keyword">as</span> T</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).<span class="keyword">get</span>(</span><br><span class="line">            MyViewModel::<span class="keyword">class</span>.java</span><br><span class="line">        ).apply &#123;</span><br><span class="line">            nameLiveData.observe(<span class="keyword">this</span><span class="symbol">@MainActivity</span>, &#123;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建myViewModelB</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> myViewModelB <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        ViewModelProvider(<span class="keyword">this</span>, <span class="keyword">object</span> : ViewModelProvider.Factory &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ViewModel&gt;</span> <span class="title">create</span><span class="params">(modelClass: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span>: T &#123;</span><br><span class="line">                <span class="keyword">return</span> MyViewModel(<span class="number">20</span>) <span class="keyword">as</span> T</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).<span class="keyword">get</span>(</span><br><span class="line">            MyViewModel::<span class="keyword">class</span>.java</span><br><span class="line">        ).apply &#123;</span><br><span class="line">            nameLiveData.observe(<span class="keyword">this</span><span class="symbol">@MainActivity</span>, &#123;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        Log.i(TAG, myViewModelA.toString() + <span class="string">&quot; age: &quot;</span> + myViewModelA.age)</span><br><span class="line">        Log.i(TAG, myViewModelB.toString() + <span class="string">&quot; age: &quot;</span> + myViewModelB.age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">I/ViewModelActivity01: com.example.easyjetpack.viewmodel.<span class="symbol">MyViewModel@</span>eb69c1 age: <span class="number">1</span></span><br><span class="line">I/ViewModelActivity01: com.example.easyjetpack.viewmodel.<span class="symbol">MyViewModel@</span>eb69c1 age: <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><code>myViewModelA</code> 和 <code>myViewModelB</code> 虽然入参不同，但其对应同一个内存地址，即最先初始化的<code>ViewModel</code>实例被缓存下来重复使用。myViewModelB不会被初始化</p>
<p>这是因为二者默认对应的<code>Key</code>是一样的，所以初始化 <code>myViewModelB</code>时之间复用之前的缓存。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">open</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ViewModel&gt;</span> <span class="title">get</span><span class="params">(key: <span class="type">String</span>, modelClass: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">var</span> viewModel = store[key]</span><br><span class="line">    <span class="keyword">if</span> (modelClass.isInstance(viewModel)) &#123;</span><br><span class="line">        (factory <span class="keyword">as</span>? OnRequeryFactory)?.onRequery(viewModel)</span><br><span class="line">        <span class="keyword">return</span> viewModel <span class="keyword">as</span> T</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="meta">@Suppress(<span class="meta-string">&quot;ControlFlowWithEmptyBody&quot;</span>)</span></span><br><span class="line">        <span class="keyword">if</span> (viewModel != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> log a warning.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    viewModel = <span class="keyword">if</span> (factory <span class="keyword">is</span> KeyedFactory) &#123;</span><br><span class="line">        factory.create(key, modelClass)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        factory.create(modelClass)</span><br><span class="line">    &#125;</span><br><span class="line">    store.put(key, viewModel)</span><br><span class="line">    <span class="keyword">return</span> viewModel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果希望 <code>myViewModelA</code> 和 <code>myViewModelB</code> 对应不同的实例对象，那么就需要在初始化的时候主动为它们指定不同的 <code>Key</code>，这样它们就可以一起被存到 <code>ViewModelStore</code> 的 <code>HashMap</code> 中</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> myViewModelA <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    ViewModelProvider(<span class="keyword">this</span>, <span class="keyword">object</span> : ViewModelProvider.Factory &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ViewModel&gt;</span> <span class="title">create</span><span class="params">(modelClass: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span>: T &#123;</span><br><span class="line">            <span class="keyword">return</span> MyViewModel(<span class="number">10</span>) <span class="keyword">as</span> T</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).<span class="keyword">get</span>(</span><br><span class="line">        <span class="string">&quot;keyA&quot;</span>, MyViewModel::<span class="keyword">class</span>.java</span><br><span class="line">    ).apply &#123;</span><br><span class="line">        nameLiveData.observe(<span class="keyword">this</span><span class="symbol">@MainActivity</span>, &#123;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> myViewModelB <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    ViewModelProvider(<span class="keyword">this</span>, <span class="keyword">object</span> : ViewModelProvider.Factory &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ViewModel&gt;</span> <span class="title">create</span><span class="params">(modelClass: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span>: T &#123;</span><br><span class="line">            <span class="keyword">return</span> MyViewModel(<span class="number">20</span>) <span class="keyword">as</span> T</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).<span class="keyword">get</span>(</span><br><span class="line">        <span class="string">&quot;keyB&quot;</span>, MyViewModel::<span class="keyword">class</span>.java</span><br><span class="line">    ).apply &#123;</span><br><span class="line">        nameLiveData.observe(<span class="keyword">this</span><span class="symbol">@MainActivity</span>, &#123;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line">I/ViewModelActivity01: com.example.easyjetpack.viewmodel.<span class="symbol">MyViewModel@</span>25ca954 age: <span class="number">3</span></span><br><span class="line">I/ViewModelActivity01: com.example.easyjetpack.viewmodel.<span class="symbol">MyViewModel@</span>8e211f2 age: <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>当自定义<code>ViewModel</code>，不同的<code>ViewModel</code>使用相同的Key缓存时，后初始化的<code>ViewModel</code>会导致先初始化的销毁。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCleared</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCleared()</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;AViewModel onCleared&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BViewMode</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCleared</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCleared()</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;BViewMode onCleared &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> aViewModel <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    ViewModelProvider(<span class="keyword">this</span>).<span class="keyword">get</span>(</span><br><span class="line">        <span class="string">&quot;myKey&quot;</span>, AViewModel::<span class="keyword">class</span>.java</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> bViewModel <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    ViewModelProvider(<span class="keyword">this</span>).<span class="keyword">get</span>(</span><br><span class="line">        <span class="string">&quot;myKey&quot;</span>, BViewMode::<span class="keyword">class</span>.java</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">     Log.i(TAG, aViewModel.toString())</span><br><span class="line">     Log.i(TAG, bViewModel.toString())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">I/ViewModelActivity01: com.example.easyjetpack.viewmodel.ViewModelActivity$<span class="symbol">AViewModel@</span>5a6d3c0</span><br><span class="line">I/ViewModelActivity01: AViewModel onCleared <span class="comment">// 注意这里</span></span><br><span class="line">I/ViewModelActivity01: com.example.easyjetpack.viewmodel.ViewModelActivity$<span class="symbol">BViewMode@</span>30cd8f9</span><br></pre></td></tr></table></figure>

<p>上述<code>AViewModel onCleared</code>原因是 <code>aViewModel</code> 和 <code>bViewModel</code> 使用了同个<code>key</code>，但是又不是同一个<code>ViewModel</code>类型，导致初始化<code>bViewModel</code> 时，会将<code>HashMap</code>中的 <code>aViewModel</code>覆盖并回收旧值。</p>
<h1 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h1><p><a href="https://juejin.cn/post/6844904079265644551">https://juejin.cn/post/6844904079265644551</a></p>
<p><a href="https://juejin.cn/post/7066390258950078500#heading-11">https://juejin.cn/post/7066390258950078500#heading-11</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>Lifecycle</category>
      </categories>
  </entry>
  <entry>
    <title>Jetpack_03_LiveData</title>
    <url>/2021/02/24/Notes/Android/03Jetpack/Jetpack_03_LiveData/</url>
    <content><![CDATA[<h1 id="Jetpack-03-LiveData"><a href="#Jetpack-03-LiveData" class="headerlink" title="Jetpack_03_LiveData"></a>Jetpack_03_LiveData</h1><span id="more"></span>

<h1 id="一、为什么使用LiveData？"><a href="#一、为什么使用LiveData？" class="headerlink" title="一、为什么使用LiveData？"></a>一、为什么使用LiveData？</h1><p><a href="https://developer.android.google.cn/reference/androidx/lifecycle/LiveData?hl=zh-cn"><code>LiveData</code></a> 是一种可观察的数据存储器类。与常规的可观察类不同，LiveData 具有生命周期感知能力，意指它遵循其他应用组件（如 Activity、Fragment 或 Service）的生命周期。这种感知能力可确保 LiveData 仅更新处于活跃生命周期状态的应用组件观察者。</p>
<p>如果观察者的生命周期处于<code>STARTED</code>或<code>RESUMED</code>状态，则<code>LiveData</code>会认为观察者处于活跃状态。LiveData通知观察者时会检查其实时状态，仅会通知处于活跃状态的观察者。一个观察者处于 <code>PAUSED</code> 或 <code>DESTROYED</code> 状态，它将不会收到通知。一旦观察者重新恢复 <code>RESUMED</code> 状态，它将会重新收到 <code>LiveData</code> 的最新数据。</p>
<p><code>LiveData</code>可以注册和实现<code>LifecycleOwner</code>接口的对象配对的观察者，当相应的<code>Lifecycle</code>对象状态变为<code>DESTROYED</code>，便可移除此观察者，这样就可以防止内存泄漏问题（当 <code>Activity</code> 和 <code>Fragment</code> 的生命周期被销毁时，系统会立即退订它们）</p>
<h2 id="使用-LiveData-的优势"><a href="#使用-LiveData-的优势" class="headerlink" title="使用 LiveData 的优势"></a>使用 LiveData 的优势</h2><p>使用 LiveData 具有以下优势：</p>
<ul>
<li><p><strong>确保界面符合数据状态</strong></p>
<p>LiveData 遵循观察者模式。当底层数据发生变化时，LiveData 会通知 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/Observer?hl=zh-cn"><code>Observer</code></a> 对象。您可以整合代码以在这些 <code>Observer</code> 对象中更新界面。这样一来，您无需在每次应用数据发生变化时更新界面，因为观察者会替您完成更新。</p>
</li>
<li><p><strong>不会发生内存泄漏</strong></p>
<p>观察者会绑定到 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/Lifecycle?hl=zh-cn"><code>Lifecycle</code></a> 对象，生命周期结束时立刻解除对数据的订阅，从而避免内存泄漏等问题。</p>
</li>
<li><p><strong>不会因 Activity 停止而导致崩溃</strong></p>
<p>如果观察者的生命周期处于非活跃状态（如返回栈中的 Activity），则它不会接收任何 LiveData 事件。</p>
</li>
<li><p><strong>不再需要手动处理生命周期</strong></p>
<p>界面组件只是观察相关数据，不会停止或恢复观察。LiveData 将自动管理所有这些操作，因为它在观察时可以感知相关的生命周期状态变化。</p>
</li>
<li><p><strong>数据始终保持最新状态</strong></p>
<p>如果生命周期变为非活跃状态，它会在再次变为活跃状态时接收最新的数据。例如，曾经在后台的 Activity 会在返回前台后立即接收最新的数据。</p>
</li>
<li><p><strong>配置更改</strong></p>
<p>如果由于配置更改（如设备旋转）而重新创建了 Activity 或 Fragment，它会立即接收最新的可用数据。</p>
</li>
<li><p><strong>共享资源</strong></p>
<p>您可以使用单例模式扩展 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/LiveData?hl=zh-cn"><code>LiveData</code></a> 对象以封装系统服务，以便在应用中共享它们。<code>LiveData</code> 对象连接到系统服务一次，然后需要相应资源的任何观察者只需观察 <code>LiveData</code> 对象。如需了解详情，请参阅<a href="https://developer.android.google.cn/topic/libraries/architecture/livedata?hl=zh-cn#extend_livedata">扩展 LiveData</a>。</p>
</li>
</ul>
<h1 id="二、基本使用"><a href="#二、基本使用" class="headerlink" title="二、基本使用"></a>二、基本使用</h1><blockquote>
<p>本文Demo基于<code>Lifecycle 2.4.1</code>版本源码，程序demo基于<code>sdk 31</code></p>
</blockquote>
<p><strong>引入依赖</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="keyword">def</span> lifecycle_version = <span class="string">&quot;2.4.1&quot;</span></span><br><span class="line">    <span class="comment">// ViewModel</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycle_version&quot;</span></span><br><span class="line">    <span class="comment">// LiveData</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.lifecycle:lifecycle-livedata-ktx:$lifecycle_version&quot;</span></span><br><span class="line">    <span class="comment">// Lifecycles only (without ViewModel or LiveData)</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.lifecycle:lifecycle-runtime-ktx:$lifecycle_version&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Saved state module for ViewModel</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.lifecycle:lifecycle-viewmodel-savedstate:$lifecycle_version&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Annotation processor</span></span><br><span class="line">    kapt <span class="string">&quot;androidx.lifecycle:lifecycle-compiler:$lifecycle_version&quot;</span></span><br><span class="line">    <span class="comment">// alternately - if using Java8, use the following instead of lifecycle-compiler</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.lifecycle:lifecycle-common-java8:$lifecycle_version&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-1、简单使用"><a href="#2-1、简单使用" class="headerlink" title="2.1、简单使用"></a>2.1、简单使用</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LiveDataActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">       <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;LiveDataActivity&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_livedata)</span><br><span class="line">        <span class="comment">// 1、创建 mutableLiveData</span></span><br><span class="line">        <span class="keyword">val</span> mutableLiveData = MutableLiveData&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、observer，需要传入 LifecycleOwner 对象，这里使用的是this</span></span><br><span class="line">        mutableLiveData.observe(</span><br><span class="line">            <span class="keyword">this</span>,</span><br><span class="line">            <span class="keyword">object</span> : Observer&lt;String&gt; &#123;</span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onChanged</span><span class="params">(it: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">                    Log.d(TAG,<span class="string">&quot;onChanged:<span class="variable">$it</span>&quot;</span> )</span><br><span class="line">                    Toast.makeText(<span class="keyword">this</span><span class="symbol">@LiveDataActivity</span>,it,Toast.LENGTH_LONG).show()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、更新源数据</span></span><br><span class="line">        mutableLiveData.postValue(<span class="string">&quot;Hello LiveData&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>observer</code>方法有两个参数：</p>
<ol>
<li><code>LifecycleOwner</code>，<code>LiveData</code> 观察活跃状态的能力就来自于此</li>
<li><code>Observer&lt;T&gt;</code>, value发生变化时，在<code>onChange</code>方法中回调</li>
</ol>
<h3 id="创建-LiveData-对象"><a href="#创建-LiveData-对象" class="headerlink" title="创建 LiveData 对象"></a>创建 LiveData 对象</h3><p>LiveData 是一种可用于任何数据的封装容器，其中包括可实现 <code>Collections</code> 的对象，如 <code>List</code>。<a href="https://developer.android.google.cn/reference/androidx/lifecycle/LiveData?hl=zh-cn"><code>LiveData</code></a> 对象通常存储在 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel?hl=zh-cn"><code>ViewModel</code></a> 对象中，并可通过 getter 方法进行访问，如以下示例中所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a LiveData with a String</span></span><br><span class="line">    <span class="keyword">val</span> currentName: MutableLiveData&lt;String&gt; <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        MutableLiveData&lt;String&gt;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rest of the ViewModel...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存储在<code>ViewModel</code>对象主要原因如下：</p>
<ul>
<li>避免 Activity 和 Fragment 过于庞大。现在，这些界面控制器负责显示数据，但不负责存储数据状态。</li>
<li>将 <code>LiveData</code> 实例与特定的 Activity 或 Fragment 实例分离开，并使 <code>LiveData</code> 对象在配置更改后继续存在。</li>
</ul>
<h3 id="观察-LiveData-对象"><a href="#观察-LiveData-对象" class="headerlink" title="观察 LiveData 对象"></a>观察 LiveData 对象</h3><p>在大多数情况下，应用组件的 <code>onCreate()</code> 方法是开始观察 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/LiveData?hl=zh-cn"><code>LiveData</code></a> 对象的，原因如下：</p>
<ul>
<li>确保系统不会从 Activity 或 Fragment 的 <code>onResume()</code> 方法进行冗余调用。</li>
<li>确保 Activity 或 Fragment 变为活跃状态后具有可以立即显示的数据。一旦应用组件处于 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/Lifecycle.State?hl=zh-cn#STARTED"><code>STARTED</code></a> 状态，就会从它正在观察的 <code>LiveData</code> 对象接收最新值。只有在设置了要观察的 <code>LiveData</code> 对象时，才会发生这种情况。</li>
</ul>
<p><code>LiveData </code>更新数据情况如下：</p>
<ol>
<li>活跃状态下，数据发生更改时更新，并且仅发送给活跃观察者。</li>
<li>观察者从非活跃状态更改为活跃状态时也会收到更新。</li>
<li>观察者第二次从非活跃状态更改为活跃状态，则只有在自上次变为活跃状态以来值发生了更改时，它才会收到更新。</li>
</ol>
<p><code>LiveData</code>还提供了一个<code>observeForever()</code>方法，与<code>observe()</code>的区别在于当<code>LiveData</code>包装的数据发生变化时，无论页面处于什么状态，<code>observeForever()</code>都能收到通知。使用完成后，要记得调用<code>removeObserver()</code>来停止对<code>LiveData</code>的观察，否则<code>LiveData</code>会一直处于激活状态，<code>Activity</code>永远不会被系统自动回收。</p>
<h3 id="更新-LiveData-对象"><a href="#更新-LiveData-对象" class="headerlink" title="更新 LiveData 对象"></a>更新 LiveData 对象</h3><p><code>LiveData</code> 没有公开可用的方法来更新存储的数据。通常情况下会在 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel?hl=zh-cn"><code>ViewModel</code></a> 中使用 <code>MutableLiveData</code>，然后 <code>ViewModel</code> 只会向观察者公开不可变的 <code>LiveData</code> 对象，然后使用<a href="https://developer.android.google.cn/reference/androidx/lifecycle/MutableLiveData?hl=zh-cn"><code>MutableLiveData</code></a> 通过 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/MutableLiveData?hl=zh-cn#setValue(T)"><code>setValue(T)</code></a> 和 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/MutableLiveData?hl=zh-cn#postValue(T)"><code>postValue(T)</code></a> 更新数据。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">button.setOnClickListener &#123;</span><br><span class="line">    <span class="keyword">val</span> anotherName = <span class="string">&quot;John Doe&quot;</span></span><br><span class="line">    model.currentName.setValue(anotherName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在主线程中更新数据可以使用<a href="https://developer.android.google.cn/reference/androidx/lifecycle/MutableLiveData?hl=zh-cn#setValue(T)"><code>setValue(T)</code></a> 更新。</p>
<p>如果在工作器线程中执行代码，可以改用 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/MutableLiveData?hl=zh-cn#postValue(T)"><code>postValue(T)</code></a> 。</p>
<h2 id="2-2、扩展LiveData"><a href="#2-2、扩展LiveData" class="headerlink" title="2.2、扩展LiveData"></a>2.2、扩展LiveData</h2><p><a href="https://developer.android.google.cn/topic/libraries/architecture/livedata?hl=zh-cn#extend_livedata">官方案例</a>，可以将<code>LiveData</code>类实现为一个单例，然后在多个 <code>Activity</code>、<code>Fragment</code> 和 <code>Service</code> 之间共享这个对象，仅当一个或多个页面处于活跃状态时，<code>LiveData</code> 才会连接服务并更新数据。如果观察者的生命周期处于 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/Lifecycle.State?hl=zh-cn#STARTED"><code>STARTED</code></a> 或 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/Lifecycle.State?hl=zh-cn#RESUMED"><code>RESUMED</code></a> 状态，则 LiveData 会认为该观察者处于活跃状态。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockLiveData</span></span>(symbol: String) : LiveData&lt;BigDecimal&gt;() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> stockManager: StockManager = StockManager(symbol)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> listener = &#123; price: BigDecimal -&gt;</span><br><span class="line">        <span class="comment">// 官方案例                    </span></span><br><span class="line">        value = price</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActive</span><span class="params">()</span></span> &#123;</span><br><span class="line">        stockManager.requestPriceUpdates(listener)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onInactive</span><span class="params">()</span></span> &#123;</span><br><span class="line">        stockManager.removeUpdates(listener)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> sInstance: StockLiveData</span><br><span class="line"></span><br><span class="line">        <span class="meta">@MainThread</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(symbol: <span class="type">String</span>)</span></span>: StockLiveData &#123;</span><br><span class="line">            sInstance = <span class="keyword">if</span> (::sInstance.isInitialized) sInstance <span class="keyword">else</span> StockLiveData(symbol)</span><br><span class="line">            <span class="keyword">return</span> sInstance</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3、转换-LiveData"><a href="#2-3、转换-LiveData" class="headerlink" title="2.3、转换 LiveData"></a>2.3、<a href="https://developer.android.google.cn/topic/libraries/architecture/livedata?hl=zh-cn#transform_livedata">转换 LiveData</a></h2><p><a href="https://developer.android.google.cn/topic/libraries/architecture/livedata?hl=zh-cn#transform_livedata">官方案例</a>，如果要在 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/LiveData?hl=zh-cn"><code>LiveData</code></a> 对象分派给观察者之前对存储在其中的值进行更改。</p>
<p>[<code>Transformations.map()</code>](<a href="https://developer.android.google.cn/reference/androidx/lifecycle/Transformations?hl=zh-cn#map">https://developer.android.google.cn/reference/androidx/lifecycle/Transformations?hl=zh-cn#map</a>(android.arch.lifecycle.LiveData, android.arch.core.util.Function))</p>
<p>对存储在 <code>LiveData</code> 对象中的值应用函数，并将结果传播到下游。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> mutableLiveData = MutableLiveData&lt;String&gt;()</span><br><span class="line">    mutableLiveData.observe(<span class="keyword">this</span>) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onChanged:<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, it, Toast.LENGTH_LONG).show()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//LiveData返回值实例转换</span></span><br><span class="line">    <span class="keyword">val</span> transformedLiveData = Transformations.map(mutableLiveData) &#123; name -&gt;</span><br><span class="line">        <span class="string">&quot;<span class="subst">$&#123;name&#125;</span>LiveData is great&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    transformedLiveData.observe(<span class="keyword">this</span>)&#123;</span><br><span class="line">        Log.d(TAG,<span class="string">&quot;onChange2<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    mutableLiveData.postValue(<span class="string">&quot;Hello LiveData &quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[<code>Transformations.switchMap()</code>](<a href="https://developer.android.google.cn/reference/androidx/lifecycle/Transformations?hl=zh-cn#switchMap">https://developer.android.google.cn/reference/androidx/lifecycle/Transformations?hl=zh-cn#switchMap</a>(android.arch.lifecycle.LiveData, android.arch.core.util.Function&gt;))</p>
<p>与 <code>map()</code> 类似，对存储在 <code>LiveData</code> 对象中的值<strong>应用函数</strong>，并将结果解封和分派到下游。传递给 <code>switchMap()</code> 的函数必须返回 <code>LiveData</code> 对象，如以下示例中所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"> 	</span><br><span class="line">    <span class="keyword">val</span> userId: MutableLiveData&lt;String&gt; = MutableLiveData&lt;String&gt;()</span><br><span class="line">    <span class="keyword">val</span> user = Transformations.switchMap(userId) &#123; id -&gt; getUser(id) &#125;</span><br><span class="line">    userId.observe(<span class="keyword">this</span>) &#123;</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, it, Toast.LENGTH_SHORT).show()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    user.observe(<span class="keyword">this</span>) &#123;</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span><span class="symbol">@LiveDataActivity</span>, it.toString(), Toast.LENGTH_SHORT).show()</span><br><span class="line">    &#125;</span><br><span class="line">    userId.value = <span class="string">&quot;id10&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(id: <span class="type">String</span>)</span></span>: LiveData&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> MutableLiveData(User(<span class="string">&quot;zxw&quot;</span>, <span class="number">20</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4、合并多个-LiveData-源"><a href="#2-4、合并多个-LiveData-源" class="headerlink" title="2.4、合并多个 LiveData 源"></a>2.4、合并多个 LiveData 源</h2><p><a href="https://developer.android.google.cn/reference/androidx/lifecycle/MediatorLiveData?hl=zh-cn"><code>MediatorLiveData</code></a> 是 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/LiveData?hl=zh-cn"><code>LiveData</code></a> 的子类，允许您合并多个 LiveData 源。只要任何一个<code>LiveData</code> 对象发生更改，就会触发 <code>MediatorLiveData</code> 对象的观察者。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">		<span class="keyword">val</span> mediatorLiveData : MediatorLiveData&lt;String&gt; = MediatorLiveData()</span><br><span class="line">    <span class="keyword">val</span> livedata1 = MutableLiveData&lt;String&gt;()</span><br><span class="line">    <span class="keyword">val</span> livedata2 = MutableLiveData&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">    mediatorLiveData.addSource(livedata1) &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;livedata1 change <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    mediatorLiveData.addSource(livedata2) &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;livedata2 change <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mediatorLiveData.observe(<span class="keyword">this</span>) &#123;</span><br><span class="line">        Log.i(TAG,<span class="string">&quot;onChanged:<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    livedata1.value = <span class="string">&quot;1&quot;</span></span><br><span class="line">    livedata2.value = <span class="string">&quot;2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line">I/LiveDataActivity: livedata1 change <span class="number">1</span></span><br><span class="line">I/LiveDataActivity: livedata2 change <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h1 id="三、原理分析"><a href="#三、原理分析" class="headerlink" title="三、原理分析"></a>三、原理分析</h1><p><strong><code>LiveData</code>的实现原理，简单总结为</strong>：</p>
<ol>
<li>添加观察者：将<code>LifecycleOwner</code>和<code>observer</code>进行包装成可感知生命周期的包装类，添加到<code>LifecycleObserver</code>中，它将在<code>LifecycleOwner</code>更改状态时得到通知</li>
<li>事件回调：收到<code>LifecycleOwner</code>状态更改通知时，进行状态判断等处理，通知观察者对象</li>
<li>数据更新：当数据发生变化时，进行状态判断，通知观察者对象</li>
<li>数据更新：遍历观察者对象，分发状态，更新数据版本号</li>
</ol>
<img src="/pics/9329ebbd854443a3a09a527712a11151~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="livedata原理" style="zoom:67%;" />

<h2 id="3-1、添加Observer"><a href="#3-1、添加Observer" class="headerlink" title="3.1、添加Observer"></a>3.1、添加Observer</h2><p><code>LiveData</code>通过<code>observer()</code>方法来注册观察者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">observe</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner owner, <span class="meta">@NonNull</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">    assertMainThread(<span class="string">&quot;observe&quot;</span>);</span><br><span class="line">    <span class="comment">// 1、当前绑定的组件（activity或fragment)状态为为DESTROYED的时候，则会忽视当前的订阅请求</span></span><br><span class="line">    <span class="keyword">if</span> (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2、创建生命周期感知的观察者包装类 LifecycleBoundObserver</span></span><br><span class="line">    LifecycleBoundObserver wrapper = <span class="keyword">new</span> LifecycleBoundObserver(owner, observer);</span><br><span class="line">    <span class="comment">// 3、如果指定的键尚未与某个值关联，则将其与给定的值关联</span></span><br><span class="line">    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class="line">    <span class="comment">// 4、同一个Observer只能与一个owner绑定</span></span><br><span class="line">    <span class="keyword">if</span> (existing != <span class="keyword">null</span> &amp;&amp; !existing.isAttachedTo(owner)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Cannot add the same observer&quot;</span></span><br><span class="line">                                           + <span class="string">&quot; with different lifecycles&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (existing != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5、添加一个LifecycleObserver，它将在LifecycleOwner更改状态时得到通知</span></span><br><span class="line">    owner.getLifecycle().addObserver(wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上逻辑主要是创建<code>Observer</code>并和<code>LifeCycleOwner</code>绑定，后续的流程和<code>Lifecycle</code>添加<code>Observer</code>过程基本相同。</p>
<h2 id="3-2、数据更新"><a href="#3-2、数据更新" class="headerlink" title="3.2、数据更新"></a>3.2、数据更新</h2><p>我们知道，通过<code>setValue</code>或者<code>postValue</code>改变<code>LiveData</code>的数据是，<code>Observer</code>中会接收到相关的变化，那么数据更新是如何通知到Observer的呢？</p>
<h3 id="3-2-1、setValue过程"><a href="#3-2-1、setValue过程" class="headerlink" title="3.2.1、setValue过程"></a>3.2.1、setValue过程</h3><h4 id="1、LiveData-setValue"><a href="#1、LiveData-setValue" class="headerlink" title="1、LiveData#setValue"></a>1、LiveData#setValue</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    assertMainThread(<span class="string">&quot;setValue&quot;</span>);	<span class="comment">//检查是否在主线程</span></span><br><span class="line">    mVersion++;	<span class="comment">//默认值是-1，每次更新数据都会自增</span></span><br><span class="line">    mData = value;	<span class="comment">//更新的数据赋值给mData</span></span><br><span class="line">		<span class="comment">// 分发数据</span></span><br><span class="line">    dispatchingValue(<span class="keyword">null</span>);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 调用 <code>dispatchingValue</code>方法并传入null，将数据分发给所有观察者。如果是具体的<code>ObserverWrapper</code>对象，则通知到具体的Observer。</p>
<h4 id="2、LiveData-dispatchingValue"><a href="#2、LiveData-dispatchingValue" class="headerlink" title="2、LiveData#dispatchingValue"></a>2、LiveData#dispatchingValue</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchingValue</span><span class="params">(<span class="meta">@Nullable</span> ObserverWrapper initiator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDispatchingValue) &#123;</span><br><span class="line">        mDispatchInvalidated = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mDispatchingValue = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        mDispatchInvalidated = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (initiator != <span class="keyword">null</span>) &#123;</span><br><span class="line">            considerNotify(initiator);</span><br><span class="line">            initiator = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Iterator&lt;Map.Entry&lt;Observer&lt;? <span class="keyword">super</span> T&gt;, ObserverWrapper&gt;&gt; iterator =</span><br><span class="line">                    mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;</span><br><span class="line">                <span class="comment">// 通知所有的 观察者     </span></span><br><span class="line">                considerNotify(iterator.next().getValue());</span><br><span class="line">                <span class="keyword">if</span> (mDispatchInvalidated) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (mDispatchInvalidated);</span><br><span class="line">    mDispatchingValue = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、LiveData-considerNotify"><a href="#3、LiveData-considerNotify" class="headerlink" title="3、LiveData#considerNotify"></a>3、LiveData#considerNotify</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">considerNotify</span><span class="params">(ObserverWrapper observer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!observer.mActive) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 1、如果是活跃状态则回调</span></span><br><span class="line">    <span class="keyword">if</span> (!observer.shouldBeActive()) &#123;</span><br><span class="line">        observer.activeStateChanged(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2、obserer的verson &gt;= LiveData version 时，直接return</span></span><br><span class="line">    <span class="keyword">if</span> (observer.mLastVersion &gt;= mVersion) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2、更新数据版本号</span></span><br><span class="line">    observer.mLastVersion = mVersion; </span><br><span class="line">    <span class="comment">// 3、回调到Observer#onChanged方法中</span></span><br><span class="line">    observer.mObserver.onChanged((T) mData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>setValue</code>总体的流程如下：<code>setValue</code> ——&gt; <code>dispatchingValue(null)</code> ——&gt; <code>considerNotify</code>——&gt; <code>onChanged</code>。</p>
<p><code>LiveData</code>中，其初始的<code>version</code>是-1，当我们调用了其<code>setValue</code>或者<code>postValue</code>，其<code>version</code>会+1</p>
<p>对于每一个观察者<code>ObserverWrapper</code>，其初始version也为-1，也就是说，每一个新注册的观察者，其<code>version</code>为-1；<code>LiveData</code>每注册一个新的订阅者，这个订阅者立刻会收到一个回调，即使这个设置的动作发生在订阅之前。</p>
<h3 id="3-2-2、postValue"><a href="#3-2-2、postValue" class="headerlink" title="3.2.2、postValue"></a>3.2.2、postValue</h3><h4 id="1、LiveData-postValue"><a href="#1、LiveData-postValue" class="headerlink" title="1、LiveData#postValue"></a>1、LiveData#postValue</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> postTask;</span><br><span class="line">    <span class="keyword">synchronized</span> (mDataLock) &#123;</span><br><span class="line">        postTask = mPendingData == NOT_SET;</span><br><span class="line">        mPendingData = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!postTask) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过线程池 post 到主线程</span></span><br><span class="line">    ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable mPostValueRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object newValue;</span><br><span class="line">        <span class="keyword">synchronized</span> (mDataLock) &#123;</span><br><span class="line">            newValue = mPendingData;</span><br><span class="line">            mPendingData = NOT_SET;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// runnable 中调用到 主线程</span></span><br><span class="line">        setValue((T) newValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>postValue</code>是将消息通过线程池分发到主线程去处理，调用的也是主线程。</p>
<h2 id="3-3、事件驱动"><a href="#3-3、事件驱动" class="headerlink" title="3.3、事件驱动"></a>3.3、事件驱动</h2><p>我们知道<code>LiveData</code>还有一个变化生命周期变化时会触发数据的更新，当组件（<code>Activity/Fragment</code>）生命周期变化时，会回调到<code>Observer#onStateChanged</code>中。<code>LiveData</code>中<code>Observer</code>的实现类是<code>LifecycleBoundObserver</code>，下面具体来看下。</p>
<h3 id="3-3-1、LifecycleBoundObserver"><a href="#3-3-1、LifecycleBoundObserver" class="headerlink" title="3.3.1、LifecycleBoundObserver"></a>3.3.1、LifecycleBoundObserver</h3><p><code>LifecycleBoundObserver</code>是<code>LiveData</code>内部封装的<code>Observer</code>监听类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LifecycleBoundObserver</span> <span class="keyword">extends</span> <span class="title">ObserverWrapper</span> <span class="keyword">implements</span> <span class="title">LifecycleEventObserver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">final</span> LifecycleOwner mOwner;</span><br><span class="line"></span><br><span class="line">    LifecycleBoundObserver(<span class="meta">@NonNull</span> LifecycleOwner owner, Observer&lt;? <span class="keyword">super</span> T&gt; observer) &#123;</span><br><span class="line">        <span class="keyword">super</span>(observer);</span><br><span class="line">        mOwner = owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 1、是否是活跃状态</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">shouldBeActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 2、组件生命周期变化时，会触发到 lifecycle 状态变化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStateChanged</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner source,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="meta">@NonNull</span> Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">        Lifecycle.State currentState = mOwner.getLifecycle().getCurrentState();</span><br><span class="line">        <span class="keyword">if</span> (currentState == DESTROYED) &#123;</span><br><span class="line">            removeObserver(mObserver);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Lifecycle.State prevState = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (prevState != currentState) &#123;</span><br><span class="line">            prevState = currentState;</span><br><span class="line">            <span class="comment">// 3、调用到 ObserverWrapper#activeStateChanged</span></span><br><span class="line">            activeStateChanged(shouldBeActive());</span><br><span class="line">            currentState = mOwner.getLifecycle().getCurrentState();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAttachedTo</span><span class="params">(LifecycleOwner owner)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mOwner == owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">detachObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mOwner.getLifecycle().removeObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-2、ObserverWrapper"><a href="#3-3-2、ObserverWrapper" class="headerlink" title="3.3.2、ObserverWrapper"></a>3.3.2、ObserverWrapper</h3><p><code>ObserverWrapper#activeStateChanged</code>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverWrapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; mObserver;</span><br><span class="line">    <span class="keyword">boolean</span> mActive;</span><br><span class="line">    <span class="comment">// 这里注意 version</span></span><br><span class="line">    <span class="keyword">int</span> mLastVersion = START_VERSION;</span><br><span class="line"></span><br><span class="line">    ObserverWrapper(Observer&lt;? <span class="keyword">super</span> T&gt; observer) &#123;</span><br><span class="line">        mObserver = observer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">shouldBeActive</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAttachedTo</span><span class="params">(LifecycleOwner owner)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">detachObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">activeStateChanged</span><span class="params">(<span class="keyword">boolean</span> newActive)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1、活跃状态没有变化</span></span><br><span class="line">        <span class="keyword">if</span> (newActive == mActive) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// immediately set active state, so we&#x27;d never dispatch anything to inactive</span></span><br><span class="line">        <span class="comment">// owner</span></span><br><span class="line">        mActive = newActive;</span><br><span class="line">        changeActiveCounter(mActive ? <span class="number">1</span> : -<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 2、分发值，下面介绍</span></span><br><span class="line">        <span class="keyword">if</span> (mActive) &#123;</span><br><span class="line">            dispatchingValue(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、常见问题"><a href="#四、常见问题" class="headerlink" title="四、常见问题"></a>四、常见问题</h1><h2 id="4-1、数据倒灌"><a href="#4-1、数据倒灌" class="headerlink" title="4.1、数据倒灌"></a>4.1、数据倒灌</h2><p>使用<code>LiveData</code>的一个常见问题是数据倒灌，表现为用户在页面没有做任何操作，却进行了页面跳转，数据请求等操作。<code>LiveData</code>在页面重建时，会自动推送最后一次数据。对于页面重建，常见的场景有：</p>
<ol>
<li>屏幕旋转</li>
<li>系统语言切换</li>
<li>内存不足，应用在后台被系统杀死。之后用户再重新进入应用</li>
<li>……</li>
</ol>
<p>这里我们讨论的数据倒灌跟前两种场景相关。下面通过一个示例演示一下数据倒灌问题</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LiveDataActivity</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">				<span class="comment">// ...</span></span><br><span class="line">      </span><br><span class="line">				<span class="keyword">val</span> lvModel: LiveDataVModel = ViewModelProvider(<span class="keyword">this</span>)[LiveDataVModel::<span class="keyword">class</span>.java]</span><br><span class="line">        lvModel.lvData.observe(<span class="keyword">this</span>) &#123;</span><br><span class="line">            Thread&#123;</span><br><span class="line">                SystemClock.sleep(<span class="number">3000</span>)</span><br><span class="line">                <span class="keyword">val</span> intent = Intent(<span class="symbol">LiveDataActivity@</span><span class="keyword">this</span>, ViewModelActivity::<span class="keyword">class</span>.java);</span><br><span class="line">                startActivity(intent)</span><br><span class="line">            &#125;.start()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        findViewById&lt;Button&gt;(R.id.bt01).setOnClickListener &#123;</span><br><span class="line">            lvModel.lvData.value = <span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LiveDataVModel</span> </span>() : ViewModel()&#123;</span><br><span class="line">    <span class="keyword">val</span> lvData = MutableLiveData&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码示例，如果用户在<code>LiveDataActivity</code>中点击按钮，会将<code>ViewModel</code>中的<code>lvData</code>的值置为3，然后延迟3S后会跳转到下一个页面。如果用户返回当前页面，在当前页面旋转屏幕，发现会自动跳转到下一个页面。这就是数据倒灌导致的。</p>
<p>前述页面旋转重建了，会自动推送最后一次数据。<code>LiveData</code>的事件回调过程是：<code>observe</code> ——&gt; <code>onStateChanged</code> ——&gt; <code>activeStateChanged</code> ——&gt; <code>dispatchingValue</code> ——&gt; <code>considerNotify</code> ——&gt; <code>onChanged</code>。通过断点调试，可将问题定位在<code>considerNotify</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">considerNotify</span><span class="params">(ObserverWrapper observer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//观察者非活跃，直接return</span></span><br><span class="line">    <span class="keyword">if</span> (!observer.mActive) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//观察者状态活跃，但是当前变为了不可见状态，再调用activeStateChanged方法，并传入false，其内部会再次判断</span></span><br><span class="line">    <span class="keyword">if</span> (!observer.shouldBeActive()) &#123;</span><br><span class="line">        observer.activeStateChanged(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处判断无效导致数据倒灌</span></span><br><span class="line">    <span class="keyword">if</span> (observer.mLastVersion &gt;= mVersion) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//修改数据版本</span></span><br><span class="line">    observer.mLastVersion = mVersion;</span><br><span class="line">    observer.mObserver.onChanged((T) mData);<span class="comment">//回调真正的mObserver的onChanged方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>LiveData</code>在前述屏幕旋转中也执行了事件分发，其原因是<code>if (observer.mLastVersion &gt;= mVersion)</code> 没有生效。</p>
<h3 id="LiveData-mVersion"><a href="#LiveData-mVersion" class="headerlink" title="LiveData#mVersion"></a><strong><code>LiveData#mVersion</code></strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LiveData.java   </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> START_VERSION = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mVersion;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LiveData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mData = NOT_SET;</span><br><span class="line">    mVersion = START_VERSION;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mVersion</code>是<code>LiveData</code>的成员变量，一个<code>LiveData</code>维护一份实例对象</p>
<p>在初始化<code>LiveData</code>时，<code>mVersion</code>设置为-1，之后每次调用<code>setValue</code>等方法，会执行<code>mVersion++</code>自增方法。</p>
<h3 id="ObserverWrapper-mLastVersion"><a href="#ObserverWrapper-mLastVersion" class="headerlink" title="ObserverWrapper#mLastVersion"></a><strong><code>ObserverWrapper#mLastVersion</code></strong></h3><p><code>mLastVersion</code>默认值也是-1。如果分发事件成功，将当前<code>LiveData</code>的<code>mVersion</code>赋值给<code>mLastVersion</code>。</p>
<p>也就是说当屏幕旋转后，该值重新变为-1，导致了数据倒灌问题发生。为什么 mLastVersion 会变成-1呢？</p>
<p>回看一下<code>LiveData</code>的<code>observer()</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">observe</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner owner, <span class="meta">@NonNull</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    LifecycleBoundObserver wrapper = <span class="keyword">new</span> LifecycleBoundObserver(owner, observer);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>Activity</code>等页面重建后，<code>LiveData</code>调用<code>observe()</code>，方法内会new一个新的<code>LifecycleBoundObserver</code>对象，该对象继承<code>ObserverWrapper</code>类</li>
<li><code>ObserverWrapper</code>类初始化会重新初始化 <code>int mLastVersion = START_VERSION;</code>将<code>mLastVersion</code>赋值为<code>-1</code></li>
<li>因为<code>observer.mLasterVersion &lt; mVersion</code> ,<code>considerNotify()</code>方法中的判断失效，重新分发事件，导致数据倒灌</li>
</ol>
<p>第二个问题，为什么页面重建会触发到<code>considerNotify()</code>方法？</p>
<p>其实这个问题 <code>3.3 节</code>已经解释过了，当组件的生命周期发生变化时，会触发到<code>LifecycleBoundObserver#onStateChanged</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onStateChanged(@NonNull LifecycleOwner source,</span><br><span class="line">                           @NonNull Lifecycle.Event event) &#123;</span><br><span class="line">    //如果当前Activity的状态是onDestory,移除</span><br><span class="line">    Lifecycle.State currentState = mOwner.getLifecycle().getCurrentState();</span><br><span class="line">    if (currentState == DESTROYED) &#123;</span><br><span class="line">        removeObserver(mObserver);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    Lifecycle.State prevState = null;</span><br><span class="line">    // 上一次的state跟当前的不同时，执行事件分发</span><br><span class="line">    while (prevState != currentState) &#123;</span><br><span class="line">        prevState = currentState;</span><br><span class="line">        activeStateChanged(shouldBeActive());</span><br><span class="line">        currentState = mOwner.getLifecycle().getCurrentState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果生命周期变为非活跃状态，它会在再次变为活跃状态时接收最新的数据。</p>
<p><strong>简单小结</strong>：</p>
<ol>
<li>页面异常销毁重建，<code>ViewModel</code>会保存销毁之前的数据，在Activity重建完成后进行数据回复，所以<code>LiveData</code>成员变量中的<code>mVersion</code>会恢复到重建之前的值</li>
<li>页面重建后会调用<code>LiveData</code>的<code>observe()</code>方法，方法内部会重新<code>new</code>一个实例，会将<code>mLastVersion</code>恢复到初始值。</li>
<li>由于<code>LiveData</code>本身的特性，<code>Activity</code>的生命周期由非活跃变成活跃时，<code>LiveData</code>会触发事件分发，导致屏幕旋转或者切换系统语言后出现数据倒灌</li>
</ol>
<p><strong>数据倒灌解决方法</strong>：</p>
<ul>
<li><a href="https://link.juejin.cn/?target=https://github.com/android/architecture-samples/blob/dev-todo-mvvm-live/todoapp/app/src/main/java/com/example/android/architecture/blueprints/todoapp/SingleLiveEvent.java">官方扩展的SingleLiveEvent</a></li>
<li><a href="https://link.juejin.cn/?target=https://tech.meituan.com/2018/07/26/android-livedatabus.html">美团反射修改mVersion</a></li>
<li><a href="https://link.juejin.cn/?target=https://github.com/KunMinX/UnPeek-LiveData">UnPeek-LiveData</a></li>
</ul>
<h2 id="4-2、postValue数据丢失"><a href="#4-2、postValue数据丢失" class="headerlink" title="4.2、postValue数据丢失"></a>4.2、postValue数据丢失</h2><p><code>postValue</code>数据丢失的典型表现就是使用<code>LiveData</code>时，连续<code>postValue</code>两次，发现第一次的值会丢失。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">lvModel.lvData.observe(<span class="keyword">this</span>) &#123;</span><br><span class="line">    Log.i(TAG, <span class="string">&quot;ret = <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">lvModel.lvData.postValue(<span class="number">100</span>)</span><br><span class="line">lvModel.lvData.postValue(<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**实际只会打印第二次postValue的值**/</span></span><br><span class="line">LiveDataActivity: ret = <span class="number">200</span></span><br></pre></td></tr></table></figure>

<p>看一下<code>postValue</code>的内部实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> Object mPendingData = NOT_SET;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> postTask;</span><br><span class="line">    <span class="keyword">synchronized</span> (mDataLock) &#123;</span><br><span class="line">        <span class="comment">// 标记任务是否被执行</span></span><br><span class="line">        postTask = mPendingData == NOT_SET;</span><br><span class="line">        mPendingData = value;	<span class="comment">//暂存数据，后面的数据会覆盖前面的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!postTask) &#123;	<span class="comment">//保证只抛一个mPostValueRunnabl</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable mPostValueRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object newValue;</span><br><span class="line">        <span class="keyword">synchronized</span> (mDataLock) &#123;</span><br><span class="line">            newValue = mPendingData;</span><br><span class="line">            mPendingData = NOT_SET;</span><br><span class="line">        &#125;</span><br><span class="line">        setValue((T) newValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>postValue</code>的主要内容：</p>
<ol>
<li>每次调用<code>postVaule</code>，会将新值赋给<code>mPendingData</code></li>
<li>在<code>Runnable</code>中进行值的分发，通过<code>ArchTaskExecutor</code>将任务发布到主线程中</li>
</ol>
<p>到这其实连续<code>postValue</code>时值会丢失的原因已经清楚了</p>
<ol>
<li>调用<code>postValue</code>时，其实只是将值暂存到<code>mPendingData</code>，然后往主线程抛一个<code>Runnable</code>，通过<code>setValue</code>将暂存的值设置进去，回调观察者</li>
<li>如果在这个<code>Runnable</code>真正执行前多次<code>postValue</code>，只会改变暂存值<code>mPendingData</code>，通过<code>postTask</code>的检测不会再往主线程抛<code>Runnable</code></li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://liuwangshu.cn/application/jetpack/4-livedata-use.html">http://liuwangshu.cn/application/jetpack/4-livedata-use.html</a></p>
<p><a href="https://blog.csdn.net/hewuzhao/article/details/117165379">https://blog.csdn.net/hewuzhao/article/details/117165379</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>Lifecycle</category>
      </categories>
  </entry>
  <entry>
    <title>Jetpack_01_Lifecycle</title>
    <url>/2021/02/24/Notes/Android/03Jetpack/Jetpack_01_Lifecycle/</url>
    <content><![CDATA[<h1 id="Jetpack-01-Lifecycle"><a href="#Jetpack-01-Lifecycle" class="headerlink" title="Jetpack_01_Lifecycle"></a>Jetpack_01_Lifecycle</h1><span id="more"></span>

<h1 id="一、为什么使用Lifecycle？"><a href="#一、为什么使用Lifecycle？" class="headerlink" title="一、为什么使用Lifecycle？"></a>一、为什么使用Lifecycle？</h1><p>Android 开发中，使用Activity 或者 Fragment 组件时，不可避免的要考虑到组件的生命周期。比如，在Activty启动时开始执行任务，在Activity 前后台切换开始或暂停动画等等。</p>
<p>常见的做法是在<code>Activity</code>中注册一个<code>Listener</code>，在<code>Activity</code>的生命周期中进行调用。但是当我们有多个组件需要监听时，需要在<code>Activity</code>的生命周期中存放大量的代码，难以维护。</p>
<p><code>Lifecycle</code> 就应运而生了，它可以帮助我们轻松的管理UI组件的生命周期，同时也可以避免内存泄漏的问题。</p>
<blockquote>
<p>本文Demo基于<code>Lifecycle 2.4.1</code>版本源码，程序demo基于<code>sdk 31</code></p>
</blockquote>
<h1 id="二、Lifecycle-的基本使用"><a href="#二、Lifecycle-的基本使用" class="headerlink" title="二、Lifecycle 的基本使用"></a>二、Lifecycle 的基本使用</h1><p><a href="https://developer.android.com/jetpack/androidx/releases/lifecycle">引入依赖</a></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="keyword">def</span> lifecycle_version = <span class="string">&quot;2.4.1&quot;</span></span><br><span class="line">    <span class="keyword">def</span> arch_version = <span class="string">&quot;2.1.0&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ViewModel</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycle_version&quot;</span></span><br><span class="line">    <span class="comment">// ViewModel utilities for Compose</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.lifecycle:lifecycle-viewmodel-compose:$lifecycle_version&quot;</span></span><br><span class="line">    <span class="comment">// LiveData</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.lifecycle:lifecycle-livedata-ktx:$lifecycle_version&quot;</span></span><br><span class="line">    <span class="comment">// Lifecycles only (without ViewModel or LiveData)</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.lifecycle:lifecycle-runtime-ktx:$lifecycle_version&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Saved state module for ViewModel</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.lifecycle:lifecycle-viewmodel-savedstate:$lifecycle_version&quot;</span></span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 注释1</span></span><br><span class="line">    <span class="comment">// Annotation processor </span></span><br><span class="line">    kapt <span class="string">&quot;androidx.lifecycle:lifecycle-compiler:$lifecycle_version&quot;</span></span><br><span class="line">    <span class="comment">// alternately - if using Java8, use the following instead of lifecycle-compiler</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.lifecycle:lifecycle-common-java8:$lifecycle_version&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - helpers for implementing LifecycleOwner in a Service</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.lifecycle:lifecycle-service:$lifecycle_version&quot;</span></span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 注释2</span></span><br><span class="line">    <span class="comment">// optional - ProcessLifecycleOwner provides a lifecycle for the whole application process</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.lifecycle:lifecycle-process:$lifecycle_version&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - ReactiveStreams support for LiveData</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.lifecycle:lifecycle-reactivestreams-ktx:$lifecycle_version&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - Test helpers for LiveData</span></span><br><span class="line">    testImplementation <span class="string">&quot;androidx.arch.core:core-testing:$arch_version&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1：Lifecycle 注解编译器，<code>v2.4</code>已废弃，原因后面详说。</p>
<p>注释2：进程生命周期管理 <code>ProcessLifecycleOwner</code></p>
<h2 id="2-1、Lifecycle简单使用"><a href="#2-1、Lifecycle简单使用" class="headerlink" title="2.1、Lifecycle简单使用"></a>2.1、Lifecycle简单使用</h2><h3 id="2-1-1、创建Observer"><a href="#2-1-1、创建Observer" class="headerlink" title="2.1.1、创建Observer"></a>2.1.1、创建Observer</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承 DefaultLifecycleObserver 和 LifecycleEventObserver</span></span><br><span class="line"><span class="comment">// 这2个可以同时继承也可以继承任意一个</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObserver</span>: <span class="type">DefaultLifecycleObserver</span>, <span class="type">LifecycleEventObserver &#123;</span></span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;MyObserver&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(owner: <span class="type">LifecycleOwner</span>)</span></span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onCreate&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">(owner: <span class="type">LifecycleOwner</span>)</span></span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onResume&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">(owner: <span class="type">LifecycleOwner</span>)</span></span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onStop&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">(owner: <span class="type">LifecycleOwner</span>)</span></span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onDestroy&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStateChanged</span><span class="params">(source: <span class="type">LifecycleOwner</span>, event: <span class="type">Lifecycle</span>.<span class="type">Event</span>)</span></span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onStateChanged = <span class="variable">$event</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-2、监听生命周期"><a href="#2-1-2、监听生命周期" class="headerlink" title="2.1.2、监听生命周期"></a>2.1.2、监听生命周期</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        <span class="comment">// 1、继承自DefaultLifecycleObserver 方式</span></span><br><span class="line">        <span class="comment">// 2、使用Lifecycle 进行监听</span></span><br><span class="line">        lifecycle.addObserver(MyObserver())</span><br><span class="line">        <span class="comment">// 2、使用注解方式监听</span></span><br><span class="line">        <span class="comment">// lifecycle.addObserver(MyAptObserver())</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>Activity</code>继承了<code>AppCompatActivity</code>，其父类<code>ComponentActivity</code>默认实现了<code>LifecycleOwner</code>接口</li>
<li>通过<code>getLifecycle()</code>方法直接返回一个<code>Lifecycle</code>对象，可通过该对象的<code>addObserver()</code>方法将<code>Lifecycle</code>与指定的<code>LifecycleObserver</code>进行绑定</li>
</ol>
<p>如果是继承自普通的<code>Activity</code>，则无法直接使用<code>getLifecycle()</code>方法获取<code>Lifecycle</code>，需要自己实现<code>LifecycleOwner</code>接口。</p>
<h2 id="2-2、自定义LifecycleOwner"><a href="#2-2、自定义LifecycleOwner" class="headerlink" title="2.2、自定义LifecycleOwner"></a>2.2、自定义LifecycleOwner</h2><p>如果继承自普通<code>Activity</code>，需要自定义<code>LifecycleOwner</code>接口。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLifecycleOwnerActivity</span> : <span class="type">Activity</span></span>(), LifecycleOwner &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mLifecycleRegistry: LifecycleRegistry</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        mLifecycleRegistry = LifecycleRegistry(<span class="keyword">this</span>)</span><br><span class="line">        <span class="comment">// 1、添加observer</span></span><br><span class="line">        lifecycle.addObserver(MyObserver())</span><br><span class="line">        <span class="comment">// 2、修改状态</span></span><br><span class="line">        mLifecycleRegistry.currentState = Lifecycle.State.CREATED</span><br><span class="line">        <span class="comment">// markstate 废弃， 使用setCurrentState替代</span></span><br><span class="line">        <span class="comment">// mLifecycleRegistry.markState(Lifecycle.State.STARTED)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart()</span><br><span class="line">        mLifecycleRegistry.currentState = Lifecycle.State.STARTED</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPause</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause()</span><br><span class="line">        mLifecycleRegistry.currentState = Lifecycle.State.STARTED</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        mLifecycleRegistry.currentState = Lifecycle.State.DESTROYED</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 实现Lifecycle</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getLifecycle</span><span class="params">()</span></span>: Lifecycle &#123;</span><br><span class="line">        <span class="keyword">return</span> mLifecycleRegistry</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>LifecycleObserver</code>实现组件与<code>LifecycleOwner</code>实现类可以无缝协同，其所有者可提供生命周期，而观察者可以注册以观察生命周期。</p>
<h2 id="2-3、ProcessObserver"><a href="#2-3、ProcessObserver" class="headerlink" title="2.3、ProcessObserver"></a>2.3、ProcessObserver</h2><p>使用<code>ProcessLifecycleOwner</code>可以直接获取应用前后台切换状态（要引入依赖<code>lifecycle-process</code>）</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&quot;androidx.lifecycle:lifecycle-process:$lifecycle_version&quot;</span></span><br></pre></td></tr></table></figure>

<p>使用方式</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> : <span class="type">Application</span></span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;MyApplication&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line">        <span class="comment">//注册App生命周期观察者</span></span><br><span class="line">        ProcessLifecycleOwner.<span class="keyword">get</span>().lifecycle.addObserver(ApplicationLifecycleObserver())</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="class"><span class="keyword">class</span> <span class="title">ApplicationLifecycleObserver</span> : <span class="type">LifecycleEventObserver &#123;</span></span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStateChanged</span><span class="params">(source: <span class="type">LifecycleOwner</span>, event: <span class="type">Lifecycle</span>.<span class="type">Event</span>)</span></span> &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">&quot;ApplicationLifecycleObserver: <span class="variable">$event</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ProcessLifecycleOwner</code> 有如下的特点：</p>
<ol>
<li><code>Lifecycle.Event.ON_CREATE</code>只会分发一次，<code>Lifecycle.Event.ON_DESTROY</code>不会被分发。</li>
<li>第一个<code>Activity</code>进入时，<code>ProcessLifecycleOwner</code>将分派<code>Lifecycle.Event.ON_START</code>, <code>Lifecycle.Event.ON_RESUME</code>。</li>
<li><code>Lifecycle.Event.ON_PAUSE</code>, <code>Lifecycle.Event.ON_STOP</code>，将在最后一个<code>Activit</code>退出后后延迟分发。</li>
</ol>
<p>利用 2、3 我们可以比较方便的监听应用前后台的切换。</p>
<h1 id="三、原理分析"><a href="#三、原理分析" class="headerlink" title="三、原理分析"></a>三、原理分析</h1><p>Lifecycle 中的角色有三个：</p>
<ol>
<li><p>Lifecycle/LifycycleRegistry</p>
<p><strong>持有组件生命周期状态</strong>（如<code>Activity</code>或<code>Fragment</code>）的信息的类，并允许其他对象观察此状态。</p>
<p><code>Lifecycle</code>是一个抽象类，其<strong>唯一实现类是<code>LifecycleRegistry</code></strong></p>
</li>
<li><p>LifecycleOwner</p>
<p><strong>持有生命周期（<code>Lifecycle</code>对象</strong>）；实现<code>LifecycleOwner</code>接口，生命周期的改变会被<code>LifecycleObserver</code>观察到</p>
</li>
<li><p>LifecycleObserver</p>
<p><strong><code>Lifecycle</code>观察者</strong>；实现该接口的类，可以通过被<code>LifecycleOwner</code>类的<code>addObserver()</code>方法注册，被注册后，<code>LifecycleObserver</code>便可以观察到<code>LifecycleOwner</code>的生命周期事件。</p>
</li>
</ol>
<p><code>Lifecycle</code>的原理实现机制图大致如下：</p>
<img src="/pics/image-20220410204032268.png" alt="image-20220410204150137" style="zoom:33%;" />

<p>类之间的关系如下图所示：</p>
<img src="/pics/image-20220410204150137.png" alt="image-20220410204150137" style="zoom:33%;" />

<p>Lifecycle的工作机制可以概括为：</p>
<ol>
<li><code>AppCompatActivity</code>实现了 <code>LifecycleOwner</code> 接口，其 <code>getLifecycle()</code> 方法返回的 <code>Lifecycle</code> 对象为 <code>LifecycleRegistry</code></li>
<li><code>AppCompatActivity</code> 默认挂载了一个无 <code>UI</code> 界面的 <code>Fragment</code>，该<code>Fragment</code> 会根据用户手机的系统版本号高低，用不同的方式获取到 <code>AppCompatActivity</code> 的事件变化通知，最终调用 <code>LifecycleRegistry</code> 的 <code>handleLifecycleEvent()</code> 方法将  <code>Lifecycle.Event</code> 传递出去。此时，<code>LifecycleRegistry</code> 就拿到了  <code>Lifecycle.Event</code></li>
<li><code>LifecycleRegistry</code> 会将外部通过 <code>addObserver</code> 传进来的 <code>LifecycleObserver</code> 对象都给包装成 <code>ObserverWithState</code> 类内部的 <code>LifecycleEventObserver</code> 对象，屏蔽了外部传进来的 <code>LifecycleObserver</code> 的差异性（可能是接口，也可能是注解）</li>
<li><code>LifecycleRegistry</code> 通过直接调用 <code>ObserverWithState</code> 类内部的 <code>LifecycleEventObserver#onStateChanged</code> 方法来完成最终的事件回调。</li>
</ol>
<p>下面详细介绍上以上的各个过程。</p>
<h2 id="3-1、Lifecycle"><a href="#3-1、Lifecycle" class="headerlink" title="3.1、Lifecycle"></a>3.1、Lifecycle</h2><p> <code>MainActivity</code> 继承于<code>AppCompatActivity</code>, <code>AppCompatActivity</code>又继承自<code>ComponentActivity</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">       <span class="comment">// 这行代码分2步讲，第一步介绍lifecycle，第二步介绍addObserver的过程</span></span><br><span class="line">       lifecycle </span><br><span class="line">       .addObserver(MyObserver())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ComponentActivity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComponentActivity</span> <span class="title">extends</span> <span class="title">androidx</span>.<span class="title">core</span>.<span class="title">app</span>.<span class="title">ComponentActivity</span> <span class="title">implements</span></span></span><br><span class="line">    LifecycleOwner,</span><br><span class="line">ViewModelStoreOwner,</span><br><span class="line">SavedStateRegistryOwner,</span><br><span class="line">OnBackPressedDispatcherOwner &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> Lifecycle getLifecycle() &#123;</span><br><span class="line">        <span class="keyword">return</span> mLifecycleRegistry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ComponentActivity</code>实现了<code>LifecycleOwner</code>接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LifecycleOwner</span> </span>&#123;</span><br><span class="line">    <span class="function">Lifecycle <span class="title">getLifecycle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getLifecycle()</code>返回了一个<code>LifecycleRegister</code>对象实例。我们看下<code>Lifecycle</code>的结构</p>
<h3 id="3-1-1、Lifecycle"><a href="#3-1-1、Lifecycle" class="headerlink" title="3.1.1、Lifecycle"></a>3.1.1、Lifecycle</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    AtomicReference&lt;Object&gt; mInternalScopeRef = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(<span class="meta">@NonNull</span> LifecycleObserver observer)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(<span class="meta">@NonNull</span> LifecycleObserver observer)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> State <span class="title">getCurrentState</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;WeakerAccess&quot;)</span></span><br><span class="line">     <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">        ON_CREATE,</span><br><span class="line">        ON_START,</span><br><span class="line">        ON_RESUME,</span><br><span class="line">        ON_PAUSE,</span><br><span class="line">        ON_STOP,</span><br><span class="line">        ON_DESTROY,</span><br><span class="line">        ON_ANY</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="meta">@SuppressWarnings(&quot;WeakerAccess&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">        DESTROYED,</span><br><span class="line">        INITIALIZED,</span><br><span class="line">        CREATED,</span><br><span class="line">        STARTED,</span><br><span class="line">        RESUMED;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAtLeast</span><span class="params">(<span class="meta">@NonNull</span> State state)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> compareTo(state) &gt;= <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>Event</code>与<code>State</code>的关系如下图：</p>
<img src="/pics/lifecycle-states.svg" alt="lifecycle-states.svg" style="zoom:10%;" />

<p>以上的图代表了<code>Events</code> 流转和<code>State</code> 的关系。在讲到 <code>Events</code>分发时我们再进一步解释。</p>
<h3 id="3-1-2、LifecycleRegister"><a href="#3-1-2、LifecycleRegister" class="headerlink" title="3.1.2、LifecycleRegister"></a>3.1.2、LifecycleRegister</h3><p><code>LifecycleRegistry</code>是<code>Lifecycle</code>的唯一实现类，用来实现具体的事件回调和状态管理。</p>
<p>看一下<code>LifecycleRegistry</code>内部实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleRegistry</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Current state</span></span><br><span class="line">    <span class="keyword">private</span> State mState;</span><br><span class="line">     <span class="comment">//持有对 LifecycleOwner 的弱引用，避免内存泄露</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;LifecycleOwner&gt; mLifecycleOwner;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LifecycleRegistry</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner provider)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(provider, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LifecycleRegistry</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner provider, <span class="keyword">boolean</span> enforceMainThread)</span> </span>&#123;</span><br><span class="line">        mLifecycleOwner = <span class="keyword">new</span> WeakReference&lt;&gt;(provider);</span><br><span class="line">        mState = INITIALIZED;</span><br><span class="line">        mEnforceMainThread = enforceMainThread;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ......  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>LifecycleRegistry</code>内部持有了对<code>LifecycleOwner</code>的弱引用。外部可以通过<code>addObserver()</code> 方法向<code>LifecycleRegistry</code> 添加 <code>Observer</code>。<code>Observer</code>内部可能会执行一些耗时操作，耗时操作完成前<code>Activity</code>可能已经<code>Destroy</code>。所以<code>LifecycleRegistry</code> 持有<code>LifcycleOwner</code>的弱引用而不是强引用，避免内存泄漏。</p>
<h2 id="3-2、Lifecycle-addObserver"><a href="#3-2、Lifecycle-addObserver" class="headerlink" title="3.2、Lifecycle#addObserver"></a>3.2、Lifecycle#addObserver</h2><p><code>addObserver</code>的具体实现在 <code>LifecycleRegistry#addObserver</code>中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Lifecycle 类中对 addObserver 方法添加了 @MainThread 注解，此处无需考虑多线程情况</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(<span class="meta">@NonNull</span> LifecycleObserver observer)</span> </span>&#123;</span><br><span class="line">    enforceMainThreadIfNeeded(<span class="string">&quot;addObserver&quot;</span>);</span><br><span class="line">    <span class="comment">//计算初始状态，如果当前Lifecycle状态不为DESTROYED，我们就设置为初始状态</span></span><br><span class="line">    State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;</span><br><span class="line">    <span class="comment">//构造ObserverWithState，即带状态的观察者，这个状态的作用：新的事件触发后 遍历通知所有观察者时，判断是否已经通知这个观察者了</span></span><br><span class="line">    ObserverWithState statefulObserver = <span class="keyword">new</span> ObserverWithState(observer, initialState);</span><br><span class="line">    <span class="comment">//将observer对象和statefulObserver对象添加到FastSafeIterableMap数据结构中</span></span><br><span class="line">    ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//一个observer不能多次加入到同一个Lifecycle中。如果 observer 之前已经传进来过了，则不重复添加，直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();</span><br><span class="line">    <span class="keyword">if</span> (lifecycleOwner == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果 LifecycleOwner 对象已经被回收了，则直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断该添加是否可重入，正常情况该标志永远为false</span></span><br><span class="line">    <span class="comment">//mAddingObserverCounter != 0。</span></span><br><span class="line">    <span class="comment">// 会出现这种情况，是由于开发者先添加了一个 LifecycleObserver ，当还在向其回调事件的过程中，在回调方法里又再次调用了 addObserver 方法添加了一个新的 LifecycleObserver</span></span><br><span class="line">    <span class="keyword">boolean</span> isReentrance = mAddingObserverCounter != <span class="number">0</span> || mHandlingEvent;</span><br><span class="line">    <span class="comment">//计算当前Lifecycle的状态</span></span><br><span class="line">    State targetState = calculateTargetState(observer);</span><br><span class="line">    <span class="comment">//递增加一，标记当前正处于向新添加的 LifecycleObserver 回调 Event 值的过程</span></span><br><span class="line">    mAddingObserverCounter++;</span><br><span class="line">    <span class="comment">//新添加的观察者的状态小于当前状态，将它迁移到当前状态，例如当前状态为RESUMED,则Observer将收到ONCREATE ONSTART ONRESUME事件</span></span><br><span class="line">    <span class="keyword">while</span> ((statefulObserver.mState.compareTo(targetState) &lt; <span class="number">0</span></span><br><span class="line">            &amp;&amp; mObserverMap.contains(observer))) &#123;</span><br><span class="line">        <span class="comment">//将 observer 已经遍历到的当前的状态值 mState 保存下来</span></span><br><span class="line">        pushParentState(statefulObserver.mState);</span><br><span class="line">        <span class="keyword">final</span> Event event = Event.upFrom(statefulObserver.mState);</span><br><span class="line">        <span class="keyword">if</span> (event == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;no event up from &quot;</span> + statefulObserver.mState);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 分发事件</span></span><br><span class="line">        statefulObserver.dispatchEvent(lifecycleOwner, event);</span><br><span class="line">        <span class="comment">// 移除 mState</span></span><br><span class="line">        popParentState();</span><br><span class="line">        targetState = calculateTargetState(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isReentrance) &#123;</span><br><span class="line">        sync();</span><br><span class="line">    &#125;</span><br><span class="line">    mAddingObserverCounter--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>addObserver()</code>函数的主要逻辑是：</p>
<ol>
<li>计算初始状态，如果当前<code>Lifecycle</code>状态不为<code>DESTROYED</code>，我们就设置为初始状态</li>
<li>将传入的<code>observer</code>对象包装为<code>ObserverWithState</code>，判断<code>observer</code>是否已添加到<code>map</code>数据中</li>
<li>若未添加到<code>map</code>中，计算当前<code>Lifecycle</code>的<code>State</code>，通过循环检查方式向<code>ObserverWithState</code>逐步下发<code>Event</code>值</li>
</ol>
<img src="/pics/image-20220410211755494.png" alt="image-20220410211755494" style="zoom:30%;" />

<p>看一下<code>ObserverWithState</code>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverWithState</span> </span>&#123;</span><br><span class="line">    State mState;</span><br><span class="line">    LifecycleEventObserver mLifecycleObserver;</span><br><span class="line"></span><br><span class="line">    ObserverWithState(LifecycleObserver observer, State initialState) &#123;</span><br><span class="line">        <span class="comment">//将Observer传给Lifycycling进行类型包装</span></span><br><span class="line">        mLifecycleObserver = Lifecycling.lifecycleEventObserver(observer);</span><br><span class="line">        mState = initialState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dispatchEvent</span><span class="params">(LifecycleOwner owner, Event event)</span> </span>&#123;</span><br><span class="line">        State newState = event.getTargetState();</span><br><span class="line">        mState = min(mState, newState);</span><br><span class="line">        mLifecycleObserver.onStateChanged(owner, event);</span><br><span class="line">        mState = newState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Lifecycling</code>的处理是为了将</p>
<ol>
<li>使用注解<code>Lifecycle.Event</code>时，最后通过反射或 apt 编译方式调用到的回调</li>
<li>使用继承自<code>DefaultLifecycleObserver和LifecycleEventObserver</code></li>
</ol>
<p>这2种方式的回调都给汇总综合成一个新的 <code>LifecycleEventObserver</code> 对象，从而使得 <code>Event</code> 分发过程都统一为一个入口。</p>
<p><strong><code>Lifecycling#lifecycleEventObserver</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> LifecycleEventObserver <span class="title">lifecycleEventObserver</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isLifecycleEventObserver = object <span class="keyword">instanceof</span> LifecycleEventObserver;</span><br><span class="line">    <span class="keyword">boolean</span> isFullLifecycleObserver = object <span class="keyword">instanceof</span> FullLifecycleObserver;</span><br><span class="line">    <span class="comment">// 1、如果 object 对象同时继承了 LifecycleEventObserver 和 FullLifecycleObserver,则将其包装为FullLifecycleObserverAdapter对象来进行事件转发</span></span><br><span class="line">    <span class="keyword">if</span> (isLifecycleEventObserver &amp;&amp; isFullLifecycleObserver) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FullLifecycleObserverAdapter((FullLifecycleObserver) object,</span><br><span class="line">                                                (LifecycleEventObserver) object);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2、如果 object 对象只继承了 FullLifecycleObserver,也就是继承自DefaultLifecycleObserver 则将其包装为 FullLifecycleObserverAdapter对象来进行事件转发</span></span><br><span class="line">    <span class="keyword">if</span> (isFullLifecycleObserver) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FullLifecycleObserverAdapter((FullLifecycleObserver) object, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、object 是LifecycleEventObserver，直接返回即可</span></span><br><span class="line">    <span class="keyword">if</span> (isLifecycleEventObserver) &#123;</span><br><span class="line">        <span class="keyword">return</span> (LifecycleEventObserver) object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、注解@Lifecycle.Event + APT产生的类</span></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; klass = object.getClass();</span><br><span class="line">    <span class="comment">// 判断 sClassToAdapters Map 中是否存在 XXX_LifecycleAdapter</span></span><br><span class="line">    <span class="keyword">int</span> type = getObserverConstructorType(klass);</span><br><span class="line">    <span class="keyword">if</span> (type == GENERATED_CALLBACK) &#123;</span><br><span class="line">        <span class="comment">// 从 Map 中获取 klass 相关集合</span></span><br><span class="line">        List&lt;Constructor&lt;? extends GeneratedAdapter&gt;&gt; constructors =</span><br><span class="line">            sClassToAdapters.get(klass);</span><br><span class="line">        <span class="keyword">if</span> (constructors.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 根据 XXX_LifecycleAdapter 构造方法创建对象</span></span><br><span class="line">            GeneratedAdapter generatedAdapter = createGeneratedAdapter(</span><br><span class="line">                constructors.get(<span class="number">0</span>), object);</span><br><span class="line">            <span class="comment">// 然后将创建的对象封装在 SingleGeneratedAdapterObserver 对象中</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SingleGeneratedAdapterObserver(generatedAdapter);</span><br><span class="line">        &#125;</span><br><span class="line">        GeneratedAdapter[] adapters = <span class="keyword">new</span> GeneratedAdapter[constructors.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; constructors.size(); i++) &#123;</span><br><span class="line">            adapters[i] = createGeneratedAdapter(constructors.get(i), object);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CompositeGeneratedAdaptersObserver(adapters);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5、注解@Lifecycle.Event + 反射 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReflectiveGenericLifecycleObserver(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过注解的方式来自定义<code>LifecycleObserver</code> 的时候，有2种回调的方式</p>
<h3 id="3-2-1、反射来对注解进行解析"><a href="#3-2-1、反射来对注解进行解析" class="headerlink" title="3.2.1、反射来对注解进行解析"></a>3.2.1、反射来对注解进行解析</h3><p>通过<code>ReflectiveGenericLifecycleObserver</code>进行回调。当然这样会对性能造成一定影响。<code>lifecycle</code> 中增加了缓存，来避免每次都通过反射获取构造器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReflectiveGenericLifecycleObserver</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReflectiveGenericLifecycleObserver</span> <span class="keyword">implements</span> <span class="title">LifecycleEventObserver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object mWrapped;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> androidx.lifecycle.ClassesInfoCache.CallbackInfo mInfo;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStateChanged</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner source, <span class="meta">@NonNull</span> Event event)</span> </span>&#123;</span><br><span class="line">        mInfo.invokeCallbacks(source, event, mWrapped);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// CallbackInfo</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallbackInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Map&lt;Lifecycle.Event, List&lt;MethodReference&gt;&gt; mEventToHandlers;</span><br><span class="line">    <span class="keyword">final</span> Map&lt;MethodReference, Lifecycle.Event&gt; mHandlerToEvent;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;ConstantConditions&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invokeCallbacks</span><span class="params">(LifecycleOwner source, Lifecycle.Event event, Object target)</span> </span>&#123;</span><br><span class="line">        invokeMethodsForEvent(mEventToHandlers.get(event), source, event, target);</span><br><span class="line">        invokeMethodsForEvent(mEventToHandlers.get(Lifecycle.Event.ON_ANY), source, event,</span><br><span class="line">                target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeMethodsForEvent</span><span class="params">(List&lt;MethodReference&gt; handlers,</span></span></span><br><span class="line"><span class="params"><span class="function">            LifecycleOwner source, Lifecycle.Event event, Object mWrapped)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handlers != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = handlers.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                handlers.get(i).invokeCallback(source, event, mWrapped);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-2、使用-apt-注解处理器"><a href="#3-2-2、使用-apt-注解处理器" class="headerlink" title="3.2.2、使用 apt 注解处理器"></a>3.2.2、使用 <code>apt</code> 注解处理器</h3><p>在编译时对那些被<code>@OnLifecycleEvent</code>注解标注的普通方法，进行预处理，生成以“<code>类名_LifecycleAdapter</code>”命名的类，将各种回调方法通过<code>SingleGeneratedAdapterObserver 或 CompositeGeneratedAdaptersObserver</code>直接进行逻辑转换，避免反射，进而来提高性能。使用 <code>apt</code> 需要引入以下的依赖。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Annotation processor</span></span><br><span class="line">kapt <span class="string">&quot;androidx.lifecycle:lifecycle-compiler:$lifecycle_version&quot;</span></span><br><span class="line"><span class="comment">// alternately - if using Java8, use the following instead of lifecycle-compiler</span></span><br><span class="line">implementation <span class="string">&quot;androidx.lifecycle:lifecycle-common-java8:$lifecycle_version&quot;</span></span><br></pre></td></tr></table></figure>

<p>引入后会自动生成以下的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAptObserver_LifecycleAdapter</span> <span class="keyword">implements</span> <span class="title">GeneratedAdapter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> MyAptObserver mReceiver;</span><br><span class="line"></span><br><span class="line">  MyAptObserver_LifecycleAdapter(MyAptObserver receiver) &#123;</span><br><span class="line">    <span class="keyword">this</span>.mReceiver = receiver;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callMethods</span><span class="params">(LifecycleOwner owner, Lifecycle.Event event, <span class="keyword">boolean</span> onAny,</span></span></span><br><span class="line"><span class="params"><span class="function">      MethodCallsLogger logger)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> hasLogger = logger != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (onAny) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (event == Lifecycle.Event.ON_CREATE) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!hasLogger || logger.approveCall(<span class="string">&quot;onCreate&quot;</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        mReceiver.onCreate();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (event == Lifecycle.Event.ON_RESUME) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!hasLogger || logger.approveCall(<span class="string">&quot;connectListener&quot;</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        mReceiver.connectListener();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (event == Lifecycle.Event.ON_PAUSE) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!hasLogger || logger.approveCall(<span class="string">&quot;disconnectListener&quot;</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        mReceiver.disconnectListener();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (event == Lifecycle.Event.ON_DESTROY) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!hasLogger || logger.approveCall(<span class="string">&quot;destroy&quot;</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        mReceiver.destroy();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们的事件是声明在<code>MyObserver</code>的方法注解上面的,每次去反射取这些东西,比较耗性能.那么我们通过该依赖库,把这些标注了的方法进行预处理,然后直接回调这些方法,避免反射,进行提高性能</p>
<p>分析前述的<code>lifecycleEventObserver</code>方法发现，因为<code>MyObserver_LifecycleAdapter</code>只有一个构造方法,那么就会构造出<code>SingleGeneratedAdapterObserver</code>，而<code>SingleGeneratedAdapterObserver</code>内部其实就是调用一下方法而已</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleGeneratedAdapterObserver</span> <span class="keyword">implements</span> <span class="title">LifecycleEventObserver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> GeneratedAdapter mGeneratedAdapter;</span><br><span class="line"></span><br><span class="line">    SingleGeneratedAdapterObserver(GeneratedAdapter generatedAdapter) &#123;</span><br><span class="line">        mGeneratedAdapter = generatedAdapter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStateChanged</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner source, <span class="meta">@NonNull</span> Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">        mGeneratedAdapter.callMethods(source, event, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        mGeneratedAdapter.callMethods(source, event, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的<code>mGeneratedAdapter</code>其实就是我们的<code>MyAptObserver_LifecycleAdapter</code>。            </p>
<h2 id="3-3、事件分发"><a href="#3-3、事件分发" class="headerlink" title="3.3、事件分发"></a>3.3、事件分发</h2><p>让我们回到<code>ComponentActivity</code>，我们知道生命周期的事件一定是由生命周期组件分发出来的。下面就来探寻下生命周期事件是如何分发出来的。</p>
<p><strong><code>ComponentActivity#onCreate</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    mSavedStateRegistryController.performRestore(savedInstanceState);</span><br><span class="line">    <span class="comment">// 初始化 ReportFragment</span></span><br><span class="line">    ReportFragment.injectIfNeededIn(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (mContentLayoutId != <span class="number">0</span>) &#123;</span><br><span class="line">        setContentView(mContentLayoutId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-1、ReportFragment-injectIfNeededIn"><a href="#3-3-1、ReportFragment-injectIfNeededIn" class="headerlink" title="3.3.1、ReportFragment#injectIfNeededIn"></a>3.3.1、<code>ReportFragment#injectIfNeededIn</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectIfNeededIn</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1、</span></span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">29</span>) &#123;</span><br><span class="line">        LifecycleCallbacks.registerIn(activity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2、</span></span><br><span class="line">    android.app.FragmentManager manager = activity.getFragmentManager();</span><br><span class="line">    <span class="keyword">if</span> (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        manager.beginTransaction().add(<span class="keyword">new</span> ReportFragment(), REPORT_FRAGMENT_TAG).commit();</span><br><span class="line">        <span class="comment">// Hopefully, we are the first to make a transaction.</span></span><br><span class="line">        manager.executePendingTransactions();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ReportFragment</code> 的 <code>injectIfNeededIn()</code> 函数会根据两种情况来进行事件分发</p>
<ul>
<li><p>运行设备的系统版本号大于或等于29。</p>
<p>此情况会向 <code>Activity</code> 注册一个 <code>LifecycleCallbacks</code> ，以此来直接获得各个生命周期事件的回调通知。</p>
</li>
<li><p>运行设备的系统版本号小于 29。</p>
<p>此情况会通过向 <code>Activity</code> 添加一个无 <code>UI</code> 界面的 <code>Fragment</code>（即 <code>ReportFragment</code>），间接获得 <code>Activity</code> 的各个生命周期事件的回调通知</p>
</li>
</ul>
<p><code>injectIfNeededIn()</code>根据两种情况来进行事件分发，这是因为<code>registerActivityLifecycleCallbacks</code> 是 <code>SDK 29</code> 时 <code>android.app.Activity</code> 新添加的方法，从这个版本开始支持直接在 <code>LifecycleCallbacks</code> 中取得事件通知。</p>
<p><strong><code>SDK&gt;=29</code>的情况</strong></p>
<p>通过<code>LifeCycleCallbacks</code>进行事件分发。就是在<code>Activity</code>类的 <code>onCreate、onStart、onResume</code> 等方法被<strong>调用后</strong>通过 <code>dispatch()</code> 方法发送相应的 <code>Event</code> 值，并在 <code>onPause、onStop、onDestroy</code> 等方法被<strong>调用前</strong>发送相应的 <code>Event</code> 值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequiresApi(29)</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleCallbacks</span> <span class="keyword">implements</span> <span class="title">Application</span>.<span class="title">ActivityLifecycleCallbacks</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerIn</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        activity.registerActivityLifecycleCallbacks(<span class="keyword">new</span> LifecycleCallbacks());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(<span class="meta">@NonNull</span> Activity activity,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="meta">@Nullable</span> Bundle bundle)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityPostCreated</span><span class="params">(<span class="meta">@NonNull</span> Activity activity,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">// ReportFragment#dispatch</span></span><br><span class="line">        dispatch(activity, Lifecycle.Event.ON_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略部分相似代码</span></span><br><span class="line">    ···</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityPreDestroyed</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> </span>&#123;</span><br><span class="line">        dispatch(activity, Lifecycle.Event.ON_DESTROY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityDestroyed</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>SDK&lt;29</code>的情况</strong></p>
<p><code>ReportFragment</code>本身生命周期和所在的<code>Activity</code>是相关联的。通过在 <code>ReportFragment</code> 相应的生命周期函数里调用 <code>dispatch()</code> 函数发送相应的 <code>Event</code> 值，以此来间接获得 <code>Activity </code>的各个生命周期事件的回调通知</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReportFragment</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">app</span>.<span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onActivityCreated(savedInstanceState);</span><br><span class="line">        <span class="comment">// 后面单独说</span></span><br><span class="line">        dispatchCreate(mProcessListener);</span><br><span class="line">        dispatch(Lifecycle.Event.ON_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        dispatchStart(mProcessListener);</span><br><span class="line">        dispatch(Lifecycle.Event.ON_START);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(<span class="meta">@NonNull</span> Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="number">29</span>) &#123;</span><br><span class="line">            dispatch(getActivity(), event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>dispatch()</code>函数内部会判断目标设备版本号来决定是否真的分发<code>Event</code>值，避免当 <code>SDK</code> 版本号大于 <code>29</code> 时和 <code>LifecycleCallbacks</code> 重复发送。</p>
<p><strong><code>ReportFragment#dispatch</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(<span class="meta">@NonNull</span> Activity activity, <span class="meta">@NonNull</span> Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> LifecycleRegistryOwner) &#123;</span><br><span class="line">        ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> LifecycleOwner) &#123;</span><br><span class="line">        Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();</span><br><span class="line">        <span class="keyword">if</span> (lifecycle <span class="keyword">instanceof</span> LifecycleRegistry) &#123;</span><br><span class="line">            ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>dispatch()</code> 方法拿到 <code>Event</code> 值后，通过 <code>activity</code> 拿到 <code>Lifecycle</code> 对象。之后再通过类型判断拿到<code>LifecycleRegistry</code> 对象，最终通过调用<code>handleLifecycleEvent()</code> 方法将 <code>Event</code> 值传递出去，使外部得到各生命周期事件通知。</p>
<h3 id="3-3-2、LifecycleRegistry-handleLifecycleEvent"><a href="#3-3-2、LifecycleRegistry-handleLifecycleEvent" class="headerlink" title="3.3.2、LifecycleRegistry#handleLifecycleEvent"></a>3.3.2、<strong>LifecycleRegistry#handleLifecycleEvent</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleLifecycleEvent</span><span class="params">(<span class="meta">@NonNull</span> Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">    enforceMainThreadIfNeeded(<span class="string">&quot;handleLifecycleEvent&quot;</span>);</span><br><span class="line">    moveToState(event.getTargetState());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToState</span><span class="params">(State next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mState == next) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mState = next;</span><br><span class="line">    <span class="keyword">if</span> (mHandlingEvent || mAddingObserverCounter != <span class="number">0</span>) &#123;</span><br><span class="line">        mNewEventOccurred = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// we will figure out what to do on upper level.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mHandlingEvent = <span class="keyword">true</span>;</span><br><span class="line">    sync();</span><br><span class="line">    mHandlingEvent = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>LifecycleRegistry#sync()</code>，将生命周期同步给所有观察者。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();</span><br><span class="line">    <span class="keyword">if</span> (lifecycleOwner == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;LifecycleOwner of this LifecycleRegistry is already&quot;</span></span><br><span class="line">                                        + <span class="string">&quot;garbage collected. It is too late to change lifecycle state.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环遍历所有观察者</span></span><br><span class="line">    <span class="keyword">while</span> (!isSynced()) &#123;	<span class="comment">//判断所有的观察者是否都同步完了？</span></span><br><span class="line">        mNewEventOccurred = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//根据当前状态和mObserverMap中的eldest(最老的观察者)和newest（最新的观察者）的状态做对比 ，判断当前状态是向前还是向后，比如由STARTED到RESUMED是状态向前，反过来就是状态向后</span></span><br><span class="line">        <span class="keyword">if</span> (mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//向后分发事件</span></span><br><span class="line">            backwardPass(lifecycleOwner);</span><br><span class="line">        &#125;</span><br><span class="line">        Entry&lt;LifecycleObserver, ObserverWithState&gt; newest = mObserverMap.newest();</span><br><span class="line">        <span class="keyword">if</span> (!mNewEventOccurred &amp;&amp; newest != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; mState.compareTo(newest.getValue().mState) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//向前分发事件</span></span><br><span class="line">            forwardPass(lifecycleOwner);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mNewEventOccurred = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Sync</code>方法主要内容为：</p>
<ol>
<li>首先判断所有的观察者是否都已状态同步；如果未同步，则进行状态比较</li>
<li>将当前<code>Lifecycle</code>的<code>State</code>和所有<code>Observer</code>的<code>State</code>比较，判断执行<code>backwardpass</code>还是<code>forwardPass</code>方法。</li>
</ol>
<p>看一下<code>isSynced()</code>和<code>forwardPass()</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSynced</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mObserverMap.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// mObserverMap 保存着注册到这个组件上的所有observer</span></span><br><span class="line">    <span class="comment">// 如果第一个Observer 和 最后一个 Obsever的state 和 mState相同，说明所有observer的生命周期都已经分发过了</span></span><br><span class="line">    State eldestObserverState = mObserverMap.eldest().getValue().mState;</span><br><span class="line">    State newestObserverState = mObserverMap.newest().getValue().mState;</span><br><span class="line">    <span class="keyword">return</span> eldestObserverState == newestObserverState &amp;&amp; mState == newestObserverState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">forwardPass</span><span class="params">(LifecycleOwner lifecycleOwner)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取一个按添加Observer顺序的迭代器</span></span><br><span class="line">    Iterator&lt;Map.Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; ascendingIterator =</span><br><span class="line">        mObserverMap.iteratorWithAdditions();</span><br><span class="line">    <span class="comment">//遍历所有Observer</span></span><br><span class="line">    <span class="keyword">while</span> (ascendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) &#123;</span><br><span class="line">        Map.Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = ascendingIterator.next();</span><br><span class="line">        ObserverWithState observer = entry.getValue();</span><br><span class="line">        <span class="comment">//如果当前Observer的State小于mState,则递增当前状态，</span></span><br><span class="line">        <span class="keyword">while</span> ((observer.mState.compareTo(mState) &lt; <span class="number">0</span> &amp;&amp; !mNewEventOccurred</span><br><span class="line">                &amp;&amp; mObserverMap.contains(entry.getKey()))) &#123;</span><br><span class="line">            pushParentState(observer.mState);</span><br><span class="line">            <span class="comment">// 递增当前状态</span></span><br><span class="line">            <span class="keyword">final</span> Event event = Event.upFrom(observer.mState);</span><br><span class="line">            <span class="keyword">if</span> (event == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;no event up from &quot;</span> + observer.mState);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 分发事件，ObserverWithState#dispatchEvent</span></span><br><span class="line">            observer.dispatchEvent(lifecycleOwner, event);</span><br><span class="line">            popParentState();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>forwardPass()</code>方法：</p>
<ol>
<li>首先获取一个按添加<code>Observer</code>顺序的迭代器，然后遍历所有的<code>Observer</code>，注意这里的observer 是<code>ObserverWithState</code>对象</li>
<li>对每一个<code>Observer</code>，递增其状态并通过<code>dispatchEvent</code>分发生命周期事件，直到其状态递增到<code>Lifecycle</code>的<code>mState</code>为止。</li>
<li>对应图中的 <code>INITIALIZED -&gt; RESUMED</code></li>
</ol>
<p>联系上一节，通过Observer完成了状态同步和事件分发。</p>
<h2 id="3-4、ProcessLifecycleOwner"><a href="#3-4、ProcessLifecycleOwner" class="headerlink" title="3.4、ProcessLifecycleOwner"></a>3.4、ProcessLifecycleOwner</h2><p><code>ReportFragment</code>在生命周期方法中也调用了<code>dispatchCreate()</code>，和进程的生命周期相关</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onActivityCreated(savedInstanceState);</span><br><span class="line">    <span class="comment">// 进程生命周期</span></span><br><span class="line">    dispatchCreate(mProcessListener);</span><br><span class="line">    dispatch(Lifecycle.Event.ON_CREATE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchCreate</span><span class="params">(ActivityInitializationListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">        listener.onCreate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下<code>mProcessListener</code>在哪里设置的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReportFragment</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">app</span>.<span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">ActivityInitializationListener</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-1、ProcessLifecycleOwner"><a href="#3-4-1、ProcessLifecycleOwner" class="headerlink" title="3.4.1、ProcessLifecycleOwner"></a>3.4.1、<code>ProcessLifecycleOwner</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessLifecycleOwner</span> <span class="keyword">implements</span> <span class="title">LifecycleOwner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@VisibleForTesting</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TIMEOUT_MS = <span class="number">700</span>; <span class="comment">//mls</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Handler mHandler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LifecycleRegistry mRegistry = <span class="keyword">new</span> LifecycleRegistry(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 1、onPasue 和 onStop 是延迟触发的</span></span><br><span class="line">    <span class="keyword">private</span> Runnable mDelayedPauseRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            dispatchPauseIfNeeded();</span><br><span class="line">            dispatchStopIfNeeded();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">		<span class="comment">// 2、&lt;29 会通过在ReportFragment中对这个Listener进行生命周期的回调</span></span><br><span class="line">    ActivityInitializationListener mInitializationListener =</span><br><span class="line">            <span class="keyword">new</span> ActivityInitializationListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    activityStarted();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    activityResumed();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ProcessLifecycleOwner sInstance = <span class="keyword">new</span> ProcessLifecycleOwner();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LifecycleOwner <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sInstance;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 3、Provider 启动时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        sInstance.attach(context);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 4、只有首次启动 start 和 resume 才会分发成功</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">activityStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mStartedCounter++;</span><br><span class="line">        <span class="keyword">if</span> (mStartedCounter == <span class="number">1</span> &amp;&amp; mStopSent) &#123;</span><br><span class="line">            mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START);</span><br><span class="line">            mStopSent = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">activityResumed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mResumedCounter++;</span><br><span class="line">        <span class="keyword">if</span> (mResumedCounter == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mPauseSent) &#123;</span><br><span class="line">                mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_RESUME);</span><br><span class="line">                mPauseSent = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mHandler.removeCallbacks(mDelayedPauseRunnable);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 5、pause 和 stop 会延迟 700ms 调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">activityPaused</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mResumedCounter--;</span><br><span class="line">        <span class="keyword">if</span> (mResumedCounter == <span class="number">0</span>) &#123;</span><br><span class="line">            mHandler.postDelayed(mDelayedPauseRunnable, TIMEOUT_MS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">activityStopped</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mStartedCounter--;</span><br><span class="line">        dispatchStopIfNeeded();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dispatchPauseIfNeeded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mResumedCounter == <span class="number">0</span>) &#123;</span><br><span class="line">            mPauseSent = <span class="keyword">true</span>;</span><br><span class="line">            mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dispatchStopIfNeeded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mStartedCounter == <span class="number">0</span> &amp;&amp; mPauseSent) &#123;</span><br><span class="line">            mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_STOP);</span><br><span class="line">            mStopSent = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ProcessLifecycleOwner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        mHandler = <span class="keyword">new</span> Handler();</span><br><span class="line">       <span class="comment">// 6、首次启动先分发 ON_CREATE</span></span><br><span class="line">        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);</span><br><span class="line">        Application app = (Application) context.getApplicationContext();</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 7、给所有的Activity 注册一个 Lifecycle 用来处理， application 的onStart 和 onResume 的周期，这样做的目的是为了保证 onStart/onResume 一定在 activity#onStart/onResume之前</span></span><br><span class="line">        app.registerActivityLifecycleCallbacks(<span class="keyword">new</span> EmptyActivityLifecycleCallbacks() &#123;</span><br><span class="line">            <span class="meta">@RequiresApi(29)</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityPreCreated</span><span class="params">(<span class="meta">@NonNull</span> Activity activity,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">								</span><br><span class="line">                activity.registerActivityLifecycleCallbacks(<span class="keyword">new</span> EmptyActivityLifecycleCallbacks() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityPostStarted</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> </span>&#123;</span><br><span class="line">                        activityStarted();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityPostResumed</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> </span>&#123;</span><br><span class="line">                        activityResumed();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Activity activity, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">               <span class="comment">// 8、 &lt; 29时 需要通过ReportFragment 分发Process事件</span></span><br><span class="line">                <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="number">29</span>) &#123;</span><br><span class="line">                    ReportFragment.get(activity).setProcessListener(mInitializationListener);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityPaused</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">                activityPaused();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityStopped</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">                activityStopped();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Lifecycle <span class="title">getLifecycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mRegistry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟着<code>ProcessLifecycleOwner</code>的<code>init()</code>方法的调用处，来到了<code>ProcessLifecycleOwnerInitializer</code></p>
<h3 id="3-4-2、ProcessLifecycleInitializer"><a href="#3-4-2、ProcessLifecycleInitializer" class="headerlink" title="3.4.2、ProcessLifecycleInitializer"></a>3.4.2、<code>ProcessLifecycleInitializer</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessLifecycleInitializer</span> <span class="keyword">implements</span> <span class="title">Initializer</span>&lt;<span class="title">LifecycleOwner</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LifecycleOwner <span class="title">create</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1、初始化 LifecycleDispatcher</span></span><br><span class="line">        LifecycleDispatcher.init(context);</span><br><span class="line">        <span class="comment">// 2、初始化 ProcessLifecycleOwner</span></span><br><span class="line">        ProcessLifecycleOwner.init(context);</span><br><span class="line">        <span class="keyword">return</span> ProcessLifecycleOwner.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里发现了<code>LifecycleDispatcher</code>的初始化方法，我们来细看一下整个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LifecycleDispatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicBoolean sInitialized = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sInitialized.getAndSet(<span class="keyword">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1、注册一个监听器</span></span><br><span class="line">        ((Application) context.getApplicationContext())</span><br><span class="line">                .registerActivityLifecycleCallbacks(<span class="keyword">new</span> DispatcherActivityCallback());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;WeakerAccess&quot;)</span></span><br><span class="line">    <span class="meta">@VisibleForTesting</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherActivityCallback</span> <span class="keyword">extends</span> <span class="title">EmptyActivityLifecycleCallbacks</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Activity activity, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 2、onActivityCreated时注入一个ReportFragment</span></span><br><span class="line">            ReportFragment.injectIfNeededIn(activity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityStopped</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivitySaveInstanceState</span><span class="params">(Activity activity, Bundle outState)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LifecycleDispatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结下以上：</p>
<ol>
<li><code>ProcessLifecycleInitializer</code>在<code>ContentProvider#onCreate()</code>中初始化，并调用到<code>LifecycleDispatcher</code>和<code>ProcessLifecycleOwner</code>的初始化</li>
</ol>
<img src="/pics/image-20220410232611050.png" alt="image-20220410232611050" style="zoom:40%;" />

<ol start="2">
<li><code>LifecycleDispatcher</code>初始化时，为所有的<code>activity</code>设置监听，当<code>onActivityCreated</code>时注入一个<code>ReportFragment</code>。<code>ComponentActivity#onCreate</code>中也会注入<code>ReportFragment</code>，如果这里先注入成功了，那么<code>ComponentActivity</code> 就不会重复注入。</li>
<li><code>ProcessLifecycleOwner</code>是一个全局单例，<code>ProcessLifecycleOwner中，</code>通过<code>registerActivityLifecycleCallbacks</code> 监听应用的生命周期。如果是 <code>&lt;29 </code>，会将 <code>ActivityInitializationListener</code> 注入到<code>ReporFragment中</code>实现，从而实现对<code>activity</code>生命周期的监听。</li>
</ol>
<h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>关于<code>Lifecycle</code>的使用和解析如前述所示，但是在使用时有几点需要注意：</p>
<ol>
<li><code>Lifecycle</code>有状态倒灌过程，也就是在任意生命周期中注册<code>LifecycleObserver</code>，这个<code>LifecycleObserver</code>会把前面的生命周期回调都执行一遍，直到和注册时的生命周期状态同步。</li>
<li>在<code>Activity/Fragment</code>重写生命周期方法时，必须调用父类的相应方法，因为<code>Lifecycle</code>的生命周期分发在父类的相应生命周期方法中</li>
<li><code>LifecycleObserver</code>是使用的一个<code>Map</code>来存的，虽然<code>LifecycleObserver</code>是<code>Map</code>的<code>Key</code>，但其实也是当成一个<code>List&lt;Pair&lt;LifecycleObserver,xxx&gt;&gt;</code>来存在的，也就是说从根本上来说还是一个<code>List</code>，但同一个<code>Observer</code>只能存一份，如果一个<code>LifecycleObserver</code>被<code>add</code>了两次，那么生命周期方法也只会回调一次。</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/Liberty_zw/article/details/84587257">https://blog.csdn.net/Liberty_zw/article/details/84587257</a></p>
<p><a href="https://juejin.cn/post/7064964028434481159#heading-12">https://juejin.cn/post/7064964028434481159#heading-12</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>Jetpack</category>
      </categories>
  </entry>
  <entry>
    <title>Jetpack_04_WorkManager使用</title>
    <url>/2022/05/14/Notes/Android/03Jetpack/Jetpack_04_WorkManager%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Jetpack-04-WorkManager使用"><a href="#Jetpack-04-WorkManager使用" class="headerlink" title="Jetpack_04_WorkManager使用"></a>Jetpack_04_WorkManager使用</h1><span id="more"></span>

<h1 id="一、为什么使用WorkManager"><a href="#一、为什么使用WorkManager" class="headerlink" title="一、为什么使用WorkManager"></a>一、为什么使用WorkManager</h1><p><a href="https://developer.android.com/reference/androidx/work/WorkManager?hl=zh-cn">WorkManager</a> 是适合用于持久性工作的推荐解决方案。如果工作始终要通过应用重启和系统重新启动来调度，便是永久性的工作。由于大多数后台处理操作都是通过持久性工作完成的，因此 WorkManager 是适用于后台处理操作的主要推荐 API。</p>
<p><strong>持久性工作的类型</strong></p>
<p>WorkManager 可处理三种类型的永久性工作：</p>
<ul>
<li><strong>立即执行</strong>：必须立即开始且很快就完成的任务，可以加急。</li>
<li><strong>长时间运行</strong>：运行时间可能较长（有可能超过 10 分钟）的任务。</li>
<li><strong>可延期执行</strong>：延期开始并且可以定期运行的预定任务。</li>
</ul>
<img src="/pics/image-20220514154916176.png" alt="image-20220514154916176" style="zoom:40%;" />

<h1 id="二、基本使用"><a href="#二、基本使用" class="headerlink" title="二、基本使用"></a>二、基本使用</h1><blockquote>
<p>本文Demo基于<code>workManager 2.7.1</code>版本源码，程序demo基于<code>sdk 31</code></p>
</blockquote>
<p><strong>引入依赖</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    def work_version = &quot;2.7.1&quot;</span><br><span class="line"></span><br><span class="line">    // (Java only)</span><br><span class="line">    implementation &quot;androidx.work:work-runtime:$work_version&quot;</span><br><span class="line"></span><br><span class="line">    // Kotlin + coroutines</span><br><span class="line">    implementation &quot;androidx.work:work-runtime-ktx:$work_version&quot;</span><br><span class="line"></span><br><span class="line">    // optional - RxJava2 support</span><br><span class="line">    implementation &quot;androidx.work:work-rxjava2:$work_version&quot;</span><br><span class="line"></span><br><span class="line">    // optional - GCMNetworkManager support</span><br><span class="line">    implementation &quot;androidx.work:work-gcm:$work_version&quot;</span><br><span class="line"></span><br><span class="line">    // optional - Test helpers</span><br><span class="line">    androidTestImplementation &quot;androidx.work:work-testing:$work_version&quot;</span><br><span class="line"></span><br><span class="line">    // optional - Multiprocess support</span><br><span class="line">    implementation &quot;androidx.work:work-multiprocess:$work_version&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-1、简单使用"><a href="#2-1、简单使用" class="headerlink" title="2.1、简单使用"></a>2.1、简单使用</h2><p><code>WorkManager</code> 的使用步骤分为：</p>
<ol>
<li>定义 <code>Worker</code>，执行具体的后台逻辑</li>
<li>创建<code>WorkRequest</code>，配置任务的后台执行方式</li>
<li>使用 <code>WorkerManager</code>执行任务</li>
</ol>
<h3 id="1、定义Worker"><a href="#1、定义Worker" class="headerlink" title="1、定义Worker"></a>1、定义Worker</h3><p>工作使用 <code>Worker</code> 类定义。<code>doWork()</code> 方法在 WorkManager 提供的后台线程上异步运行。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UploadWorker</span></span>(appContext: Context, workerParams: WorkerParameters):</span><br><span class="line">    Worker(appContext, workerParams) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;UploadWorker&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span>: Result &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;Thread = <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do the work here--in this case, upload the images.</span></span><br><span class="line">        uploadImages()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Indicate whether the work finished successfully with the Result</span></span><br><span class="line">        <span class="keyword">return</span> Result.success()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">uploadImages</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;uploadImages start&quot;</span>)</span><br><span class="line">        Thread.sleep(<span class="number">3</span> * <span class="number">1000L</span>)</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;uploadImages end&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 <code>doWork()</code> 返回的 <code>Result</code> 会通知 WorkManager 服务工作是否成功，以及工作失败时是否应重试工作。</p>
<ul>
<li><code>Result.success()</code>：工作成功完成。</li>
<li><code>Result.failure()</code>：工作失败。</li>
<li><code>Result.retry()</code>：工作失败，应根据其<a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/define-work?hl=zh-cn#retries_backoff">重试政策</a>在其他时间尝试。</li>
</ul>
<h3 id="2、创建WorkRequest"><a href="#2、创建WorkRequest" class="headerlink" title="2、创建WorkRequest"></a>2、创建WorkRequest</h3><p><code>WorkRequest</code>用于定义如何调度工作，可以将工作安排为在某段时间内<a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/define-work?hl=zh-cn#schedule_periodic_work">定期运行 PeriodicWorkRequest</a> ，也可以将其安排为仅运行<a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/define-work?hl=zh-cn#constraints">一次 OneTimeWorkRequest</a>。最简单的情况下，使用 <code>OneTimeWorkRequest</code>，如以下示例所示</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> request0: WorkRequest =</span><br><span class="line">    OneTimeWorkRequestBuilder&lt;UploadWorker&gt;()</span><br><span class="line">         <span class="comment">// 延迟启动   </span></span><br><span class="line">        .setInitialDelay(<span class="number">3</span>, TimeUnit.SECONDS)</span><br><span class="line">        .build()</span><br></pre></td></tr></table></figure>

<p>创建<code>WorkRequest</code>时，需要使用 <code>WorkRequest.Builder</code>，可以设置任务执行的启动延迟，约束条件 <code>Constraints</code> 等。下一节介绍。</p>
<h3 id="3、将-WorkRequest-提交给系统"><a href="#3、将-WorkRequest-提交给系统" class="headerlink" title="3、将 WorkRequest 提交给系统"></a>3、将 WorkRequest 提交给系统</h3><p>最后，使用 <code>enqueue()</code> 方法将 <code>WorkRequest</code> 提交到 <code>WorkManager</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WorkManager</span><br><span class="line">    .getInstance(myContext)</span><br><span class="line">    .enqueue(request0)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：执行工作器的确切时间取决于 <code>WorkRequest</code> 中使用的约束和系统优化方式。<code>WorkManager </code>经过设计，能够在满足这些约束的情况下提供最佳行为。</p>
</blockquote>
<h2 id="2-2、PeriodicWorkRequest"><a href="#2-2、PeriodicWorkRequest" class="headerlink" title="2.2、PeriodicWorkRequest"></a>2.2、PeriodicWorkRequest</h2><p>除了一次性工作<code>OneTimeWorkRequest</code>外，当我们需要定时执行某些工作。例如，定期备份数据、定期下载应用中的新鲜内容或者定期上传日志到服务器。</p>
<p>可以使用 <code>PeriodicWorkRequest</code> 创建定期执行的 <code>WorkRequest</code> 对象的方法如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> saveRequest =</span><br><span class="line">       PeriodicWorkRequestBuilder&lt;SaveImageToFileWorker&gt;(<span class="number">1</span>, TimeUnit.HOURS)</span><br><span class="line">    <span class="comment">// Additional configuration</span></span><br><span class="line">           .build()</span><br></pre></td></tr></table></figure>

<p>以上示例中，工作的运行时间间隔定为一小时。</p>
<h3 id="灵活的运行间隔"><a href="#灵活的运行间隔" class="headerlink" title="灵活的运行间隔"></a>灵活的运行间隔</h3><p>有些情况下仅限定时间隔是不够的，比如定时下载任务可能会导致服务器集中请求，导致CDN带宽波动较大，这种情况下可以使用 <code>PeriodicWorkRequest</code> 配置为在每个时间间隔的<strong>灵活时间段</strong>内运行。</p>
<p><img src="https://developer.android.com/images/topic/libraries/architecture/workmanager/how-to/definework-flex-period.png?hl=zh-cn" alt="您可以为定期作业设置一个灵活间隔。您要定义一个重复间隔，然后再定义一个灵活间隔（指定一个在重复间隔末尾开始的具体时间段）。WorkManager 会尝试在每个周期的灵活间隔内运行作业。"></p>
<p>创建 <code>PeriodicWorkRequest</code> 时传递 <code>flexInterval</code> 以及 <code>repeatInterval</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val myUploadWork = PeriodicWorkRequestBuilder&lt;SaveImageToFileWorker&gt;(</span><br><span class="line">       1, TimeUnit.HOURS, // repeatInterval (the period cycle)</span><br><span class="line">       15, TimeUnit.MINUTES) // flexInterval</span><br><span class="line">    .build()</span><br></pre></td></tr></table></figure>

<p>这样的话，我们的任务执行间隔就是范围的<code>[repeatInterval - flexInterval ,repeatInterval]</code>。</p>
<blockquote>
<p>repeatInterval 的最小值是 15分钟，flexInterval 的最小值时 5 分钟</p>
</blockquote>
<h1 id="三、WorkRequest配置"><a href="#三、WorkRequest配置" class="headerlink" title="三、WorkRequest配置"></a>三、WorkRequest配置</h1><p>下面我们介绍下 <code>WorkRequest</code>相关的配置</p>
<h2 id="3-1、工作约束"><a href="#3-1、工作约束" class="headerlink" title="3.1、工作约束"></a>3.1、工作约束</h2><p><a href="https://developer.android.com/reference/androidx/work/Constraints?hl=zh-cn">约束<code>Constraints</code></a>可确保将工作延迟到满足最佳条件时运行。以下约束适用于 WorkManager。</p>
<table>
<thead>
<tr>
<th><strong>NetworkType</strong></th>
<th>约束运行工作所需的<a href="https://developer.android.com/reference/androidx/work/NetworkType?hl=zh-cn">网络类型</a>。例如 Wi-Fi (<code>UNMETERED</code>)。</th>
</tr>
</thead>
<tbody><tr>
<td><strong>BatteryNotLow</strong></td>
<td>如果设置为 true，那么当设备处于“电量不足模式”时，工作不会运行。</td>
</tr>
<tr>
<td><strong>RequiresCharging</strong></td>
<td>如果设置为 true，那么工作只能在设备充电时运行。</td>
</tr>
<tr>
<td><strong>DeviceIdle</strong></td>
<td>如果设置为 true，则要求用户的设备必须处于空闲状态，才能运行工作。在运行批量操作时，此约束会非常有用；若是不用此约束，批量操作可能会降低用户设备上正在积极运行的其他应用的性能。</td>
</tr>
<tr>
<td><strong>StorageNotLow</strong></td>
<td>如果设置为 true，那么当用户设备上的存储空间不足时，工作不会运行。</td>
</tr>
</tbody></table>
<p>可以使用 <code>Contraints.Builder()</code> 创建 <code>Constraints</code> 实例，并将该实例分配给 <code>WorkRequest.Builder()</code>。</p>
<p>例如，以下代码会构建了一个工作请求，该工作请求仅在用户设备正在充电且连接到 Wi-Fi 网络时才会运行：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> constraints = Constraints.Builder()</span><br><span class="line">   .setRequiredNetworkType(NetworkType.UNMETERED)</span><br><span class="line">   .setRequiresCharging(<span class="literal">true</span>)</span><br><span class="line">   .build()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> myWorkRequest: WorkRequest =</span><br><span class="line">   OneTimeWorkRequestBuilder&lt;MyWork&gt;()</span><br><span class="line">       .setConstraints(constraints)</span><br><span class="line">       .build()</span><br></pre></td></tr></table></figure>

<p>如果指定了多个约束，工作将仅在满足所有约束时才会运行。</p>
<p>如果在工作运行时不再满足某个约束，WorkManager 将停止工作器。系统将在满足所有约束后重试工作。</p>
<h2 id="3-2、延迟工作"><a href="#3-2、延迟工作" class="headerlink" title="3.2、延迟工作"></a>3.2、延迟工作</h2><p>如果工作没有约束，或者当工作加入队列时所有约束都得到了满足，那么系统可能会选择立即运行该工作。如果您不希望工作立即运行，可以将工作指定为在经过一段最短初始延迟时间后再启动。</p>
<p>下面举例说明了如何将工作设置为在加入队列后至少经过 10 分钟后再运行。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> myWorkRequest = OneTimeWorkRequestBuilder&lt;MyWork&gt;()</span><br><span class="line">   .setInitialDelay(<span class="number">10</span>, TimeUnit.MINUTES)</span><br><span class="line">   .build()</span><br></pre></td></tr></table></figure>

<p>该示例说明了如何为 <code>OneTimeWorkRequest</code> 设置初始延迟时间，也可以为 <code>PeriodicWorkRequest</code> 设置初始延迟时间。在这种情况下，定期工作只有首次运行时会延迟。</p>
<h2 id="3-3、重试和退避策略"><a href="#3-3、重试和退避策略" class="headerlink" title="3.3、重试和退避策略"></a>3.3、重试和退避策略</h2><p>如果您需要让 WorkManager 重试工作，可以从工作器返回 <code>Result.retry()</code>。然后，系统将根据<a href="https://developer.android.com/reference/androidx/work/WorkRequest?hl=zh-cn#DEFAULT_BACKOFF_DELAY_MILLIS">退避延迟时间</a>和<a href="https://developer.android.com/reference/androidx/work/BackoffPolicy?hl=zh-cn">退避政策</a>重新调度工作。</p>
<ul>
<li>退避延迟时间指定了首次尝试后重试工作前的最短等待时间。此值范围是[<a href="https://developer.android.com/reference/androidx/work/WorkRequest?hl=zh-cn#MIN_BACKOFF_MILLIS">MIN_BACKOFF_MILLIS</a> –10s，<a href="https://developer.android.com/reference/androidx/work/WorkRequest?hl=zh-cn#MAX_BACKOFF_MILLIS">MAX_BACKOFF_MILLIS</a> – 5小时]。</li>
<li>退避政策定义了在后续重试过程中，退避延迟时间随时间以怎样的方式增长。WorkManager 支持 2 个退避政策，即 <code>LINEAR</code> 和 <code>EXPONENTIAL</code>。<ul>
<li> <code>LINEAR</code>，线性增长，每次尝试重试时，重试间隔都会增加约 10 秒。例如，第一次运行以 <code>Result.retry()</code> 结束并在 10 秒后重试；然后，如果工作在后续尝试后继续返回 <code>Result.retry()</code>，那么接下来会在 20 秒、30 秒、40 秒后重试，以此类推。</li>
<li><code>EXPONENTIAL</code>，指数性增长，那么重试时长序列将接近 20、40、80 秒，以此类推。</li>
</ul>
</li>
</ul>
<p>每个工作请求都有退避政策和退避延迟时间。默认政策是 <code>EXPONENTIAL</code>，延迟时间为 10 秒，但您可以在工作请求配置中替换此设置。</p>
<p>以下是自定义退避延迟时间和政策的示例。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> myWorkRequest = OneTimeWorkRequestBuilder&lt;MyWork&gt;()</span><br><span class="line">   .setBackoffCriteria(</span><br><span class="line">       BackoffPolicy.LINEAR,</span><br><span class="line">       OneTimeWorkRequest.MIN_BACKOFF_MILLIS,</span><br><span class="line">       TimeUnit.MILLISECONDS)</span><br><span class="line">   .build()</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：退避延迟时间不精确，在两次重试之间可能会有几秒钟的差异，但绝不会低于配置中指定的初始退避延迟时间。</p>
</blockquote>
<h2 id="3-4、标记工作"><a href="#3-4、标记工作" class="headerlink" title="3.4、标记工作"></a>3.4、标记工作</h2><p>每个工作请求都有一个<a href="https://developer.android.com/reference/androidx/work/WorkRequest?hl=zh-cn#getId()">唯一标识符</a>，该标识符可用于在以后标识该工作，以便<a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/managing-work?hl=zh-cn#cancelling">取消</a>工作或<a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/states-and-observation?hl=zh-cn#observing">观察其进度</a>。</p>
<p>如果有一组在逻辑上相关的工作，对这些工作项进行标记可能也会很有帮助。通过标记，可以一起处理一组工作请求。</p>
<p>例如，<code>WorkManager.cancelAllWorkByTag(String)</code> 会取消带有特定标记的所有工作请求，<code>WorkManager.getWorkInfosByTag(String)</code> 会返回一个 WorkInfo 对象列表，该列表可用于确定当前工作状态。</p>
<p>以下代码展示了如何向工作添加 <code>cleanup</code>标记：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> myWorkRequest = OneTimeWorkRequestBuilder&lt;MyWork&gt;()</span><br><span class="line">   .addTag(<span class="string">&quot;cleanup&quot;</span>)</span><br><span class="line">   .build()</span><br></pre></td></tr></table></figure>

<p>最后，可以向单个工作请求添加多个标记。这些标记在内部以一组字符串的形式进行存储。您可以使用 <a href="https://developer.android.com/reference/androidx/work/WorkInfo?hl=zh-cn#getTags()">WorkInfo.getTags()</a> 获取与 <code>WorkRequest</code> 关联的标记集。</p>
<p>从 <code>Worker</code> 类中，您可以通过 <a href="https://developer.android.com/reference/androidx/work/ListenableWorker?hl=zh-cn#getTags()">ListenableWorker.getTags()</a> 检索其标记集。</p>
<h2 id="3-5、分配输入数据"><a href="#3-5、分配输入数据" class="headerlink" title="3.5、分配输入数据"></a>3.5、分配输入数据</h2><p>工作可能需要输入数据才能正常运行。例如，处理图片上传的工作可能需要使用待上传图片的 URI 作为输入数据。</p>
<p>输入值以键值对的形式存储在 <code>Data</code> 对象中，并且可以在工作请求中设置。WorkManager 会在执行工作时将输入 <code>Data</code> 传递给工作。<code>Worker</code> 类可通过调用 <code>Worker.getInputData()</code> 访问输入参数。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Define the Worker requiring input</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UploadWork</span></span>(appContext: Context, workerParams: WorkerParameters)</span><br><span class="line">   : Worker(appContext, workerParams) &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span>: Result &#123;</span><br><span class="line">       <span class="keyword">val</span> imageUriInput =</span><br><span class="line">           inputData.getString(<span class="string">&quot;IMAGE_URI&quot;</span>) ?: <span class="keyword">return</span> Result.failure()</span><br><span class="line"></span><br><span class="line">       uploadFile(imageUriInput)</span><br><span class="line">       <span class="keyword">return</span> Result.success()</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a WorkRequest for your Worker and sending it input</span></span><br><span class="line"><span class="keyword">val</span> myUploadWork = OneTimeWorkRequestBuilder&lt;UploadWork&gt;()</span><br><span class="line">   .setInputData(workDataOf(</span><br><span class="line">       <span class="string">&quot;IMAGE_URI&quot;</span> to <span class="string">&quot;http://...&quot;</span></span><br><span class="line">   ))</span><br><span class="line">   .build()</span><br></pre></td></tr></table></figure>

<p>同样，可使用 <code>Data</code> 类输出返回值。如需详细了解输入和输出数据，请参阅<a href="https://developer.android.com/topic/libraries/architecture/workmanager/advanced?hl=zh-cn#params">输入参数和返回值</a>部分。</p>
<blockquote>
<p>注意：Data 数据的 不能超过 <a href="https://developer.android.com/reference/kotlin/androidx/work/Data#max_data_bytes">MAX_DATA_BYTES</a> – 10 KB </p>
</blockquote>
<h1 id="四、加急工作"><a href="#四、加急工作" class="headerlink" title="四、加急工作"></a>四、加急工作</h1><p>WorkManager 2.7.0 引入了加急工作的概念，它指的是可以在后台快速执行，并需要立即开始执行的工作。</p>
<p>加急工作具有以下特征：</p>
<ul>
<li><strong>重要性</strong>：加急工作适用于对用户很重要或由用户启动的任务。</li>
<li><strong>速度</strong>：加急工作最适合那些立即启动并在几分钟内完成的简短任务。</li>
<li><strong>配额</strong>：限制前台执行时间的系统级配额决定了加急作业是否可以启动。</li>
<li><strong>电源管理</strong>：<a href="https://developer.android.com/topic/performance/power/power-details?hl=zh-cn">电源管理限制</a>（如省电模式和低电耗模式）不太可能影响加急工作。</li>
<li><strong>延迟时间</strong>：系统立即执行加急工作，前提是系统的当前工作负载允许执行此操作。这意味着这些工作对延迟时间较为敏感，不能安排到以后执行。</li>
</ul>
<h2 id="4-1、配额"><a href="#4-1、配额" class="headerlink" title="4.1、配额"></a>4.1、配额</h2><p>系统必须先为加急作业分配应用执行时间，然后才能运行作业。执行时间并非无限制，而是受配额限制。如果您的应用使用其执行时间并达到分配的配额，在配额刷新之前，您无法再执行加急工作。这样，Android 可以更有效地在应用之间平衡资源。</p>
<p>每个应用均有自己的前台执行时间配额。可用的执行时间取决于<a href="https://developer.android.com/topic/performance/appstandby?hl=zh-cn">待机模式存储分区</a>和进程的重要性。</p>
<p>您可以确定在执行配额不允许立即运行加急作业时会出现什么情况。如需了解详情，请参阅以下代码段。</p>
<blockquote>
<p><strong>注意</strong>：当您的应用在前台运行时，配额不会限制加急工作的执行。仅在应用在后台运行时或当应用移至后台时，执行时间配额才适用。因此，您应在后台加快要继续的工作。当应用在前台运行时，您可以继续使用 <code>setForeground()</code>。</p>
</blockquote>
<h2 id="4-2、执行加急工作"><a href="#4-2、执行加急工作" class="headerlink" title="4.2、执行加急工作"></a>4.2、执行加急工作</h2><p>从 WorkManager 2.7 开始，您的应用可以调用 <code>setExpedited()</code> 来声明 <code>WorkRequest</code> 应该使用加急作业，以尽可能快的速度运行。以下代码段展示了关于如何使用 <code>setExpedited()</code> 的示例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> request = OneTimeWorkRequestBuilder()</span><br><span class="line">    .setExpedited(OutOfQuotaPolicy.RUN_AS_NON_EXPEDITED_WORK_REQUEST)</span><br><span class="line">    .build()</span><br><span class="line"></span><br><span class="line">WorkManager.getInstance(context)</span><br><span class="line">    .enqueue(request)</span><br></pre></td></tr></table></figure>

<p>在此示例中，我们初始化 <code>OneTimeWorkRequest</code> 的实例并对其调用 <code>setExpedited()</code>。然后，此请求就会变成加急工作。如果配额允许，它将立即开始在后台运行。</p>
<p><code>setExpedited</code>配额不足时：</p>
<ul>
<li><code>OutOfQuotaPolicy.RUN_AS_NON_EXPEDITED_WORK_REQUEST</code>：导致作业作为普通工作请求运行</li>
<li><code>OutOfQuotaPolicy.DROP_WORK_REQUEST</code>：配额不足时取消请求</li>
</ul>
<h2 id="4-3、向后兼容性和前台服务"><a href="#4-3、向后兼容性和前台服务" class="headerlink" title="4.3、向后兼容性和前台服务"></a>4.3、向后兼容性和前台服务</h2><p>android12 之前 <code>WorkManager</code>使用前台服务运行加急任务，为了保证兼容性，通过<code>setExpedited</code> 使用加急任务时，一定要复写<code>worker</code>中的 <code>getForegroundInfoAsync </code>或 <code>getForegroundInfo</code></p>
<p><code>(CoroutineWorker)</code> 方法，创建前台服务需要的通知，让 WorkManager 在必要时显示通知，以便启动 <code>ForegroundService</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通worker</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExpeditedWorker</span></span>(context: Context, workerParams: WorkerParameters) : Worker(</span><br><span class="line">    context,</span><br><span class="line">    workerParams</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span>: Result &#123;</span><br><span class="line">        Log.i(<span class="string">&quot;ExpeditedWorker&quot;</span>, <span class="string">&quot;ExpeditedWorker  doWork start&quot;</span>)</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>)</span><br><span class="line">        Log.i(<span class="string">&quot;ExpeditedWorker&quot;</span>, <span class="string">&quot;ExpeditedWorker  doWork end&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> Result.success()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequiresApi(Build.VERSION_CODES.O)</span></span><br><span class="line">    <span class="meta">@SuppressLint(<span class="meta-string">&quot;RestrictedApi&quot;</span>)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getForegroundInfoAsync</span><span class="params">()</span></span>: ListenableFuture&lt;ForegroundInfo&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> future = SettableFuture.create&lt;ForegroundInfo&gt;()</span><br><span class="line">        future.<span class="keyword">set</span>(ForegroundInfo(<span class="number">1001</span>, createNotification()))</span><br><span class="line">        <span class="keyword">return</span> future</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequiresApi(Build.VERSION_CODES.O)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">createNotification</span><span class="params">()</span></span>: Notification &#123;</span><br><span class="line">        <span class="keyword">var</span> channelId: String? = <span class="literal">null</span></span><br><span class="line">        <span class="comment">// 8.0 以上需要特殊处理</span></span><br><span class="line">        <span class="comment">// 8.0 以上需要特殊处理</span></span><br><span class="line">        channelId = <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">            createNotificationChannel(<span class="string">&quot;ExpeditedWorker&quot;</span>, <span class="string">&quot;ExpeditedWorker01&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Notification.Builder(applicationContext, channelId)</span><br><span class="line">            .setSmallIcon(R.drawable.ic_launcher_foreground)</span><br><span class="line">            .setContentTitle(<span class="string">&quot;ExpeditedWorker&quot;</span>)</span><br><span class="line">            .setContentText(<span class="string">&quot;ExpeditedWorker content&quot;</span>)</span><br><span class="line">            .build()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建通知通道</span></span><br><span class="line">    <span class="meta">@RequiresApi(Build.VERSION_CODES.O)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createNotificationChannel</span><span class="params">(channelId: <span class="type">String</span>, channelName: <span class="type">String</span>)</span></span>: String? &#123;</span><br><span class="line">        <span class="keyword">val</span> channel = NotificationChannel(</span><br><span class="line">            channelId,</span><br><span class="line">            channelName, NotificationManager.IMPORTANCE_NONE</span><br><span class="line">        )</span><br><span class="line">        channel.lightColor = Color.BLUE</span><br><span class="line">        channel.lockscreenVisibility = Notification.VISIBILITY_PRIVATE</span><br><span class="line">        <span class="keyword">val</span> service =</span><br><span class="line">            applicationContext.getSystemService(Context.NOTIFICATION_SERVICE) <span class="keyword">as</span> NotificationManager?</span><br><span class="line">        service!!.createNotificationChannel(channel)</span><br><span class="line">        <span class="keyword">return</span> channelId</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CoroutineWorker</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExpeditedWorker</span></span>(appContext: Context, workerParams: WorkerParameters):</span><br><span class="line"> CoroutineWorker(appContext, workerParams) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getForegroundInfo</span><span class="params">()</span></span>: ForegroundInfo &#123;</span><br><span class="line">     <span class="keyword">return</span> ForegroundInfo(</span><br><span class="line">         NOTIFICATION_ID, createNotification()</span><br><span class="line">     )</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span>: Result &#123;</span><br><span class="line">     TODO()</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createNotification</span><span class="params">()</span></span> : Notification &#123;</span><br><span class="line">     TODO()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：如果未能实现对应的 <code>getForegroundInfo</code> 方法，那么在旧版平台上调用 <code>setExpedited</code> 时，可能会导致运行时崩溃。</p>
</blockquote>
<h3 id="1、前台服务说明"><a href="#1、前台服务说明" class="headerlink" title="1、前台服务说明"></a>1、前台服务说明</h3><p>除了<code>setExpedited</code> API外，也可以调用 <code>ListenableWorker.setForegroundAsync()</code>启动前台服务，当应用后台启动前台服务时，除了这些情外<a href="https://developer.android.com/about/versions/12/foreground-services#cases-fgs-background-starts-allowed">应用不受前台服务限制</a>会抛出 <a href="https://developer.android.com/reference/android/app/ForegroundServiceStartNotAllowedException">ForegroundServiceStartNotAllowedException</a>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExpeditedNotifyWorker</span></span>(context: Context, workerParams: WorkerParameters) : Worker(</span><br><span class="line">    context,</span><br><span class="line">    workerParams</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;ExpeditedNotifyWorker&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span>: Result &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;doWork start&quot;</span>)</span><br><span class="line">        <span class="comment">// 使用 setForegroundAsync</span></span><br><span class="line">        setForegroundAsync(ForegroundInfo(<span class="number">1002</span>, createNotification()))</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>)</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;doWork end&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> Result.success()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequiresApi(Build.VERSION_CODES.O)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">createNotification</span><span class="params">()</span></span>: Notification &#123;</span><br><span class="line">        <span class="comment">// 创建通知,https://zhuanlan.zhihu.com/p/361776650</span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> expeditedRequest02 = OneTimeWorkRequestBuilder&lt;ExpeditedNotifyWorker&gt;()</span><br><span class="line">    <span class="comment">// 注意这里没有setExpedited</span></span><br><span class="line">    <span class="comment">// .setExpedited()</span></span><br><span class="line">    .build()</span><br><span class="line">workManager.enqueue(expeditedRequest02)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：将 <code>setForeground()</code> 封装在 <code>try/catch</code> 块中，以捕获可能出现的 <code>IllegalStateException</code>。如果应用此时无法在前台运行，便可能会发生这类<code>ForegroundServiceStartNotAllowedException</code>异常。</p>
</blockquote>
<h3 id="2、支持长时间运行的工作器"><a href="#2、支持长时间运行的工作器" class="headerlink" title="2、支持长时间运行的工作器"></a>2、支持长时间运行的工作器</h3><p>​        WorkManager <code>2.3.0-alpha02</code> 增加了对长时间运行的工作器的内置支持。<a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager/advanced/long-running">文档</a></p>
<h1 id="五、管理工作"><a href="#五、管理工作" class="headerlink" title="五、管理工作"></a>五、管理工作</h1><p>定义完<code>Worker</code>和<code>WorkRequest</code>，需要将工作加入队列。将工作加入队列的最简单方法是调用 <code>WorkManager</code> <code>enqueue()</code> 方法，然后传递要运行的 <code>WorkRequest</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">WorkManager.getInstance(<span class="keyword">this</span>).enqueue(workRequest)</span><br></pre></td></tr></table></figure>

<h2 id="5-1、唯一工作"><a href="#5-1、唯一工作" class="headerlink" title="5.1、唯一工作"></a>5.1、唯一工作</h2><p>将工作加入队列时需小心谨慎，避免重复。例如，应用可能会每 24 小时尝试将其日志上传到后端服务。如果不谨慎，即使作业只需运行一次，您最终也可能会多次将同一作业加入队列。为了实现此目标，可以将工作调度为<a href="https://link.juejin.cn/?target=https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/managing-work?hl=zh-cn%23unique-work">唯一工作</a>。</p>
<p>唯一工作可确保同一时刻只有一个具有特定名称的工作实例。唯一名称由开发者指定，仅与一个工作实例相关联。</p>
<p>唯一工作可用于一次性工作，也可用于定期工作。创建方法为</p>
<ul>
<li><a href="%5Bdeveloper.android.google.cn/reference/a%E2%80%A6%5D(https://link.juejin.cn?target=https://developer.android.google.cn/reference/androidx/work/WorkManager?hl=zh-cn#enqueueUniqueWork(java.lang.String"><code>WorkManager.enqueueUniqueWork()</code></a>, androidx.work.ExistingWorkPolicy, androidx.work.OneTimeWorkRequest))（用于一次性工作）</li>
<li><a href="%5Bdeveloper.android.google.cn/reference/a%E2%80%A6%5D(https://link.juejin.cn?target=https://developer.android.google.cn/reference/androidx/work/WorkManager?hl=zh-cn#enqueueUniquePeriodicWork(java.lang.String"><code>WorkManager.enqueueUniquePeriodicWork()</code></a>, androidx.work.ExistingPeriodicWorkPolicy, androidx.work.PeriodicWorkRequest))（用于定期工作）</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>uniqueWorkName</code></td>
<td>唯一标识工作请求的<code>String</code></td>
</tr>
<tr>
<td><code>existingWorkPolicy</code></td>
<td>此 <code>enum</code> 可告知 <code>WorkManager</code>：如果已有使用该名称且尚未完成的唯一工作链，应执行什么操作</td>
</tr>
<tr>
<td><code>work</code></td>
<td>要调度的<code>WorkRequest</code></td>
</tr>
</tbody></table>
<p>调度唯一工作时，您必须告知 <code>WorkManager</code> 在发生冲突时要执行的操作，其处理冲突的策略选项有4个：</p>
<ul>
<li><p><a href="https://link.juejin.cn/?target=https://developer.android.google.cn/reference/androidx/work/ExistingWorkPolicy?hl=zh-cn%23REPLACE"><code>REPLACE</code></a>：用新工作替换现有工作。此选项将取消现有工作</p>
</li>
<li><p><a href="https://link.juejin.cn/?target=https://developer.android.google.cn/reference/androidx/work/ExistingWorkPolicy?hl=zh-cn%23KEEP"><code>KEEP</code></a>：保留现有工作，并忽略新工作。</p>
</li>
<li><p><a href="https://link.juejin.cn/?target=https://developer.android.google.cn/reference/androidx/work/ExistingWorkPolicy?hl=zh-cn%23APPEND"><code>APPEND</code></a>：将新工作附加到现有工作的末尾。此政策将导致您的新工作<a href="https://link.juejin.cn/?target=https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/chain-work?hl=zh-cn">链接</a>到现有工作，在现有工作完成后运行。</p>
<p>现有工作将成为新工作的先决条件。如果现有工作变为 <code>CANCELLED</code> 或 <code>FAILED</code> 状态，新工作也会变为 <code>CANCELLED</code> 或 <code>FAILED</code>。如果您希望无论现有工作的状态如何都运行新工作，请改用 <code>APPEND_OR_REPLACE</code>。</p>
</li>
<li><p><a href="https://link.juejin.cn/?target=https://developer.android.google.cn/reference/androidx/work/ExistingWorkPolicy?hl=zh-cn%23APPEND"><code>APPEND_OR_REPLACE</code></a> 函数类似于 <code>APPEND</code>，不过它并不依赖于<strong>先决条件</strong>工作状态。即使现有工作变为 <code>CANCELLED</code> 或 <code>FAILED</code> 状态，新工作仍会运行。</p>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> sendLogsWorkRequest =</span><br><span class="line">       PeriodicWorkRequestBuilder&lt;SendLogsWorker&gt;(<span class="number">24</span>, TimeUnit.HOURS)</span><br><span class="line">           .setConstraints(Constraints.Builder()</span><br><span class="line">               .setRequiresCharging(<span class="literal">true</span>)</span><br><span class="line">               .build()</span><br><span class="line">            )</span><br><span class="line">           .build()</span><br><span class="line">WorkManager.getInstance(<span class="keyword">this</span>).enqueueUniquePeriodicWork(</span><br><span class="line">           <span class="string">&quot;sendLogs&quot;</span>,</span><br><span class="line">           ExistingPeriodicWorkPolicy.KEEP,</span><br><span class="line">           sendLogsWorkRequest</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>上述代码在 <code>sendLogs</code> 作业已处于队列中的情况下运行，系统会保留现有的作业，并且不会添加新的作业。</p>
<h2 id="5-2、任务状态"><a href="#5-2、任务状态" class="headerlink" title="5.2、任务状态"></a>5.2、任务状态</h2><h3 id="1、-WorkInfo类"><a href="#1、-WorkInfo类" class="headerlink" title="1、**WorkInfo类**"></a>1、**<code>WorkInfo</code>类**</h3><p>工作在整个生命周期内会经历一系列<code>State</code>更改，而<code>WorkInfo</code>用于包含其特定的任务信息与状态。</p>
<p>工作状态分为：<code>ENQUEUED</code>、<code>RUNNING</code>、<code>SUCCEEDED</code>、<code>FAILED</code>、<code>BLOCKED</code>与<code>CANCELLED</code>。</p>
<ul>
<li><p><strong>一次性工作的状态</strong></p>
<p>对于一次性工作请求，初始状态为<code>ENQUEUED</code>。</p>
<p><code>ENQUEUED</code>状态下，工作满足<code>Constraints</code>和初始延迟计时要求后立即运行，工作状态转为<code>RUNNING</code>状态，然后根据结果转为<code>SUCCEEDED</code>、<code>FAILED</code>。如果结果是<code>retry</code>，重回到<code>ENQUEUED</code>状态。在此过程中可随时取消工作，状态变更为<code>CANCELLED</code>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d844f1b3c4c343b88463b1de0d5d60aa~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<p><code>SUCCEEDED</code>、<code>FAILED</code> 和 <code>CANCELLED</code> 均表示此工作的终止状态。处于此状态时，<code>WorkInfo.State.isFinished()</code>返回<code>true</code>。</p>
</li>
<li><p><strong>定期工作的状态</strong></p>
<p>成功和失败状态仅适用于一次性工作和链式工作，定期工作只有一个终止状态 <code>CANCELLED</code></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b84f517593d74a879a041a3e4eca99f9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
</li>
<li><p><strong>链式工作的状态</strong></p>
<p>关于链式工作，其多了个<code>BLOCKED</code>状态。关于链式工作状态，可直接参看<a href="https://link.juejin.cn/?target=https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/chain-work?hl=zh-cn">链接和工作状态</a></p>
</li>
</ul>
<h3 id="2、查询状态"><a href="#2、查询状态" class="headerlink" title="2、查询状态"></a>2、查询状态</h3><p>将工作加入队列后，可以按 <code>name</code>、<code>id</code> 或 <code>tag</code> 在 WorkManager 中进行查询<code>WorkInfo</code>任务状态。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// by id</span></span><br><span class="line">workManager.getWorkInfoById(syncWorker.id) <span class="comment">// ListenableFuture&lt;WorkInfo&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// by name</span></span><br><span class="line">workManager.getWorkInfosForUniqueWork(<span class="string">&quot;sync&quot;</span>) <span class="comment">// ListenableFuture&lt;List&lt;WorkInfo&gt;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// by tag</span></span><br><span class="line">workManager.getWorkInfosByTag(<span class="string">&quot;syncTag&quot;</span>) <span class="comment">// ListenableFuture&lt;List&lt;WorkInfo&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p>该查询会返回 <a href="https://developer.android.com/reference/androidx/work/WorkInfo?hl=zh-cn"><code>WorkInfo</code></a> 对象的 <a href="https://guava.dev/releases/23.1-android/api/docs/com/google/common/util/concurrent/ListenableFuture.html"><code>ListenableFuture</code></a>，该值包含工作的 <a href="https://developer.android.com/reference/androidx/work/WorkInfo?hl=zh-cn#getId()"><code>id</code></a>、其标记、其当前的 <a href="https://developer.android.com/reference/androidx/work/WorkInfo.State?hl=zh-cn"><code>State</code></a> 以及通过 <a href="https://developer.android.com/reference/androidx/work/ListenableWorker.Result?hl=zh-cn#success(androidx.work.Data)"><code>Result.success(outputData)</code></a> 设置的任何输出数据。</p>
<p>利用每个方法的 <a href="https://developer.android.com/topic/libraries/architecture/livedata?hl=zh-cn"><code>LiveData</code></a> 变种，您可以通过注册监听器来观察 <code>WorkInfo</code> 的变化。例如，如果您想要在某项工作成功完成后向用户显示消息，您可以进行如下设置：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">workManager.getWorkInfoByIdLiveData(syncWorker.id)</span><br><span class="line">               .observe(viewLifecycleOwner) &#123; workInfo -&gt;</span><br><span class="line">   <span class="keyword">if</span>(workInfo?.state == WorkInfo.State.SUCCEEDED) &#123;</span><br><span class="line">       Snackbar.make(requireView(),</span><br><span class="line">      R.string.work_completed, Snackbar.LENGTH_SHORT)</span><br><span class="line">           .show()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、复杂的工作查询"><a href="#3、复杂的工作查询" class="headerlink" title="3、复杂的工作查询"></a>3、复杂的工作查询</h3><p><code>WorkManager 2.4.0</code> 及更高版本支持使用 <a href="https://link.juejin.cn/?target=https://developer.android.google.cn/reference/androidx/work/WorkQuery?hl=zh-cn"><code>WorkQuery</code></a> 对象对已加入队列的作业进行复杂查询。<code>WorkQuery</code> 支持按工作的<code>ID/ 标记tag、状态state、名称name</code>组合进行查询。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> workQuery = WorkQuery.Builder</span><br><span class="line">       .fromTags(listOf(<span class="string">&quot;syncTag&quot;</span>))</span><br><span class="line">       .addStates(listOf(WorkInfo.State.FAILED, WorkInfo.State.CANCELLED))</span><br><span class="line">       .addUniqueWorkNames(listOf(<span class="string">&quot;preProcess&quot;</span>, <span class="string">&quot;sync&quot;</span>)</span><br><span class="line">    )</span><br><span class="line">   .build()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> workInfos: ListenableFuture&lt;List&lt;WorkInfo&gt;&gt; = workManager.getWorkInfos(workQuery)</span><br></pre></td></tr></table></figure>

<p><code>WorkQuery</code> 中的每个条件（ID，标记、状态或名称）与其他组件都是 <code>AND</code> 逻辑关系。条件中的每个值都是 <code>OR</code> 逻辑关系。<code>WorkQuery</code> 也适用于等效的 LiveData 方法 <a href="https://link.juejin.cn/?target=https://developer.android.google.cn/reference/androidx/work/WorkManager?hl=zh-cn%23getWorkInfosLiveData(androidx.work.WorkQuery)"><code>getWorkInfosLiveData()</code></a>。</p>
<h2 id="5-3、取消和停止工作"><a href="#5-3、取消和停止工作" class="headerlink" title="5.3、取消和停止工作"></a>5.3、取消和停止工作</h2><p>如果您不再需要运行先前加入队列的工作，则可以要求将其取消。可以按工作的 <code>name</code>、<code>id</code> 或 <code>tag</code> 取消工作。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// by id</span></span><br><span class="line">workManager.cancelWorkById(syncWorker.id)</span><br><span class="line"></span><br><span class="line"><span class="comment">// by name</span></span><br><span class="line">workManager.cancelUniqueWork(<span class="string">&quot;sync&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// by tag</span></span><br><span class="line">workManager.cancelAllWorkByTag(<span class="string">&quot;syncTag&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>取消时，WorkManager 会检查工作的 <a href="https://developer.android.google.cn/reference/androidx/work/WorkInfo.State?hl=zh-cn"><code>State</code></a>。如果工作已经<a href="https://developer.android.google.cn/reference/androidx/work/WorkInfo.State?hl=zh-cn#isFinished()">完成</a>，系统不会执行任何操作。否则，工作的状态会更改为 <a href="https://developer.android.google.cn/reference/androidx/work/WorkInfo.State?hl=zh-cn#CANCELLED"><code>CANCELLED</code></a>，之后就不会运行这个工作。任何<a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/chain-work?hl=zh-cn">依赖于此工作</a>的 <a href="https://developer.android.google.cn/reference/androidx/work/WorkRequest?hl=zh-cn"><code>WorkRequest</code></a> 作业也将变为 <code>CANCELLED</code>。</p>
<blockquote>
<p><strong>注意</strong>：<a href="https://developer.android.google.cn/reference/androidx/work/WorkManager?hl=zh-cn#cancelAllWorkByTag(java.lang.String)"><code>cancelAllWorkByTag(String)</code></a> 会取消具有给定标记的所有工作。</p>
</blockquote>
<h2 id="5-4、停止Worker"><a href="#5-4、停止Worker" class="headerlink" title="5.4、停止Worker"></a>5.4、停止<code>Worker</code></h2><p>正在运行的 <code>Worker</code> 可能会由于以下几种原因而停止运行：</p>
<ul>
<li>明确要求取消它（例如，通过调用 <code>WorkManager.cancelWorkById(UUID)</code> 取消）。</li>
<li>如果是<a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/managing-work?hl=zh-cn#unique-work">唯一工作</a>，将 <a href="https://developer.android.google.cn/reference/androidx/work/ExistingWorkPolicy?hl=zh-cn"><code>ExistingWorkPolicy</code></a> 为 <a href="https://developer.android.google.cn/reference/androidx/work/ExistingWorkPolicy?hl=zh-cn#REPLACE"><code>REPLACE</code></a> 的新 <code>WorkRequest</code> 加入到了队列中。旧的 <code>WorkRequest</code> 会立即被视为已取消。</li>
<li>工作约束条件已不再满足。</li>
<li>系统出于某种原因指示您的应用停止工作。如果超过 10 分钟的执行期限，可能会发生这种情况。该工作会调度为在稍后重试。</li>
</ul>
<h3 id="1、onStopped-回调"><a href="#1、onStopped-回调" class="headerlink" title="1、onStopped() 回调"></a>1、<strong>onStopped() 回调</strong></h3><p><code>Worker</code>被取消时，可以在onStop中收到回调，此时应该主动释放<code>Worker</code>的所有资源。例如，此时关闭所打开的数据库和文件句柄等等。</p>
<h3 id="2、isStopped-属性"><a href="#2、isStopped-属性" class="headerlink" title="2、isStopped() 属性"></a>2、isStopped() 属性</h3><p>您可以调用 <a href="https://developer.android.google.cn/reference/androidx/work/ListenableWorker?hl=zh-cn#isStopped()"><code>ListenableWorker.isStopped()</code></a> 方法以检查工作器是否已停止。如果您在工作器执行长时间运行的操作或重复操作，您应经常检查此属性，并尽快将其用作停止工作的信号。</p>
<blockquote>
<p><strong>注意</strong>：WorkManager 会忽略已收到 onStop 信号的工作器所设置的 <a href="https://developer.android.google.cn/reference/androidx/work/ListenableWorker.Result?hl=zh-cn"><code>Result</code></a>，因为工作器已被视为停止。</p>
</blockquote>
<p>示例如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UploadWorker</span></span>(appContext: Context, workerParams: WorkerParameters):</span><br><span class="line">    Worker(appContext, workerParams) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;UploadWorker&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span>: Result &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;Thread = <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isStopped) &#123;</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;work stopped&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> Result.failure()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Do the work here--in this case, upload the images.</span></span><br><span class="line">        uploadImages()</span><br><span class="line">        <span class="comment">// Indicate whether the work finished successfully with the Result</span></span><br><span class="line">        <span class="keyword">return</span> Result.success()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">uploadImages</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;uploadImages start&quot;</span>)</span><br><span class="line">        <span class="comment">// 模拟任务执行 3s</span></span><br><span class="line">        Thread.sleep(<span class="number">3</span> * <span class="number">1000L</span>)</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;uploadImages end&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStopped</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// release resource</span></span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onStopped ...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动</span></span><br><span class="line"><span class="keyword">val</span> request0: WorkRequest =</span><br><span class="line">    OneTimeWorkRequestBuilder&lt;UploadWorker&gt;()</span><br><span class="line">        .addTag(<span class="string">&quot;UploadWorker0&quot;</span>)</span><br><span class="line">        .build()</span><br><span class="line">workManager.enqueue(request0)</span><br><span class="line"><span class="comment">// 延迟 1s 执行</span></span><br><span class="line">Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">workManager.cancelAllWorkByTag(<span class="string">&quot;UploadWorker0&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="5-5、任务进度观察"><a href="#5-5、任务进度观察" class="headerlink" title="5.5、任务进度观察"></a>5.5、任务进度观察</h2><p><code>WorkManager 2.3.0-alpha01</code> 为设置和观察工作器的中间进度添加了支持。</p>
<p><code>Worker中</code>通过<code>ListenableWorker#setProgressAsync</code>或 <code>CoroutineWorker#setProgress</code>，允许保留中间进度。开发者能可通过界面观察到的中间进度。<code>progress</code>进度类型是 <a href="https://link.juejin.cn/?target=https://developer.android.google.cn/reference/androidx/work/Data?hl=zh-cn"><code>Data</code></a> 类型。</p>
<h3 id="1、更新进度"><a href="#1、更新进度" class="headerlink" title="1、更新进度"></a>1、更新进度</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProgressWorker</span></span>(context: Context, parameters: WorkerParameters) :</span><br><span class="line">    CoroutineWorker(context, parameters) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> Progress = <span class="string">&quot;Progress&quot;</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> delayDuration = <span class="number">1L</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span>: Result &#123;</span><br><span class="line">        <span class="keyword">val</span> firstUpdate = workDataOf(Progress to <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">val</span> lastUpdate = workDataOf(Progress to <span class="number">100</span>)</span><br><span class="line">        setProgress(firstUpdate)</span><br><span class="line">        delay(delayDuration)</span><br><span class="line">        <span class="comment">// 设置进度</span></span><br><span class="line">        setProgress(lastUpdate)</span><br><span class="line">        <span class="keyword">return</span> Result.success()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2、观察进度"><a href="#2、观察进度" class="headerlink" title="2、观察进度"></a>2、观察进度</h3><p>可以使用 <a href="https://link.juejin.cn/?target=https://developer.android.google.cn/reference/androidx/work/WorkManager?hl=zh-cn%23getWorkInfoById(java.util.UUID)"><code>getWorkInfoBy…()</code> 或 <code>getWorkInfoBy…LiveData()</code></a> 方法，并引用 <a href="https://link.juejin.cn/?target=https://developer.android.google.cn/reference/androidx/work/WorkInfo?hl=zh-cn"><code>WorkInfo</code></a>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">WorkManager.getInstance(applicationContext)</span><br><span class="line">    <span class="comment">// requestId is the WorkRequest id</span></span><br><span class="line">    .getWorkInfoByIdLiveData(requestId)</span><br><span class="line">    .observe(observer, Observer &#123; workInfo: WorkInfo? -&gt;</span><br><span class="line">            <span class="keyword">if</span> (workInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> progress = workInfo.progress</span><br><span class="line">                <span class="keyword">val</span> value = progress.getInt(Progress, <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// Do something with progress information</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<h1 id="六、工作链"><a href="#六、工作链" class="headerlink" title="六、工作链"></a>六、工作链</h1><p>可以使用 WorkManager 创建工作链并将其加入队列。工作链用于指定多个依存任务并定义这些任务的运行顺序。当您需要以特定顺序运行多个任务时，此功能尤其有用。</p>
<p>创建任务链可以使用<a href="https://link.juejin.cn/?target=https://developer.android.google.cn/reference/androidx/work/WorkManager?hl=zh-cn%23beginWith(androidx.work.OneTimeWorkRequest)"><code>WorkManager.beginWith(OneTimeWorkRequest)</code></a></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">WorkManager.getInstance(<span class="keyword">this</span>)</span><br><span class="line">    .beginWith(workA)</span><br><span class="line">    .then(workB)   </span><br><span class="line">    .then(workC)</span><br><span class="line">    .enqueue()</span><br></pre></td></tr></table></figure>

<p>任务会按照设置的顺序依次执行A、B、C。<code>WorkManager</code>在执行过程中，遇到其中一个<code>Work</code>不成功，会停止执行。比如代码执行到<code>WorkB</code>返回<code>FAILURE</code>状态，代码结束，<code>WorkC</code>不执行。</p>
<p>也可以使用 <a href="https://link.juejin.cn/?target=https://developer.android.google.cn/reference/androidx/work/WorkManager?hl=zh-cn%23beginWith(java.util.List)"><code>WorkManager.beginWith(List)</code></a>传入一个List，其中的<code>Worker </code>是并行执行的。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">WorkManager.getInstance(myContext)</span><br><span class="line">   <span class="comment">// Candidates to run in parallel</span></span><br><span class="line">   .beginWith(listOf(plantName1, plantName2, plantName3))</span><br><span class="line">   <span class="comment">// Dependent work (only runs after all previous work in chain)</span></span><br><span class="line">   .then(cache)</span><br><span class="line">   .then(upload)</span><br><span class="line">   <span class="comment">// Call enqueue to kick things off</span></span><br><span class="line">   .enqueue()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然，then接口也可以传入list集合，并行执行任务。</p>
<h2 id="6-1、输入合并器"><a href="#6-1、输入合并器" class="headerlink" title="6.1、输入合并器"></a>6.1、<strong>输入合并器</strong></h2><p>当链接 <code>OneTimeWorkRequest</code> 实例时，父级工作请求的输出将作为子级的输入传入。因此，在上面的示例中，<code>plantName1</code>、<code>plantName2</code> 和 <code>plantName3</code> 的输出将作为 <code>cache</code> 请求的输入传入。</p>
<p>为了管理来自多个父级工作请求的输入，WorkManager 使用 <a href="https://developer.android.google.cn/reference/androidx/work/InputMerger"><code>InputMerger</code></a>。</p>
<p>WorkManager 提供两种不同类型的 <code>InputMerger</code>：</p>
<ul>
<li><a href="https://developer.android.google.cn/reference/androidx/work/OverwritingInputMerger"><code>OverwritingInputMerger</code></a> 会尝试将所有输入中的所有键添加到输出中。如果发生冲突，它会覆盖先前设置的键。</li>
<li><a href="https://developer.android.google.cn/reference/androidx/work/ArrayCreatingInputMerger"><code>ArrayCreatingInputMerger</code></a> 会尝试合并输入，并在必要时创建数组。</li>
</ul>
<h3 id="1、OverwritingInputMerger"><a href="#1、OverwritingInputMerger" class="headerlink" title="1、OverwritingInputMerger"></a>1、OverwritingInputMerger</h3><p><code>OverwritingInputMerger</code> 是默认的合并方法。如果合并过程中存在键冲突，键的最新值将覆盖生成的输出数据中的所有先前版本。</p>
<p>例如，如果每种植物的输入都有一个与其各自变量名称（<code>&quot;plantName1&quot;</code>、<code>&quot;plantName2&quot;</code> 和 <code>&quot;plantName3&quot;</code>）匹配的键，传递给 <code>cache</code> 工作器的数据将具有三个键值对。</p>
<img src="/pics/image-20220515201114992.png" alt="image-20220515201114992" style="zoom:50%;" />

<p>如果存在冲突，那么最后一个工作器将在争用中“取胜”，其值将传递给 <code>cache</code>。</p>
<img src="/pics/image-20220515201138035.png" style="zoom:50%;" />

<p>由于工作请求是并行运行的，因此无法保证其运行顺序。在上面的示例中，<code>plantName1</code> 可以保留值 <code>&quot;tulip&quot;</code> 或 <code>&quot;elm&quot;</code>，具体取决于最后写入的是哪个值。如果有可能存在键冲突，并且您需要在合并器中保留所有输出数据，那么 <code>ArrayCreatingInputMerger</code> 可能是更好的选择。</p>
<h3 id="2、ArrayCreatingInputMerger"><a href="#2、ArrayCreatingInputMerger" class="headerlink" title="2、ArrayCreatingInputMerger"></a>2、ArrayCreatingInputMerger</h3><p>对于上面的示例，假设我们要保留所有植物名称工作器的输出，则应使用 <code>ArrayCreatingInputMerger</code>。</p>
<p><a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/chain-work#kotlin">Kotlin</a><a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/chain-work#java">Java</a></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> cache: OneTimeWorkRequest = OneTimeWorkRequestBuilder&lt;PlantWorker&gt;()</span><br><span class="line">   .setInputMerger(ArrayCreatingInputMerger::<span class="class"><span class="keyword">class</span>)</span></span><br><span class="line">   .setConstraints(constraints)</span><br><span class="line">   .build()</span><br></pre></td></tr></table></figure>

<p><code>ArrayCreatingInputMerger</code> 将每个键与数组配对。如果每个键都是唯一的，您会得到一系列一元数组。</p>
<img src="/pics/image-20220515201325106.png" alt="image-20220515201325106" style="zoom:50%;" />

<p>如果存在任何键冲突，那么所有对应的值会分组到一个数组中。</p>
<img src="/pics/image-20220515201342698.png" alt="image-20220515201342698" style="zoom:50%;" />

<h2 id="6-2、链接和工作状态"><a href="#6-2、链接和工作状态" class="headerlink" title="6.2、链接和工作状态"></a>6.2、链接和工作状态</h2><p>只要工作成功完成（即，返回 <code>Result.success()</code>），<code>OneTimeWorkRequest</code> 链便会按顺序执行。运行时，工作请求可能会失败或被取消，这会对依存工作请求产生下游影响。</p>
<p>当第一个 <code>OneTimeWorkRequest</code> 被加入工作请求链队列时，所有后续工作请求会被屏蔽，直到第一个工作请求的工作完成为止。</p>
<p>具体工作机制：<a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/chain-work#work-statuses">链接和工作状态</a></p>
<h1 id="七、自定义"><a href="#七、自定义" class="headerlink" title="七、自定义"></a>七、自定义</h1><h2 id="7-1、自定义WorkManager"><a href="#7-1、自定义WorkManager" class="headerlink" title="7.1、自定义WorkManager"></a>7.1、自定义WorkManager</h2><p>默认情况下，应用启动时，<code>WorkManager</code> 使用适合大多数应用的合理选项自动进行配置。如果需要进一步控制 <code>WorkManager</code> 管理和调度工作的方式，可以通过自行初始化 <code>WorkManager</code> 来自定义 <code>WorkManager</code> 配置。</p>
<h3 id="移除默认实现"><a href="#移除默认实现" class="headerlink" title="移除默认实现"></a>移除默认实现</h3><p>通过按需初始化，可以在仅需要<code>WorkManager</code>时创建该组件，不用每次应用启动都创建，提高应用启动性能。</p>
<p>如需提供自己的配置，必须先移除默认初始化程序，使用合并规则 <code>tools:node=&quot;remove&quot;</code> 更新 <a href="https://link.juejin.cn/?target=https://developer.android.google.cn/guide/topics/manifest/manifest-intro?hl=zh-cn"><code>AndroidManifest.xml</code></a>。</p>
<p>从 <code>WorkManager 2.6</code> 开始，应用启动功能在<code>WorkManager</code>内部使用。若需提供自定义初始化程序，需移除<code>androidx.startup</code>节点</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 如果您不在应用中使用应用启动功能，则可以将其彻底移除 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:name</span>=<span class="string">&quot;androidx.startup.InitializationProvider&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:authorities</span>=<span class="string">&quot;$&#123;applicationId&#125;.androidx-startup&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">tools:node</span>=<span class="string">&quot;remove&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>否则，如果要使用<code>startUp</code>其他功能，可以仅移除 <code>WorkManagerInitializer</code> 节点即可。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:name</span>=<span class="string">&quot;androidx.startup.InitializationProvider&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:authorities</span>=<span class="string">&quot;$&#123;applicationId&#125;.androidx-startup&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">tools:node</span>=<span class="string">&quot;merge&quot;</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- If you are using androidx.startup to initialize other components --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:name</span>=<span class="string">&quot;androidx.work.WorkManagerInitializer&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:value</span>=<span class="string">&quot;androidx.startup&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">tools:node</span>=<span class="string">&quot;remove&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="实现Configguration-Provider"><a href="#实现Configguration-Provider" class="headerlink" title="实现Configguration.Provider"></a><strong>实现<code>Configguration.Provider</code></strong></h3><p>让 <code>Application</code> 类实现 <a href="https://link.juejin.cn/?target=https://developer.android.google.cn/reference/androidx/work/Configuration.Provider?hl=zh-cn"><code>Configuration.Provider</code></a> 接口，并提供自定义的 <a href="https://link.juejin.cn/?target=https://developer.android.google.cn/reference/androidx/work/Configuration.Provider?hl=zh-cn%23getWorkManagerConfiguration()"><code>Configuration.Provider.getWorkManagerConfiguration</code>()</a> 实现</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> : <span class="type">Application</span></span>(), Configuration.Provider &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getWorkManagerConfiguration</span><span class="params">()</span></span> =</span><br><span class="line">        Configuration.Builder()</span><br><span class="line">            .setWorkerFactory(RenameWorkerFactory())</span><br><span class="line">            .setMinimumLoggingLevel(Log.VERBOSE)</span><br><span class="line">            .build()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如需查看可用自定义的完整列表，请参阅 <a href="https://link.juejin.cn/?target=https://developer.android.google.cn/reference/androidx/work/Configuration.Builder?hl=zh-cn"><code>Configuration.Builder()文档</code></a> </p>
<blockquote>
<p><strong>注意</strong>： 必须<a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager/advanced/custom-configuration#remove-default">移除默认的初始化程序</a>，自定义的 <code>getWorkManagerConfiguration()</code> 实现才能生效。</p>
</blockquote>
<h2 id="7-2、自定义WorkerFactory"><a href="#7-2、自定义WorkerFactory" class="headerlink" title="7.2、自定义WorkerFactory"></a>7.2、自定义WorkerFactory</h2><p><code>WorkManager</code>执行 <code>Worker</code>任务时，会通过<code>WorkerFactory</code>反射实例化你定义的<code>Worker</code>。默认的<code>WorkerFactory</code>创建<code>Worker</code>需要两个参数：</p>
<ol>
<li><code>Application’s Context</code></li>
<li><code>WorkerParameters</code></li>
</ol>
<p>实际开发中，可能需要为<code>Worker</code>构造函数添加其他参数，满足我们的功能需求。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWorkerFactory</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> name: String = <span class="string">&quot;MyWorkerFactory-&quot;</span>) : WorkerFactory() &#123;</span><br><span class="line">    <span class="meta">@SuppressLint(<span class="meta-string">&quot;RestrictedApi&quot;</span>)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">createWorker</span><span class="params">(appContext: <span class="type">Context</span>, workerClassName: <span class="type">String</span>, workerParameters: <span class="type">WorkerParameters</span>)</span></span>: ListenableWorker? &#123;</span><br><span class="line">        Log.i(<span class="string">&quot;zxw&quot;</span>, <span class="string">&quot;workerClassName = <span class="variable">$workerClassName</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">when</span> (workerClassName) &#123;</span><br><span class="line">            MyWorker01::<span class="keyword">class</span>.java.name -&gt; MyWorker01(name, appContext, workerParameters)</span><br><span class="line">            MyWorker02::<span class="keyword">class</span>.java.name -&gt; MyWorker02(name, appContext, workerParameters)</span><br><span class="line">            <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">                <span class="comment">// 调用默认的Factory方法</span></span><br><span class="line">                getDefaultWorkerFactory().createWorker(appContext, workerClassName, workerParameters)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWorker01</span> </span>(<span class="keyword">private</span> <span class="keyword">val</span> name:String, appContext: Context, workerParams: WorkerParameters):</span><br><span class="line">    Worker(appContext, workerParams)&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span>: Result &#123;</span><br><span class="line">        Log.i(<span class="string">&quot;zxw&quot;</span>, <span class="string">&quot;MyWorker01 = <span class="variable">$name</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> Result.success()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> request11 = OneTimeWorkRequestBuilder&lt;MyWorker01&gt;().build()</span><br><span class="line">            workManager.enqueue(request11)</span><br></pre></td></tr></table></figure>

<h3 id="DelegatingWorkerFactory使用"><a href="#DelegatingWorkerFactory使用" class="headerlink" title="DelegatingWorkerFactory使用"></a><strong><code>DelegatingWorkerFactory</code>使用</strong></h3><p>实际开发中可能会有多个<code>Worker</code>类，示例中直接返回某个特定<code>Worker</code>实例的操作就不是很适用，可以通过<code>DelegatingWorkerFactory</code>解决。</p>
<p>可以使用<code>DelegatingWorkerFactory</code>，将其设置到我们的<code>WorkerFactory</code>中，从而支持多个多个工厂。这种情况下，如果一个<code>WorkerFactory</code>没有创建<code>Worker</code>，<code>DelegatingFactory</code>会去找到下一个<code>WorkerFactory</code>。如果没有任何被注册的工厂知道如何处理某个类，那么它将回退到使用反射的默认工厂。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWorkerFactory</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> name: String = <span class="string">&quot;MyWorkerFactory-&quot;</span>) : WorkerFactory() &#123;</span><br><span class="line">    <span class="meta">@SuppressLint(<span class="meta-string">&quot;RestrictedApi&quot;</span>)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">createWorker</span><span class="params">(appContext: <span class="type">Context</span>, workerClassName: <span class="type">String</span>, workerParameters: <span class="type">WorkerParameters</span>)</span></span>: ListenableWorker? &#123;</span><br><span class="line">        Log.i(<span class="string">&quot;zxw&quot;</span>, <span class="string">&quot;workerClassName = <span class="variable">$workerClassName</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">when</span> (workerClassName) &#123;</span><br><span class="line">            MyWorker01::<span class="keyword">class</span>.java.name -&gt; MyWorker01(name, appContext, workerParameters)</span><br><span class="line">            MyWorker02::<span class="keyword">class</span>.java.name -&gt; MyWorker02(name, appContext, workerParameters)</span><br><span class="line">            <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">                <span class="literal">null</span></span><br><span class="line">                <span class="comment">// 返回null 让其他factory 进行处理，如果没有任何自定义工厂处理某个类，将使用默认的反射工厂</span></span><br><span class="line">                <span class="comment">// getDefaultWorkerFactory().createWorker(appContext, workerClassName, workerParameters)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> : <span class="type">Application</span></span>(), Configuration.Provider &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getWorkManagerConfiguration</span><span class="params">()</span></span>: Configuration &#123;</span><br><span class="line">        <span class="keyword">val</span> factory = DelegatingWorkerFactory()</span><br><span class="line">        factory.addFactory(MyWorkerFactory())</span><br><span class="line">        <span class="keyword">return</span> Configuration.Builder()</span><br><span class="line">            <span class="comment">// .setWorkerFactory(MyWorkerFactory())</span></span><br><span class="line">            <span class="comment">// 变化在这里</span></span><br><span class="line">            .setWorkerFactory(factory)</span><br><span class="line">            .setMinimumLoggingLevel(android.util.Log.INFO)</span><br><span class="line">            .build()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="八、线程处理"><a href="#八、线程处理" class="headerlink" title="八、线程处理"></a>八、线程处理</h1><p>在 <a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager/basics">WorkManager 使用入门</a>中，我们提到 WorkManager 可以代表您异步执行后台工作。</p>
<p>WorkManager 提供了四种不同类型的工作基元：</p>
<ul>
<li><a href="https://developer.android.google.cn/reference/androidx/work/Worker"><code>Worker</code></a> 是最简单的实现，WorkManager 会自动在后台线程中调用 <a href="https://developer.android.google.cn/reference/androidx/work/Worker#doWork()"><code>Worker.doWork()</code></a></li>
<li><a href="https://developer.android.google.cn/reference/kotlin/androidx/work/CoroutineWorker"><code>CoroutineWorker</code></a> 是为 Kotlin 用户建议的实现。<code>CoroutineWorker</code> 实例公开了后台工作的一个挂起函数。详细了解 <code>CoroutineWorker</code> 实例中的线程处理，请参阅 <a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager/advanced/coroutineworker">CoroutineWorker 中的线程处理</a>。</li>
<li><a href="https://developer.android.google.cn/reference/androidx/work/RxWorker"><code>RxWorker</code></a> 是为 RxJava 用户建议的实现。</li>
<li><a href="https://developer.android.google.cn/reference/androidx/work/ListenableWorker"><code>ListenableWorker</code></a> 是 <code>Worker</code>、<code>CoroutineWorker</code> 和 <code>RxWorker</code> 的基类。</li>
</ul>
<h2 id="8-1、Worker-中的线程处理"><a href="#8-1、Worker-中的线程处理" class="headerlink" title="8.1、Worker 中的线程处理"></a>8.1、Worker 中的线程处理</h2><p>当您使用 <a href="https://developer.android.google.cn/reference/androidx/work/Worker"><code>Worker</code></a> 时，WorkManager 会自动在后台线程中调用 <a href="https://developer.android.google.cn/reference/androidx/work/Worker#doWork()"><code>Worker.doWork()</code></a>。该后台线程来自于 WorkManager 的 <a href="https://developer.android.google.cn/reference/androidx/work/Configuration"><code>Configuration</code></a> 中指定的 <code>Executor</code>。默认情况下，WorkManager 会为您设置 <code>Executor</code>，但您也可以自己进行自定义,按以下方式指定 <code>Executor</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">WorkManager.initialize(</span><br><span class="line">    context,</span><br><span class="line">    Configuration.Builder()</span><br><span class="line">         <span class="comment">// Uses a fixed thread pool of size 8 threads.</span></span><br><span class="line">        .setExecutor(Executors.newFixedThreadPool(<span class="number">8</span>))</span><br><span class="line">        .build())</span><br></pre></td></tr></table></figure>

<blockquote>
<p>WorkManager中的线程池有2种：1、bgExecutor，用来执行后台worker任务 2、taskExecutor，用来处理任务调度</p>
</blockquote>
<h2 id="8-2、ListenableWorker-中的线程处理"><a href="#8-2、ListenableWorker-中的线程处理" class="headerlink" title="8.2、ListenableWorker 中的线程处理"></a>8.2、ListenableWorker 中的线程处理</h2><p>在某些情况下，需要处理基于回调的异步操作。在这种情况下，不能只依靠 <code>Worker</code> 来完成操作，因为它无法以阻塞方式完成这项工作。WorkManager 通过 <a href="https://developer.android.google.cn/reference/androidx/work/ListenableWorker"><code>ListenableWorker</code></a> 支持该用例。</p>
<p><code>ListenableWorker</code> 是最基本的工作器 API；<a href="https://developer.android.google.cn/reference/androidx/work/Worker"><code>Worker</code></a>、<a href="https://developer.android.google.cn/reference/kotlin/androidx/work/CoroutineWorker"><code>CoroutineWorker</code></a> 和 <a href="https://developer.android.google.cn/reference/androidx/work/RxWorker"><code>RxWorker</code></a> 都是从这个类衍生而来的。<code>ListenableWorker</code> 只会发出信号以表明应该开始和停止工作，而线程处理则完全交您决定。开始工作信号在主线程上调用，因此请务必手动转到您选择的后台线程。</p>
<p>抽象方法 <a href="https://developer.android.google.cn/reference/androidx/work/ListenableWorker#startWork()"><code>ListenableWorker.startWork()</code></a> 会返回一个将使用操作的 <a href="https://developer.android.google.cn/reference/androidx/work/ListenableWorker.Result"><code>Result</code></a> 设置的 <code>ListenableFuture</code>。<code>ListenableFuture</code> 是一个轻量级接口：它是一个 <code>Future</code>，用于提供附加监听器和传播异常的功能。在 <code>startWork</code> 方法中，应该返回 <code>ListenableFuture</code>，完成操作后，您需要使用操作的 <code>Result</code> 设置这个返回结果。您可以通过以下两种方式之一创建 <code>ListenableFuture</code> 实例：</p>
<p>首先引入依赖 <a href="https://developer.android.google.cn/jetpack/androidx/releases/concurrent#declaring_dependencies"><code>councurrent-futures</code></a> 依赖：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&quot;androidx.concurrent:concurrent-futures-ktx:1.1.0&quot;</span></span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallBackWorker</span></span>(</span><br><span class="line">    context: Context,</span><br><span class="line">    params: WorkerParameters</span><br><span class="line">) : ListenableWorker(context, params) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">startWork</span><span class="params">()</span></span>: ListenableFuture&lt;Result&gt; &#123;</span><br><span class="line">        Log.i(<span class="string">&quot;zxw&quot;</span>, <span class="string">&quot;startWork&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> CallbackToFutureAdapter.getFuture &#123; completer -&gt;</span><br><span class="line">            <span class="keyword">val</span> callback = <span class="keyword">object</span> : Callback &#123;</span><br><span class="line">                <span class="meta">@Volatile</span></span><br><span class="line">                <span class="keyword">var</span> successes = <span class="number">0</span></span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">()</span></span> &#123;</span><br><span class="line">                    Log.i(<span class="string">&quot;zxw&quot;</span>, <span class="string">&quot;onFailure&quot;</span>)</span><br><span class="line">                    completer.<span class="keyword">set</span>(Result.failure())</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">()</span></span> &#123;</span><br><span class="line">                    successes++</span><br><span class="line">                    <span class="keyword">if</span> (successes == <span class="number">100</span>) &#123;</span><br><span class="line">                        Log.i(<span class="string">&quot;zxw&quot;</span>, <span class="string">&quot;onSuccess + <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">                        completer.<span class="keyword">set</span>(Result.success())</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            downloadAsynchronously(<span class="string">&quot;https://example.com&quot;</span>, callback)</span><br><span class="line">             <span class="comment">// 添加一个取消监听器即可：                                       </span></span><br><span class="line">            completer.addCancellationListener(&#123;</span><br><span class="line">                Log.i(<span class="string">&quot;zxw&quot;</span>, <span class="string">&quot;run cancel&quot;</span>)</span><br><span class="line">            &#125;, Executors.newSingleThreadExecutor())</span><br><span class="line"></span><br><span class="line">            callback</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="meta">@SuppressLint(<span class="meta-string">&quot;RestrictedApi&quot;</span>)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">downloadAsynchronously</span><span class="params">(s: <span class="type">String</span>, callback: <span class="type">Callback</span>)</span></span> &#123;</span><br><span class="line">        Thread &#123;</span><br><span class="line">            Log.i(<span class="string">&quot;zxw&quot;</span>, <span class="string">&quot;backgroundExecutor execute&quot;</span>)</span><br><span class="line">            repeat(<span class="number">100</span>) &#123;</span><br><span class="line">                callback.onSuccess()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-3、跨进程支持"><a href="#8-3、跨进程支持" class="headerlink" title="8.3、跨进程支持"></a>8.3、跨进程支持</h2><p>使用 <a href="https://developer.android.google.cn/reference/kotlin/androidx/work/multiprocess/RemoteListenableWorker"><code>RemoteListenableWorker</code></a>（<code>ListenableWorker</code> 的实现）将工作器绑定到特定进程，<a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager/advanced/listenableworker#remotelistenableworker">文档</a>。</p>
<h1 id="九、调试WorkManager"><a href="#九、调试WorkManager" class="headerlink" title="九、调试WorkManager"></a>九、调试WorkManager</h1><h2 id="9-1、jobscheduler"><a href="#9-1、jobscheduler" class="headerlink" title="9.1、jobscheduler"></a>9.1、jobscheduler</h2><p>在targetSdk &gt; 23 的版本上，WorkManager是通过JobSchedule实现的，可以通过shell 命令快速调试。</p>
<p>常用命令有如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// jobschedule 终端操作帮助文档</span></span><br><span class="line">adb shell cmd jobscheduler </span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看当前包下面所有的job信息以及状态</span></span><br><span class="line">adb shell dumpsys jobscheduler packageName</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前 jobID 为106 状态</span></span><br><span class="line">adb shell cmd jobscheduler get-job-state -u <span class="number">0</span> packageName <span class="number">106</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 强制执行com.vivo.ai.ime 包下的JobID 为106的Job</span></span><br><span class="line">adb shell cmd jobscheduler run -f packageName <span class="number">106</span></span><br></pre></td></tr></table></figure>

<h2 id="9-2、WorkManager-gt-2-4-0"><a href="#9-2、WorkManager-gt-2-4-0" class="headerlink" title="9.2、WorkManager&gt;= 2.4.0"></a>9.2、WorkManager&gt;= 2.4.0</h2><p>在应用的调试 build 中，您可以使用以下命令从 WorkManager 2.4.0 及更高版本请求诊断信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell am broadcast -a &quot;androidx.work.diagnostics.REQUEST_DIAGNOSTICS&quot; -p &quot;&lt;your_app_package_name&gt;&quot;</span><br></pre></td></tr></table></figure>

<p>这提供了以下方面的信息：</p>
<ul>
<li>在过去 24 小时内完成的工作请求。</li>
<li>目前正在运行的工作请求。</li>
<li>预定运行的工作请求。</li>
<li></li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager?hl=zh-cn">https://developer.android.google.cn/topic/libraries/architecture/workmanager?hl=zh-cn</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>Lifecycle</category>
      </categories>
  </entry>
  <entry>
    <title>Jetpack_05_WorkManager原理</title>
    <url>/2022/05/21/Notes/Android/03Jetpack/Jetpack_05_WorkManager%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="Jetpack-05-WorkManager原理"><a href="#Jetpack-05-WorkManager原理" class="headerlink" title="Jetpack_05_WorkManager原理"></a>Jetpack_05_WorkManager原理</h1><span id="more"></span>

<p>在上一篇文章中介绍了<code>WorkManager</code>的使用方法，这篇文章我们来看下 <code>WorkManager</code>是如何执行任务的。</p>
<blockquote>
<p>本文基于<code>workManager 2.7.1</code>版本源码，程序demo基于<code>sdk 31</code></p>
</blockquote>
<h1 id="一、WorkManager的初始化"><a href="#一、WorkManager的初始化" class="headerlink" title="一、WorkManager的初始化"></a>一、<code>WorkManager</code>的初始化</h1><p>引入依赖后，<code>Manifest</code>中会注册一个<code>Provider</code> ，<code>Provider</code>中我们发现会默认注册一个<code>WorkManagerInitializer</code> 的类，就是用来初始化<code>WorkManager</code>的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;provider</span><br><span class="line">    android:name=<span class="string">&quot;androidx.startup.InitializationProvider&quot;</span></span><br><span class="line">    android:exported=<span class="string">&quot;false&quot;</span></span><br><span class="line">    android:authorities=<span class="string">&quot;com.example.easyjetpack.androidx-startup&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;meta-data</span><br><span class="line">        android:name=<span class="string">&quot;androidx.work.WorkManagerInitializer&quot;</span></span><br><span class="line">        android:value=<span class="string">&quot;androidx.startup&quot;</span> /&gt;</span><br><span class="line">    <span class="comment">//... </span></span><br><span class="line">&lt;/provider&gt;</span><br></pre></td></tr></table></figure>

<p>下面看下 <code>WorkManagerInitializer</code> 中的逻辑。</p>
<h2 id="1-1、WorkManagerInitializer"><a href="#1-1、WorkManagerInitializer" class="headerlink" title="1.1、WorkManagerInitializer"></a>1.1、<code>WorkManagerInitializer</code></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkManagerInitializer</span> <span class="keyword">implements</span> <span class="title">Initializer</span>&lt;<span class="title">WorkManager</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = Logger.tagWithPrefix(<span class="string">&quot;WrkMgrInitializer&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WorkManager <span class="title">create</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Initialize WorkManager with the default configuration.</span></span><br><span class="line">        Logger.get().debug(TAG, <span class="string">&quot;Initializing WorkManager with default configuration.&quot;</span>);</span><br><span class="line">        <span class="comment">// 初始化 WorkManager</span></span><br><span class="line">        WorkManager.initialize(context, <span class="keyword">new</span> Configuration.Builder().build());</span><br><span class="line">        <span class="keyword">return</span> WorkManager.getInstance(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Class&lt;? extends androidx.startup.Initializer&lt;?&gt;&gt;&gt; dependencies() &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@NonNull</span> <span class="function">WorkManager <span class="title">getInstance</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> WorkManagerImpl.getInstance(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@NonNull</span> <span class="function">WorkManagerImpl <span class="title">getInstance</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (sLock) &#123;</span><br><span class="line">        WorkManagerImpl instance = getInstance();</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Context appContext = context.getApplicationContext();</span><br><span class="line">            <span class="keyword">if</span> (appContext <span class="keyword">instanceof</span> Configuration.Provider) &#123;</span><br><span class="line">                initialize(</span><br><span class="line">                        appContext,</span><br><span class="line">                        ((Configuration.Provider) appContext).getWorkManagerConfiguration());</span><br><span class="line">                instance = getInstance(appContext);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(<span class="meta">@NonNull</span> Context context, <span class="meta">@NonNull</span> Configuration configuration)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (sLock) &#123;</span><br><span class="line">       <span class="comment">// ..</span></span><br><span class="line">        <span class="keyword">if</span> (sDelegatedInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            context = context.getApplicationContext();</span><br><span class="line">            <span class="keyword">if</span> (sDefaultInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 构造WorkManagerImpl</span></span><br><span class="line">                sDefaultInstance = <span class="keyword">new</span> WorkManagerImpl(</span><br><span class="line">                        context,</span><br><span class="line">                        configuration,</span><br><span class="line">                        <span class="keyword">new</span> WorkManagerTaskExecutor(configuration.getTaskExecutor()));</span><br><span class="line">            &#125;</span><br><span class="line">            sDelegatedInstance = sDefaultInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过以上的调用，最终会构造出一个<code>WorkManagerImpl</code>对象。</p>
<h2 id="1-2、WorkManagerImpl"><a href="#1-2、WorkManagerImpl" class="headerlink" title="1.2、WorkManagerImpl"></a>1.2、<code>WorkManagerImpl</code></h2><p><code>WorkManager</code> 的初始化逻辑最终会调用到 <code>WorkManagerImpl</code>的构造函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WorkManagerImpl</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@NonNull</span> Context context,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@NonNull</span> Configuration configuration,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@NonNull</span> TaskExecutor workTaskExecutor,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@NonNull</span> WorkDatabase database)</span> </span>&#123;</span><br><span class="line">    Context applicationContext = context.getApplicationContext();</span><br><span class="line">    Logger.setLogger(<span class="keyword">new</span> Logger.LogcatLogger(configuration.getMinimumLoggingLevel()));</span><br><span class="line">    <span class="comment">// 调度器</span></span><br><span class="line">    List&lt;Scheduler&gt; schedulers =</span><br><span class="line">            createSchedulers(applicationContext, configuration, workTaskExecutor);</span><br><span class="line">    <span class="comment">// 执行器</span></span><br><span class="line">    Processor processor = <span class="keyword">new</span> Processor(</span><br><span class="line">            context,</span><br><span class="line">            configuration,</span><br><span class="line">            workTaskExecutor,</span><br><span class="line">            database,</span><br><span class="line">            schedulers);</span><br><span class="line">    internalInit(context, configuration, workTaskExecutor, database, schedulers, processor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">internalInit</span><span class="params">(<span class="meta">@NonNull</span> Context context,                       </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@NonNull</span> Configuration configuration,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@NonNull</span> TaskExecutor workTaskExecutor,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@NonNull</span> WorkDatabase workDatabase,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@NonNull</span> List&lt;Scheduler&gt; schedulers,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@NonNull</span> Processor processor)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    context = context.getApplicationContext();</span><br><span class="line">    mContext = context;</span><br><span class="line">    <span class="comment">// workManager 的 config 配置，包含factory 等</span></span><br><span class="line">    mConfiguration = configuration;</span><br><span class="line">    <span class="comment">// 调度任务 线程</span></span><br><span class="line">    mWorkTaskExecutor = workTaskExecutor;</span><br><span class="line">    <span class="comment">// 默认是room 数据库，将任务信息以序列话的形式保存到本地</span></span><br><span class="line">    mWorkDatabase = workDatabase;</span><br><span class="line">    mSchedulers = schedulers;</span><br><span class="line">    mProcessor = processor;</span><br><span class="line">    mPreferenceUtils = <span class="keyword">new</span> PreferenceUtils(workDatabase);</span><br><span class="line">    mForceStopRunnableCompleted = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for direct boot mode</span></span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N &amp;&amp; context.isDeviceProtectedStorage()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Cannot initialize WorkManager in direct boot mode&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Checks for app force stops.</span></span><br><span class="line">  	<span class="comment">// 这个Runnable的作用就是在WorkManager初始化过程中，发现了未完成的，需要重新执行的任务，或者app被强制kill的情况下，直接对Scheduler进行调度。</span></span><br><span class="line">    mWorkTaskExecutor.executeOnBackgroundThread(<span class="keyword">new</span> ForceStopRunnable(context, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a><code>Scheduler</code></h3><p><code>Scheduler</code>主要用来调度任务，可以分为2类：</p>
<ul>
<li>执行没有任何约束的非周期性的任务 <code>GreedyScheduler</code></li>
<li>执行周期性 或 有约束条件的任务<ul>
<li><code>SDK version &gt;= 23</code>时，则返回<code>SystemJobScheduler</code></li>
<li><code>SDK version &lt; 23</code>时，先尝试使用<code>GcmScheduler</code>进行管理。若无法创建<code>GcmScheduler</code>则创建<code>SystemAlarmScheduler</code>使用<code>AlamManager + 广播</code> 进行任务管理。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Scheduler&gt; <span class="title">createSchedulers</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@NonNull</span> Context context,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@NonNull</span> Configuration configuration,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@NonNull</span> TaskExecutor taskExecutor)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Arrays.asList(</span><br><span class="line">            Schedulers.createBestAvailableBackgroundScheduler(context, <span class="keyword">this</span>),</span><br><span class="line">            <span class="comment">// Specify the task executor directly here as this happens before internalInit.</span></span><br><span class="line">            <span class="comment">// GreedyScheduler creates ConstraintTrackers and controllers eagerly.</span></span><br><span class="line">            <span class="keyword">new</span> GreedyScheduler(context, configuration, taskExecutor, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Scheduler <span class="title">createBestAvailableBackgroundScheduler</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@NonNull</span> Context context,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@NonNull</span> WorkManagerImpl workManager)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Scheduler scheduler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= WorkManagerImpl.MIN_JOB_SCHEDULER_API_LEVEL) &#123;</span><br><span class="line">        <span class="comment">// &gt; 23 使用</span></span><br><span class="line">        scheduler = <span class="keyword">new</span> SystemJobScheduler(context, workManager);</span><br><span class="line">        setComponentEnabled(context, SystemJobService.class, <span class="keyword">true</span>);</span><br><span class="line">        Logger.get().debug(TAG, <span class="string">&quot;Created SystemJobScheduler and enabled SystemJobService&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        scheduler = tryCreateGcmBasedScheduler(context);</span><br><span class="line">        <span class="keyword">if</span> (scheduler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            scheduler = <span class="keyword">new</span> SystemAlarmScheduler(context);</span><br><span class="line">            setComponentEnabled(context, SystemAlarmService.class, <span class="keyword">true</span>);</span><br><span class="line">            Logger.get().debug(TAG, <span class="string">&quot;Created SystemAlarmScheduler&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> scheduler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结下初始化过程：</p>
<img src="https://pic2.zhimg.com/v2-61b832aa9c912ffbeaec57769d166221_r.jpg" style="zoom:67%;" />

<ol>
<li><code>WorkManager</code>的初始化是在app冷启动后，由<code>WorkManagerInitializer</code>这个<code>ContentProvider</code>执行</li>
<li>初始化过程包含了对<code>Configuration/WorkManagerTaskExecutor/WorkDatabase/Schedulers/Processor</code>等的初始化。</li>
<li><code>Schedulers</code> 用来调度任务执行，根据SDK Version 创建不同的 <code>Scheduler</code>，最后再通过<code>Processor</code> 执行具体的任务。</li>
</ol>
<h1 id="二、WorkRequest创建"><a href="#二、WorkRequest创建" class="headerlink" title="二、WorkRequest创建"></a>二、<code>WorkRequest</code>创建</h1><p>创建任务时，我们通常是通过<code>WorkRequestBuilder</code>来构建，</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> request6 = OneTimeWorkRequestBuilder&lt;CallBackWorker&gt;().build()</span><br></pre></td></tr></table></figure>

<p>我们以<code>OneTimeWorkRequestBuilder</code>看下 <code>WorkRequest</code>的构建流程</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> W : ListenableWorker&gt;</span> <span class="title">OneTimeWorkRequestBuilder</span><span class="params">()</span></span>:</span><br><span class="line">    <span class="comment">// OneTimeWorkRequest#Builder</span></span><br><span class="line">    OneTimeWorkRequest.Builder = OneTimeWorkRequest.Builder(W::<span class="keyword">class</span>.java)</span><br><span class="line"></span><br><span class="line"><span class="comment">// OneTimeWorkRequestBuilder#Builder</span></span><br><span class="line"><span class="keyword">public</span> Builder(<span class="meta">@NonNull</span> Class&lt;? extends ListenableWorker&gt; workerClass) &#123;</span><br><span class="line">       <span class="keyword">super</span>(workerClass);</span><br><span class="line">       mWorkSpec.inputMergerClassName = OverwritingInputMerger.<span class="keyword">class</span>.getName();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WorkRequestBuilder#Builder</span></span><br><span class="line">Builder(<span class="meta">@NonNull</span> Class&lt;? extends ListenableWorker&gt; workerClass) &#123;</span><br><span class="line">    <span class="comment">// 生成 builder 的id</span></span><br><span class="line">    mId = UUID.randomUUID();</span><br><span class="line">    mWorkerClass = workerClass;</span><br><span class="line">    mWorkSpec = new WorkSpec(mId.toString(), workerClass.getName());</span><br><span class="line">    addTag(workerClass.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>OneTimeWorkRequest</code>为builder对象创建了<code>WorkSpec</code>对象用来保存任务id和类名，其中</p>
<ul>
<li>id是通过UUID自动生成的，mId 会保存到 <code>WorkRequest</code>中</li>
<li>tag默认是通过类名生成的，外部也可调用addTag()方法设置标签</li>
<li>为<code>WorkSpec</code>设置了默认的任务输入流的合并规则：<code>OverwritingInputMerger</code></li>
</ul>
<h2 id="2-1、WorkSpec"><a href="#2-1、WorkSpec" class="headerlink" title="2.1、WorkSpec"></a>2.1、<code>WorkSpec</code></h2><p><code>WorkSpec</code> 包含了任务的详细信息，同时也是任务存储在数据库中的实体。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkSpec</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> static <span class="keyword">final</span> String TAG = Logger.tagWithPrefix(<span class="string">&quot;WorkSpec&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> long SCHEDULE_NOT_REQUESTED_YET = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">&quot;id&quot;</span>)</span></span><br><span class="line">    <span class="meta">@PrimaryKey</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">public</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">&quot;state&quot;</span>)</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">public</span> WorkInfo.State state = ENQUEUED;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">&quot;worker_class_name&quot;</span>)</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">public</span> String workerClassName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">&quot;input_merger_class_name&quot;</span>)</span></span><br><span class="line">    <span class="keyword">public</span> String inputMergerClassName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">&quot;input&quot;</span>)</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">public</span> Data input = Data.EMPTY;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">&quot;output&quot;</span>)</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">public</span> Data output = Data.EMPTY;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">&quot;initial_delay&quot;</span>)</span></span><br><span class="line">    <span class="keyword">public</span> long initialDelay;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">&quot;interval_duration&quot;</span>)</span></span><br><span class="line">    <span class="keyword">public</span> long intervalDuration;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="meta-string">&quot;flex_duration&quot;</span>)</span></span><br><span class="line">    <span class="keyword">public</span> long flexDuration;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">    <span class="keyword">public</span> WorkSpec(<span class="meta">@NonNull</span> String id, <span class="meta">@NonNull</span> String workerClassName) &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.workerClassName = workerClassName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-2、WorkRequest-build"><a href="#2-2、WorkRequest-build" class="headerlink" title="2.2、WorkRequest#build"></a>2.2、<code>WorkRequest#build</code></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="meta">@NonNull</span> <span class="function">W <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// buildInternal()方法返回了一个WorkRequest对象，这是个抽象方法</span></span><br><span class="line">    W returnValue = buildInternal();</span><br><span class="line">    Constraints constraints = mWorkSpec.constraints;</span><br><span class="line">    <span class="comment">// Create a new id and WorkSpec so this WorkRequest.Builder can be used multiple times.</span></span><br><span class="line">    mId = UUID.randomUUID();</span><br><span class="line">    mWorkSpec = <span class="keyword">new</span> WorkSpec(mWorkSpec);</span><br><span class="line">    mWorkSpec.id = mId.toString();</span><br><span class="line">    <span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// OneTimeWorkRequest#buildInternal</span></span><br><span class="line"><span class="meta">@NonNull</span> <span class="function">OneTimeWorkRequest <span class="title">buildInternal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mBackoffCriteriaSet</span><br><span class="line">            &amp;&amp; Build.VERSION.SDK_INT &gt;= <span class="number">23</span></span><br><span class="line">            &amp;&amp; mWorkSpec.constraints.requiresDeviceIdle()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                <span class="string">&quot;Cannot set backoff criteria on an idle mode job&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> OneTimeWorkRequest(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">OneTimeWorkRequest(Builder builder) &#123;</span><br><span class="line">    <span class="keyword">super</span>(builder.mId, builder.mWorkSpec, builder.mTags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">WorkRequest</span><span class="params">(<span class="meta">@NonNull</span> UUID id, <span class="meta">@NonNull</span> WorkSpec workSpec, <span class="meta">@NonNull</span> Set&lt;String&gt; tags)</span> </span>&#123;</span><br><span class="line">    mId = id;</span><br><span class="line">    mWorkSpec = workSpec;</span><br><span class="line">    mTags = tags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WorkRequest的创建是为了持有三个重要的成员变量。分别是：</p>
<ol>
<li>mId：由UUID生成的任务id。</li>
<li>mWorkSpec：每个任务的属性。</li>
<li>mTags：每个任务的标签。</li>
</ol>
<p>注意：<code>OneTimeWorkRequest#buildInternal</code>中为<code>Builder</code>创建了一个新的<code>WorkSpec</code>对象，并赋予了新的<code>UUID</code>。虽然与原先的<code>WorkSpec</code>对象中每个属性的值是一致的，但指向了不同的内存地址。这么做的目的是为了这个<code>Builder</code>对象可被重复利用。好了，现在我们一个任务的WorkRequest创建就完成了。</p>
<p><img src="/pics/v2-fdae66d3ef4c350fbb4298935a831e64_r.jpg" alt="request"></p>
<h1 id="三、任务的执行"><a href="#三、任务的执行" class="headerlink" title="三、任务的执行"></a>三、任务的执行</h1><p><code>WorkeRequest</code>任务创建完成后，下一步就是任务的执行了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> request6 = OneTimeWorkRequestBuilder&lt;CallBackWorker&gt;().build()</span><br><span class="line">workManager.enqueue(request6)</span><br></pre></td></tr></table></figure>

<h2 id="3-1、workManager-enqueue"><a href="#3-1、workManager-enqueue" class="headerlink" title="3.1、workManager#enqueue"></a>3.1、<code>workManager#enqueue</code></h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Operation enqueue(<span class="meta">@NonNull</span> WorkRequest workRequest) &#123;</span><br><span class="line">    <span class="keyword">return</span> enqueue(Collections.singletonList(workRequest));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Operation enqueue(</span><br><span class="line">            <span class="meta">@NonNull</span> List&lt;? extends WorkRequest&gt; requests) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This error is not being propagated as part of the Operation, as we want the</span></span><br><span class="line">        <span class="comment">// app to crash during development. Having no workRequests is always a developer error.</span></span><br><span class="line">        <span class="keyword">if</span> (requests.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> new IllegalArgumentException(</span><br><span class="line">                    <span class="string">&quot;enqueue needs at least one WorkRequest.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建WorkContinuationImpl 对象</span></span><br><span class="line">        <span class="keyword">return</span> new WorkContinuationImpl(<span class="keyword">this</span>, requests).enqueue();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>创建一个<code>WorkContinuationImpl</code>对象，再执行<code>enqueue</code>方法。</p>
<h3 id="WorkContinuationImpl"><a href="#WorkContinuationImpl" class="headerlink" title="WorkContinuationImpl"></a><code>WorkContinuationImpl</code></h3><p><code>WorkContinuationImpl</code>是<code>WorkContinuation</code>的子类。用来把多个<code>OneTimeWorkRequest</code>根据需求串行，并行或合并处理。我们熟悉的<code>then</code>，<code>enqueue</code>等都是这个类的方法。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> WorkContinuationImpl(<span class="meta">@NonNull</span> WorkManagerImpl workManagerImpl,</span><br><span class="line">        <span class="meta">@Nullable</span> String name,</span><br><span class="line">        <span class="meta">@NonNull</span> ExistingWorkPolicy existingWorkPolicy,</span><br><span class="line">        <span class="meta">@NonNull</span> List&lt;? extends WorkRequest&gt; work,</span><br><span class="line">        <span class="meta">@Nullable</span> List&lt;WorkContinuationImpl&gt; parents) &#123;</span><br><span class="line">    mWorkManagerImpl = workManagerImpl;</span><br><span class="line">    mName = name;</span><br><span class="line">    mExistingWorkPolicy = existingWorkPolicy;</span><br><span class="line">    mWork = work;</span><br><span class="line">    mParents = parents;</span><br><span class="line">    mIds = new ArrayList&lt;&gt;(mWork.size());</span><br><span class="line">    mAllIds = new ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (parents != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (WorkContinuationImpl parent : parents) &#123;</span><br><span class="line">            mAllIds.addAll(parent.mAllIds);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; work.size(); i++) &#123;</span><br><span class="line">        String id = work.<span class="keyword">get</span>(i).getStringId();</span><br><span class="line">        mIds.add(id);</span><br><span class="line">        mAllIds.add(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们继续看<code>enqueue</code> 方法的实现。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@NonNull</span> Operation enqueue() &#123;</span><br><span class="line">    <span class="comment">// Only enqueue if not already enqueued.</span></span><br><span class="line">    <span class="keyword">if</span> (!mEnqueued) &#123;</span><br><span class="line">        <span class="comment">// The runnable walks the hierarchy of the continuations</span></span><br><span class="line">        <span class="comment">// and marks them enqueued using the markEnqueued() method, parent first.</span></span><br><span class="line">        <span class="comment">// 1.创建 EnqueueRunnable</span></span><br><span class="line">        EnqueueRunnable runnable = new EnqueueRunnable(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 2.使用WorkManager的TaskExecutor执行 </span></span><br><span class="line">        mWorkManagerImpl.getWorkTaskExecutor().executeOnBackgroundThread(runnable);</span><br><span class="line">        mOperation = runnable.getOperation();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Logger.<span class="keyword">get</span>().warning(TAG,</span><br><span class="line">                String.format(<span class="string">&quot;Already enqueued work ids (%s)&quot;</span>, TextUtils.join(<span class="string">&quot;, &quot;</span>, mIds)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mOperation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>WorkManager</code>的<code>TaskExecutor</code>执行<code>EnqueueRunnable</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EnqueueRunnable</span></span><br><span class="line"><span class="keyword">public</span> void run() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mWorkContinuation.hasCycles()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> new IllegalStateException(</span><br><span class="line">                    String.format(<span class="string">&quot;WorkContinuation has cycles (%s)&quot;</span>, mWorkContinuation));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1.将任务添加到 数据库 中</span></span><br><span class="line">        boolean needsScheduling = addToDatabase();</span><br><span class="line">        <span class="keyword">if</span> (needsScheduling) &#123;</span><br><span class="line">            <span class="comment">// Enable RescheduleReceiver, only when there are Worker&#x27;s that need scheduling.</span></span><br><span class="line">            <span class="keyword">final</span> Context context =</span><br><span class="line">                    mWorkContinuation.getWorkManagerImpl().getApplicationContext();</span><br><span class="line">            PackageManagerHelper.setComponentEnabled(context, RescheduleReceiver.<span class="keyword">class</span>, <span class="literal">true</span>);</span><br><span class="line">            <span class="comment">// 2.开始执行</span></span><br><span class="line">            scheduleWorkInBackground();</span><br><span class="line">        &#125;</span><br><span class="line">        mOperation.setState(Operation.SUCCESS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable exception) &#123;</span><br><span class="line">        mOperation.setState(new Operation.State.FAILURE(exception));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> void scheduleWorkInBackground() &#123;</span><br><span class="line">    WorkManagerImpl workManager = mWorkContinuation.getWorkManagerImpl();</span><br><span class="line">    Schedulers.schedule(</span><br><span class="line">            workManager.getConfiguration(),</span><br><span class="line">            workManager.getWorkDatabase(),</span><br><span class="line">            workManager.getSchedulers());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Schedulers-schedule"><a href="#Schedulers-schedule" class="headerlink" title="Schedulers#schedule"></a><code>Schedulers#schedule</code></h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> static void schedule(</span><br><span class="line">        <span class="meta">@NonNull</span> Configuration configuration,</span><br><span class="line">        <span class="meta">@NonNull</span> WorkDatabase workDatabase,</span><br><span class="line">        List&lt;Scheduler&gt; schedulers) &#123;</span><br><span class="line">    <span class="keyword">if</span> (schedulers == <span class="literal">null</span> || schedulers.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WorkSpecDao workSpecDao = workDatabase.workSpecDao();</span><br><span class="line">    <span class="comment">// 1、有限制条件的任务</span></span><br><span class="line">    List&lt;WorkSpec&gt; eligibleWorkSpecsForLimitedSlots;</span><br><span class="line">    <span class="comment">// 2、有限制条件的任务</span></span><br><span class="line">    List&lt;WorkSpec&gt; allEligibleWorkSpecs;</span><br><span class="line"></span><br><span class="line">    workDatabase.beginTransaction();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Enqueued workSpecs when scheduling limits are applicable.</span></span><br><span class="line">        eligibleWorkSpecsForLimitedSlots = workSpecDao.getEligibleWorkForScheduling(</span><br><span class="line">                configuration.getMaxSchedulerLimit());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Enqueued workSpecs when scheduling limits are NOT applicable.</span></span><br><span class="line">        allEligibleWorkSpecs = workSpecDao.getAllEligibleWorkSpecsForScheduling(</span><br><span class="line">                MAX_GREEDY_SCHEDULER_LIMIT);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        workDatabase.endTransaction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eligibleWorkSpecsForLimitedSlots != <span class="literal">null</span></span><br><span class="line">            &amp;&amp; eligibleWorkSpecsForLimitedSlots.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        WorkSpec[] eligibleWorkSpecsArray =</span><br><span class="line">                new WorkSpec[eligibleWorkSpecsForLimitedSlots.size()];</span><br><span class="line">        eligibleWorkSpecsArray =</span><br><span class="line">                eligibleWorkSpecsForLimitedSlots.toArray(eligibleWorkSpecsArray);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Delegate to the underlying schedulers.</span></span><br><span class="line">        <span class="comment">// 3、执行有限制的周期任务</span></span><br><span class="line">        <span class="keyword">for</span> (Scheduler scheduler : schedulers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (scheduler.hasLimitedSchedulingSlots()) &#123;</span><br><span class="line">                scheduler.schedule(eligibleWorkSpecsArray);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (allEligibleWorkSpecs != <span class="literal">null</span> &amp;&amp; allEligibleWorkSpecs.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        WorkSpec[] enqueuedWorkSpecsArray = new WorkSpec[allEligibleWorkSpecs.size()];</span><br><span class="line">        enqueuedWorkSpecsArray = allEligibleWorkSpecs.toArray(enqueuedWorkSpecsArray);</span><br><span class="line">        <span class="comment">// Delegate to the underlying schedulers.</span></span><br><span class="line">        <span class="keyword">for</span> (Scheduler scheduler : schedulers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!scheduler.hasLimitedSchedulingSlots()) &#123;</span><br><span class="line">           			<span class="comment">// 4、执行无限制任务</span></span><br><span class="line">                scheduler.schedule(enqueuedWorkSpecsArray);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先进行了一系列的数据库操作，然后开始根据条件每个任务进行调度。其中eligibleWorkSpecs返回的是在ENQUEUED状态下，未被执行且未被取消的WorkSpec列表，然后更新这些任务的request状态到数据库。最后遍历schedulers调用scheduler.schedule()对每个任务进行调度处理。</p>
<p>先进行了一系列的数据库操作，然后开始根据条件每个任务进行调度。其中<code>eligibleWorkSpecs</code>返回的是在<code>ENQUEUED</code>状态下，未被执行且未被取消的<code>WorkSpec</code>列表，然后更新这些任务的状态到数据库。最后遍历<code>schedulers</code>调用<code>scheduler.schedule</code>对每个任务进行调度处理。</p>
<h2 id="3-2、无限制条件任务的执行"><a href="#3-2、无限制条件任务的执行" class="headerlink" title="3.2、无限制条件任务的执行"></a>3.2、无限制条件任务的执行</h2><h3 id="GreedyScheduler-schedule"><a href="#GreedyScheduler-schedule" class="headerlink" title="GreedyScheduler#schedule"></a><code>GreedyScheduler#schedule</code></h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> void schedule(<span class="meta">@NonNull</span> WorkSpec... workSpecs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mInDefaultProcess == <span class="literal">null</span>) &#123;</span><br><span class="line">        checkDefaultProcess();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mInDefaultProcess) &#123;</span><br><span class="line">        Logger.<span class="keyword">get</span>().info(TAG, <span class="string">&quot;Ignoring schedule request in a secondary process&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    registerExecutionListenerIfNeeded();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Keep track of the list of new WorkSpecs whose constraints need to be tracked.</span></span><br><span class="line">    <span class="comment">// Add them to the known list of constrained WorkSpecs and call replace() on</span></span><br><span class="line">    <span class="comment">// WorkConstraintsTracker. That way we only need to synchronize on the part where we</span></span><br><span class="line">    <span class="comment">// are updating mConstrainedWorkSpecs.</span></span><br><span class="line">    Set&lt;WorkSpec&gt; constrainedWorkSpecs = new HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; constrainedWorkSpecIds = new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (WorkSpec workSpec : workSpecs) &#123;</span><br><span class="line">        long nextRunTime = workSpec.calculateNextRunTime();</span><br><span class="line">        long now = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 1、WorkSpec是ENQUEUED的状态</span></span><br><span class="line">        <span class="keyword">if</span> (workSpec.state == WorkInfo.State.ENQUEUED) &#123;</span><br><span class="line">            <span class="comment">//2、非延迟执行</span></span><br><span class="line">            <span class="keyword">if</span> (now &lt; nextRunTime) &#123;</span><br><span class="line">                <span class="comment">// Future work</span></span><br><span class="line">                <span class="keyword">if</span> (mDelayedWorkTracker != <span class="literal">null</span>) &#123;</span><br><span class="line">                    mDelayedWorkTracker.schedule(workSpec);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (workSpec.hasConstraints()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (SDK_INT &gt;= <span class="number">23</span> &amp;&amp; workSpec.constraints.requiresDeviceIdle()) &#123;</span><br><span class="line">                    <span class="comment">// Ignore requests that have an idle mode constraint.</span></span><br><span class="line">                    Logger.<span class="keyword">get</span>().debug(TAG,</span><br><span class="line">                            String.format(<span class="string">&quot;Ignoring WorkSpec %s, Requires device idle.&quot;</span>,</span><br><span class="line">                                    workSpec));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SDK_INT &gt;= <span class="number">24</span> &amp;&amp; workSpec.constraints.hasContentUriTriggers()) &#123;</span><br><span class="line">                    <span class="comment">// Ignore requests that have content uri triggers.</span></span><br><span class="line">                    Logger.<span class="keyword">get</span>().debug(TAG,</span><br><span class="line">                            String.format(<span class="string">&quot;Ignoring WorkSpec %s, Requires ContentUri triggers.&quot;</span>,</span><br><span class="line">                                    workSpec));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    constrainedWorkSpecs.add(workSpec);</span><br><span class="line">                    constrainedWorkSpecIds.add(workSpec.id);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Logger.<span class="keyword">get</span>().debug(TAG, String.format(<span class="string">&quot;Starting work for %s&quot;</span>, workSpec.id));</span><br><span class="line">                <span class="comment">// 3、开始执行任务</span></span><br><span class="line">                mWorkManagerImpl.startWork(workSpec.id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>WorkSpec</code>是ENQUEUED的状态 &amp; 非延迟任务，调用<code>WorkManagerImpl</code>执行。</p>
<h3 id="WorkManager-startWork"><a href="#WorkManager-startWork" class="headerlink" title="WorkManager#startWork"></a><code>WorkManager#startWork</code></h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> void startWork(<span class="meta">@NonNull</span> String workSpecId) &#123;</span><br><span class="line">    startWork(workSpecId, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> void startWork(</span><br><span class="line">        <span class="meta">@NonNull</span> String workSpecId,</span><br><span class="line">        <span class="meta">@Nullable</span> WorkerParameters.RuntimeExtras runtimeExtras) &#123;</span><br><span class="line">    mWorkTaskExecutor</span><br><span class="line">            .executeOnBackgroundThread(</span><br><span class="line">                    new StartWorkRunnable(<span class="keyword">this</span>, workSpecId, runtimeExtras));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>WorkTaskExecutor</code> 执行<code>StartWorkRunnable</code></p>
<h3 id="StartWorkRunnable-run"><a href="#StartWorkRunnable-run" class="headerlink" title="StartWorkRunnable#run"></a><code>StartWorkRunnable#run</code></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    mWorkManagerImpl.getProcessor().startWork(mWorkSpecId, mRuntimeExtras);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>StartWorkRunnable</code>会将任务的信息交给<code>Processor</code>，由<code>Processor#startWork</code>执行任务:</p>
<h3 id="Processor-startWork"><a href="#Processor-startWork" class="headerlink" title="Processor#startWork"></a><code>Processor#startWork</code></h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> boolean startWork(</span><br><span class="line">        <span class="meta">@NonNull</span> String id,</span><br><span class="line">        <span class="meta">@Nullable</span> WorkerParameters.RuntimeExtras runtimeExtras) &#123;</span><br><span class="line"></span><br><span class="line">    WorkerWrapper workWrapper;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        <span class="comment">// Work may get triggered multiple times if they have passing constraints</span></span><br><span class="line">        <span class="comment">// and new work with those constraints are added.</span></span><br><span class="line">        <span class="keyword">if</span> (isEnqueued(id)) &#123;</span><br><span class="line">            Logger.<span class="keyword">get</span>().debug(</span><br><span class="line">                    TAG,</span><br><span class="line">                    String.format(<span class="string">&quot;Work %s is already enqueued for processing&quot;</span>, id));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//1、构建 workWrapper</span></span><br><span class="line">        workWrapper =</span><br><span class="line">                new WorkerWrapper.Builder(</span><br><span class="line">                        mAppContext,</span><br><span class="line">                        mConfiguration,</span><br><span class="line">                        mWorkTaskExecutor,</span><br><span class="line">                        <span class="keyword">this</span>,</span><br><span class="line">                        mWorkDatabase,</span><br><span class="line">                        id)</span><br><span class="line">                        .withSchedulers(mSchedulers)</span><br><span class="line">                        .withRuntimeExtras(runtimeExtras)</span><br><span class="line">                        .build();</span><br><span class="line">        </span><br><span class="line">        ListenableFuture&lt;<span class="built_in">Boolean</span>&gt; future = workWrapper.getFuture();</span><br><span class="line">        future.addListener(</span><br><span class="line">                <span class="comment">// 2、在 workWrapper 执行完成后 执行 FutureListener</span></span><br><span class="line">                new FutureListener(<span class="keyword">this</span>, id, future),</span><br><span class="line">                mWorkTaskExecutor.getMainThreadExecutor());</span><br><span class="line">        mEnqueuedWorkMap.put(id, workWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3、执行workWrapper</span></span><br><span class="line">    mWorkTaskExecutor.getBackgroundExecutor().execute(workWrapper);</span><br><span class="line">    Logger.<span class="keyword">get</span>().debug(TAG, String.format(<span class="string">&quot;%s: processing %s&quot;</span>, getClass().getSimpleName(), id));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建了一个<code>WorkerWrapper</code>对象，交由<code>WorkTaskExecutor</code>调度处理。</p>
<h3 id="WorkerWrapper-run"><a href="#WorkerWrapper-run" class="headerlink" title="WorkerWrapper#run"></a><code>WorkerWrapper#run</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WorkerThread</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mTags = mWorkTagDao.getTagsForWorkSpecId(mWorkSpecId);</span><br><span class="line">    mWorkDescription = createWorkDescription(mTags);</span><br><span class="line">    <span class="comment">// 执行runWorker</span></span><br><span class="line">    runWorker();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryCheckForInterruptionAndResolve()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mWorkDatabase.beginTransaction();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1、从数据库中查找任务</span></span><br><span class="line">        mWorkSpec = mWorkSpecDao.getWorkSpec(mWorkSpecId);</span><br><span class="line">        mWorkDatabase.setTransactionSuccessful();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mWorkDatabase.endTransaction();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">		<span class="comment">// 2、组装 WorkerParameters</span></span><br><span class="line">    <span class="keyword">final</span> WorkerParameters params = <span class="keyword">new</span> WorkerParameters(</span><br><span class="line">            UUID.fromString(mWorkSpecId),</span><br><span class="line">            input,</span><br><span class="line">            mTags,</span><br><span class="line">            mRuntimeExtras,</span><br><span class="line">            mWorkSpec.runAttemptCount,</span><br><span class="line">            mConfiguration.getExecutor(),</span><br><span class="line">            mWorkTaskExecutor,</span><br><span class="line">            mConfiguration.getWorkerFactory(),</span><br><span class="line">            <span class="keyword">new</span> WorkProgressUpdater(mWorkDatabase, mWorkTaskExecutor),</span><br><span class="line">            <span class="keyword">new</span> WorkForegroundUpdater(mWorkDatabase, mForegroundProcessor, mWorkTaskExecutor));</span><br><span class="line"></span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (trySetRunning()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryCheckForInterruptionAndResolve()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">// 3、构造future 对象用来做任务调度</span></span><br><span class="line">        <span class="keyword">final</span> SettableFuture&lt;ListenableWorker.Result&gt; future = SettableFuture.create();</span><br><span class="line">        <span class="comment">// 4、构造 WorkForegroundRunnable</span></span><br><span class="line">        <span class="keyword">final</span> WorkForegroundRunnable foregroundRunnable =</span><br><span class="line">                <span class="keyword">new</span> WorkForegroundRunnable(</span><br><span class="line">                        mAppContext,</span><br><span class="line">                        mWorkSpec,</span><br><span class="line">                        mWorker,</span><br><span class="line">                        params.getForegroundUpdater(),</span><br><span class="line">                        mWorkTaskExecutor</span><br><span class="line">                );</span><br><span class="line">        <span class="comment">// 5、主线程中执行 foregroundRunnable</span></span><br><span class="line">        mWorkTaskExecutor.getMainThreadExecutor().execute(foregroundRunnable);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6、获取 foregroundRunnable的future 对象</span></span><br><span class="line">        <span class="keyword">final</span> ListenableFuture&lt;Void&gt; runExpedited = foregroundRunnable.getFuture();</span><br><span class="line">        runExpedited.addListener(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 7、等待 foregroundRunnable 执行完成</span></span><br><span class="line">                    runExpedited.get();</span><br><span class="line">                    Logger.get().debug(TAG,</span><br><span class="line">                            String.format(<span class="string">&quot;Starting work for %s&quot;</span>, mWorkSpec.workerClassName));</span><br><span class="line">                    <span class="comment">// Call mWorker.startWork() on the main thread.</span></span><br><span class="line">                    <span class="comment">// 8、执行任务，会进一步调用到Worker#doWork</span></span><br><span class="line">                    mInnerFuture = mWorker.startWork();</span><br><span class="line">                    <span class="comment">// 9、将future </span></span><br><span class="line">                    future.setFuture(mInnerFuture);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    future.setException(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, mWorkTaskExecutor.getMainThreadExecutor());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Avoid synthetic accessors.</span></span><br><span class="line">        <span class="keyword">final</span> String workDescription = mWorkDescription;</span><br><span class="line">        future.addListener(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="meta">@SuppressLint(&quot;SyntheticAccessor&quot;)</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// If the ListenableWorker returns a null result treat it as a failure.            // 10、等待后台任务返回结果</span></span><br><span class="line">                    ListenableWorker.Result result = future.get();</span><br><span class="line">                    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        Logger.get().error(TAG, String.format(</span><br><span class="line">                                <span class="string">&quot;%s returned a null result. Treating it as a failure.&quot;</span>,</span><br><span class="line">                                mWorkSpec.workerClassName));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        Logger.get().debug(TAG, String.format(<span class="string">&quot;%s returned a %s result.&quot;</span>,</span><br><span class="line">                                mWorkSpec.workerClassName, result));</span><br><span class="line">                        mResult = result;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (CancellationException exception) &#123;</span><br><span class="line">                    <span class="comment">// Cancellations need to be treated with care here because innerFuture</span></span><br><span class="line">                    <span class="comment">// cancellations will bubble up, and we need to gracefully handle that.</span></span><br><span class="line">                    Logger.get().info(TAG, String.format(<span class="string">&quot;%s was cancelled&quot;</span>, workDescription),</span><br><span class="line">                            exception);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException exception) &#123;</span><br><span class="line">                    Logger.get().error(TAG,</span><br><span class="line">                            String.format(<span class="string">&quot;%s failed because it threw an exception/error&quot;</span>,</span><br><span class="line">                                    workDescription), exception);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 11、后台任务执行完成回调</span></span><br><span class="line">                    onWorkFinished();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, mWorkTaskExecutor.getBackgroundExecutor());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolveIncorrectStatus();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Worker 的执行过程涉及到比较复杂的线程调度，主要利用了<code>SettableFuture</code>和<code>ListenableFuture</code>的2个特性。    </p>
<ol>
<li><code>future#get</code>会阻塞当前线程的执行<ol start="2">
<li>addListener监听方法，当任务执行完成，会主动回调该方法</li>
</ol>
</li>
</ol>
<p>我们通过一张时序图来看下。</p>
<p><img src="/pics/image-20220528180120396.png" alt="image-20220528180120396"></p>
<p>run 方法的执行过程会涉及到3个线程的切换：</p>
<ol>
<li>Task 线程主要用来调度任务</li>
<li>主线程，获取 前台服务 的信息，任务执行完成回调到Processor 中</li>
<li>worker线程，执行后台任务</li>
</ol>
<h3 id="WorkerWrapper-onWorkFinished"><a href="#WorkerWrapper-onWorkFinished" class="headerlink" title="WorkerWrapper#onWorkFinished"></a><code>WorkerWrapper#onWorkFinished</code></h3><p><code>onWorkFinished</code>会对执行完毕的任务根据state作进一步处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onWorkFinished</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryCheckForInterruptionAndResolve()) &#123;</span><br><span class="line">        mWorkDatabase.beginTransaction();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            WorkInfo.State state = mWorkSpecDao.getState(mWorkSpecId);</span><br><span class="line">            mWorkDatabase.workProgressDao().delete(mWorkSpecId);</span><br><span class="line">            <span class="keyword">if</span> (state == <span class="keyword">null</span>) &#123;</span><br><span class="line">                resolve(<span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == RUNNING) &#123;</span><br><span class="line">               <span class="comment">// 正常走这里</span></span><br><span class="line">                handleResult(mResult);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!state.isFinished()) &#123;</span><br><span class="line">                rescheduleAndResolve();</span><br><span class="line">            &#125;</span><br><span class="line">            mWorkDatabase.setTransactionSuccessful();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mWorkDatabase.endTransaction();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// handleResult()执行完毕后更新isWorkFinished。如果isWorkFinished为true，由于我们在GreedyScheduler已经处理了这个任务，为了避免这个任务被其他schedulers处理，WorkManager遍历了mSchedulers列表，并将这个任务从其他schedulers中移除。最后再次执行Schedulers.schedule()方法，schedule下一个任务。</span></span><br><span class="line">     <span class="keyword">if</span> (mSchedulers != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="keyword">for</span> (Scheduler scheduler : mSchedulers) &#123;</span><br><span class="line">         scheduler.cancel(mWorkSpecId);</span><br><span class="line">     &#125;</span><br><span class="line">     Schedulers.schedule(mConfiguration, mWorkDatabase, mSchedulers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据任务的最终状态进行处理</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleResult</span><span class="params">(ListenableWorker.Result result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (result <span class="keyword">instanceof</span> ListenableWorker.Result.Success) &#123;</span><br><span class="line">        Logger.get().info(</span><br><span class="line">                TAG,</span><br><span class="line">                String.format(<span class="string">&quot;Worker result SUCCESS for %s&quot;</span>, mWorkDescription));</span><br><span class="line">        <span class="keyword">if</span> (mWorkSpec.isPeriodic()) &#123;</span><br><span class="line">            resetPeriodicAndResolve();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            setSucceededAndResolve();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result <span class="keyword">instanceof</span> ListenableWorker.Result.Retry) &#123;</span><br><span class="line">        Logger.get().info(</span><br><span class="line">                TAG,</span><br><span class="line">                String.format(<span class="string">&quot;Worker result RETRY for %s&quot;</span>, mWorkDescription));</span><br><span class="line">        rescheduleAndResolve();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Logger.get().info(</span><br><span class="line">                TAG,</span><br><span class="line">                String.format(<span class="string">&quot;Worker result FAILURE for %s&quot;</span>, mWorkDescription));</span><br><span class="line">        <span class="keyword">if</span> (mWorkSpec.isPeriodic()) &#123;</span><br><span class="line">            resetPeriodicAndResolve();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            setFailedAndResolve();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>handleResult</code>方法中会根据任务类型和result结果进行不同的处理。例如周期性的任务会重新将这个任务的状态设置为ENQUEUED，更新其他相关参数，并更新数据库。具体的处理的过程就不展开了。</p>
<h2 id="3-3、有限制条件任务的执行"><a href="#3-3、有限制条件任务的执行" class="headerlink" title="3.3、有限制条件任务的执行"></a>3.3、有限制条件任务的执行</h2><p>上面我们分析了没有约束条件的一次性任务的执行过程。下面分析下有约束任务的执行。</p>
<p>创建一个非低电量才能执行的任务：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> constraints = Constraints.Builder()</span><br><span class="line">                .setRequiresBatteryNotLow(<span class="literal">true</span>)</span><br><span class="line">                .build()</span><br><span class="line"><span class="keyword">val</span> work2Request = OneTimeWorkRequestBuilder&lt;Worker2&gt;()</span><br><span class="line">                .setConstraints(constraints)</span><br><span class="line">                .build()</span><br><span class="line">WorkManager.getInstance(<span class="keyword">this</span>).enqueue(work2Request)</span><br></pre></td></tr></table></figure>

<p>任务的创建过程中，会为WorkSpec添加Constraints属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final @NonNull B setConstraints(@NonNull Constraints constraints) &#123;</span><br><span class="line">            mWorkSpec.constraints = constraints;</span><br><span class="line">            return getThis();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>在任务执行的过程中，由于增加了约束条件，根据之前章节的分析，常驻的<code>GreedyScheduler#schedule</code>方法将不会执行，而是根据<code>SDKVersion</code>交由<code>SystemJobScheduler</code>或<code>SystemAlarmScheduler</code>进行处理。先来看使用<code>SystemJobScheduler</code>的情况：</p>
<h3 id="SystemJobScheduler-Version-gt-23"><a href="#SystemJobScheduler-Version-gt-23" class="headerlink" title="SystemJobScheduler(Version &gt;=23)"></a><code>SystemJobScheduler(Version &gt;=23)</code></h3><p><code>SystemJobScheduler</code>使用的是<code>JobScheduler</code>来调度执行任务。<code>WorkManager</code>是如何使用JobScheduler进行任务调度的。<code>JobScheduler</code>的分析<a href="http://gityuan.com/2017/03/10/job_scheduler_service/%E3%80%82">http://gityuan.com/2017/03/10/job_scheduler_service/。</a></p>
<p><code>SystemJobScheduler</code></p>
<h4 id="SystemJobService"><a href="#SystemJobService" class="headerlink" title="SystemJobService"></a><code>SystemJobService</code></h4><p> <code>SystemJobService</code>是执行任务的服务类，在onStartJob中，会调用<code>WorkManagerImpl#startWork</code>执行任务。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//SystemJobService</span><br><span class="line">@Override</span><br><span class="line">public boolean onStartJob(@NonNull JobParameters params) &#123;</span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    String workSpecId = getWorkSpecIdFromJobParameters(params);</span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    synchronized (mJobParameters) &#123;</span><br><span class="line">       ... ...</span><br><span class="line">        mJobParameters.put(workSpecId, params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line">    mWorkManagerImpl.startWork(workSpecId, runtimeExtras);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>startWork</code>的逻辑前面分析过了，这一次不同的是会调用到<code>SystemJobScheduler#schedule</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SystemJobScheduler</span><span class="params">(<span class="meta">@NonNull</span> Context context, <span class="meta">@NonNull</span> WorkManagerImpl workManager)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context,</span><br><span class="line">            workManager,</span><br><span class="line">             <span class="comment">// 初始化SystemJobScheduler的时候会获取JobScheduler对象</span></span><br><span class="line">            (JobScheduler) context.getSystemService(JOB_SCHEDULER_SERVICE),</span><br><span class="line">            <span class="keyword">new</span> SystemJobInfoConverter(context));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">(<span class="meta">@NonNull</span> WorkSpec... workSpecs)</span> </span>&#123;</span><br><span class="line">    WorkDatabase workDatabase = mWorkManager.getWorkDatabase();</span><br><span class="line">    IdGenerator idGenerator = <span class="keyword">new</span> IdGenerator(workDatabase);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (WorkSpec workSpec : workSpecs) &#123;</span><br><span class="line">        workDatabase.beginTransaction();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// ...</span></span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            scheduleInternal(workSpec, jobId);</span><br><span class="line">					  <span class="comment">// ...</span></span><br><span class="line">            workDatabase.setTransactionSuccessful();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            workDatabase.endTransaction();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SystemJobScheduler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleInternal</span><span class="params">(WorkSpec workSpec, <span class="keyword">int</span> jobId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1、将workspec 任务转化成 JobInfo 任务</span></span><br><span class="line">    JobInfo jobInfo = mSystemJobInfoConverter.convert(workSpec, jobId);</span><br><span class="line">    Logger.get().debug(</span><br><span class="line">            TAG,</span><br><span class="line">            String.format(<span class="string">&quot;Scheduling work ID %s Job ID %s&quot;</span>, workSpec.id, jobId));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 2、使用JobScheduler 调度任务</span></span><br><span class="line">        mJobScheduler.schedule(jobInfo);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">        ... ...</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(message, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">        Logger.get().error(TAG, String.format(<span class="string">&quot;Unable to schedule %s&quot;</span>, workSpec), throwable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SystemJobInfoConverter.convert</code>方法就是创建了一个<code>JobInfo</code>，并将<code>Constraints</code>里的约束条件赋予<code>JobInfo</code>对象，之后便执行了<code>JobScheduler.schedule</code>，根据约束条件对任务进行调度。</p>
<h3 id="SystemAlarmScheduler-Version-lt-23"><a href="#SystemAlarmScheduler-Version-lt-23" class="headerlink" title="SystemAlarmScheduler(Version &lt;23)"></a><code>SystemAlarmScheduler(Version &lt;23)</code></h3><p><code>SystemAlarmScheduler</code>使用的是<code>AlarmManager + Receviver</code>来调度执行任务。<code>WorkManager会</code>在mainfest中注册广播，我们以网络广播为例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;receiver    android:name=<span class="string">&quot;androidx.work.impl.background.systemalarm.ConstraintProxy$NetworkStateProxy&quot;</span></span><br><span class="line">    android:directBootAware=<span class="string">&quot;false&quot;</span></span><br><span class="line">    android:enabled=<span class="string">&quot;false&quot;</span></span><br><span class="line">    android:exported=<span class="string">&quot;false&quot;</span></span><br><span class="line">    tools:targetApi=<span class="string">&quot;n&quot;</span> &gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=<span class="string">&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;</span> /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure>

<p>在网络变化时，收到的<code>CONNECTIVITY_CHANGE</code>广播，在<code>NetworkStateProxy</code>的<code>onReceive</code>进行处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstraintProxy</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = Logger.tagWithPrefix(<span class="string">&quot;ConstraintProxy&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        Logger.get().debug(TAG, String.format(<span class="string">&quot;onReceive : %s&quot;</span>, intent));</span><br><span class="line">        Intent constraintChangedIntent = CommandHandler.createConstraintsChangedIntent(context);</span><br><span class="line">      <span class="comment">// 启动SystemAlarmService</span></span><br><span class="line">        context.startService(constraintChangedIntent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkStateProxy</span> <span class="keyword">extends</span> <span class="title">ConstraintProxy</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 创建 action</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> Intent <span class="title">createConstraintsChangedIntent</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(context, SystemAlarmService.class);</span><br><span class="line">        intent.setAction(ACTION_CONSTRAINTS_CHANGED);</span><br><span class="line">        <span class="keyword">return</span> intent;</span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动<code>SystemAlarmService</code>进行处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> SystemAlarmDispatcher mDispatcher;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</span><br><span class="line">    <span class="keyword">if</span> (mIsShutdown) &#123;</span><br><span class="line">        Logger.get().info(TAG,</span><br><span class="line">                <span class="string">&quot;Re-initializing SystemAlarmDispatcher after a request to shut-down.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Destroy the old dispatcher to complete it&#x27;s lifecycle.</span></span><br><span class="line">        mDispatcher.onDestroy();</span><br><span class="line">        <span class="comment">// Create a new dispatcher to setup a new lifecycle.</span></span><br><span class="line">        initializeDispatcher();</span><br><span class="line">        <span class="comment">// Set mIsShutdown to false, to correctly accept new commands.</span></span><br><span class="line">        mIsShutdown = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (intent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// SystemAlarmDispatcher # add </span></span><br><span class="line">        mDispatcher.add(intent, startId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the service were to crash, we want all unacknowledged Intents to get redelivered.</span></span><br><span class="line">    <span class="keyword">return</span> Service.START_REDELIVER_INTENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用到 <code>SystemAlarmDispatcher#add</code> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(<span class="meta">@NonNull</span> <span class="keyword">final</span> Intent intent, <span class="keyword">final</span> <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">    Logger.get().debug(TAG, String.format(<span class="string">&quot;Adding command %s (%s)&quot;</span>, intent, startId));</span><br><span class="line">    assertMainThread();</span><br><span class="line">    String action = intent.getAction();</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(action)) &#123;</span><br><span class="line">        Logger.get().warning(TAG, <span class="string">&quot;Unknown command. Ignoring&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CommandHandler.ACTION_CONSTRAINTS_CHANGED.equals(action)</span><br><span class="line">            &amp;&amp; hasIntentWithAction(CommandHandler.ACTION_CONSTRAINTS_CHANGED)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    intent.putExtra(KEY_START_ID, startId);</span><br><span class="line">    <span class="keyword">synchronized</span> (mIntents) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> hasCommands = !mIntents.isEmpty();</span><br><span class="line">        mIntents.add(intent);</span><br><span class="line">        <span class="keyword">if</span> (!hasCommands) &#123;</span><br><span class="line">						<span class="comment">// 执行</span></span><br><span class="line">            processCommand();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>processCommand</code>中继续处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertMainThread();</span><br><span class="line">    PowerManager.WakeLock processCommandLock =</span><br><span class="line">            WakeLocks.newWakeLock(mContext, PROCESS_COMMAND_TAG);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        processCommandLock.acquire();</span><br><span class="line">        <span class="comment">// Process commands on the background thread.</span></span><br><span class="line">        mWorkManager.getWorkTaskExecutor().executeOnBackgroundThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">												<span class="comment">// 调用</span></span><br><span class="line">                        mCommandHandler.onHandleIntent(mCurrentIntent, startId,</span><br><span class="line">                                SystemAlarmDispatcher.<span class="keyword">this</span>);</span><br><span class="line">              <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CommandHandler-onHandleIntent"><a href="#CommandHandler-onHandleIntent" class="headerlink" title="CommandHandler#onHandleIntent"></a><code>CommandHandler#onHandleIntent</code></h4><p>调用过来后，此时的action是 <code>ACTION_CONSTRAINTS_CHANGE</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@NonNull</span> Intent intent,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> startId,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@NonNull</span> SystemAlarmDispatcher dispatcher)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String action = intent.getAction();</span><br><span class="line">		<span class="comment">// 此时的action是 ACTION_CONSTRAINTS_CHANGED</span></span><br><span class="line">    <span class="keyword">if</span> (ACTION_CONSTRAINTS_CHANGED.equals(action)) &#123;</span><br><span class="line">        handleConstraintsChanged(intent, startId, dispatcher);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ACTION_RESCHEDULE.equals(action)) &#123;</span><br><span class="line">        handleReschedule(intent, startId, dispatcher);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Bundle extras = intent.getExtras();</span><br><span class="line">        <span class="keyword">if</span> (!hasKeys(extras, KEY_WORKSPEC_ID)) &#123;</span><br><span class="line">            Logger.get().error(TAG,</span><br><span class="line">                    String.format(<span class="string">&quot;Invalid request for %s, requires %s.&quot;</span>,</span><br><span class="line">                            action,</span><br><span class="line">                            KEY_WORKSPEC_ID));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ACTION_SCHEDULE_WORK.equals(action)) &#123;</span><br><span class="line">                handleScheduleWorkIntent(intent, startId, dispatcher);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ACTION_DELAY_MET.equals(action)) &#123;</span><br><span class="line">                handleDelayMet(intent, startId, dispatcher);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ACTION_STOP_WORK.equals(action)) &#123;</span><br><span class="line">                handleStopWork(intent, dispatcher);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ACTION_EXECUTION_COMPLETED.equals(action)) &#123;</span><br><span class="line">                handleExecutionCompleted(intent, startId);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Logger.get().warning(TAG, String.format(<span class="string">&quot;Ignoring intent %s&quot;</span>, intent));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理<code>ACTION_CONSTRAINTS_CHANGE</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleConstraintsChanged</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@NonNull</span> Intent intent, <span class="keyword">int</span> startId,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@NonNull</span> SystemAlarmDispatcher dispatcher)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">    ConstraintsCommandHandler changedCommandHandler =</span><br><span class="line">            <span class="keyword">new</span> ConstraintsCommandHandler(mContext, startId, dispatcher);</span><br><span class="line">  <span class="comment">// 调用  </span></span><br><span class="line">  changedCommandHandler.handleConstraintsChanged();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleConstraintsChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.从数据中查找需要执行的任务</span></span><br><span class="line">    List&lt;WorkSpec&gt; candidates = mDispatcher.getWorkManager().getWorkDatabase()</span><br><span class="line">            .workSpecDao()</span><br><span class="line">            .getScheduledWork();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update constraint proxy to potentially disable proxies for previously</span></span><br><span class="line">    <span class="comment">// completed WorkSpecs.</span></span><br><span class="line">    ConstraintProxy.updateAll(mContext, candidates);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This needs to be done to populate matching WorkSpec ids in every constraint controller.</span></span><br><span class="line">    mWorkConstraintsTracker.replace(candidates);</span><br><span class="line"></span><br><span class="line">    List&lt;WorkSpec&gt; eligibleWorkSpecs = <span class="keyword">new</span> ArrayList&lt;&gt;(candidates.size());</span><br><span class="line">    <span class="comment">// Filter candidates should have already been scheduled.</span></span><br><span class="line">    <span class="comment">// 2.过滤任务</span></span><br><span class="line">    <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (WorkSpec workSpec : candidates) &#123;</span><br><span class="line">        String workSpecId = workSpec.id;</span><br><span class="line">        <span class="keyword">long</span> triggerAt = workSpec.calculateNextRunTime();</span><br><span class="line">        <span class="keyword">if</span> (now &gt;= triggerAt &amp;&amp; (!workSpec.hasConstraints()</span><br><span class="line">                || mWorkConstraintsTracker.areAllConstraintsMet(workSpecId))) &#123;</span><br><span class="line">            eligibleWorkSpecs.add(workSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (WorkSpec workSpec : eligibleWorkSpecs) &#123;</span><br><span class="line">        String workSpecId = workSpec.id;</span><br><span class="line">        <span class="comment">// 3.创建 intent</span></span><br><span class="line">        Intent intent = CommandHandler.createDelayMetIntent(mContext, workSpecId);</span><br><span class="line">        Logger.get().debug(TAG, String.format(</span><br><span class="line">                <span class="string">&quot;Creating a delay_met command for workSpec with id (%s)&quot;</span>, workSpecId));</span><br><span class="line">        <span class="comment">// 4.再回到 Dispatcher 进行处理</span></span><br><span class="line">        mDispatcher.postOnMainThread(</span><br><span class="line">                <span class="keyword">new</span> SystemAlarmDispatcher.AddRunnable(mDispatcher, intent, mStartId));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mWorkConstraintsTracker.reset();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Intent <span class="title">createDelayMetIntent</span><span class="params">(<span class="meta">@NonNull</span> Context context, <span class="meta">@NonNull</span> String workSpecId)</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(context, SystemAlarmService.class);</span><br><span class="line">        <span class="comment">// 新的aciton</span></span><br><span class="line">        intent.setAction(ACTION_DELAY_MET);</span><br><span class="line">        intent.putExtra(KEY_WORKSPEC_ID, workSpecId);</span><br><span class="line">        <span class="keyword">return</span> intent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>handleConstraintsChanged</code>()方法的执行中，会创建一个action为<code>ACTION_DELAY_MET</code>的Intent然后由<code>SystemAlarmDispatcher</code>发送出去，再次重复上面的过程<code>SystemAlarmDispatcher#add</code> -&gt;<code>SystemAlarmDispatcher#processCommand</code> -&gt; <code>CommandHandler.onHandleIntent</code> ，然后由于此时的action是，进入到<code>handleDelayMet</code>中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleDelayMet</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="meta">@NonNull</span> Intent intent,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">int</span> startId,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="meta">@NonNull</span> SystemAlarmDispatcher dispatcher)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Bundle extras = intent.getExtras();</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            String workSpecId = extras.getString(KEY_WORKSPEC_ID);</span><br><span class="line">							  <span class="comment">//...</span></span><br><span class="line">                DelayMetCommandHandler delayMetCommandHandler =</span><br><span class="line">                        <span class="keyword">new</span> DelayMetCommandHandler(mContext, startId, workSpecId, dispatcher);</span><br><span class="line">                mPendingDelayMet.put(workSpecId, delayMetCommandHandler);</span><br><span class="line">                <span class="comment">// 继续处理</span></span><br><span class="line">                delayMetCommandHandler.handleProcessWork();</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="meta">@WorkerThread</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleProcessWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">    WorkSpec workSpec = mDispatcher.getWorkManager()</span><br><span class="line">            .getWorkDatabase()</span><br><span class="line">            .workSpecDao()</span><br><span class="line">            .getWorkSpec(mWorkSpecId);</span><br><span class="line"></span><br><span class="line">    mHasConstraints = workSpec.hasConstraints();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mHasConstraints) &#123;</span><br><span class="line">        Logger.get().debug(TAG, String.format(<span class="string">&quot;No constraints for %s&quot;</span>, mWorkSpecId));</span><br><span class="line">      <span class="comment">// 所有条件都满足 </span></span><br><span class="line">      onAllConstraintsMet(Collections.singletonList(mWorkSpecId));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Allow tracker to report constraint changes</span></span><br><span class="line">        mWorkConstraintsTracker.replace(Collections.singletonList(workSpec));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAllConstraintsMet</span><span class="params">(<span class="meta">@NonNull</span> List&lt;String&gt; workSpecIds)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// WorkConstraintsTracker will call onAllConstraintsMet with list of workSpecs whose</span></span><br><span class="line">    <span class="comment">// constraints are met. Ensure the workSpecId we are interested is part of the list</span></span><br><span class="line">    <span class="comment">// before we call Processor#startWork().</span></span><br><span class="line">    <span class="keyword">if</span> (!workSpecIds.contains(mWorkSpecId)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCurrentState == STATE_INITIAL) &#123;</span><br><span class="line">            mCurrentState = STATE_START_REQUESTED;</span><br><span class="line">						<span class="comment">// 启动</span></span><br><span class="line">            <span class="keyword">boolean</span> isEnqueued = mDispatcher.getProcessor().startWork(mWorkSpecId);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isEnqueued) &#123;</span><br><span class="line">                <span class="comment">// setup timers to enforce quotas on workers that have</span></span><br><span class="line">                <span class="comment">// been enqueued</span></span><br><span class="line">                mDispatcher.getWorkTimer()</span><br><span class="line">                        .startTimer(mWorkSpecId, WORK_PROCESSING_TIME_IN_MS, <span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// if we did not actually enqueue the work, it was enqueued before</span></span><br><span class="line">                <span class="comment">// cleanUp and pretend this never happened.</span></span><br><span class="line">                cleanUp();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Logger.get().debug(TAG, String.format(<span class="string">&quot;Already started work for %s&quot;</span>, mWorkSpecId));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里终于看到由<code>SystemAlarmDispatcher</code>调用了<code>Processor#startWork</code>方法，回到了之前的任务执行流程中。</p>
<h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>至此，<code>WorkManager</code> 的基本原理就分析完毕了，其实<code>WorkManager</code>中任务的周期和约束条件都是依赖于系统的机制，<code>WorkManager</code> 运用策略模式很好的兼容了不同 android 版本。</p>
<p><img src="/pics/v2-bffd85c278ba2eb0bf8ef550e9b93b4f_r.jpg" alt="preview"></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>Lifecycle</category>
      </categories>
  </entry>
  <entry>
    <title>open_01_LeakCancary</title>
    <url>/2021/07/24/Notes/Android/02%E5%BC%80%E6%BA%90/open_01_LeakCancary/</url>
    <content><![CDATA[<h1 id="open-01-LeakCancary源码分析"><a href="#open-01-LeakCancary源码分析" class="headerlink" title="open_01_LeakCancary源码分析"></a>open_01_LeakCancary源码分析</h1><span id="more"></span>

<p><a href="https://github.com/square/leakcanary/releases/tag/v1.6.3">基于v1.6.3版本</a></p>
<h1 id="一、使用方法"><a href="#一、使用方法" class="headerlink" title="一、使用方法"></a>一、使用方法</h1><p>1、添加依赖</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">debugImplementation <span class="string">&#x27;com.squareup.leakcanary:leakcanary-android:1.6.3&#x27;</span></span><br><span class="line">releaseImplementation <span class="string">&#x27;com.squareup.leakcanary:leakcanary-android-no-op:1.6.3&#x27;</span></span><br><span class="line"><span class="comment">// Optional, if you use support library fragments:</span></span><br><span class="line">debugImplementation <span class="string">&#x27;com.squareup.leakcanary:leakcanary-support-fragment:1.6.3&#x27;</span></span><br></pre></td></tr></table></figure>

<p>2、初始化 + 配置权限</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        <span class="keyword">if</span> (LeakCanary.isInAnalyzerProcess(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LeakCanary.install(<span class="keyword">this</span>);</span><br><span class="line">    		LeakCanary.enableDisplayLeakActivity(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Android10 以上，1.6.3 要正常运行必须添加这些权限，另外手动将手机中app授权全部开启</span></span><br><span class="line">&lt;uses-permission android:name=<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span> /&gt;</span><br><span class="line">&lt;uses-permission android:name=<span class="string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span> /&gt;</span><br><span class="line">&lt;uses-permission android:name=<span class="string">&quot;android.permission.FOREGROUND_SERVICE&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<h1 id="二、原理说明"><a href="#二、原理说明" class="headerlink" title="二、原理说明"></a>二、原理说明</h1><h2 id="2-1、如何监听内存泄露？"><a href="#2-1、如何监听内存泄露？" class="headerlink" title="2.1、如何监听内存泄露？"></a>2.1、如何监听内存泄露？</h2><p>LeakCanary是通过在Application的registerActivityLifecycleCallbacks方法实现对Activity销毁监听的，该方法主要用来统一管理所有activity的生命周期。所有Activity在销毁时在其OnDestory方法中都会回调<code>ActivityLifecycleCallbacks#onActivityDestroyed</code>方法，而LeakCanary要做的就是在该方法中调用RefWatcher#watch方法实现对activity进行内存泄漏监控。</p>
<h2 id="2-2、如何判断某个Activity可能会发生内存泄漏呢？"><a href="#2-2、如何判断某个Activity可能会发生内存泄漏呢？" class="headerlink" title="2.2、如何判断某个Activity可能会发生内存泄漏呢？"></a>2.2、如何判断某个Activity可能会发生内存泄漏呢？</h2><p><code>WeakReference</code>和<code>ReferenceQueue</code>，即<code>LeakCanary</code>利用了<code>Java</code>的<code>WeakReference</code>和<code>ReferenceQueue</code>，通过将<code>Activity</code>包装到<code>WeakReference</code>中，被<code>WeakReference</code>包装过的<code>Activity</code>对象如果能够被回收，则说明引用可达，垃圾回收器就会将该<code>WeakReference</code>引用存放到<code>ReferenceQueue</code>中。假如我们要监视某个<code>activity</code>对象，<code>LeakCanary</code>就会去<code>ReferenceQueue</code>找这个对象的引用，如果找到了，说明该对象是引用可达的，能被GC回收，如果没有找到，说明该对象有可能发生了内存泄漏。</p>
<h2 id="2-3、如何dump堆栈？"><a href="#2-3、如何dump堆栈？" class="headerlink" title="2.3、如何dump堆栈？"></a>2.3、如何dump堆栈？</h2><p>LeakCanary会将Java堆转储到一个.hprof文件中，再使用Shark(堆分析工具)分析.hprof文件并定位堆转储中“滞留”的对象，并对每个”滞留”的对象找出 GC roots 的最短强引用路径，并确定是否是泄露，如果泄漏，建立导致泄露的引用链。最后，再将分析完毕的结果以通知的形式展现出来。</p>
<h1 id="三、源码分析"><a href="#三、源码分析" class="headerlink" title="三、源码分析"></a>三、源码分析</h1><h2 id="3-1、初始化"><a href="#3-1、初始化" class="headerlink" title="3.1、初始化"></a>3.1、初始化</h2><h3 id="3-1-1、LeanCanary-install"><a href="#3-1-1、LeanCanary-install" class="headerlink" title="3.1.1、LeanCanary#install"></a>3.1.1、LeanCanary#install</h3><p>LeakCanary的入口方法是<code>LeanCanary$install</code>方法，该方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RefWatcher <span class="title">install</span><span class="params">(Application application)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> refWatcher(application)</span><br><span class="line">      .listenerServiceClass(DisplayLeakService.class)</span><br><span class="line">      .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())</span><br><span class="line">      .buildAndInstall();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AndroidRefWatcherBuilder#buildAndInstall**</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RefWatcher <span class="title">buildAndInstall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (LeakCanaryInternals.installedRefWatcher != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;buildAndInstall() should only be called once.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">// 创建RefWatcher对象</span></span><br><span class="line">   RefWatcher refWatcher = build();</span><br><span class="line">   <span class="keyword">if</span> (refWatcher != DISABLED) &#123;</span><br><span class="line">     <span class="comment">// 监听activity</span></span><br><span class="line">     <span class="keyword">if</span> (watchActivities) &#123;</span><br><span class="line">       ActivityRefWatcher.install(context, refWatcher);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 监听frament</span></span><br><span class="line">     <span class="keyword">if</span> (watchFragments) &#123;</span><br><span class="line">       FragmentRefWatcher.Helper.install(context, refWatcher);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   LeakCanaryInternals.installedRefWatcher = refWatcher;</span><br><span class="line">   <span class="keyword">return</span> refWatcher;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p> install方法目的就是创建并返回一个<code>RefWatcher</code>对象，这个RefWatcher是LeakCanary的核心类，通过建造者模式构建。其中，listenerServiceClass方法传入了展示分析结果的<code>DisplayLeakService</code>；excludedRefs方法排除开发中可以忽略的泄漏路径；<code>buildAndInstall</code>主要是注册<code>Activity</code> 和 <code>Fragment</code>销毁监听。</p>
<h3 id="3-1-2、ActivityRefWatcher-install"><a href="#3-1-2、ActivityRefWatcher-install" class="headerlink" title="3.1.2、ActivityRefWatcher#install"></a>3.1.2、ActivityRefWatcher#install</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">(Context context, RefWatcher refWatcher)</span> </span>&#123;</span><br><span class="line">  Application application = (Application) context.getApplicationContext();</span><br><span class="line">  <span class="comment">// 实例化ActivityRefWatcher对象</span></span><br><span class="line">  ActivityRefWatcher activityRefWatcher = <span class="keyword">new</span> ActivityRefWatcher(application, refWatcher);</span><br><span class="line">  <span class="comment">//监听Activity的生命周期</span></span><br><span class="line">  application.registerActivityLifecycleCallbacks(activityRefWatcher.lifecycleCallbacks);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Application.ActivityLifecycleCallbacks lifecycleCallbacks =</span><br><span class="line">    <span class="keyword">new</span> ActivityLifecycleCallbacksAdapter() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityDestroyed</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Activity的onDestory方法中实施监听</span></span><br><span class="line">        refWatcher.watch(activity);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>总结下：LeakCanary 初始化做了2件事情：</p>
<ol>
<li>构造refwatcher对象</li>
<li>注册对Activity和Fragment的销毁的监听</li>
</ol>
<p>在组件销毁时，调用RefWatcher.watch方法进行泄漏检测。</p>
<h2 id="3-2、检测泄漏"><a href="#3-2、检测泄漏" class="headerlink" title="3.2、检测泄漏"></a>3.2、检测泄漏</h2><h3 id="3-2-1、RefWatcher-watch"><a href="#3-2-1、RefWatcher-watch" class="headerlink" title="3.2.1、RefWatcher#watch"></a>3.2.1、RefWatcher#watch</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watch</span><span class="params">(Object watchedReference)</span> </span>&#123;</span><br><span class="line">  watch(watchedReference, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watch</span><span class="params">(Object watchedReference, String referenceName)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> == DISABLED) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  checkNotNull(watchedReference, <span class="string">&quot;watchedReference&quot;</span>);</span><br><span class="line">  checkNotNull(referenceName, <span class="string">&quot;referenceName&quot;</span>);</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">long</span> watchStartNanoTime = System.nanoTime();</span><br><span class="line">  <span class="comment">// 生成一个随机的key</span></span><br><span class="line">  String key = UUID.randomUUID().toString();</span><br><span class="line">  <span class="comment">// 将key 放到 retainedKeys 中</span></span><br><span class="line">  retainedKeys.add(key);</span><br><span class="line">  <span class="comment">// 将activity的引用包装到KeyedWeakReference中</span></span><br><span class="line">  <span class="keyword">final</span> KeyedWeakReference reference =</span><br><span class="line">      <span class="keyword">new</span> KeyedWeakReference(watchedReference, key, referenceName, queue);</span><br><span class="line">  <span class="comment">// 开始检测</span></span><br><span class="line">  ensureGoneAsync(watchStartNanoTime, reference);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureGoneAsync</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> watchStartNanoTime, <span class="keyword">final</span> KeyedWeakReference reference)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在主线程的 IdleHandler中进行检测，watchExecutor 后面再讲</span></span><br><span class="line">  watchExecutor.execute(<span class="keyword">new</span> Retryable() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> Retryable.<span class="function">Result <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> ensureGone(reference, watchStartNanoTime);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-2、RefWatcher-ensureGone"><a href="#3-2-2、RefWatcher-ensureGone" class="headerlink" title="3.2.2、RefWatcher#ensureGone"></a>3.2.2、RefWatcher#ensureGone</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Retryable.<span class="function">Result <span class="title">ensureGone</span><span class="params">(<span class="keyword">final</span> KeyedWeakReference reference, <span class="keyword">final</span> <span class="keyword">long</span> watchStartNanoTime)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> gcStartNanoTime = System.nanoTime();</span><br><span class="line">  <span class="keyword">long</span> watchDurationMs = NANOSECONDS.toMillis(gcStartNanoTime - watchStartNanoTime);</span><br><span class="line">	<span class="comment">// 1、移除可回收的对象</span></span><br><span class="line">  removeWeaklyReachableReferences();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (debuggerControl.isDebuggerAttached()) &#123;</span><br><span class="line">    <span class="comment">// The debugger can create false leaks.</span></span><br><span class="line">    <span class="keyword">return</span> RETRY;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2、确定retainedKeys集合中是否存在该activity对应的key</span></span><br><span class="line">  <span class="comment">// 如果不存在了，说明该对象已经被回收，直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (gone(reference)) &#123;</span><br><span class="line">    <span class="keyword">return</span> DONE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 3、触发一下GC操作</span></span><br><span class="line">  gcTrigger.runGc();</span><br><span class="line">  <span class="comment">// 4、再次移除可回收的对象</span></span><br><span class="line">  removeWeaklyReachableReferences();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5、如果仍然存在activity 引用对应的可以，则说明发生了内存泄漏.生成堆内存快照，分析快照</span></span><br><span class="line">  <span class="keyword">if</span> (!gone(reference)) &#123;</span><br><span class="line">    <span class="keyword">long</span> startDumpHeap = System.nanoTime();</span><br><span class="line">    <span class="keyword">long</span> gcDurationMs = NANOSECONDS.toMillis(startDumpHeap - gcStartNanoTime);</span><br><span class="line">     <span class="comment">// 6、创建heapDump文件，还没写入</span></span><br><span class="line">    File heapDumpFile = heapDumper.dumpHeap();</span><br><span class="line">    <span class="keyword">if</span> (heapDumpFile == RETRY_LATER) &#123;</span><br><span class="line">      <span class="comment">// Could not dump the heap.</span></span><br><span class="line">      <span class="keyword">return</span> RETRY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> heapDumpDurationMs = NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap);</span><br><span class="line">    <span class="comment">//3.创建HeapDump对象</span></span><br><span class="line">    HeapDump heapDump = heapDumpBuilder.heapDumpFile(heapDumpFile).referenceKey(reference.key)</span><br><span class="line">        .referenceName(reference.name)</span><br><span class="line">        .watchDurationMs(watchDurationMs)</span><br><span class="line">        .gcDurationMs(gcDurationMs)</span><br><span class="line">        .heapDumpDurationMs(heapDumpDurationMs)</span><br><span class="line">        .build();</span><br><span class="line">	  <span class="comment">// 7.调用heapdumpListener分析，启动HeapAnalyzerService的analyze实现，即后台执行分析任务</span></span><br><span class="line">    heapdumpListener.analyze(heapDump);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> DONE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测Activity是否已经被回收，只要Activity对应的key不在了，就说明已经回收了</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">gone</span><span class="params">(KeyedWeakReference reference)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !retainedKeys.contains(reference.key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用队列存在的对象，说明是GC可回收的，将其从retainedKeys中移除</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeWeaklyReachableReferences</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  KeyedWeakReference ref;</span><br><span class="line">  <span class="keyword">while</span> ((ref = (KeyedWeakReference) queue.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    retainedKeys.remove(ref.key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下检测的逻辑：</p>
<ol>
<li>在<code>watchExecutor</code>中执行(<code>watchExecutor</code>其实是个<code>AndroidWatchExecutor</code>，用来切换线程)，当我们的检测逻辑运行时，大概率已经发生过<code>gc</code>了</li>
<li>尝试先清除一次<code>activity</code>的<code>key</code>队列，然后检测被<code>destroy</code>的<code>activity</code>是否已经被回收</li>
<li>如果没有被回收，也不一定发生了泄漏，因为可能还没有进行过<code>gc</code>，所以我们手动进行了一次<code>gc</code></li>
<li>然后再次检测该<code>activity</code> 对应的<code>key</code>是否还在<code>key</code>队列，如果还在，那么就说明发生了泄漏</li>
<li>直接<code>dump</code>堆空间以及相关信息，并提示给开发者。</li>
</ol>
<h3 id="3-2-3、ReferenceQueue-amp-retainedKeys"><a href="#3-2-3、ReferenceQueue-amp-retainedKeys" class="headerlink" title="3.2.3、ReferenceQueue &amp; retainedKeys"></a>3.2.3、ReferenceQueue &amp; retainedKeys</h3><p>关于retainedKeys：保存所有要检测回收<code>Activity</code>的key。</p>
<p>ReferenceQueue：弱引用队列，包装了<code>Activity</code>对象和<code>key</code>，</p>
<p>当这个<code>Activity</code>被回收后，指向它的弱引用就会被放入引用队列<code>queue</code>中，所以当我们检测到<code>queue</code>中有这个引用时，就说明该<code>Activity</code>已经被回收了，就从<code>retainedKeys</code>队列移除这个<code>key</code>。所以，当一个<code>Activity</code>被<code>destroy</code>之后，就先把它对应的<code>key</code>添加到<code>retainedKeys</code>队列中，等到<code>gc</code>之后，再检测<code>retainedKeys</code>这个队列，如果对应的<code>key</code>还在，就说明发生了内存泄漏。</p>
<p>这里有个问题，为什么<code>gc</code>可能发生，也可能没发生，能精确的判断是否发生过<code>gc</code>吗？不能！</p>
<p>很简单， 我们知道，Android的Gc是通过GcIdler实现的，它是一个IdleHandler。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GcIdler</span> <span class="keyword">implements</span> <span class="title">MessageQueue</span>.<span class="title">IdleHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doGcIfNeeded();</span><br><span class="line">        purgePendingResources();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>系统在空闲的时候</strong>先向<code>ActivityThread</code>投递一个标记为<code>GC_WHEN_IDLE</code>的<code>Message</code>，然后调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Looper.myQueue().addIdleHandler(mGcIdler)</span><br></pre></td></tr></table></figure>

<p>来触发Gc，说白了就是:  <strong>Android的Gc过程是通过空闲消息实现的，优先级是很低</strong>。那么，系统什么时候空闲呢？</p>
<p>当<code>MainLooper</code>中没有消息执行时，就是空闲的，此时就会执行<code>mIdleHandlers</code>里面的内容，<code>gc</code>才会得到执行。</p>
<p>根据前面分析，我们的检测逻辑要放在<code>gc</code>之后，才能保证正确性，那就需要在<code>mIdleHandlers</code>执行之后了，但是，系统并没有提供比<code>mIdleHandlers</code>优先级更低的工具，所以，我们也只能将我们的检测逻辑也放到<code>mIdleHandlers</code>中去碰碰运气了，万一跑在了<code>gc</code>之后就省事了，万一没跑到<code>gc</code>之后呢？再主动调用一次gc。<code>AndroidWatchExecutor</code>就是做这件事的。</p>
<h3 id="3-2-4、AndroidWatchExecutor"><a href="#3-2-4、AndroidWatchExecutor" class="headerlink" title="3.2.4、AndroidWatchExecutor"></a>3.2.4、AndroidWatchExecutor</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Retryable retryable)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Looper.getMainLooper().getThread() == Thread.currentThread()) &#123;</span><br><span class="line">    waitForIdle(retryable, <span class="number">0</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    postWaitForIdle(retryable, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postWaitForIdle</span><span class="params">(<span class="keyword">final</span> Retryable retryable, <span class="keyword">final</span> <span class="keyword">int</span> failedAttempts)</span> </span>&#123;</span><br><span class="line">  mainHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 调用到waitForIdle</span></span><br><span class="line">      waitForIdle(retryable, failedAttempts);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">waitForIdle</span><span class="params">(<span class="keyword">final</span> Retryable retryable, <span class="keyword">final</span> <span class="keyword">int</span> failedAttempts)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// This needs to be called from the main thread.</span></span><br><span class="line">  <span class="comment">// 创建 IdleHandler</span></span><br><span class="line">  Looper.myQueue().addIdleHandler(<span class="keyword">new</span> MessageQueue.IdleHandler() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      postToBackgroundWithDelay(retryable, failedAttempts);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToBackgroundWithDelay</span><span class="params">(<span class="keyword">final</span> Retryable retryable, <span class="keyword">final</span> <span class="keyword">int</span> failedAttempts)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// failedAttempts 默认是0，exponentialBackoffFactor 第一次是 1</span></span><br><span class="line">  <span class="keyword">long</span> exponentialBackoffFactor = (<span class="keyword">long</span>) Math.min(Math.pow(<span class="number">2</span>, failedAttempts), maxBackoffFactor);</span><br><span class="line">  <span class="comment">// initialDelayMillis 默认是5s，综合以上第一次执行的时间是 activity destroy 之后 5s。</span></span><br><span class="line">  <span class="keyword">long</span> delayMillis = initialDelayMillis * exponentialBackoffFactor;</span><br><span class="line">  backgroundHandler.postDelayed(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Retryable.Result result = retryable.run();</span><br><span class="line">      <span class="comment">// result == RETRY，再次调用 postWaitForIdle，下一次的 delayMillis= 上一次的  delayMillis *2；</span></span><br><span class="line">        <span class="comment">// 正常情况下，不会返回 RETRY，当 heapDumpFile == RETRY_LATER （即 dump heap 失败的时候），会返回 RETRY</span></span><br><span class="line">      <span class="keyword">if</span> (result == RETRY) &#123;</span><br><span class="line">        postWaitForIdle(retryable, failedAttempts + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结一下：<code>AndroidWatchExecutor</code>主要作用是在主线程空闲时进行泄漏检测，原理是IdleHanlder，第一次检测是在<code>Activity</code>被销毁5s 后。</p>
<h2 id="3-3、dump-堆栈"><a href="#3-3、dump-堆栈" class="headerlink" title="3.3、dump 堆栈"></a>3.3、dump 堆栈</h2><p>dump堆栈主要是调用 AndroidHeapDumper 的 dumpHeap 方法</p>
<p><code>AndroidHeapDumper#dumpHeap</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> File <span class="title">dumpHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  File heapDumpFile = leakDirectoryProvider.newHeapDumpFile();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (heapDumpFile == RETRY_LATER) &#123;</span><br><span class="line">    <span class="keyword">return</span> RETRY_LATER;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  FutureResult&lt;Toast&gt; waitingForToast = <span class="keyword">new</span> FutureResult&lt;&gt;();</span><br><span class="line">  showToast(waitingForToast);</span><br><span class="line">	<span class="comment">// RETRY_LATER 的情况</span></span><br><span class="line">  <span class="keyword">if</span> (!waitingForToast.wait(<span class="number">5</span>, SECONDS)) &#123;</span><br><span class="line">    CanaryLog.d(<span class="string">&quot;Did not dump heap, too much time waiting for Toast.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> RETRY_LATER;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ！！！关键dump 信息到文件！！！</span></span><br><span class="line">    Debug.dumpHprofData(heapDumpFile.getAbsolutePath());</span><br><span class="line">    cancelToast(toast);</span><br><span class="line">    notificationManager.cancel(notificationId);</span><br><span class="line">    <span class="keyword">return</span> heapDumpFile;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    CanaryLog.d(e, <span class="string">&quot;Could not dump heap&quot;</span>);</span><br><span class="line">    <span class="comment">// Abort heap dump</span></span><br><span class="line">    <span class="keyword">return</span> RETRY_LATER;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4、解析hprof"><a href="#3-4、解析hprof" class="headerlink" title="3.4、解析hprof"></a>3.4、解析hprof</h2><p>hprof 的入口在<code>ServiceHeapDumpListener#analyze</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">analyze</span><span class="params">(HeapDump heapDump)</span> </span>&#123;</span><br><span class="line">  checkNotNull(heapDump, <span class="string">&quot;heapDump&quot;</span>);</span><br><span class="line">  <span class="comment">// 后台执行分析任务</span></span><br><span class="line">  HeapAnalyzerService.runAnalysis(context, heapDump, listenerServiceClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-1、HeapAnalyzerService-runAnalysis"><a href="#3-4-1、HeapAnalyzerService-runAnalysis" class="headerlink" title="3.4.1、HeapAnalyzerService.runAnalysis"></a>3.4.1、HeapAnalyzerService.runAnalysis</h3><p> <code>HeapAnalyzerService</code>是一个IntentServcie，启动后会在子线程执行具体的任务，当任务执行完毕后，该Service会被自动销毁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runAnalysis</span><span class="params">(Context context, HeapDump heapDump,</span></span></span><br><span class="line"><span class="params"><span class="function">    Class&lt;? extends AbstractAnalysisResultService&gt; listenerServiceClass)</span> </span>&#123;</span><br><span class="line">  setEnabledBlocking(context, HeapAnalyzerService.class, <span class="keyword">true</span>);</span><br><span class="line">  setEnabledBlocking(context, listenerServiceClass, <span class="keyword">true</span>);</span><br><span class="line">  Intent intent = <span class="keyword">new</span> Intent(context, HeapAnalyzerService.class);</span><br><span class="line">  intent.putExtra(LISTENER_CLASS_EXTRA, listenerServiceClass.getName());</span><br><span class="line">  intent.putExtra(HEAPDUMP_EXTRA, heapDump);</span><br><span class="line">  <span class="comment">//前台服务，以降低被系统杀死的概率。</span></span><br><span class="line">  ContextCompat.startForegroundService(context, intent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntentInForeground</span><span class="params">(<span class="meta">@Nullable</span> Intent intent)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (intent == <span class="keyword">null</span>) &#123;</span><br><span class="line">    CanaryLog.d(<span class="string">&quot;HeapAnalyzerService received a null intent, ignoring.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  String listenerClassName = intent.getStringExtra(LISTENER_CLASS_EXTRA);</span><br><span class="line">  HeapDump heapDump = (HeapDump) intent.getSerializableExtra(HEAPDUMP_EXTRA);</span><br><span class="line">  <span class="comment">// 创建HeapAnalyzer</span></span><br><span class="line">  HeapAnalyzer heapAnalyzer =</span><br><span class="line">      <span class="keyword">new</span> HeapAnalyzer(heapDump.excludedRefs, <span class="keyword">this</span>, heapDump.reachabilityInspectorClasses);</span><br><span class="line"> <span class="comment">// HeapAnanlyzer工具分析</span></span><br><span class="line"> <span class="comment">// 即分析堆内存快照,找出 GC roots 的最短强引用路径，并确定是否是泄露</span></span><br><span class="line">  AnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey,</span><br><span class="line">      heapDump.computeRetainedHeapSize);</span><br><span class="line"> <span class="comment">// 启动DisplayLeakService记录日志和展示通知</span></span><br><span class="line">  AbstractAnalysisResultService.sendResultToListener(<span class="keyword">this</span>, listenerClassName, heapDump, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-2、HeapAnalyzer-checkForLeak"><a href="#3-4-2、HeapAnalyzer-checkForLeak" class="headerlink" title="3.4.2、HeapAnalyzer#checkForLeak"></a>3.4.2、HeapAnalyzer#checkForLeak</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@NonNull</span> <span class="function">AnalysisResult <span class="title">checkForLeak</span><span class="params">(<span class="meta">@NonNull</span> File heapDumpFile,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="meta">@NonNull</span> String referenceKey,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">boolean</span> computeRetainedSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> analysisStartNanoTime = System.nanoTime();</span><br><span class="line">	<span class="comment">// 确定堆快照文件是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (!heapDumpFile.exists()) &#123;</span><br><span class="line">      Exception exception = <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;File does not exist: &quot;</span> </span><br><span class="line">                                                         + heapDumpFile);</span><br><span class="line">      <span class="keyword">return</span> failure(exception, since(analysisStartNanoTime));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      listener.onProgressUpdate(READING_HEAP_DUMP_FILE);</span><br><span class="line">	  <span class="comment">// 将heap文件封装成MemoryMappedFileBuffer</span></span><br><span class="line">      HprofBuffer buffer = <span class="keyword">new</span> MemoryMappedFileBuffer(heapDumpFile);</span><br><span class="line">	  <span class="comment">// 创建hprof解析器，解析hprof文件</span></span><br><span class="line">      HprofParser parser = <span class="keyword">new</span> HprofParser(buffer);</span><br><span class="line">      listener.onProgressUpdate(PARSING_HEAP_DUMP);</span><br><span class="line">      Snapshot snapshot = parser.parse();</span><br><span class="line">      listener.onProgressUpdate(DEDUPLICATING_GC_ROOTS);</span><br><span class="line">	  <span class="comment">// 移除相同GC root</span></span><br><span class="line">      deduplicateGcRoots(snapshot);</span><br><span class="line">      listener.onProgressUpdate(FINDING_LEAKING_REF);</span><br><span class="line">	  <span class="comment">// 找出泄漏的对象</span></span><br><span class="line">      Instance leakingRef = findLeakingReference(referenceKey, snapshot);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// False alarm, weak reference was cleared in between key check and heap dump.</span></span><br><span class="line">      <span class="comment">//检测是否存在泄漏的引用</span></span><br><span class="line">      <span class="keyword">if</span> (leakingRef == <span class="keyword">null</span>) &#123;</span><br><span class="line">        String className = leakingRef.getClassObj().getClassName();</span><br><span class="line">        <span class="keyword">return</span> noLeak(className, since(analysisStartNanoTime));</span><br><span class="line">      &#125;</span><br><span class="line">	   <span class="comment">//根据leakingRef寻找引用路径</span></span><br><span class="line">      <span class="keyword">return</span> findLeakTrace(analysisStartNanoTime, snapshot, leakingRef, </span><br><span class="line">                           computeRetainedSize);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">      <span class="keyword">return</span> failure(e, since(analysisStartNanoTime));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 使用 haha 库分析</span></span><br><span class="line"> <span class="comment">// https://github.com/square/haha</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> List&lt;TrackedReference&gt; <span class="title">findTrackedReferences</span><span class="params">(File heapDumpFile)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!heapDumpFile.exists()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;File does not exist: &quot;</span> + heapDumpFile);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      HprofBuffer buffer = <span class="keyword">new</span> MemoryMappedFileBuffer(heapDumpFile);</span><br><span class="line">      HprofParser parser = <span class="keyword">new</span> HprofParser(buffer);</span><br><span class="line">      Snapshot snapshot = parser.parse();</span><br><span class="line">      deduplicateGcRoots(snapshot);</span><br><span class="line">      ClassObj refClass = snapshot.findClass(KeyedWeakReference.class.getName());</span><br><span class="line">      List&lt;TrackedReference&gt; references = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (Instance weakRef : refClass.getInstancesList()) &#123;</span><br><span class="line">        List&lt;ClassInstance.FieldValue&gt; values = classInstanceValues(weakRef);</span><br><span class="line">        String key = asString(fieldValue(values, <span class="string">&quot;key&quot;</span>));</span><br><span class="line">        String name =</span><br><span class="line">            hasField(values, <span class="string">&quot;name&quot;</span>) ? asString(fieldValue(values, <span class="string">&quot;name&quot;</span>)) : <span class="string">&quot;(No name field)&quot;</span>;</span><br><span class="line">        Instance instance = fieldValue(values, <span class="string">&quot;referent&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (instance != <span class="keyword">null</span>) &#123;</span><br><span class="line">          String className = getClassName(instance);</span><br><span class="line">          List&lt;LeakReference&gt; fields = describeFields(instance);</span><br><span class="line">          references.add(<span class="keyword">new</span> TrackedReference(key, name, className, fields));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> references;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>最终调用<code>findLeakingReference</code>方法，使用<a href="https://github.com/square/haha">haha 库</a>来判断是否真的存在内存泄漏。</p>
<p>经过解析之后会把数据传递到 DisplayLeakService ，Service 会根据传入进来的数据发送通知栏通知，当你点击对应的通知进入DisplayLeakActivity界面就能显示泄漏日志了。</p>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><h3 id="4-1、流程总结"><a href="#4-1、流程总结" class="headerlink" title="4.1、流程总结"></a>4.1、流程总结</h3><img src="/pics/image-20220217220603432.png" alt="image-20220217220603432" style="zoom:50%;" />

<ol>
<li><p>LeakCanary.install(application);</p>
<p>此时使用application进行registerActivityLifecycleCallbacks，从而来监听Activity的何时被destroy。</p>
</li>
<li><p>在onActivityDestroyed(Activity activity)的回调中，去检测Activity是否被回收，检测方式如以下步骤。</p>
</li>
<li><p>使用一个弱引用WeakReference指向这个activity，并且给这个弱引用指定一个引用队列queue，同时创建一个key来标识该activity。</p>
</li>
<li><p>然后将检测的方法ensureGone()投递到空闲消息队列。</p>
</li>
<li><p>当空闲消息执行的时候，去检测queue里面是否存在刚刚的弱引用，如果存在，则说明此activity已经被回收，就移除对应的key，没有内存泄漏发生。</p>
</li>
<li><p>如果queue里不存在刚刚的弱引用，则手动进行一次gc。</p>
</li>
<li><p>gc之后再次检测queue里面是否存在刚刚的弱引用，如果不存在，则说明此activity还没有被回收，此时已经发生了内存泄漏，直接dump堆栈信息并打印日志，否则没有发生内存泄漏，流程结束。</p>
</li>
</ol>
<h3 id="4-2、原理总结"><a href="#4-2、原理总结" class="headerlink" title="4.2、原理总结"></a>4.2、原理总结</h3><ul>
<li>监听 Activity 的生命周期</li>
<li>在 onDestroy 的时候，创建相应的 Refrence 和 RefrenceQueue，并启动后台进程去检测</li>
<li>5s后，从 RefrenceQueue 读取，若读取不到相应 activity 的 Refrence，有可能发生泄露了，这个时候，再促发 gc，一段时间之后，再去读取，若在从 RefrenceQueue 还是读取不到相应 activity 的 refrence，可以断定是发生内存泄露了</li>
<li>发生内存泄露之后，dump，分析 hprof 文件，找到泄露路径（使用 haha 库分析）</li>
</ul>
<img src="/pics/image-20220217221037781.png" alt="image-20220217221037781" style="zoom:50%;" />

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/80752876?spm=1001.2014.3001.5501">https://blog.csdn.net/gdutxiaoxu/article/details/80752876?spm=1001.2014.3001.5501</a></p>
<p><a href="https://juejin.cn/post/7055188859121827848">https://juejin.cn/post/7055188859121827848</a></p>
<p><a href="https://blog.csdn.net/AndrExpert/article/details/103781575">https://blog.csdn.net/AndrExpert/article/details/103781575</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>开源</category>
      </categories>
  </entry>
  <entry>
    <title>open_02_ARouter</title>
    <url>/2021/02/27/Notes/Android/02%E5%BC%80%E6%BA%90/open_02_ARouter%20%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h1 id="open-02-ARouter基础用法"><a href="#open-02-ARouter基础用法" class="headerlink" title="open_02_ARouter基础用法"></a>open_02_ARouter基础用法</h1><span id="more"></span>

<h2 id="Android原生方案的不足"><a href="#Android原生方案的不足" class="headerlink" title="Android原生方案的不足"></a>Android原生方案的不足</h2><p>我们所使用的原生路由方案一般是通过显式intent和隐式intent两种方式实现的，均存在一定意义上的缺陷：</p>
<p>显式intent，譬如 Intent intent = new Intent(activity, XXActivity.class);<br>由于需要直接持有对应class，从而导致了强依赖关系，提高了耦合度</p>
<p>隐式intent，譬如 Intent it = new Intent();<br>it.setAction(“com.android.activity.MY_ACTION”);<br>action等属性的定义在Manifest，导致了扩展性较差规则集中式管理，导致协作变得非常困难</p>
<p>原生的路由方案会出现跳转过程无法控制的问题，因为一旦使用了StartActivity()就无法插手其中任何环节了，只能交给系统管理，这就导致了在跳转失败的情况下无法降级，而是会直接抛出运营级的异常</p>
<p>##自定义路由框架存在的意义：<br>组件化：随着业务量的不断增长，app也会不断的膨胀，开发团队的规模和工作量也会逐渐增大，面对所衍生的64K问题、协作开发问题等，app一般都会走向组件化。组件化就是将APP按照一定的功能和业务拆分成多个组件module，不同的组件独立开发，组件化不仅能够提供团队的工作效率，还能够提高应用性能。而组件化的前提就是解耦，那么我们首先要做的就是解耦页面之间的依赖关系</p>
<p>动态跳转：在一些复杂的业务场景下（比如电商），页面跳转需要较强的灵活性，很多功能都是运营人员动态配置的，比如下发一个活动页面，我们事先并不知道具体的目标页面，期望根据下发的数据自动的选择页面并进行跳转。</p>
<h2 id="1-配置"><a href="#1-配置" class="headerlink" title="1.配置"></a>1.配置</h2><h3 id="1-1-引入"><a href="#1-1-引入" class="headerlink" title="1.1 引入"></a>1.1 引入</h3><pre><code>android &#123;
    defaultConfig &#123;
        ...
            javaCompileOptions &#123;
                annotationProcessorOptions &#123;
                    arguments = [AROUTER_MODULE_NAME: project.getName()]
                &#125;
            &#125;
        &#125;
    &#125;

dependencies &#123;
    // 替换成最新版本, 需要注意的是api
    // 要与compiler匹配使用，均使用最新版可以保证兼容
    compile &#39;com.alibaba:arouter-api:x.x.x&#39;
    annotationProcessor &#39;com.alibaba:arouter-compiler:x.x.x&#39;
    ...
&#125;
</code></pre>
<h3 id="1-2-分包注意："><a href="#1-2-分包注意：" class="headerlink" title="1.2 分包注意："></a>1.2 分包注意：</h3><p>进行module分仓的配置可参考如下方式，注意必须要在每个使用到ARouter的module的buid.gradle文件中增加<br>每个module都要配置的，为了应对单个module 分别编译的场景</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.gradle </span></span><br><span class="line">annotationProcessorOptions &#123;</span><br><span class="line">    arguments = [AROUTER_MODULE_NAME: project.getName(), AROUTER_GENERATE_DOC: <span class="string">&quot;enable&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">annotationProcessor <span class="string">&#x27;com.alibaba:arouter-compiler:1.2.2&#x27;</span></span><br><span class="line"></span><br><span class="line">defaultConfig &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 用到ARouter的每个module中都必须加</span></span><br><span class="line">    javaCompileOptions &#123;</span><br><span class="line">        annotationProcessorOptions &#123;</span><br><span class="line">            arguments = [AROUTER_MODULE_NAME: project.getName()]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">//  core 中已经编译了</span></span><br><span class="line">    <span class="function">implementation <span class="title">project</span><span class="params">(<span class="string">&#x27;:core&#x27;</span>)</span></span></span><br><span class="line"><span class="function">    annotationProcessor &#x27;com.alibaba:arouter-compiler:1.2.2&#x27;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// core.gradle </span></span></span><br><span class="line"><span class="function">dependencies </span>&#123;</span><br><span class="line">    <span class="comment">// gradle 3.0以上使用api 以下使用 compile </span></span><br><span class="line">    api <span class="string">&#x27;com.alibaba:arouter-api:1.4.1&#x27;</span></span><br><span class="line">    annotationProcessor <span class="string">&#x27;com.alibaba:arouter-compiler:1.2.2&#x27;</span></span><br><span class="line">    api <span class="string">&#x27;com.alibaba:fastjson:1.1.70.android&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/qijingwang/article/details/79805794">compile 和 implementation 的区别参考</a></p>
<h3 id="1-3-混淆"><a href="#1-3-混淆" class="headerlink" title="1.3 混淆"></a>1.3 混淆</h3><pre><code>-keep public class com.alibaba.android.arouter.routes.**&#123;*;&#125;
-keep public class com.alibaba.android.arouter.facade.**&#123;*;&#125;
-keep class * implements com.alibaba.android.arouter.facade.template.ISyringe&#123;*;&#125;

# 如果使用了 byType 的方式获取 Service，需添加下面规则，保护接口
-keep interface * implements com.alibaba.android.arouter.facade.template.IProvider

# 如果使用了 单类注入，即不定义接口实现 IProvider，需添加下面规则，保护实现
# -keep class * implements com.alibaba.android.arouter.facade.template.IProvider
</code></pre>
<h3 id="1-4-首次启动优化"><a href="#1-4-首次启动优化" class="headerlink" title="1.4 首次启动优化"></a>1.4 首次启动优化</h3><p>字节码插桩技术，编译期实现路由表的自动加载，从而避免启动耗时</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">apply plugin: <span class="string">&#x27;com.alibaba.arouter&#x27;</span></span><br><span class="line"></span><br><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">&quot;com.alibaba:arouter-register:?&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-页面跳转"><a href="#2-页面跳转" class="headerlink" title="2.页面跳转"></a>2.页面跳转</h2><h3 id="2-1-初始化sdk"><a href="#2-1-初始化sdk" class="headerlink" title="2.1 初始化sdk"></a>2.1 初始化sdk</h3><pre><code>if (isDebug()) &#123;           // 这两行必须写在init之前，否则这些配置在init过程中将无效
    ARouter.openLog();     // 打印日志
    ARouter.openDebug();   // 开启调试模式(如果在InstantRun模式下运行，必须开启调试模式！线上版本需要关闭,否则有安全风险)
&#125;
ARouter.init(mApplication); // 尽可能早，推荐在Application中初始化
</code></pre>
<h3 id="2-2-在支持路由的页面上添加注解-必选"><a href="#2-2-在支持路由的页面上添加注解-必选" class="headerlink" title="2.2 在支持路由的页面上添加注解(必选)"></a>2.2 在支持路由的页面上添加注解(必选)</h3><pre><code>// 这里的路径需要注意的是至少需要有两级，/xx/xx
@Route(path = &quot;/test/activity&quot;)
public class YourActivity extend Activity &#123;
    ...
&#125;
</code></pre>
<h3 id="2-3-发起路由操作"><a href="#2-3-发起路由操作" class="headerlink" title="2.3 发起路由操作"></a>2.3 发起路由操作</h3><pre><code>// 1. 应用内简单的跳转(通过URL跳转在&#39;进阶用法&#39;中)
ARouter.getInstance().build(&quot;/test/activity&quot;).navigation();

// 2. 跳转并携带参数
ARouter.getInstance().build(&quot;/test/1&quot;)
            .withLong(&quot;key1&quot;, 666L)
            .withString(&quot;key3&quot;, &quot;888&quot;)
            .withObject(&quot;key4&quot;, new Test(&quot;Jack&quot;, &quot;Rose&quot;))
            .navigation();
</code></pre>
<h2 id="3-值传递和获取"><a href="#3-值传递和获取" class="headerlink" title="3.值传递和获取"></a>3.值传递和获取</h2><h3 id="3-1-Autowired注解方式"><a href="#3-1-Autowired注解方式" class="headerlink" title="3.1  @Autowired注解方式"></a>3.1  @Autowired注解方式</h3><pre><code>// 为每一个参数声明一个字段，并使用 @Autowired 标注, 不可是private
// URL中不能传递Parcelable类型数据，通过ARouter api可以传递Parcelable对象
@Route(path = &quot;/test/activity&quot;)
public class Test1Activity extends Activity &#123;
    @Autowired
    public String name;
    @Autowired
    int age;
    @Autowired(name = &quot;girl&quot;) // 通过name来映射URL中的不同参数
    boolean boy;
    @Autowired
    TestObj obj;    // 支持解析自定义对象，URL中使用json传递

    @Override
    protected void onCreate(Bundle savedInstanceState) &#123;
    super.onCreate(savedInstanceState);
    ARouter.getInstance().inject(this);

    // ARouter会自动对字段进行赋值，无需主动获取
    Log.d(&quot;param&quot;, name + age + boy);
    &#125;
&#125;
</code></pre>
<h3 id="3-2-getIntent方式"><a href="#3-2-getIntent方式" class="headerlink" title="3.2 getIntent方式"></a>3.2 getIntent方式</h3><pre><code>    getIntent().getIntExtra();
</code></pre>
<h3 id="3-3-传递对象"><a href="#3-3-传递对象" class="headerlink" title="3.3 传递对象"></a>3.3 传递对象</h3><p>3.3.1 Parcelable或Serializable</p>
<pre><code>ARouter.getInstance().build(&quot;/test/activity&quot;).withSerializable(&quot;obj3&quot;, new TestObj3()).withParcelable(&quot;obj2&quot;, new TestObj2()).navigation()；    
</code></pre>
<p>3.3.2 如果需要传递自定义对象，新建一个类（并非自定义对象类），然后实现 SerializationService,并使用@Route注解标注(方便用户自行选择序列化方式)，例如：</p>
<pre><code>@Route(path = &quot;/yourservicegroupname/json&quot;)
public class JsonServiceImpl implements SerializationService &#123;
    @Override
    public void init(Context context) &#123;

    &#125;
    // 需要引入fastJson 或者 Gson 处理序列化操作。
    @Override
    public &lt;T&gt; T json2Object(String text, Class&lt;T&gt; clazz) &#123;
        return JSON.parseObject(text, clazz);
    &#125;

    @Override
    public String object2Json(Object instance) &#123;
        return JSON.toJSONString(instance);
    &#125;
&#125;
</code></pre>
<h2 id="4-Url跳转"><a href="#4-Url跳转" class="headerlink" title="4.Url跳转"></a>4.Url跳转</h2><h3 id="4-1-新建一个Activity用于监听Scheme事件-之后直接把url传递给ARouter即可"><a href="#4-1-新建一个Activity用于监听Scheme事件-之后直接把url传递给ARouter即可" class="headerlink" title="4.1 新建一个Activity用于监听Scheme事件,之后直接把url传递给ARouter即可"></a>4.1 新建一个Activity用于监听Scheme事件,之后直接把url传递给ARouter即可</h3><pre><code>public class OpenJumpActivity extends BaseActivity &#123;
    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_open_jump);
        Uri uri = getIntent().getData();
        ARouter.getInstance().build(uri).navigation();
        finish();
    &#125;
&#125;
</code></pre>
<h3 id="4-2-AndroidManifest-xml"><a href="#4-2-AndroidManifest-xml" class="headerlink" title="4.2 AndroidManifest.xml"></a>4.2 AndroidManifest.xml</h3><pre><code>&lt;activity android:name=&quot;.activity.open.OpenJumpActivity&quot;&gt;
    &lt;intent-filter&gt;
        &lt;data
            android:host=&quot;aliyun&quot;
            android:scheme=&quot;arouter&quot; /&gt;
        &lt;action android:name=&quot;arouter.demo.test&quot; /&gt;
        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
</code></pre>
<h3 id="4-3-创建匹配的uri"><a href="#4-3-创建匹配的uri" class="headerlink" title="4.3 创建匹配的uri"></a>4.3 创建匹配的uri</h3><pre><code>Intent intent = new Intent();
intent.setPackage(&quot;com.vivo.test.arouterdemo&quot;);
intent.setAction(&quot;arouter.demo.test&quot;);
intent.setData(Uri.parse(&quot;arouter://aliyun/test/activity?name=vivo&amp;&amp;age=12&amp;&amp;girl=true&quot;));
startActivity(intent); 
</code></pre>
<h2 id="5-拦截器"><a href="#5-拦截器" class="headerlink" title="5.拦截器"></a>5.拦截器</h2><p>拦截器是自动注册的，在调用navigation时会自动的处理拦截<br>1.定义了拦截器一定要处理实现，没有实现的情况下，不会执行跳转等方法。<br>2.拦截器的priority越小优先级越高。<br>3.不能定义相同的priority的拦截器。</p>
<pre><code>@Interceptor(priority = 8,name = &quot;test1Interceptor&quot;)
public class TestInterceptor implements IInterceptor &#123;

    private static final String TAG = &quot;TestInterceptor&quot;;

    @Override
    public void process(Postcard postcard, InterceptorCallback callback) &#123;
        // 必须处理
        callback.onContinue(new Postcard().withString(&quot;callback&quot;, &quot;ok&quot;));
    &#125;

    @Override
    public void init(Context context) &#123;

    &#125;
&#125;
</code></pre>
<h2 id="6-处理跳转结果（降级策略）"><a href="#6-处理跳转结果（降级策略）" class="headerlink" title="6.处理跳转结果（降级策略）"></a>6.处理跳转结果（降级策略）</h2><p>降级策略有2种，使用NavigationCallback或者DegradeService，自定义的方式优先于全局的方式，当设置自定义的NavigationCallback时，全局的降级策略不生效，当然自定义的还可以处理路由成功的场景等</p>
<h3 id="1-处理单次跳转结果"><a href="#1-处理单次跳转结果" class="headerlink" title="1.处理单次跳转结果"></a>1.处理单次跳转结果</h3><pre><code>// 使用两个参数的navigation方法，可以获取单次跳转的结果
ARouter.getInstance().build(&quot;/test/1&quot;).navigation(this, new NavigationCallback() &#123;
    
    @Override
    public void onInterrupt(Postcard postcard) &#123;
        Log.d(TAG, &quot;onInterrupt: &quot; + postcard.toString());
    &#125;
    
    @Override
    public void onFound(Postcard postcard) &#123;
    ...
    &#125;

    @Override
    public void onLost(Postcard postcard) &#123;
    ...
    &#125;
&#125;);
</code></pre>
<h3 id="2-全局降级策略"><a href="#2-全局降级策略" class="headerlink" title="2.全局降级策略"></a>2.全局降级策略</h3><pre><code>// 实现DegradeService接口，并加上一个Path内容任意的注解即可
@Route(path = &quot;/xxx/xxx&quot;)
public class DegradeServiceImpl implements DegradeService &#123;
@Override
public void onLost(Context context, Postcard postcard) &#123;
    // do something.
&#125;

@Override
public void init(Context context) &#123;

&#125;
&#125;
</code></pre>
<h2 id="7-服务管理"><a href="#7-服务管理" class="headerlink" title="7.服务管理"></a>7.服务管理</h2><h3 id="7-1-暴露服务"><a href="#7-1-暴露服务" class="headerlink" title="7.1 暴露服务"></a>7.1 暴露服务</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明接口,其他组件通过接口来调用服务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> <span class="keyword">extends</span> <span class="title">IProvider</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现接口</span></span><br><span class="line"><span class="meta">@Route(path = &quot;/yourservicegroupname/hello&quot;, name = &quot;测试服务&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello, &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-2-发现服务"><a href="#7-2-发现服务" class="headerlink" title="7.2 发现服务"></a>7.2 发现服务</h3><p>发现服务有2种方式分别是byName和byType</p>
<pre><code>public class Test &#123;
    @Autowired
    HelloService helloService;

    @Autowired(name = &quot;/yourservicegroupname/hello&quot;)
    HelloService helloService2;

    HelloService helloService3;

    HelloService helloService4;

    public Test() &#123;
    ARouter.getInstance().inject(this);
    &#125;

    public void testService() &#123;
    // 1. (推荐)使用依赖注入的方式发现服务,通过注解标注字段,即可使用，无需主动获取
    // Autowired注解中标注name之后，将会使用byName的方式注入对应的字段，不设置name属性，会默认使用byType的方式发现服务(当同一接口有多个实现的时候，必须使用byName的方式发现服务)
    helloService.sayHello(&quot;Vergil&quot;);
    helloService2.sayHello(&quot;Vergil&quot;);

    // 2. 使用依赖查找的方式发现服务，主动去发现服务并使用，下面两种方式分别是byName和byType
    helloService3 = (HelloService) ARouter.getInstance().build(&quot;/yourservicegroupname/hello&quot;).navigation();
    helloService4 = ARouter.getInstance().navigation(HelloService.class);
    helloService3.sayHello(&quot;Vergil&quot;);
    helloService4.sayHello(&quot;Vergil&quot;);
    &#125;
&#125;
</code></pre>
<h2 id="8-跳转fragment"><a href="#8-跳转fragment" class="headerlink" title="8.跳转fragment"></a>8.跳转fragment</h2><p>跳转fragment的一般操作是先路由到Fragment的Activity，再构建出对应的fragment，对fragment进行操作。</p>
<h3 id="8-1-创建fragement并添加注解"><a href="#8-1-创建fragement并添加注解" class="headerlink" title="8.1 创建fragement并添加注解"></a>8.1 创建fragement并添加注解</h3><pre><code>@Route(path = &quot;/test/fragment/testFragment1&quot;)
public class TestFragment1 extends Fragment &#123;

    @Nullable
    @Override
    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123;
        return inflater.inflate(R.layout.activity_test_fragment, container, false);
    &#125;
&#125;
</code></pre>
<h3 id="8-2-为fragmentActivity添加路由，-target-参数是对应fragment的路由路径"><a href="#8-2-为fragmentActivity添加路由，-target-参数是对应fragment的路由路径" class="headerlink" title="8.2 为fragmentActivity添加路由， target 参数是对应fragment的路由路径"></a>8.2 为fragmentActivity添加路由， target 参数是对应fragment的路由路径</h3><pre><code>@Route(path = &quot;/test/fragmentActivity&quot;)
public class TestFragmentActivity extends BaseFragmentActivity &#123;

    @Autowired
    String target;

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;
        super.onCreate(savedInstanceState);

        setContentView(R.layout.activity_fragment1);
        FragmentManager fragmentManager = getSupportFragmentManager();

        FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();

        Fragment fragment = (Fragment) ARouter.getInstance().build(target).navigation();

        fragmentTransaction.add(R.id.fragment_container, fragment, &quot;fragment1&quot;).commit();
    &#125;
&#125;
</code></pre>
<h3 id="8-3-发起路由"><a href="#8-3-发起路由" class="headerlink" title="8.3 发起路由"></a>8.3 发起路由</h3><pre><code>ARouter.getInstance().build(&quot;/test/fragmentActivity&quot;).withString(&quot;target&quot;, &quot;/test/fragment/testFragment1&quot;).navigation();
</code></pre>
<h3 id="8-4-Fragment-Issue"><a href="#8-4-Fragment-Issue" class="headerlink" title="8.4 Fragment Issue:"></a>8.4 Fragment Issue:</h3><p><a href="https://github.com/alibaba/ARouter/issues/149">https://github.com/alibaba/ARouter/issues/149</a></p>
<h2 id="9-重写跳转的url"><a href="#9-重写跳转的url" class="headerlink" title="9.重写跳转的url"></a>9.重写跳转的url</h2><pre><code>// 实现PathReplaceService接口，并加上一个Path内容任意的注解即可
@Route(path = &quot;/xxx/xxx&quot;) // 必须标明注解
public class PathReplaceServiceImpl implements PathReplaceService &#123;
    /**
    * For normal path.
    *
    * @param path raw path
    */
    String forString(String path) &#123;
    return path;    // 按照一定的规则处理之后返回处理后的结果
    &#125;

/**
    * For uri type.
    *
    * @param uri raw uri
    */
Uri forUri(Uri uri) &#123;
    return url;    // 按照一定的规则处理之后返回处理后的结果
&#125;
&#125;
</code></pre>
<h2 id="10-生成路由文档"><a href="#10-生成路由文档" class="headerlink" title="10. 生成路由文档"></a>10. 生成路由文档</h2><pre><code>// 更新 build.gradle, 添加参数 AROUTER_GENERATE_DOC = enable
// 生成的文档路径 : build/generated/source/apt/(debug or release)/com/alibaba/android/arouter/docs/arouter-map-of-$&#123;moduleName&#125;.json
android &#123;
    defaultConfig &#123;
        ...
        javaCompileOptions &#123;
            annotationProcessorOptions &#123;
                arguments = [AROUTER_MODULE_NAME: project.getName(), AROUTER_GENERATE_DOC: &quot;enable&quot;]
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://github.com/alibaba/ARouter/blob/master/README_CN.md">https://github.com/alibaba/ARouter/blob/master/README_CN.md</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>开源</category>
      </categories>
  </entry>
  <entry>
    <title>open_03_ARouter源码分析</title>
    <url>/2021/02/24/Notes/Android/02%E5%BC%80%E6%BA%90/open_03_ARouter%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="open-03-ARouter源码分析"><a href="#open-03-ARouter源码分析" class="headerlink" title="open_03_ARouter源码分析"></a>open_03_ARouter源码分析</h1><span id="more"></span>

<h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h2><p>arouter-annotation: ARouter路由框架所使用的全部注解，及其相关类<br>arouter-compiler：注解编译处理器，引入“arouter-annotation”，在编译期完成了 构造路由表逻辑的创建<br>arouter-api：在运行期加载逻辑构建路由表，并实现路由控制</p>
<p><img src="https://leanote.com/api/file/getImage?fileId=5cd18987ab64417c75003571" alt="arouter-api"></p>
<p>最基础的就是Compiler这个SDK，其内部有三个处理器，分别是：Route Processor，Interceptor Processor以及Autowire Processor，通过名字就可以看出这三个处理器分别是处理路径路由、拦截器和进行自动装配的。而API的SDK是用户在运行期使用的，这一部分主要分为四层。<br>最上层是Launcher层，这一层是开发者可以直接用到的，其实所有的API都是在这一层中。<br>在Launcher层的下一层就是Frossard层，从上图中可以看到Frossard层也是绿色的，表示这一层也是可以被外部调用的，Frossard层其实包含了三部分，分别是：Service、Callback和Template，这里的Service概念和服务端的Service概念是相似的，也是在客户端的简单引申，但是却不同于Android组件中的Service，这里的Service是ARouter抽象出来的概念，从本质上讲，这里的Service是接口，从意义上讲是将一定的功能和组件封装成接口，并对外提供能力。Template则是模板，主要用于在编译期执行的SDK，这个SDK会在编译期生成一些映射文件，而这些映射文件会按照Template组件中提供的模板来生成，这样按照一定的规则和约束生成映射文件也方便Route在运行的时候进行读取。<br>再往下一层就完全是SDK的内部实现了，这一层包括了Ware House、Thread、Log、Exception以及Class工具。Ware House主要存储了ARouter在运行期间加载的一些配置文件以及映射关系；而Thread则是提供了线程池，因为存在多个拦截器的时候以及跳转过程中都是需要异步执行的；Class工具则是用于解决不同类型APK的兼容问题的。<br>再下一层就是Logistics Center，从名字上翻译就是物流中心，整个SDK的流转以及内部调用最终都会下沉到这一层，当然也会按照功能模块进行划分。</p>
<p><strong>编译期按照固定的命名格式生成映射文件，在运行期只需要通过固定的包名来加载映射文件.</strong></p>
<h2 id="1-arouter-annotation注解"><a href="#1-arouter-annotation注解" class="headerlink" title="1.arouter-annotation注解"></a>1.arouter-annotation注解</h2><h3 id="1-1-Route路由注解"><a href="#1-1-Route路由注解" class="headerlink" title="1.1 @Route路由注解"></a>1.1 @Route路由注解</h3><p>@Route 是 ARouter 最重要的注解，也是路由最基本的节点，该注解主要用于描述路由中的路径URL信息，使用该注解标注的类将被自动添加至路由表中。<br>值得说明的一点是 ARouter 并非仅提供页面（Activity）的路由功能，还可以用来路由模块想要暴露给其他模块调用的接口。</p>
<p>也就是说 @Route 不仅可用于 Activity 类，还可用于模块对外接口的实现类，实现类似于 AIDL 的功能，也就是IOC</p>
<h3 id="1-2-Interceptor拦截器注解"><a href="#1-2-Interceptor拦截器注解" class="headerlink" title="1.2 @Interceptor拦截器注解"></a>1.2 @Interceptor拦截器注解</h3><p>@Interceptor 是拦截器注解，拦截器是全应用全局的，不分module，只要集成进apk就起效</p>
<h3 id="1-3-Autowired自动装载注解"><a href="#1-3-Autowired自动装载注解" class="headerlink" title="1.3 @Autowired自动装载注解"></a>1.3 @Autowired自动装载注解</h3><p>@Autowired 是页面跳转时参数传递用的。目标Class中使用该注解标志的变量，会在页面被路由打开的时候，在调用Inject()后自动赋予传递的参数值</p>
<h3 id="1-4-RouteMeta-amp-amp-PostCard-路由元信息"><a href="#1-4-RouteMeta-amp-amp-PostCard-路由元信息" class="headerlink" title="1.4 RouteMeta &amp;&amp; PostCard 路由元信息"></a>1.4 RouteMeta &amp;&amp; PostCard 路由元信息</h3><p>如果全部路由信息认为是一张表格，那么RouteMeta就是表格的一行，代表路由表的一条元信息</p>
<h2 id="2-arouter-compiler注解编译器"><a href="#2-arouter-compiler注解编译器" class="headerlink" title="2.arouter-compiler注解编译器"></a>2.arouter-compiler注解编译器</h2><p>实现了“自动注册映射关系”也就是在编译期间自动生成映射文件，所以该module其实就是实现了一些注解处理器,目标在于生成映射文件与辅助文件(构造路由表逻辑的创建)</p>
<p><img src="https://leanote.com/api/file/getImage?fileId=5cd18987ab64417c75003570" alt="compile——out"></p>
<h2 id="2-1-组别的清单列表-【工程名-amp-amp-Root-amp-amp-模块名】"><a href="#2-1-组别的清单列表-【工程名-amp-amp-Root-amp-amp-模块名】" class="headerlink" title="2.1 组别的清单列表 【工程名&amp;&amp;Root&amp;&amp;模块名】"></a>2.1 组别的清单列表 【工程名&amp;&amp;Root&amp;&amp;模块名】</h2><p>Map&lt; String, Class&lt; ? extends IRouteGroup&gt;&gt; routes<br>包含了组名与对应组内的路由清单列表Class的映射关系<br>是Arouter的“分组管理，按需加载”的实现。<br>ARouter在初始化的时候只会一次性地加载所有的root结点，而不会加载任何一个Group结点，这样就会极大地降低初始化时加载结点的数量<br>那么什么时候加载分组结点呢？其实就是当某一个分组下的某一个页面第一次被访问的时候，整个分组的全部页面都会被加载进去，这就是ARouter的按需加载<br><img src="https://leanote.com/api/file/getImage?fileId=5cd18987ab64417c75003572" alt="root"></p>
<h3 id="2-1-1-组内的路由清单列表-【工程名-amp-amp-Group-amp-amp-分组名】"><a href="#2-1-1-组内的路由清单列表-【工程名-amp-amp-Group-amp-amp-分组名】" class="headerlink" title="2.1.1 组内的路由清单列表 【工程名&amp;&amp;Group&amp;&amp;分组名】"></a>2.1.1 组内的路由清单列表 【工程名&amp;&amp;Group&amp;&amp;分组名】</h3><p>(Map&lt; String, RouteMeta&gt; atlas<br>包含了对应分组下的，路由URL与目标对象Class的映射关系；<br>注意Router注解中无分组的话，默认以“/xx/xx”的第一个xx为分组名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DO NOT EDIT THIS FILE!!! IT WAS GENERATED BY AROUTER. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ARouter</span>$$<span class="title">Group</span>$$<span class="title">core</span> <span class="keyword">implements</span> <span class="title">IRouteGroup</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadInto</span><span class="params">(Map&lt;String, RouteMeta&gt; atlas)</span> </span>&#123;</span><br><span class="line">    atlas.put(<span class="string">&quot;/core/activity&quot;</span>, RouteMeta.build(RouteType.ACTIVITY, CoreActivity.class, <span class="string">&quot;/core/activity&quot;</span>, <span class="string">&quot;core&quot;</span>, <span class="keyword">new</span> java.util.HashMap&lt;String, Integer&gt;()&#123;&#123;put(<span class="string">&quot;name&quot;</span>, <span class="number">8</span>); &#125;&#125;, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-Ioc的动作路由清单列表-【工程名-amp-amp-Providers-amp-amp-模块名】"><a href="#2-2-Ioc的动作路由清单列表-【工程名-amp-amp-Providers-amp-amp-模块名】" class="headerlink" title="2.2 Ioc的动作路由清单列表 【工程名&amp;&amp;Providers&amp;&amp;模块名】"></a>2.2 Ioc的动作路由清单列表 【工程名&amp;&amp;Providers&amp;&amp;模块名】</h3><p>Map&lt; String, RouteMeta&gt; providers<br>PROVIDER 类型的路由节点的清单列表<br>包含了使用依赖注入方式的某class(实现了IProvide接口的直接子类)的 路由URL 与class映射关系<br>目标Class都实现了IProvider接口，借此实现部分路由转到该清单中<br>需要注意的是：Ioc动作路由清单其实只是 Route注解的一种特殊用法，总的来说，还是一种URL与目标类的映射关系<br>其实想一下，依赖注入，无非也就是指定好目标接口的目标类，然而实例化后进行赋值。</p>
<p><img src="https://leanote.com/api/file/getImage?fileId=5cd18987ab64417c75003573" alt="degrade"><br>service，同时在provider和group里，（接口，功能提供者） 特殊。<br>特别的，请注意：PROVIDER 类型的路由节点既存在于存在于对应的分组中，也存在于该类型的清单列表中<br>这就好像学生中有一些是少先队员，每个班级中都有可能有少先队员，而学校又有一份少先队员的总列表。这就意味着我们有两种方式来查找到一个可确定的少先队员</p>
<p>所以，ARouter 可通过两种方式来获取 PROVIDER 类型的路由节点</p>
<ul>
<li><p>ByName的方式：通过【组内的路由清单列表】,根据 注解的name对HelloService进行注入 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">((HelloService) ARouter.getInstance().build(“/service/hello”).navigation()).sayHello(“mike”);</span><br></pre></td></tr></table></figure></li>
<li><p>ByType的方式 ：通过【Ioc的动作路由清单列表】<br>仅在HelloService接口只有一个实现时可用 = 根据classType实现注入<br>当同一接口有多个实现的时候，必须使用byName的方式发现服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ARouter.getInstance().navigation(HelloService.class).sayHello(“mike”);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-3-模块内的拦截器清单列表-【工程名-amp-amp-Interceptors-amp-amp-模块名】"><a href="#2-3-模块内的拦截器清单列表-【工程名-amp-amp-Interceptors-amp-amp-模块名】" class="headerlink" title="2.3 模块内的拦截器清单列表 【工程名&amp;&amp;Interceptors&amp;&amp;模块名】"></a>2.3 模块内的拦截器清单列表 【工程名&amp;&amp;Interceptors&amp;&amp;模块名】</h3><p>Map&lt; Integer, Class&lt; ? extends IInterceptor&gt;&gt; interceptors<br>包含了某个模块下的拦截器 与 优先级的映射关系<br>一个模块下的所有拦截器都在该类中包含，无分组特性，所以直接以模块名命名类文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DO NOT EDIT THIS FILE!!! IT WAS GENERATED BY AROUTER. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ARouter</span>$$<span class="title">Interceptors</span>$$<span class="title">core</span> <span class="keyword">implements</span> <span class="title">IInterceptorGroup</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadInto</span><span class="params">(Map&lt;Integer, Class&lt;? extends IInterceptor&gt;&gt; interceptors)</span> </span>&#123;</span><br><span class="line">    interceptors.put(<span class="number">8</span>, TestInterceptor.class);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="2-4-Warehouse-路由仓库"><a href="#2-4-Warehouse-路由仓库" class="headerlink" title="2.4 Warehouse 路由仓库"></a>2.4 Warehouse 路由仓库</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">上述的这些路由信息最终都会保存在路由仓库里。</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Warehouse</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Cache route and metas</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; groupsIndex = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, RouteMeta&gt; routes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache provider</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Class, IProvider&gt; providers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, RouteMeta&gt; providersIndex = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache interceptor</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Integer, Class&lt;? extends IInterceptor&gt;&gt; interceptorsIndex = <span class="keyword">new</span> UniqueKeyTreeMap&lt;&gt;(<span class="string">&quot;More than one interceptors use same priority [%s]&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> List&lt;IInterceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        routes.clear();</span><br><span class="line">        groupsIndex.clear();</span><br><span class="line">        providers.clear();</span><br><span class="line">        providersIndex.clear();</span><br><span class="line">        interceptors.clear();</span><br><span class="line">        interceptorsIndex.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-Autowired注解处理"><a href="#2-4-Autowired注解处理" class="headerlink" title="2.4 Autowired注解处理"></a>2.4 Autowired注解处理</h3><p>分析下TestActivity1自动生成的路由辅助文件。</p>
<p><img src="https://leanote.com/api/file/getImage?fileId=5cd18a36ab64417a710034d4" alt="autowired"></p>
<p>通过Arouter路由框架的IOc的ByType方式对SerializationService进行注入，该类为Json转换的工具类<br>注意助理使用的是ByType方式，也就是直接找到实现了SerializationService接口的唯一类进行实例化并注入，如果实现了SerializationService接口的有多个类，那么就会出现问题<br>所以全局应用的所有模块中，只能存在一个实现了SerializationService接口的类</p>
<h3 id="2-5获取目标对象实例"><a href="#2-5获取目标对象实例" class="headerlink" title="2.5获取目标对象实例"></a>2.5获取目标对象实例</h3><p>利用目标对象的对应传值方式，对目标对象的实例中的成员变量进行赋值<br>Acitivty使用的getIntent()—–由框架自身的参数传递决定，详见 4.3API部分<br>Fragment使用getArguments()—–由框架自身的参数传递决定，详见 4.3API部分<br>OBJ对象使用JSon辅助类进行实例化转换—– 详见 4.3API部分，传递参数时会将对象封装为json字符串<br>IOc依赖注入对象，默认使用byType方式，如果Autowired注解中有标识name，则使用name指向的类实例并赋值</p>
<h2 id="3-arouter-api路由控制"><a href="#3-arouter-api路由控制" class="headerlink" title="3. arouter-api路由控制"></a>3. arouter-api路由控制</h2><h3 id="3-1-init过程"><a href="#3-1-init过程" class="headerlink" title="3.1 init过程"></a>3.1 init过程</h3><p><img src="http://upload-images.jianshu.io/upload_images/1319879-596be6eb9b74ee90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="init"></p>
<h3 id="3-1-1-ARouter-init"><a href="#3-1-1-ARouter-init" class="headerlink" title="3.1.1 ARouter.init()"></a>3.1.1 ARouter.init()</h3><pre><code>public static void init(Application application) &#123;
    if (!hasInit) &#123;
        logger = _ARouter.logger;
        _ARouter.logger.info(Consts.TAG, &quot;ARouter init start.&quot;);
        hasInit = _ARouter.init(application);

        if (hasInit) &#123;
            _ARouter.afterInit();
        &#125;

        _ARouter.logger.info(Consts.TAG, &quot;ARouter init over.&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="3-1-2-ARouter-init-application"><a href="#3-1-2-ARouter-init-application" class="headerlink" title="3.1.2 _ARouter.init(application)"></a>3.1.2 _ARouter.init(application)</h3><pre><code>protected static synchronized boolean init(Application application) &#123;
    mContext = application;
    LogisticsCenter.init(mContext, executor);
    logger.info(Consts.TAG, &quot;ARouter init success!&quot;);
    hasInit = true;
    mHandler = new Handler(Looper.getMainLooper());

    return true;
&#125;
</code></pre>
<h3 id="3-1-3-LogisticsCenter-init-mContext-executor"><a href="#3-1-3-LogisticsCenter-init-mContext-executor" class="headerlink" title="3.1.3 LogisticsCenter.init(mContext, executor)"></a>3.1.3 LogisticsCenter.init(mContext, executor)</h3><p>33 - 43 行：分组管理，按需加载<br><img src="https://yqfile.alicdn.com/a84c3b25559a4dfac5bc828c71f0484d82b44445.png" alt="load过程"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context, ThreadPoolExecutor tpe)</span> <span class="keyword">throws</span> HandlerException </span>&#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">        executor = tpe;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> startInit = System.currentTimeMillis();</span><br><span class="line">            <span class="comment">//billy.qi modified at 2017-12-06</span></span><br><span class="line">            <span class="comment">//load by plugin first</span></span><br><span class="line">            loadRouterMap();</span><br><span class="line">            <span class="keyword">if</span> (registerByPlugin) &#123;</span><br><span class="line">                logger.info(TAG, <span class="string">&quot;Load router map by arouter-auto-register plugin.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Set&lt;String&gt; routerMap;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// It will rebuild router map every times when debuggable.</span></span><br><span class="line">                <span class="keyword">if</span> (ARouter.debuggable() || PackageUtils.isNewVersion(context)) &#123;</span><br><span class="line">                    logger.info(TAG, <span class="string">&quot;Run with debug mode or new install, rebuild router map.&quot;</span>);</span><br><span class="line">                    <span class="comment">// These class was generated by arouter-compiler.</span></span><br><span class="line">                    routerMap = ClassUtils.getFileNameByPackageName(mContext, ROUTE_ROOT_PAKCAGE);</span><br><span class="line">                    <span class="keyword">if</span> (!routerMap.isEmpty()) &#123;</span><br><span class="line">                        context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).edit().putStringSet(AROUTER_SP_KEY_MAP, routerMap).apply();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    PackageUtils.updateVersion(context);    <span class="comment">// Save new version name when router map update finishes.</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    logger.info(TAG, <span class="string">&quot;Load router map from cache.&quot;</span>);</span><br><span class="line">                    routerMap = <span class="keyword">new</span> HashSet&lt;&gt;(context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).getStringSet(AROUTER_SP_KEY_MAP, <span class="keyword">new</span> HashSet&lt;String&gt;()));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                logger.info(TAG, <span class="string">&quot;Find router map finished, map size = &quot;</span> + routerMap.size() + <span class="string">&quot;, cost &quot;</span> + (System.currentTimeMillis() - startInit) + <span class="string">&quot; ms.&quot;</span>);</span><br><span class="line">                startInit = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (String className : routerMap) &#123;</span><br><span class="line">                     <span class="comment">// 初始化时只加载“根路由节点” root + provider + interceptor </span></span><br><span class="line">                    <span class="keyword">if</span> (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_ROOT)) &#123;</span><br><span class="line">                        <span class="comment">// com.alibaba.android.arouter.routes.ARouter\$\$Root</span></span><br><span class="line">                        <span class="comment">// This one of root elements, load root.</span></span><br><span class="line">                        ((IRouteRoot) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.groupsIndex);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_INTERCEPTORS)) &#123;</span><br><span class="line">                        <span class="comment">// Load interceptorMeta</span></span><br><span class="line">                        <span class="comment">// com.alibaba.android.arouter.routes.ARouter\$\$Interceptors</span></span><br><span class="line">                        ((IInterceptorGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.interceptorsIndex);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_PROVIDERS)) &#123;</span><br><span class="line">                        <span class="comment">// Load providerIndex</span></span><br><span class="line">                        <span class="comment">// com.alibaba.android.arouter.routes.ARouter\$\$Providers</span></span><br><span class="line">                        ((IProviderGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.providersIndex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-1-5-ARouter-afterInit-初始化拦截器控制器"><a href="#3-1-5-ARouter-afterInit-初始化拦截器控制器" class="headerlink" title="3.1.5 _ARouter.afterInit() 初始化拦截器控制器"></a>3.1.5 _ARouter.afterInit() 初始化拦截器控制器</h2><p>根据 Ioc.ByName()方式获取拦截器控制器，注意这个拦截器并不是我们定义的拦截器，而是Arouter实现的拦截器逻辑，它持有我们定义的拦截器，可以理解为“拦截器截面控制器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">afterInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Trigger interceptor init, use byName.</span></span><br><span class="line">    interceptorService = (InterceptorService) ARouter.getInstance().build(<span class="string">&quot;/arouter/service/interceptor&quot;</span>).navigation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Route(path = &quot;/arouter/service/interceptor&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorServiceImpl</span> <span class="keyword">implements</span> <span class="title">InterceptorService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> interceptorHasInit;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object interceptorInitLock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doInterceptions</span><span class="params">(<span class="keyword">final</span> Postcard postcard, <span class="keyword">final</span> InterceptorCallback callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != Warehouse.interceptors &amp;&amp; Warehouse.interceptors.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>12-15行：拦截器控制器的主要逻其实就是获取Warehouse中所有的拦截器，在需要拦截时执行他们的拦截方法，参见3.2.2节。</p>
<h2 id="3-2-路由寻址过程"><a href="#3-2-路由寻址过程" class="headerlink" title="3.2 路由寻址过程"></a>3.2 路由寻址过程</h2><pre><code>ARouter.getInstance().build(&quot;/core/activity&quot;).navigation();
</code></pre>
<h3 id="3-2-1-build-Postcard"><a href="#3-2-1-build-Postcard" class="headerlink" title="3.2.1 build Postcard"></a>3.2.1 build Postcard</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ARouter.build</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Postcard <span class="title">build</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _ARouter.getInstance().build(path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// _ARouter.build</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Postcard <span class="title">build</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(path)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(Consts.TAG + <span class="string">&quot;Parameter is invalid!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != pService) &#123;</span><br><span class="line">            path = pService.forString(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> build(path, extractGroup(path));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Postcard <span class="title">build</span><span class="params">(String path, String group)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(path) || TextUtils.isEmpty(group)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(Consts.TAG + <span class="string">&quot;Parameter is invalid!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != pService) &#123;</span><br><span class="line">            path = pService.forString(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Postcard(path, group);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第9和21行分别是2种build Postcard的方式，可以看到build(path)也是调用了build(String path, String group)。如果采用的是build(path)，group字段默认取”/group/path/“第一个”/“和第二个”/“之的字段，当有多个”/group/path/childpath/“，第二个”/“之后都算path。</p>
<p>13、25行 展示了PathReplaceService 的工作原理</p>
<p>29 完成创建Postcard</p>
<h3 id="3-2-2-navigation-过程"><a href="#3-2-2-navigation-过程" class="headerlink" title="3.2.2 navigation 过程"></a>3.2.2 navigation 过程</h3><p>省略Arouter调用过程，直接看最终的_ARouter.navigation，一次路由的跳转包含查找回调的调用、拦截器处理、绿色通道校验、和具体路由操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">navigation</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> Postcard postcard, <span class="keyword">final</span> <span class="keyword">int</span> requestCode, <span class="keyword">final</span> NavigationCallback callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    </span><br><span class="line">    		<span class="comment">// 1.查询具体的路由信息</span></span><br><span class="line">        LogisticsCenter.completion(postcard);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoRouteFoundException ex) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != callback) &#123;</span><br><span class="line">            callback.onLost(postcard);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">// No callback for this invoke, then we use the global degrade service.</span></span><br><span class="line">            DegradeService degradeService = ARouter.getInstance().navigation(DegradeService.class);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != degradeService) &#123;</span><br><span class="line">                degradeService.onLost(context, postcard);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != callback) &#123;</span><br><span class="line">        callback.onFound(postcard);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!postcard.isGreenChannel()) &#123;   <span class="comment">// It must be run in async thread, maybe interceptor cost too mush time made ANR.</span></span><br><span class="line">        interceptorService.doInterceptions(postcard, <span class="keyword">new</span> InterceptorCallback() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * Continue process</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> postcard route meta</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onContinue</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">                _navigation(context, postcard, requestCode, callback);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * Interrupt process, pipeline will be destory when this method called.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> exception Reson of interrupt.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInterrupt</span><span class="params">(Throwable exception)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != callback) &#123;</span><br><span class="line">                    callback.onInterrupt(postcard);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                logger.info(Consts.TAG, <span class="string">&quot;Navigation failed, termination by interceptor : &quot;</span> + exception.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 2. 真正的路由</span></span><br><span class="line">        <span class="keyword">return</span> _navigation(context, postcard, requestCode, callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第3行：完善路由信息，详细分析见3.2.4节<br>6-13行：路由异常时处理，可以看到，手动添加了降级处理的callback要优先于全局的降级处理全局的降级处理，在没有主动添加降级处理时才会触发全局的降级。</p>
<p>22-47行：拦截器的工作原理，在没有设置为greenChannel时，会调用到拦截器控制器的doInterceptions，循环遍历所有的拦截器处理拦截逻辑，结合3.1.5内容理解。</p>
<p>第49行：真正的路由过程</p>
<h3 id="3-2-3-完善路由信息-LogisticsCenter-completion-postcard"><a href="#3-2-3-完善路由信息-LogisticsCenter-completion-postcard" class="headerlink" title="3.2.3 完善路由信息 LogisticsCenter.completion(postcard)"></a>3.2.3 完善路由信息 LogisticsCenter.completion(postcard)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">completion</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == postcard) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoRouteFoundException(TAG + <span class="string">&quot;No postcard!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        RouteMeta routeMeta = Warehouse.routes.get(postcard.getPath());</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == routeMeta) &#123;    <span class="comment">// Maybe its does&#x27;t exist, or didn&#x27;t load.</span></span><br><span class="line">            Class&lt;? extends IRouteGroup&gt; groupMeta = Warehouse.groupsIndex.get(postcard.getGroup());  <span class="comment">// Load route meta.</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == groupMeta) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoRouteFoundException(TAG + <span class="string">&quot;There is no route match the path [&quot;</span> + postcard.getPath() + <span class="string">&quot;], in group [&quot;</span> + postcard.getGroup() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Load route and cache it into memory, then delete from metas.</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                    IRouteGroup iGroupInstance = groupMeta.getConstructor().newInstance();</span><br><span class="line">                    iGroupInstance.loadInto(Warehouse.routes);</span><br><span class="line">                    Warehouse.groupsIndex.remove(postcard.getGroup());</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(TAG + <span class="string">&quot;Fatal exception when loading group meta. [&quot;</span> + e.getMessage() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                completion(postcard);   <span class="comment">// Reload</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            postcard.setDestination(routeMeta.getDestination());</span><br><span class="line">            postcard.setType(routeMeta.getType());</span><br><span class="line">            postcard.setPriority(routeMeta.getPriority());</span><br><span class="line">            postcard.setExtra(routeMeta.getExtra());</span><br><span class="line"></span><br><span class="line">            Uri rawUri = postcard.getUri();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != rawUri) &#123;   <span class="comment">// Try to set params into bundle.</span></span><br><span class="line">                Map&lt;String, String&gt; resultMap = TextUtils.splitQueryParameters(rawUri);</span><br><span class="line">                Map&lt;String, Integer&gt; paramsType = routeMeta.getParamsType();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (MapUtils.isNotEmpty(paramsType)) &#123;</span><br><span class="line">                    <span class="comment">// Set value by its type, just for params which annotation by @Param</span></span><br><span class="line">                    <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; params : paramsType.entrySet()) &#123;</span><br><span class="line">                        setValue(postcard,</span><br><span class="line">                                params.getValue(),</span><br><span class="line">                                params.getKey(),</span><br><span class="line">                                resultMap.get(params.getKey()));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Save params name which need auto inject.</span></span><br><span class="line">                    postcard.getExtras().putStringArray(ARouter.AUTO_INJECT, paramsType.keySet().toArray(<span class="keyword">new</span> String[]&#123;&#125;));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Save raw uri</span></span><br><span class="line">                postcard.withString(ARouter.RAW_URI, rawUri.toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (routeMeta.getType()) &#123;</span><br><span class="line">                <span class="keyword">case</span> PROVIDER:  <span class="comment">// if the route is provider, should find its instance</span></span><br><span class="line">                    <span class="comment">// Its provider, so it must implement IProvider</span></span><br><span class="line">                    Class&lt;? extends IProvider&gt; providerMeta = (Class&lt;? extends IProvider&gt;) routeMeta.getDestination();</span><br><span class="line">                    IProvider instance = Warehouse.providers.get(providerMeta);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123; <span class="comment">// There&#x27;s no instance of this provider</span></span><br><span class="line">                        IProvider provider;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            provider = providerMeta.getConstructor().newInstance();</span><br><span class="line">                            provider.init(mContext);</span><br><span class="line">                            Warehouse.providers.put(providerMeta, provider);</span><br><span class="line">                            instance = provider;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(<span class="string">&quot;Init provider failed! &quot;</span> + e.getMessage());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    postcard.setProvider(instance);</span><br><span class="line">                    postcard.greenChannel();    <span class="comment">// Provider should skip all of interceptors</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> FRAGMENT:</span><br><span class="line">                    postcard.greenChannel();    <span class="comment">// Fragment needn&#x27;t interceptors</span></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>6 - 23行： </p>
<pre><code>1.根据路径URL获取到路径元信息 
2.如果未获取到路径元信息，可能是由于 未加载对应分组的【组内清单列表】 or 的确没有
3.从【组别的清单列表】拿到对应组的组内清单创建逻辑,如果为空，则丢出异常，未找到,不为空时，走如下逻辑（15 - 18行）：
（1）实例化【组内清单创建逻辑】
（2）将该组的【组内清单列表】加入到内存仓库中
（3）从【组别的清单列表】移除当前组 
（4）第23行重新加载路径元信息
</code></pre>
<p>26 - 29行：</p>
<pre><code>1.设置目标 class
2.设置路由类型
3.设置路由优先级
4.设置额外的配置开关信息
</code></pre>
<p>31 - 50行：<br>处理uri的跳转，如果有URI，则根据路由元信息的目标Class的需要注入的参数</p>
<pre><code>1.获取参数名和value
2.获取参数名和类型 （定义参数类型的类 TypeKind） 
3.将参数名和类型和值放到postcard对应的属性里。   
</code></pre>
<p>53 - 76行：处理不同的路由类型<br>54 - 71：PROVIDER类型的路由则实现实例化目标类绿色通道(byType方式的核心实现)，可以看到Arouter所有的服务都是单例的。</p>
<pre><code>73：如果是Fragment则设置绿色通道，不做任何拦截
</code></pre>
<h3 id="3-2-4-真正的navigation过程"><a href="#3-2-4-真正的navigation过程" class="headerlink" title="3.2.4 真正的navigation过程"></a>3.2.4 真正的navigation过程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">_navigation</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> Postcard postcard, <span class="keyword">final</span> <span class="keyword">int</span> requestCode, <span class="keyword">final</span> NavigationCallback callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Context currentContext = <span class="keyword">null</span> == context ? mContext : context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (postcard.getType()) &#123;</span><br><span class="line">        <span class="keyword">case</span> ACTIVITY:</span><br><span class="line">            <span class="comment">// Build intent</span></span><br><span class="line">            <span class="keyword">final</span> Intent intent = <span class="keyword">new</span> Intent(currentContext, postcard.getDestination());</span><br><span class="line">            intent.putExtras(postcard.getExtras());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Set flags.</span></span><br><span class="line">            <span class="keyword">int</span> flags = postcard.getFlags();</span><br><span class="line">            <span class="keyword">if</span> (-<span class="number">1</span> != flags) &#123;</span><br><span class="line">                intent.setFlags(flags);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(currentContext <span class="keyword">instanceof</span> Activity)) &#123;    <span class="comment">// Non activity, need less one flag.</span></span><br><span class="line">                intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Set Actions</span></span><br><span class="line">            String action = postcard.getAction();</span><br><span class="line">            <span class="keyword">if</span> (!TextUtils.isEmpty(action)) &#123;</span><br><span class="line">                intent.setAction(action);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Navigation in main looper.</span></span><br><span class="line">            runInMainThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    startActivity(requestCode, currentContext, intent, postcard, callback);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> PROVIDER:</span><br><span class="line">            <span class="keyword">return</span> postcard.getProvider();</span><br><span class="line">        <span class="keyword">case</span> BOARDCAST:</span><br><span class="line">        <span class="keyword">case</span> CONTENT_PROVIDER:</span><br><span class="line">        <span class="keyword">case</span> FRAGMENT:</span><br><span class="line">            Class fragmentMeta = postcard.getDestination();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Object instance = fragmentMeta.getConstructor().newInstance();</span><br><span class="line">                <span class="keyword">if</span> (instance <span class="keyword">instanceof</span> Fragment) &#123;</span><br><span class="line">                    ((Fragment) instance).setArguments(postcard.getExtras());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (instance <span class="keyword">instanceof</span> android.support.v4.app.Fragment) &#123;</span><br><span class="line">                    ((android.support.v4.app.Fragment) instance).setArguments(postcard.getExtras());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> instance;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                logger.error(Consts.TAG, <span class="string">&quot;Fetch fragment instance error, &quot;</span> + TextUtils.formatStackTrace(ex.getStackTrace()));</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> METHOD:</span><br><span class="line">        <span class="keyword">case</span> SERVICE:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5-30行：处理Activity的跳转，可以看到ARouter底层启动Activity时也是通过系统startActivity方法。同时在这里会设置intent的action，flag，另外postcard.getDestination() 返回的其实是.Class对象。</p>
<p>33-47行：处理PROVIDER、BOARDCAST、CONTENT_PROVIDER、FRAGMENT，返回一个对应类的实例，如果是Fragment，则返回实例，并填充bundle，另外这里的provider指的是ARouter的服务IProvider。</p>
<h2 id="4-其他"><a href="#4-其他" class="headerlink" title="4.其他"></a>4.其他</h2><h3 id="4-1-CallBack"><a href="#4-1-CallBack" class="headerlink" title="4.1 CallBack"></a>4.1 CallBack</h3><p>InterceptorCallback 拦截器的callbck<br>NavigationCallback 降级逻辑的全部回调<br>NavCallback 降级逻辑的部分回调</p>
<h3 id="4-2-Service"><a href="#4-2-Service" class="headerlink" title="4.2 Service"></a>4.2 Service</h3><p>AutowiredService 实现了“加载并调用辅助类以实现自动装载”， IOC.byName(/arouter/service/autowired)方式被_ARouter调用<br>ClassLoaderService 未使用<br>DegradeService 实现了全局降级逻辑， IOC.byType方式被_ARouter调用<br>InterceptorService实现了拦截器截面逻辑， IOC.byName(/arouter/service/interceptor)方式被_ARouter调用<br>PathReplaceService 实现了动态改变路由逻辑， IOC.byType方式被_ARouter调用<br>SerializationService 全局对Object对象的json转换工具类，IOC.byType方式被PostCard调用</p>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://yq.aliyun.com/articles/71687?t=t1">https://yq.aliyun.com/articles/71687?t=t1</a><br><a href="https://blog.csdn.net/fei20121106/article/details/73743235">https://blog.csdn.net/fei20121106/article/details/73743235</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>开源</category>
      </categories>
  </entry>
  <entry>
    <title>open_04_OKHTTP源码分析</title>
    <url>/2020/11/22/Notes/Android/02%E5%BC%80%E6%BA%90/open_04_OKHTTP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="open-04-OKHTTP源码分析"><a href="#open-04-OKHTTP源码分析" class="headerlink" title="open_04_OKHTTP源码分析"></a>open_04_OKHTTP源码分析</h1><span id="more"></span>

<p>OkHttp 作为目前Android平台上广泛使用的开源库，很多没有看过源码的同学可能都是知道怎么用，但是不知道具体的原理。这边文章主要通过分析源码，使大家可以对OkHttp有一个完整和深入的了解。本文会从Okttp的请求流程，拦截器以及架构角度对OkHttp进行总结。选用的Okttp版本是 3.14.x。</p>
<p>github地址：<a href="https://github.com/square/okhttp">OKHttp</a></p>
<h1 id="一、请求流程"><a href="#一、请求流程" class="headerlink" title="一、请求流程"></a>一、请求流程</h1><p>常见的OKHttp的请求如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Request request = <span class="keyword">new</span> Request.Builder().url(url).build();</span><br><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder().build();</span><br><span class="line">Call call = client.newCall(request);</span><br><span class="line">Response response = call.execute();</span><br></pre></td></tr></table></figure>

<p>请求过程中内部调用逻辑：</p>
<img src="/pics/image-20200720195342044.png" alt="image-20200720195342044" style="zoom:70%;" />

<p>涉及到的几个核心类：</p>
<ul>
<li><strong>OkHttpClient</strong>：OkHttp的核心管理类，所有的内部逻辑和对象归OkHttpClient统一来管理，采用Builder构建</li>
<li><strong>Request</strong>：发送请求封装类，内部有url, header , method，body等常见的参数；</li>
<li><strong>Response</strong>：请求的结果，包含code, message, header,body ；</li>
<li><strong>Call &amp;RealCall</strong> <ul>
<li>Call 是一个接口，是请求的抽象描述，具体实现类是 RealCall，通过Call.Factory 创建。</li>
<li>RealCall负责请求的调度（同步的话走当前线程发送请求，异步的话则使用OkHttp内部的线程池进行）；同时负责构造内部逻辑责任链，并执行责任链相关的逻辑，直到获取结果。虽然OkHttpClient是整个OkHttp的核心管理类，但是真正发出请求并且组织逻辑的是RealCall类，它同时肩负了调度和责任链组织的两大重任</li>
</ul>
</li>
<li><strong>Dispatcher：</strong>请求调度器，控制每一个 Call 的执行顺序和生命周期。</li>
<li><strong>Interceptor</strong>：拦截器，责任链模式，具体执行每个请求，参数拼接，网络连接等等。</li>
<li><strong>ConnectionPool</strong>：连接缓存池，保存空闲连接，提高响应速度。</li>
</ul>
<h2 id="2-1、同步请求"><a href="#2-1、同步请求" class="headerlink" title="2.1、同步请求"></a>2.1、同步请求</h2><p>同步请求调用的是<code>RealCall#execute()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Already Executed&quot;</span>);</span><br><span class="line">    executed = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  transmitter.timeoutEnter();</span><br><span class="line">  transmitter.callStart();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 将请求加入到同步队列runningSyncCalls 中</span></span><br><span class="line">    client.dispatcher().executed(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 获取请求结果</span></span><br><span class="line">    <span class="keyword">return</span> getResponseWithInterceptorChain();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//将 call 从 runningSyncCalls 队列中移除</span></span><br><span class="line">    client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2、请求和结果"><a href="#2-2、请求和结果" class="headerlink" title="2.2、请求和结果"></a>2.2、请求和结果</h2><p>getResponseWithInterceptorChain 是真正发出请求以及请求返回的处理都在这个方法中，是OkHttp的核心方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// 添加拦截器</span></span><br><span class="line">  List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  interceptors.addAll(client.interceptors());</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> RetryAndFollowUpInterceptor(client));</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));</span><br><span class="line">  <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">    interceptors.addAll(client.networkInterceptors());</span><br><span class="line">  &#125;</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));</span><br><span class="line">  <span class="comment">// 创建RealInterceptorChain对象，里面有个index 参数，表示当前开始执行拦截器，每次执行一个index+1</span></span><br><span class="line">  Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(interceptors, transmitter, <span class="keyword">null</span>, <span class="number">0</span>,</span><br><span class="line">      originalRequest, <span class="keyword">this</span>, client.connectTimeoutMillis(),</span><br><span class="line">      client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line">  <span class="keyword">boolean</span> calledNoMoreExchanges = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行请求</span></span><br><span class="line">    Response response = chain.proceed(originalRequest);</span><br><span class="line">    <span class="keyword">if</span> (transmitter.isCanceled()) &#123;</span><br><span class="line">      closeQuietly(response);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Canceled&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    calledNoMoreExchanges = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">throw</span> transmitter.noMoreExchanges(e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!calledNoMoreExchanges) &#123;</span><br><span class="line">      transmitter.noMoreExchanges(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拦截器执行是<strong>递归执行</strong>的，每个拦截器有2个作用：</p>
<ul>
<li>拦截上一层拦截器封装好的 Request，然后自身对这个 Request 进行处理，处理后向下传递。</li>
<li>接收下一层拦截器传递回来的 Response，然后自身对 Response 进行处理，返回给上一层。</li>
</ul>
<p>异步请求调用的是 <code>RealCall#enqueue</code>方法，我们结合着Dispatcher一起讲</p>
<h1 id="二、调度器"><a href="#二、调度器" class="headerlink" title="二、调度器"></a>二、调度器</h1><p>Dispatcher 调度器，主要用于执行异步请求，内部维护了三个队列：</p>
<ul>
<li>readyAsyncCalls：等待的异步请求队列</li>
<li>runningAsyncCalls：正在运行的异步请求队列</li>
<li>runningSyncCalls：正在运行的同步请求队列</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 线程池的最大并发量 64</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxRequests = <span class="number">64</span>;</span><br><span class="line">  <span class="comment">// 每个host 最大的请求数 5</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxRequestsPerHost = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="meta">@Nullable</span> Runnable idleCallback;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Executes calls. Created lazily. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="meta">@Nullable</span> ExecutorService executorService;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Ready async calls in the order they&#x27;ll be run. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Running asynchronous calls. Includes canceled calls that haven&#x27;t finished yet. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//对于同步请求，由于它是即时运行的， Dispatcher 只需要运行前请求前存储到 runningSyncCalls，请求结束后从 runningSyncCalls 中移除即可。</span></span><br><span class="line">  <span class="comment">/** Running synchronous calls. Includes canceled calls that haven&#x27;t finished yet. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Dispatcher</span><span class="params">(ExecutorService executorService)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.executorService = executorService;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Dispatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对于异步请求，Dispatcher 是通过启动 ExcuteService 执行异步请求先放置在 readyAsyncCalls，可以执行时放到 runningAsyncCalls 中，执行结束从runningAsyncCalls 中移除。</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ExecutorService <span class="title">executorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (executorService == <span class="keyword">null</span>) &#123;</span><br><span class="line">      executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">          <span class="keyword">new</span> SynchronousQueue&lt;&gt;(), Util.threadFactory(<span class="string">&quot;OkHttp Dispatcher&quot;</span>, <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> executorService;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们借助异步请求的过程，分析下<code>Dispatcher</code>的原理，代码入口在<code>RealCall#enqueue</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Already Executed&quot;</span>);</span><br><span class="line">    executed = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  transmitter.callStart();</span><br><span class="line">  <span class="comment">// 发起异步请求，构建AsyncCall</span></span><br><span class="line">  client.dispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-1、Dispatcher-enqueue"><a href="#2-1、Dispatcher-enqueue" class="headerlink" title="2.1、Dispatcher#enqueue"></a>2.1、Dispatcher#enqueue</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">//1.加入到readyAsyncCalls中</span></span><br><span class="line">    readyAsyncCalls.add(call);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!call.get().forWebSocket) &#123;</span><br><span class="line">      <span class="comment">// 判断是不是存在相同的host 的 AsyncCall</span></span><br><span class="line">      AsyncCall existingCall = findExistingCallWithHost(call.host());</span><br><span class="line">      <span class="keyword">if</span> (existingCall != <span class="keyword">null</span>) call.reuseCallsPerHostFrom(existingCall);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 3.真正执行的入口</span></span><br><span class="line">  promoteAndExecute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2、Dispatcher-promoteAndExecute"><a href="#2-2、Dispatcher-promoteAndExecute" class="headerlink" title="2.2、Dispatcher#promoteAndExecute"></a>2.2、Dispatcher#promoteAndExecute</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">promoteAndExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> (!Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">  List&lt;AsyncCall&gt; executableCalls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">boolean</span> isRunning;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">// 遍历reaayAsyncCall 集合</span></span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">      AsyncCall asyncCall = i.next();</span><br><span class="line">			<span class="comment">// 真正运行超过阈值，break掉，不再执行请求</span></span><br><span class="line">      <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">break</span>; <span class="comment">// Max capacity.</span></span><br><span class="line">      <span class="comment">// 相同host 的请求超过阈值，contine</span></span><br><span class="line">      <span class="keyword">if</span> (asyncCall.callsPerHost().get() &gt;= maxRequestsPerHost) <span class="keyword">continue</span>; <span class="comment">// Host max capacity.</span></span><br><span class="line"></span><br><span class="line">      i.remove();</span><br><span class="line">      <span class="comment">// 相同的host + 1</span></span><br><span class="line">      asyncCall.callsPerHost().incrementAndGet();</span><br><span class="line">      executableCalls.add(asyncCall);</span><br><span class="line">      <span class="comment">// 添加到正在执行的任务</span></span><br><span class="line">      runningAsyncCalls.add(asyncCall);</span><br><span class="line">    &#125;</span><br><span class="line">    isRunning = runningCallsCount() &gt; <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// 开始执行请求</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = executableCalls.size(); i &lt; size; i++) &#123;</span><br><span class="line">    AsyncCall asyncCall = executableCalls.get(i);</span><br><span class="line">    <span class="comment">// asyncCall#executeOn 方法执行</span></span><br><span class="line">    asyncCall.executeOn(executorService());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> isRunning;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3、AsyncCall-executeOn"><a href="#2-3、AsyncCall-executeOn" class="headerlink" title="2.3、AsyncCall#executeOn"></a>2.3、AsyncCall#executeOn</h2><p><code>AsyncCall</code>继承自<code>NamedRunnable</code>，<code>AsyncCall#executeOn</code>执行时，先调用到<code>NamedRunnable#run</code>，最终执行到<code>AsyncCall#execute</code>方法，再调用到<code>getResponseWithInterceptorChain</code>，所以同步和异步请求的底层逻辑是一致的，区别在于一个执行在调用方法的线程，一个执行在线程池中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncCall</span> <span class="keyword">extends</span> <span class="title">NamedRunnable</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//host</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> AtomicInteger callsPerHost = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">executeOn</span><span class="params">(ExecutorService executorService)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">assert</span> (!Thread.holdsLock(client.dispatcher()));</span><br><span class="line">      <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.执行NamedRunnable#run方法</span></span><br><span class="line">        executorService.execute(<span class="keyword">this</span>);</span><br><span class="line">        success = <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">				<span class="comment">//...</span></span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">          <span class="comment">// 1.结束任务</span></span><br><span class="line">          client.dispatcher().finished(<span class="keyword">this</span>); <span class="comment">// This call is no longer running!</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> signalledCallback = <span class="keyword">false</span>;</span><br><span class="line">      transmitter.timeoutEnter();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">// 核心调用，同步请求的入口</span></span><br><span class="line">        Response response = getResponseWithInterceptorChain();</span><br><span class="line">        signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">        responseCallback.onResponse(RealCall.<span class="keyword">this</span>, response);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 回收</span></span><br><span class="line">        client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NamedRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NamedRunnable</span><span class="params">(String format, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = Util.format(format, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String oldName = Thread.currentThread().getName();</span><br><span class="line">    Thread.currentThread().setName(name);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 执行execute方法</span></span><br><span class="line">      execute();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      Thread.currentThread().setName(oldName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// 由AsyncCall 实现</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4、Dispatcher-finished"><a href="#2-4、Dispatcher-finished" class="headerlink" title="2.4、Dispatcher#finished"></a>2.4、Dispatcher#finished</h2><p>异步请求每次执行完成，都会调用到<code>finished </code>方法，主要作用是：</p>
<ol>
<li>拉起下一个请求</li>
<li>执行idleCallback任务</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">  call.callsPerHost().decrementAndGet();</span><br><span class="line">  finished(runningAsyncCalls, call);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(RealCall call)</span> </span>&#123;</span><br><span class="line">  finished(runningSyncCalls, call);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(Deque&lt;T&gt; calls, T call)</span> </span>&#123;</span><br><span class="line">  Runnable idleCallback;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">&quot;Call wasn&#x27;t in-flight!&quot;</span>);</span><br><span class="line">    idleCallback = <span class="keyword">this</span>.idleCallback;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// 1.从队列中找到下一个要执行的请求</span></span><br><span class="line">  <span class="keyword">boolean</span> isRunning = promoteAndExecute();</span><br><span class="line">	<span class="comment">// 2.执行idleCallback任务</span></span><br><span class="line">  <span class="keyword">if</span> (!isRunning &amp;&amp; idleCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">    idleCallback.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-6、host限制"><a href="#2-6、host限制" class="headerlink" title="2.6、host限制"></a>2.6、host限制</h2><p>相同host 并行的请求数不超过5个，我们看下具体的逻辑是怎么实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    readyAsyncCalls.add(call);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!call.get().forWebSocket) &#123;</span><br><span class="line">      <span class="comment">// </span></span><br><span class="line">      AsyncCall existingCall = findExistingCallWithHost(call.host());</span><br><span class="line">      <span class="keyword">if</span> (existingCall != <span class="keyword">null</span>) call.reuseCallsPerHostFrom(existingCall);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  promoteAndExecute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// findExistingCallWithHost</span></span><br><span class="line"><span class="meta">@Nullable</span> <span class="function"><span class="keyword">private</span> AsyncCall <span class="title">findExistingCallWithHost</span><span class="params">(String host)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 遍历正在运行的 队列是否存在相同的host</span></span><br><span class="line">  <span class="keyword">for</span> (AsyncCall existingCall : runningAsyncCalls) &#123;</span><br><span class="line">    <span class="keyword">if</span> (existingCall.host().equals(host)) <span class="keyword">return</span> existingCall;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历等待请求的 队列是否存在相同的host</span></span><br><span class="line">  <span class="keyword">for</span> (AsyncCall existingCall : readyAsyncCalls) &#123;</span><br><span class="line">    <span class="keyword">if</span> (existingCall.host().equals(host)) <span class="keyword">return</span> existingCall;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AsyncCall#reuseCallsPerHostFrom</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reuseCallsPerHostFrom</span><span class="params">(AsyncCall other)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.callsPerHost = other.callsPerHost;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">promoteAndExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  List&lt;AsyncCall&gt; executableCalls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">boolean</span> isRunning;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">// 遍历reaayAsyncCall 集合</span></span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">      AsyncCall asyncCall = i.next();</span><br><span class="line">		</span><br><span class="line">      <span class="comment">// 相同host 的请求超过阈值，contine</span></span><br><span class="line">      <span class="keyword">if</span> (asyncCall.callsPerHost().get() &gt;= maxRequestsPerHost) <span class="keyword">continue</span>; <span class="comment">// Host max capacity.</span></span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 加入到运行队列时，host 计数+1</span></span><br><span class="line">      asyncCall.callsPerHost().incrementAndGet();</span><br><span class="line">      runningAsyncCalls.add(asyncCall);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncCall</span> <span class="keyword">extends</span> <span class="title">NamedRunnable</span> </span>&#123;</span><br><span class="line">  <span class="comment">// host 计数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> AtomicInteger callsPerHost = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>也就是说：</p>
<ol>
<li> 每次异步任务加入到执行时，先判断是不是有相同的host，存在的话，则将存在的host数值赋值给新创建的call；</li>
<li>在每次调用<code>promoteAndExecute</code>执行时对这参数进行判断，如果说大于阈值，则跳过这个任务。</li>
</ol>
<p>到此，同步和异步请求执行的逻辑基本分析完毕，下面我们看下拦截器具体做了哪些事情吧。</p>
<h1 id="三、拦截器"><a href="#三、拦截器" class="headerlink" title="三、拦截器"></a>三、拦截器</h1><p>拦截器的执行属性是getResponseWithInterceptorChain() 方法中添加的顺序，依次为：</p>
<ul>
<li>client.Interceptors，application 拦截器</li>
<li>RetryAndFollowUpInterceptor：重试和重定向</li>
<li>BridgeInterceptor：request 和 repons</li>
<li>CacheInterceptor：缓存策略</li>
<li>ConnectInterceptor：TCP/IP 连接</li>
<li>client.networkInterceptors：网络拦截器</li>
<li>CallServerInterceptor：</li>
</ul>
<h2 id="3-1、RetryAndFollowUpInterceptor"><a href="#3-1、RetryAndFollowUpInterceptor" class="headerlink" title="3.1、RetryAndFollowUpInterceptor"></a>3.1、RetryAndFollowUpInterceptor</h2><p><strong>重试和重定向拦截器</strong></p>
<p><code>RetryAndFollowUpInterceptor</code>开启了一个while(true)的循环，并在循环内部完成两个重要的判定：</p>
<ol>
<li><strong>当请求内部抛出异常时，判定是否需要重试</strong></li>
<li><strong>当响应结果是3xx重定向时，构建新的请求并发送请求</strong></li>
</ol>
<img src="/pics/image-20200605154411274.png" alt="image-20200605154411274" style="zoom:70%;" />

<p>Route或IO异常时重试的逻辑相对复杂，有如下的判定逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">recover</span><span class="params">(IOException e, Transmitter transmitter,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">boolean</span> requestSendStarted, Request userRequest)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// The application layer has forbidden retries.</span></span><br><span class="line">  <span class="keyword">if</span> (!client.retryOnConnectionFailure()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We can&#x27;t send the request body again.</span></span><br><span class="line">  <span class="keyword">if</span> (requestSendStarted &amp;&amp; requestIsOneShot(e, userRequest)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This exception is fatal.</span></span><br><span class="line">  <span class="keyword">if</span> (!isRecoverable(e, requestSendStarted)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// No more routes to attempt.</span></span><br><span class="line">  <span class="keyword">if</span> (!transmitter.canRetry()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For failure recovery, use the same route selector with a new connection.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>client的retryOnConnectionFailure参数设置为false，不进行重试</li>
<li>请求的body已经发出，不进行重试</li>
<li>特殊的异常类型不进行重试（如ProtocolException，SSLHandshakeException等）</li>
<li>没有更多的route（包含proxy和inetaddress），不进行重试。</li>
</ol>
<h2 id="3-2、BridgeInterceptor"><a href="#3-2、BridgeInterceptor" class="headerlink" title="3.2、BridgeInterceptor"></a>3.2、BridgeInterceptor</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  Request userRequest = chain.request();</span><br><span class="line">  Request.Builder requestBuilder = userRequest.newBuilder();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.请求header中添加必要的信息</span></span><br><span class="line">  RequestBody body = userRequest.body();</span><br><span class="line">  <span class="keyword">if</span> (body != <span class="keyword">null</span>) &#123;</span><br><span class="line">    MediaType contentType = body.contentType();</span><br><span class="line">    <span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">&quot;Content-Type&quot;</span>, contentType.toString());</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">long</span> contentLength = body.contentLength();</span><br><span class="line">    <span class="keyword">if</span> (contentLength != -<span class="number">1</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">&quot;Content-Length&quot;</span>, Long.toString(contentLength));</span><br><span class="line">      requestBuilder.removeHeader(<span class="string">&quot;Transfer-Encoding&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">&quot;Transfer-Encoding&quot;</span>, <span class="string">&quot;chunked&quot;</span>);</span><br><span class="line">      requestBuilder.removeHeader(<span class="string">&quot;Content-Length&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (userRequest.header(<span class="string">&quot;Host&quot;</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">    requestBuilder.header(<span class="string">&quot;Host&quot;</span>, hostHeader(userRequest.url(), <span class="keyword">false</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (userRequest.header(<span class="string">&quot;Connection&quot;</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">    requestBuilder.header(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;Keep-Alive&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.是否支持GZIP的判断</span></span><br><span class="line">  <span class="keyword">boolean</span> transparentGzip = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (userRequest.header(<span class="string">&quot;Accept-Encoding&quot;</span>) == <span class="keyword">null</span> &amp;&amp; userRequest.header(<span class="string">&quot;Range&quot;</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">    transparentGzip = <span class="keyword">true</span>;</span><br><span class="line">    requestBuilder.header(<span class="string">&quot;Accept-Encoding&quot;</span>, <span class="string">&quot;gzip&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 3.添加cookie</span></span><br><span class="line">  List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());</span><br><span class="line">  <span class="keyword">if</span> (!cookies.isEmpty()) &#123;</span><br><span class="line">    requestBuilder.header(<span class="string">&quot;Cookie&quot;</span>, cookieHeader(cookies));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (userRequest.header(<span class="string">&quot;User-Agent&quot;</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">    requestBuilder.header(<span class="string">&quot;User-Agent&quot;</span>, Version.userAgent());</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// 4.执行请求</span></span><br><span class="line">  Response networkResponse = chain.proceed(requestBuilder.build());</span><br><span class="line">	<span class="comment">// 5.response 解析为cookie</span></span><br><span class="line">  HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());</span><br><span class="line"></span><br><span class="line">  Response.Builder responseBuilder = networkResponse.newBuilder()</span><br><span class="line">      .request(userRequest);</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// 6.response GZIP 处理</span></span><br><span class="line">  <span class="keyword">if</span> (transparentGzip</span><br><span class="line">      &amp;&amp; <span class="string">&quot;gzip&quot;</span>.equalsIgnoreCase(networkResponse.header(<span class="string">&quot;Content-Encoding&quot;</span>))</span><br><span class="line">      &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;</span><br><span class="line">    <span class="comment">// 将response 转化为Gzip 流</span></span><br><span class="line">    GzipSource responseBody = <span class="keyword">new</span> GzipSource(networkResponse.body().source());</span><br><span class="line">    Headers strippedHeaders = networkResponse.headers().newBuilder()</span><br><span class="line">        .removeAll(<span class="string">&quot;Content-Encoding&quot;</span>)</span><br><span class="line">        .removeAll(<span class="string">&quot;Content-Length&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">    responseBuilder.headers(strippedHeaders);</span><br><span class="line">    String contentType = networkResponse.header(<span class="string">&quot;Content-Type&quot;</span>);</span><br><span class="line">    responseBuilder.body(<span class="keyword">new</span> RealResponseBody(contentType, -<span class="number">1L</span>, Okio.buffer(responseBody)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> responseBuilder.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>发起请求时为Requsest设置必要的Header属性</li>
<li>服务器响应返回后，若请求时设置了gzip压缩，则在接收内容后进行解压。</li>
<li>cookie操作，请求时添加，响应返回后保存。</li>
</ol>
<p><img src="/pics/image-20200721100439562.png" alt="image-20200721100439562"></p>
<p>最佳实践：</p>
<p>通过自定义拦截器将请求的公共参数比如 客户端端包名，用户标志等等。</p>
<ul>
<li>统一管理，统一维护；</li>
<li>对于异步请求，拦截器运行都是在线程里的，降低参数获取可能的的耗时操作</li>
</ul>
<h2 id="3-3、CacheInterceptor"><a href="#3-3、CacheInterceptor" class="headerlink" title="3.3、CacheInterceptor"></a>3.3、CacheInterceptor</h2><p><strong>负责缓存数据的读取、解析和更新。</strong></p>
<h3 id="3-3-1、处理流程"><a href="#3-3-1、处理流程" class="headerlink" title="3.3.1、处理流程"></a>3.3.1、处理流程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// 1.获取缓存数据 Response，cache 内部使用的是DiskLruCache</span></span><br><span class="line">  Response cacheCandidate = cache != <span class="keyword">null</span></span><br><span class="line">      ? cache.get(chain.request())</span><br><span class="line">      : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">	<span class="comment">// 2.创建strategy缓存策略</span></span><br><span class="line">  <span class="comment">// 如果 strategy.requestworkRequest == null, 表示不再使用网络请求，可能是只使用缓存数据亦或是</span></span><br><span class="line">  <span class="comment">// 如果 strategy.cacheResponse == null，说明没有缓存数据</span></span><br><span class="line">  CacheStrategy strategy = <span class="keyword">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class="line">  Request networkRequest = strategy.networkRequest;</span><br><span class="line">  Response cacheResponse = strategy.cacheResponse;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">    cache.trackResponse(strategy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cacheCandidate != <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">    closeQuietly(cacheCandidate.body()); <span class="comment">// The cache candidate wasn&#x27;t applicable. Close it.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we&#x27;re forbidden from using the network and the cache is insufficient, fail</span></span><br><span class="line">  <span class="comment">// 3.仅使用缓存数据 且 缓存数据不存在，返回504</span></span><br><span class="line">  <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Response.Builder()</span><br><span class="line">        .request(chain.request())</span><br><span class="line">        .protocol(Protocol.HTTP_1_1)</span><br><span class="line">        .code(<span class="number">504</span>)</span><br><span class="line">        .message(<span class="string">&quot;Unsatisfiable Request (only-if-cached)&quot;</span>)</span><br><span class="line">        .body(Util.EMPTY_RESPONSE)</span><br><span class="line">        .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we don&#x27;t need the network, we&#x27;re done.</span></span><br><span class="line">  <span class="comment">// 4.仅使用缓存数据</span></span><br><span class="line">  <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> cacheResponse.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Response networkResponse = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 5.继续执行请求，执行到下一个拦截器</span></span><br><span class="line">    networkResponse = chain.proceed(networkRequest);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// If we&#x27;re crashing on I/O or otherwise, don&#x27;t leak the cache body.</span></span><br><span class="line">    <span class="keyword">if</span> (networkResponse == <span class="keyword">null</span> &amp;&amp; cacheCandidate != <span class="keyword">null</span>) &#123;</span><br><span class="line">      closeQuietly(cacheCandidate.body());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we have a cache response too, then we&#x27;re doing a conditional get.</span></span><br><span class="line">  <span class="comment">// 6.网络请求结果是 304，表示资源未改变，可以使用缓存</span></span><br><span class="line">  <span class="keyword">if</span> (cacheResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">      Response response = cacheResponse.newBuilder()</span><br><span class="line">          .headers(combine(cacheResponse.headers(), networkResponse.headers()))</span><br><span class="line">          .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</span><br><span class="line">          .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</span><br><span class="line">          .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">          .networkResponse(stripBody(networkResponse))</span><br><span class="line">          .build();</span><br><span class="line">      networkResponse.body().close();</span><br><span class="line"></span><br><span class="line">      cache.trackConditionalCacheHit();</span><br><span class="line">    	<span class="comment">// 7.更新缓存数据</span></span><br><span class="line">      cache.update(cacheResponse, response);</span><br><span class="line">      <span class="keyword">return</span> response;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      closeQuietly(cacheResponse.body());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Response response = networkResponse.newBuilder()</span><br><span class="line">      .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">      .networkResponse(stripBody(networkResponse))</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">      <span class="comment">// 8.保存缓存数据</span></span><br><span class="line">      CacheRequest cacheRequest = cache.put(response);</span><br><span class="line">      <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 9.非get 请求，删除缓存</span></span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cache.remove(networkRequest);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">        <span class="comment">// The cache cannot be written.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下：</p>
<img src="/pics/image-20200721100226478.png" alt="image-20200721100226478.png" style="zoom:70%;" />

<h3 id="3-3-2、缓存策略"><a href="#3-3-2、缓存策略" class="headerlink" title="3.3.2、缓存策略"></a>3.3.2、缓存策略</h3><p>在介绍Okttp的缓存策略逻辑前，需要先补充一些Http头字段中和缓存相关的知识，逻辑对应的就是Http缓存的规则。<a href="https://blog.csdn.net/briblue/article/details/52920531">OKHTTP之缓存配置详解</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Returns a strategy to use assuming the request can use the network. */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> CacheStrategy <span class="title">getCandidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// No cached response.</span></span><br><span class="line">  <span class="keyword">if</span> (cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Drop the cached response if it&#x27;s missing a required handshake.</span></span><br><span class="line">  <span class="keyword">if</span> (request.isHttps() &amp;&amp; cacheResponse.handshake() == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 不可使用缓存</span></span><br><span class="line">  <span class="keyword">if</span> (!isCacheable(cacheResponse, request)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CacheControl 是nocache</span></span><br><span class="line">  CacheControl requestCaching = request.cacheControl();</span><br><span class="line">  <span class="keyword">if</span> (requestCaching.noCache() || hasConditions(request)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  CacheControl responseCaching = cacheResponse.cacheControl();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> ageMillis = cacheResponseAge();</span><br><span class="line">  <span class="keyword">long</span> freshMillis = computeFreshnessLifetime();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (requestCaching.maxAgeSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">    freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> minFreshMillis = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (requestCaching.minFreshSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">    minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> maxStaleMillis = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (!responseCaching.mustRevalidate() &amp;&amp; requestCaching.maxStaleSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">    maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!responseCaching.noCache() &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123;</span><br><span class="line">    Response.Builder builder = cacheResponse.newBuilder();</span><br><span class="line">    <span class="keyword">if</span> (ageMillis + minFreshMillis &gt;= freshMillis) &#123;</span><br><span class="line">      builder.addHeader(<span class="string">&quot;Warning&quot;</span>, <span class="string">&quot;110 HttpURLConnection \&quot;Response is stale\&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> oneDayMillis = <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span>;</span><br><span class="line">    <span class="keyword">if</span> (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123;</span><br><span class="line">      builder.addHeader(<span class="string">&quot;Warning&quot;</span>, <span class="string">&quot;113 HttpURLConnection \&quot;Heuristic expiration\&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(<span class="keyword">null</span>, builder.build());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find a condition to add to the request. If the condition is satisfied, the response body</span></span><br><span class="line">  <span class="comment">// will not be transmitted.</span></span><br><span class="line">  String conditionName;</span><br><span class="line">  String conditionValue;</span><br><span class="line">  <span class="keyword">if</span> (etag != <span class="keyword">null</span>) &#123;</span><br><span class="line">    conditionName = <span class="string">&quot;If-None-Match&quot;</span>;</span><br><span class="line">    conditionValue = etag;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastModified != <span class="keyword">null</span>) &#123;</span><br><span class="line">    conditionName = <span class="string">&quot;If-Modified-Since&quot;</span>;</span><br><span class="line">    conditionValue = lastModifiedString;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (servedDate != <span class="keyword">null</span>) &#123;</span><br><span class="line">    conditionName = <span class="string">&quot;If-Modified-Since&quot;</span>;</span><br><span class="line">    conditionValue = servedDateString;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>); <span class="comment">// No condition! Make a regular request.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Headers.Builder conditionalRequestHeaders = request.headers().newBuilder();</span><br><span class="line">  Internal.instance.addLenient(conditionalRequestHeaders, conditionName, conditionValue);</span><br><span class="line"></span><br><span class="line">  Request conditionalRequest = request.newBuilder()</span><br><span class="line">      .headers(conditionalRequestHeaders.build())</span><br><span class="line">      .build();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(conditionalRequest, cacheResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-3、缓存数据Cache"><a href="#3-3-3、缓存数据Cache" class="headerlink" title="3.3.3、缓存数据Cache"></a>3.3.3、缓存数据Cache</h3><p>缓存类<code>Cache</code>采用的是DiskLruCache，key是请求的url，一个请求缓存到本地的文件有2个，分别是<code>响应头</code>以及<code>响应内容</code>。</p>
<p><img src="/pics/image-20220220183504948.png" alt="image-20220220183504948"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Cache</span> <span class="keyword">implements</span> <span class="title">Closeable</span>, <span class="title">Flushable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VERSION = <span class="number">201105</span>;</span><br><span class="line">  <span class="comment">// index 0，响应头</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ENTRY_METADATA = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// index 1，响应体</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ENTRY_BODY = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 同一个key,缓存文件数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ENTRY_COUNT = <span class="number">2</span>;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Cache</span><span class="params">(File directory, <span class="keyword">long</span> maxSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(directory, maxSize, FileSystem.SYSTEM);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Cache(File directory, <span class="keyword">long</span> maxSize, FileSystem fileSystem) &#123;</span><br><span class="line">    <span class="keyword">this</span>.cache = DiskLruCache.create(fileSystem, directory, VERSION, ENTRY_COUNT, maxSize);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">Cache(File directory, <span class="keyword">long</span> maxSize, FileSystem fileSystem) &#123;</span><br><span class="line">  <span class="comment">// DISKLrucache</span></span><br><span class="line">  <span class="keyword">this</span>.cache = DiskLruCache.create(fileSystem, directory, VERSION, ENTRY_COUNT, maxSize);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h4 id="1、保存"><a href="#1、保存" class="headerlink" title="1、保存"></a>1、保存</h4><p>方法的入口在<code>CacheInterceptor#intercept</code>中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">if</span> (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">  <span class="comment">// Offer this request to the cache.</span></span><br><span class="line">  CacheRequest cacheRequest = cache.put(response);</span><br><span class="line">  <span class="comment">// 响应体写入在这里</span></span><br><span class="line">  <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>cache#put</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span> <span class="function">CacheRequest <span class="title">put</span><span class="params">(Response response)</span> </span>&#123;</span><br><span class="line">  String requestMethod = response.request().method();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (HttpMethod.invalidatesCache(response.request().method())) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      remove(response.request());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">      <span class="comment">// The cache cannot be written.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 不能缓存GET请求</span></span><br><span class="line">  <span class="keyword">if</span> (!requestMethod.equals(<span class="string">&quot;GET&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// Don&#x27;t cache non-GET responses. We&#x27;re technically allowed to cache</span></span><br><span class="line">    <span class="comment">// HEAD requests and some POST requests, but the complexity of doing</span></span><br><span class="line">    <span class="comment">// so is high and the benefit is low.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (HttpHeaders.hasVaryAll(response)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// 构造Entry 对象</span></span><br><span class="line">  Entry entry = <span class="keyword">new</span> Entry(response);</span><br><span class="line">  DiskLruCache.Editor editor = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// key 是 url</span></span><br><span class="line">    editor = cache.edit(key(response.request().url()));</span><br><span class="line">    <span class="keyword">if</span> (editor == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里主要是写入响应头</span></span><br><span class="line">    entry.writeTo(editor);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheRequestImpl(editor);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    abortQuietly(editor);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CacheRequestImpl(<span class="keyword">final</span> DiskLruCache.Editor editor) &#123;</span><br><span class="line">  <span class="keyword">this</span>.editor = editor;</span><br><span class="line">  <span class="comment">// 用于写入响应体</span></span><br><span class="line">  <span class="keyword">this</span>.cacheOut = editor.newSink(ENTRY_BODY);</span><br><span class="line">  <span class="keyword">this</span>.body = <span class="keyword">new</span> ForwardingSink(cacheOut) &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (Cache.<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (done) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        done = <span class="keyword">true</span>;</span><br><span class="line">        writeSuccessCount++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">super</span>.close();</span><br><span class="line">      editor.commit();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、读取"><a href="#2、读取" class="headerlink" title="2、读取"></a>2、读取</h4><p>读取的入口也在<code>CacheInterceptor#intercept</code>中，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Response cacheCandidate = cache != <span class="keyword">null</span></span><br><span class="line">    ? cache.get(chain.request())</span><br><span class="line">    : <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Nullable</span> <span class="function">Response <span class="title">get</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">  String key = key(request.url());</span><br><span class="line">  DiskLruCache.Snapshot snapshot;</span><br><span class="line">  Entry entry;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    snapshot = cache.get(key);</span><br><span class="line">    <span class="keyword">if</span> (snapshot == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// Give up because the cache cannot be read.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取Entry 对象，读取响应头</span></span><br><span class="line">    entry = <span class="keyword">new</span> Entry(snapshot.getSource(ENTRY_METADATA));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    Util.closeQuietly(snapshot);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2.获取Entry 对象，读取响应体</span></span><br><span class="line">  Response response = entry.response(snapshot);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!entry.matches(request, response)) &#123;</span><br><span class="line">    Util.closeQuietly(response.body());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">// Entry#response</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">response</span><span class="params">(DiskLruCache.Snapshot snapshot)</span> </span>&#123;</span><br><span class="line">  String contentType = responseHeaders.get(<span class="string">&quot;Content-Type&quot;</span>);</span><br><span class="line">  String contentLength = responseHeaders.get(<span class="string">&quot;Content-Length&quot;</span>);</span><br><span class="line">  Request cacheRequest = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(url)</span><br><span class="line">      .method(requestMethod, <span class="keyword">null</span>)</span><br><span class="line">      .headers(varyHeaders)</span><br><span class="line">      .build();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Response.Builder()</span><br><span class="line">      .request(cacheRequest)</span><br><span class="line">      .protocol(protocol)</span><br><span class="line">      .code(code)</span><br><span class="line">      .message(message)</span><br><span class="line">      .headers(responseHeaders)</span><br><span class="line">       <span class="comment">// 读取缓存数据的响应体</span></span><br><span class="line">      .body(<span class="keyword">new</span> CacheResponseBody(snapshot, contentType, contentLength))</span><br><span class="line">      .handshake(handshake)</span><br><span class="line">      .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">      .receivedResponseAtMillis(receivedResponseMillis)</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CacheResponseBody(<span class="keyword">final</span> DiskLruCache.Snapshot snapshot,</span><br><span class="line">    String contentType, String contentLength) &#123;</span><br><span class="line">  <span class="keyword">this</span>.snapshot = snapshot;</span><br><span class="line">  <span class="keyword">this</span>.contentType = contentType;</span><br><span class="line">  <span class="keyword">this</span>.contentLength = contentLength;</span><br><span class="line">	<span class="comment">// 读取缓存数据的响应体</span></span><br><span class="line">  Source source = snapshot.getSource(ENTRY_BODY);</span><br><span class="line">  bodySource = Okio.buffer(<span class="keyword">new</span> ForwardingSource(source) &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      snapshot.close();</span><br><span class="line">      <span class="keyword">super</span>.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-4、实践"><a href="#3-4-4、实践" class="headerlink" title="3.4.4、实践"></a>3.4.4、实践</h3><p>OkHttp缓存保存到本地时使用的是DiskLrucache，仅限于<strong>GET请求</strong>才能使用。常见的配置和使用方式有2种分别是okHttp推荐的CacheControl和自定义拦截器的方式。下面先介绍下CahceControl。</p>
<h4 id="1、CacheControl-配置缓存"><a href="#1、CacheControl-配置缓存" class="headerlink" title="1、CacheControl 配置缓存"></a>1、CacheControl 配置缓存</h4><p>可以针对每个请求设置不同的缓存策略：</p>
<ol>
<li><p>网络访问请求的资源是文本信息，如新闻列表，这类信息经常变动，一天更新好几次，它们用的缓存时间应该就很短；</p>
</li>
<li><p>网络访问请求的资源是图片或者视频，它们变动很少，或者是长期不变动，那么它们用的缓存时间就应该很长。</p>
</li>
</ol>
<h5 id="step1、定义缓存文件"><a href="#step1、定义缓存文件" class="headerlink" title="step1、定义缓存文件"></a>step1、定义缓存文件</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MAX_SIZE = <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> File CACHE_FILE = <span class="keyword">new</span> File(AppStoreTestApplication.getInstance().getCacheDir().getAbsolutePath() + <span class="string">&quot;/webCache&quot;</span>);</span><br><span class="line"> OkHttpClient.Builder okHttpClient = <span class="keyword">new</span> OkHttpClient.Builder().cache(<span class="keyword">new</span> Cache(CACHE_FILE, MAX_SIZE));</span><br></pre></td></tr></table></figure>

<h5 id="step2、使用CacheControl-Builder"><a href="#step2、使用CacheControl-Builder" class="headerlink" title="step2、使用CacheControl.Builder"></a>step2、使用CacheControl.Builder</h5><p>CacheControl是针对Request的，所以它可以针对每个请求设置不同的缓存策略。CacheControl.Builder有如下方法可配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">noCache();<span class="comment">//不使用缓存，用网络请求</span></span><br><span class="line">noStore();<span class="comment">//不使用缓存，也不存储缓存</span></span><br><span class="line">onlyIfCached();<span class="comment">//只使用缓存</span></span><br><span class="line">noTransform();<span class="comment">//禁止转码</span></span><br><span class="line">maxAge(<span class="number">10</span>, TimeUnit.MILLISECONDS);<span class="comment">//设置超时时间为10ms。</span></span><br><span class="line">maxStale(<span class="number">10</span>, TimeUnit.SECONDS);<span class="comment">//超时之外的超时时间为10s minFresh(10, TimeUnit.SECONDS);//超时时间为当前时间加上10秒钟</span></span><br></pre></td></tr></table></figure>

<h5 id="step3、创建request并且设置请求策略"><a href="#step3、创建request并且设置请求策略" class="headerlink" title="step3、创建request并且设置请求策略"></a>step3、创建request并且设置请求策略</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CacheControl cacheControl = <span class="keyword">new</span> CacheControl.Builder()</span><br><span class="line">    .maxAge(<span class="number">60</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">    .build();</span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">    .url(url)</span><br><span class="line">    .cacheControl(cacheControl)</span><br><span class="line">    .build();</span><br><span class="line">... 省略请求过程    </span><br></pre></td></tr></table></figure>

<h5 id="step4、强制缓存和禁止缓存"><a href="#step4、强制缓存和禁止缓存" class="headerlink" title="step4、强制缓存和禁止缓存"></a>step4、强制缓存和禁止缓存</h5><p>CacheControl中定义了2个常量分别是FORCE_CACHE – 强制缓存以及FORCE_NETWORK – 禁止缓存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 强制缓存</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> CacheControl FORCE_CACHE = <span class="keyword">new</span> Builder()</span><br><span class="line">      .onlyIfCached()</span><br><span class="line">      .maxStale(Integer.MAX_VALUE, TimeUnit.SECONDS)</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁止缓存</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> CacheControl FORCE_NETWORK = <span class="keyword">new</span> Builder().noCache().build();</span><br></pre></td></tr></table></figure>

<p>禁止缓存还有一种方式就是将maxAge设置为0</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">            .url(url)</span><br><span class="line">            .cacheControl(<span class="keyword">new</span> CacheControl.Builder()</span><br><span class="line">            .maxAge(<span class="number">0</span>, TimeUnit.SECONDS))</span><br><span class="line">            .build();</span><br></pre></td></tr></table></figure>

<h4 id="2、自定义缓存拦截器"><a href="#2、自定义缓存拦截器" class="headerlink" title="2、自定义缓存拦截器"></a>2、自定义缓存拦截器</h4><p>推荐的缓存拦截器只能对GET请求进行拦截，对于其他方式的请求是不支持的，比如Post，还有一种情况就是客户端和服务器没有约定好协议，比如控制缓存的消息头往往是服务端返回的信息中添加的如”Cache-Control:max-age=60”。所以，会有两种情况。</p>
<ol>
<li>客户端和服务端开发能够很好沟通，按照达成一致的协议，服务端按照规定添加缓存相关的消息头。</li>
<li>客户端与服务端的开发根本就不是同一家公司，没有办法也不可能要求服务端按照客户端的意愿进行开发。</li>
</ol>
<p>第一种办法当然很好，只要服务器在返回消息的时候添加好Cache-Control相关的消息便好。</p>
<p>第二种情况，就很麻烦，你真的无法左右别人的行为。怎么办呢？那就需要自定义一个拦截器，为返回Response添加消息头，然后再传递给用户，这样用户拿到的Response就有了我们理想当中的消息头Headers，从而达到控制缓存的意图，正所谓移花接木。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CacheInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Response originResponse = chain.proceed(chain.request());</span><br><span class="line">        <span class="comment">//设置缓存时间为60秒，并移除了pragma消息头，移除它的原因是因为pragma也是控制缓存的一个消息头属性</span></span><br><span class="line">        <span class="keyword">return</span> originResponse.newBuilder().removeHeader(<span class="string">&quot;pragma&quot;</span>)</span><br><span class="line">            .header(<span class="string">&quot;Cache-Control&quot;</span>,<span class="string">&quot;max-age=60&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testCacheInterceptor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//缓存文件夹</span></span><br><span class="line">        File cacheFile = <span class="keyword">new</span> File(getExternalCacheDir().toString(),<span class="string">&quot;cache&quot;</span>);</span><br><span class="line">        <span class="comment">//缓存大小为10M</span></span><br><span class="line">        <span class="keyword">int</span> cacheSize = <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">        <span class="comment">//创建缓存对象</span></span><br><span class="line">        <span class="keyword">final</span> Cache cache = <span class="keyword">new</span> Cache(cacheFile,cacheSize);</span><br><span class="line"></span><br><span class="line">        OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">                .addNetworkInterceptor(<span class="keyword">new</span> CacheInterceptor())</span><br><span class="line">                .cache(cache)</span><br><span class="line">                .build();</span><br><span class="line">         <span class="comment">// Request 中不要去设置禁止缓存，否则缓存就不生效了</span></span><br><span class="line">        Request request = <span class="keyword">new</span> Request.Builder().url(url).build();</span><br><span class="line">        .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4、ConnectInterceptor"><a href="#3-4、ConnectInterceptor" class="headerlink" title="3.4、ConnectInterceptor"></a>3.4、ConnectInterceptor</h2><p><strong>负责了Dns解析和Socket连接。</strong><a href="https://segmentfault.com/a/1190000014044351">https://segmentfault.com/a/1190000014044351</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">  Request request = realChain.request();</span><br><span class="line"> </span><br><span class="line">  Transmitter transmitter = realChain.transmitter();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span></span><br><span class="line">  <span class="keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line">  <span class="comment">// 核心逻辑</span></span><br><span class="line">  Exchange exchange = transmitter.newExchange(chain, doExtensiveHealthChecks);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> realChain.proceed(request, transmitter, exchange);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-1、整体流程"><a href="#3-4-1、整体流程" class="headerlink" title="3.4.1、整体流程"></a>3.4.1、整体流程</h3><p>ConnectInterceptor 的核心方法是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exchange exchange = transmitter.newExchange(chain, doExtensiveHealthChecks);</span><br></pre></td></tr></table></figure>

<img src="/pics/image-20220220195153696.png" alt="image-20220220195153696" style="zoom:33%;" />

<ol>
<li>Transmitter：建立连接的发射器</li>
<li>ExchangeFinder：请求连接获取，请求编解码实例构建</li>
<li>Exchange：传输交换数据实现类</li>
<li>ExchangeCodec：Http连接I/O操作上层封装类</li>
<li>RealConnection：socket连接</li>
</ol>
<p>关键步骤：</p>
<ol>
<li><code>ConnectInterceptor</code>调用<code>Transmitter#newExchange</code></li>
<li><code>Transmitter</code>调用到<code>ExchangeFinder#find</code><ol>
<li><code>ExchangeFinder#findHealthConnection</code>获得<code>RealConnection</code></li>
<li><code>RealConnection#codec</code>方法获得<code>ExchangeCodec</code></li>
<li>构建<code>ExChange</code>，将刚才的<code>ExchangeCodec</code>包含在内</li>
</ol>
</li>
</ol>
<p>最终获取到一个<code>ExChange</code>对象。</p>
<img src="/pics/image-20200701115550146-1593606532491.png" alt="image-20200701115550146.png" style="zoom:70%;" />

<p><code>ExChange</code>这个对象中最重要的2个属性为<code>RealConnection</code>和<code>ExchangeCodec</code>。</p>
<ul>
<li>RealConnection是一个Socket连接的包装类；</li>
<li><code>ExchangeCode</code>是对Request和Response的封装，它有两个实现，一个是<code>Http1ExchangeCodec</code>，一个是<code>Http2Exchangecodec</code>，分别对应的是Http1协议和Http2协议。</li>
</ul>
<p>获取socket和dns过程都是在<code>findConnection</code>方法中。</p>
<h3 id="3-4-2、findConnection"><a href="#3-4-2、findConnection" class="headerlink" title="3.4.2、findConnection"></a>3.4.2、findConnection</h3><p>Dns解析和Socket连接都在findConnection方法中，除此之外，这里还涉及到连接池的复用，总结了一个流程图</p>
<img src="/pics/image-20200721105749245.png" alt="image-20200721105749245.png" style="zoom:70%;" />

<p>findConnection这个方法做了以下几件事：</p>
<ol>
<li>检查当前exchangeFinder所保存的Connection是否满足此次请求</li>
<li>检查当前连接池ConnectionPool中是否满足此次请求的Connection</li>
<li>检查当前RouteSelector列表中，是否还有可用Route(Route是proxy,IP地址的包装类)，如果没有就发起DNS请求</li>
<li><strong>通过DNS获取到新的Route之后</strong>，第二次从ConnectionPool查找有无可复用的Connection，否则就创建新的RealConnection</li>
<li><strong>用RealConnection进行TCP和TLS连接</strong>，连接成功后保存到ConnectionPool</li>
</ol>
<h3 id="3-4-3、DNS连接"><a href="#3-4-3、DNS连接" class="headerlink" title="3.4.3、DNS连接"></a>3.4.3、DNS连接</h3><p>Dns的过程隐藏在了<code>findConnection</code>的Route检查中，整个过程在<code>findConnection</code>方法中写的比较散，可能不是特别好理解，但是只要搞明白了<code>RouteSelector, RouteSelection，Route</code>这三个类的关系，其实就比较容易理解了。</p>
<img src="/pics/image-20200702115824438.png" alt="image-20200702115824438.png" style="zoom:70%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// findConnection Route检查</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">boolean</span> newRouteSelection = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (selectedRoute == <span class="keyword">null</span> &amp;&amp; (routeSelection == <span class="keyword">null</span> || !routeSelection.hasNext())) &#123;</span><br><span class="line">	newRouteSelection = <span class="keyword">true</span>;</span><br><span class="line">	routeSelection = routeSelector.next();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Selection <span class="title">next</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!hasNext()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute the next set of routes to attempt.</span></span><br><span class="line">  List&lt;Route&gt; routes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">while</span> (hasNextProxy()) &#123;</span><br><span class="line">    <span class="comment">// Postponed routes are always tried last. For example, if we have 2 proxies and all the</span></span><br><span class="line">    <span class="comment">// routes for proxy1 should be postponed, we&#x27;ll move to proxy2. Only after we&#x27;ve exhausted</span></span><br><span class="line">    <span class="comment">// all the good routes will we attempt the postponed routes.</span></span><br><span class="line">    Proxy proxy = nextProxy();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = inetSocketAddresses.size(); i &lt; size; i++) &#123;</span><br><span class="line">      Route route = <span class="keyword">new</span> Route(address, proxy, inetSocketAddresses.get(i));</span><br><span class="line">      <span class="keyword">if</span> (routeDatabase.shouldPostpone(route)) &#123;</span><br><span class="line">        postponedRoutes.add(route);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        routes.add(route);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!routes.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (routes.isEmpty()) &#123;</span><br><span class="line">    <span class="comment">// We&#x27;ve exhausted all Proxies so fallback to the postponed routes.</span></span><br><span class="line">    routes.addAll(postponedRoutes);</span><br><span class="line">    postponedRoutes.clear();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Selection(routes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RouteSelector#next</code>方法获取到的是<code>Selection</code>，<code>Selection</code>中封装了一个<code>Route</code>的列表，<code>Route</code>中持有<code>proxy、address和InetSocketAddress</code>，Route中的Proxy和InetSocketAddress（IP地址）是配对的，<strong>同一个Proxy，address会和多个IP配对</strong>。</p>
<p><code>hasNextProxy</code>方法内部会调用到<code>resetNextInetSocketAddress</code>方法 ，然后通过<code>address.dns.lookup</code>获取<code>InetSocketAddress</code>，也就是IP地址。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Prepares the socket addresses to attempt for the current proxy or host. */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resetNextInetSocketAddress</span><span class="params">(Proxy proxy)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// Clear the addresses. Necessary if getAllByName() below throws!</span></span><br><span class="line">  inetSocketAddresses = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  String socketHost;</span><br><span class="line">  <span class="keyword">int</span> socketPort;</span><br><span class="line">  <span class="comment">// 判断代理的类型</span></span><br><span class="line">  <span class="keyword">if</span> (proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.SOCKS) &#123;</span><br><span class="line">    socketHost = address.url().host();</span><br><span class="line">    socketPort = address.url().port();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 得到代理的地址</span></span><br><span class="line">    SocketAddress proxyAddress = proxy.address();</span><br><span class="line">    <span class="keyword">if</span> (!(proxyAddress <span class="keyword">instanceof</span> InetSocketAddress)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">          <span class="string">&quot;Proxy.address() is not an &quot;</span> + <span class="string">&quot;InetSocketAddress: &quot;</span> + proxyAddress.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到代理的地址</span></span><br><span class="line">    InetSocketAddress proxySocketAddress = (InetSocketAddress) proxyAddress;</span><br><span class="line">    socketHost = getHostString(proxySocketAddress);</span><br><span class="line">    socketPort = proxySocketAddress.getPort();</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">//判断端口号是否合合法</span></span><br><span class="line">  <span class="keyword">if</span> (socketPort &lt; <span class="number">1</span> || socketPort &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">&quot;No route to &quot;</span> + socketHost + <span class="string">&quot;:&quot;</span> + socketPort</span><br><span class="line">        + <span class="string">&quot;; port is out of range&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里是关键，如果代理的类型是Socks，不适用DNS</span></span><br><span class="line">  <span class="keyword">if</span> (proxy.type() == Proxy.Type.SOCKS) &#123;</span><br><span class="line">    inetSocketAddresses.add(InetSocketAddress.createUnresolved(socketHost, socketPort));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    eventListener.dnsStart(call, socketHost);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try each address for best behavior in mixed IPv4/IPv6 environments.</span></span><br><span class="line">    List&lt;InetAddress&gt; addresses = address.dns().lookup(socketHost);</span><br><span class="line">    <span class="keyword">if</span> (addresses.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UnknownHostException(address.dns() + <span class="string">&quot; returned no addresses for &quot;</span> + socketHost);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    eventListener.dnsEnd(call, socketHost, addresses);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = addresses.size(); i &lt; size; i++) &#123;</span><br><span class="line">      InetAddress inetAddress = addresses.get(i);</span><br><span class="line">      inetSocketAddresses.add(<span class="keyword">new</span> InetSocketAddress(inetAddress, socketPort));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>37行：IP地址最终是通过address的dns获取到的，而这个dns又是怎么构建的呢？</p>
<p><code>address#dns</code>是<code>transmitter.prepareToConnect</code>时，将内置的<code>client.dns</code>传递进来，而<code>client.dns</code>是<code>OkHttpclient</code>的构建过程中传递进来<code>Dns.System</code>，里面的<code>lookup</code>是通InetAddress.getAllByName 方法获取到对应域名的IP，也就是默认的Dns实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepareToConnect</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 构造ExchangeFinder</span></span><br><span class="line">  <span class="keyword">this</span>.exchangeFinder = <span class="keyword">new</span> ExchangeFinder(<span class="keyword">this</span>, connectionPool, createAddress(request.url()),</span><br><span class="line">      call, eventListener);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Address <span class="title">createAddress</span><span class="params">(HttpUrl url)</span> </span>&#123;</span><br><span class="line">    SSLSocketFactory sslSocketFactory = <span class="keyword">null</span>;</span><br><span class="line">    HostnameVerifier hostnameVerifier = <span class="keyword">null</span>;</span><br><span class="line">    CertificatePinner certificatePinner = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (url.isHttps()) &#123;</span><br><span class="line">      sslSocketFactory = client.sslSocketFactory();</span><br><span class="line">      hostnameVerifier = client.hostnameVerifier();</span><br><span class="line">      certificatePinner = client.certificatePinner();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 此处传入client的dns</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Address(url.host(), url.port(), client.dns(), client.socketFactory(),</span><br><span class="line">        sslSocketFactory, hostnameVerifier, certificatePinner, client.proxyAuthenticator(),</span><br><span class="line">        client.proxy(), client.protocols(), client.connectionSpecs(), client.proxySelector());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>由于默认的LocalDNS 可能出现被劫持，调度不准确的问题，OkHttp的DNS是支持自定义的DNS的。目前比较成熟解决方案是在构建HttpClient时，通过OkHttpBuilder进行设置HttpDns</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> OkHttpClient.Builder().dns(<span class="keyword">new</span> HttpDnsImpl())</span><br></pre></td></tr></table></figure>

<p>关于HTTPDNS，请移步<a href="https://juejin.im/post/5c98482c5188252d9559247e">使用 HTTPDNS 优化 DNS，从原理到 OkHttp 集成</a></p>
<h3 id="3-4-4、Socket连接过程"><a href="#3-4-4、Socket连接过程" class="headerlink" title="3.4.4、Socket连接过程"></a>3.4.4、Socket连接过程</h3><p>上一步中通过Dns获得Connectoin之后，下一步就是建立连接的过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// findConnection 中调用连接</span></span><br><span class="line"><span class="comment">// Do TCP + TLS handshakes. This is a blocking operation.</span></span><br><span class="line">result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,</span><br><span class="line">        connectionRetryEnabled, call, eventListener);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> pingIntervalMillis, <span class="keyword">boolean</span> connectionRetryEnabled, Call call,</span></span></span><br><span class="line"><span class="params"><span class="function">    EventListener eventListener)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// 1. https协议使用了HTTP代理,使用隧道</span></span><br><span class="line">      <span class="keyword">if</span> (route.requiresTunnel()) &#123;</span><br><span class="line">        connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);</span><br><span class="line">        <span class="keyword">if</span> (rawSocket == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// We were unable to connect the tunnel but properly closed down our resources.</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        connectSocket(connectTimeout, readTimeout, call, eventListener);</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">// 2.在建立连接之后要进行握手</span></span><br><span class="line">      establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener);</span><br><span class="line">      eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">   	  <span class="comment">//...</span></span><br><span class="line">      <span class="keyword">if</span> (routeException == <span class="keyword">null</span>) &#123;</span><br><span class="line">        routeException = <span class="keyword">new</span> RouteException(e);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        routeException.addConnectException(e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> routeException;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键的步骤有2步：</p>
<p><strong>1.根据是否需要建立隧道调用不同的方法建立socket连接，<a href="https://juejin.im/post/5d9cc1cff265da5bb86abc8e">深究OKHttp之隧道</a></strong></p>
<p><strong>2.连接后进行握手，establishProtocol 会调用到connectTls方法进行</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">establishProtocol</span><span class="params">(ConnectionSpecSelector connectionSpecSelector,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> pingIntervalMillis, Call call, EventListener eventListener)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (route.address().sslSocketFactory() == <span class="keyword">null</span>) &#123;</span><br><span class="line">   <span class="comment">// 1.非HTTPS，支持HTTP2，优先走HTTP2</span></span><br><span class="line">    <span class="keyword">if</span> (route.address().protocols().contains(Protocol.H2_PRIOR_KNOWLEDGE)) &#123;</span><br><span class="line">      socket = rawSocket;</span><br><span class="line">      protocol = Protocol.H2_PRIOR_KNOWLEDGE;</span><br><span class="line">      startHttp2(pingIntervalMillis);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    socket = rawSocket;</span><br><span class="line">    protocol = Protocol.HTTP_1_1;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  eventListener.secureConnectStart(call);</span><br><span class="line">  <span class="comment">// 2.tls连接</span></span><br><span class="line">  connectTls(connectionSpecSelector);</span><br><span class="line">  eventListener.secureConnectEnd(call, handshake);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (protocol == Protocol.HTTP_2) &#123;</span><br><span class="line">    startHttp2(pingIntervalMillis);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此OkHttp的连接就完成了，关于SSL/TLS握手请移步<a href="https://www.jianshu.com/p/7158568e4867">SSL/TLS 握手过程详解</a>，详细的连接过程见 <a href="https://blog.csdn.net/fengrui_sd/article/details/79004826">okHttp连接流程</a></p>
<p>建立连接后再通过<code>Exchange</code>进行到数据交换。</p>
<h2 id="3-5、CallServerInterceptor"><a href="#3-5、CallServerInterceptor" class="headerlink" title="3.5、CallServerInterceptor"></a>3.5、CallServerInterceptor</h2><p>完成socket连接和tls连接后，就会进行数据交换的过程，可以划分为7个步骤：</p>
<ol>
<li>写请求头</li>
<li>写请求体</li>
<li>完成请求写入</li>
<li>构建响应</li>
<li>读取响应头</li>
<li>读取响应体</li>
<li>返回结果</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">  <span class="comment">// connectinterceptor中构建出的Exchage对象。</span></span><br><span class="line">  Exchange exchange = realChain.exchange();</span><br><span class="line">  Request request = realChain.request();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> sentRequestMillis = System.currentTimeMillis();</span><br><span class="line">	<span class="comment">// 1.写入头部信息</span></span><br><span class="line">  exchange.writeRequestHeaders(request);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> responseHeadersStarted = <span class="keyword">false</span>;</span><br><span class="line">  Response.Builder responseBuilder = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// If there&#x27;s a &quot;Expect: 100-continue&quot; header on the request, wait for a &quot;HTTP/1.1 100</span></span><br><span class="line">    <span class="comment">// Continue&quot; response before transmitting the request body. If we don&#x27;t get that, return</span></span><br><span class="line">    <span class="comment">// what we did get (such as a 4xx response) without ever transmitting the request body.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;100-continue&quot;</span>.equalsIgnoreCase(request.header(<span class="string">&quot;Expect&quot;</span>))) &#123;</span><br><span class="line">      exchange.flushRequest();</span><br><span class="line">      responseHeadersStarted = <span class="keyword">true</span>;</span><br><span class="line">      exchange.responseHeadersStart();</span><br><span class="line">      responseBuilder = exchange.readResponseHeaders(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (request.body().isDuplex()) &#123;</span><br><span class="line">        <span class="comment">// Prepare a duplex body so that the application can send a request body later.</span></span><br><span class="line">         <span class="comment">// 2.写入请求体</span></span><br><span class="line">        exchange.flushRequest();</span><br><span class="line">        BufferedSink bufferedRequestBody = Okio.buffer(</span><br><span class="line">            exchange.createRequestBody(request, <span class="keyword">true</span>));</span><br><span class="line">        request.body().writeTo(bufferedRequestBody);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Write the request body if the &quot;Expect: 100-continue&quot; expectation was met.</span></span><br><span class="line">        BufferedSink bufferedRequestBody = Okio.buffer(</span><br><span class="line">            exchange.createRequestBody(request, <span class="keyword">false</span>));</span><br><span class="line">        request.body().writeTo(bufferedRequestBody);</span><br><span class="line">        bufferedRequestBody.close();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      exchange.noRequestBody();</span><br><span class="line">      <span class="keyword">if</span> (!exchange.connection().isMultiplexed()) &#123;</span><br><span class="line">        <span class="comment">// If the &quot;Expect: 100-continue&quot; expectation wasn&#x27;t met, prevent the HTTP/1 connection</span></span><br><span class="line">        <span class="comment">// from being reused. Otherwise we&#x27;re still obligated to transmit the request body to</span></span><br><span class="line">        <span class="comment">// leave the connection in a consistent state.</span></span><br><span class="line">        exchange.noNewExchangesOnConnection();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    exchange.noRequestBody();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (request.body() == <span class="keyword">null</span> || !request.body().isDuplex()) &#123;</span><br><span class="line">    exchange.finishRequest();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!responseHeadersStarted) &#123;</span><br><span class="line">    exchange.responseHeadersStart();</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 3.读取响应头，写入到创建的ResponseBuilder</span></span><br><span class="line">  <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">    responseBuilder = exchange.readResponseHeaders(<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// 4.创建响应</span></span><br><span class="line">  Response response = responseBuilder</span><br><span class="line">      .request(request)</span><br><span class="line">      .handshake(exchange.connection().handshake())</span><br><span class="line">      .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">      .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> code = response.code();</span><br><span class="line">  <span class="keyword">if</span> (code == <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="comment">// server sent a 100-continue even though we did not request one.</span></span><br><span class="line">    <span class="comment">// try again to read the actual response</span></span><br><span class="line">    <span class="comment">// 响应码为100的情况下，再次读取响应头，重新构建response</span></span><br><span class="line">    response = exchange.readResponseHeaders(<span class="keyword">false</span>)</span><br><span class="line">        .request(request)</span><br><span class="line">        .handshake(exchange.connection().handshake())</span><br><span class="line">        .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    code = response.code();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 5.读取响应头结束</span></span><br><span class="line">  exchange.responseHeadersEnd(response);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</span><br><span class="line">    <span class="comment">// Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span></span><br><span class="line">    response = response.newBuilder()</span><br><span class="line">        .body(Util.EMPTY_RESPONSE)</span><br><span class="line">        .build();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    response = response.newBuilder()</span><br><span class="line">        <span class="comment">// 6.读取响应体</span></span><br><span class="line">        .body(exchange.openResponseBody(response))</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">// 7.返回数据</span></span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上过程会根据不同协议执行实现逻辑区分Http1.x和Http2。</p>
<img src="/pics/image-20220220192933393.png" alt="image-20220220192933393" style="zoom:40%;" />



<h2 id="3-6、ApplicationInterceptor-和-NetWorkInterceptor"><a href="#3-6、ApplicationInterceptor-和-NetWorkInterceptor" class="headerlink" title="3.6、ApplicationInterceptor 和 NetWorkInterceptor"></a>3.6、ApplicationInterceptor 和 NetWorkInterceptor</h2><p>前面提到，在OkHttpClient.Builder的构造方法有两个参数，使用者可以通过addInterceptor 和 addNetworkdInterceptor 添加自定义的拦截器，分析完 RetryAndFollowUpInterceptor 我们就可以知道这两种自动拦截器的区别了。</p>
<p>从前面添加拦截器的顺序可以知道 Interceptors 和 networkInterceptors 刚好一个在 RetryAndFollowUpInterceptor 的前面，一个在后面。</p>
<p>结合前面的责任链调用图可以分析出来，假如一个请求在 RetryAndFollowUpInterceptor 这个拦截器内部重试或者重定向了 N 次，那么其内部嵌套的所有拦截器也会被调用N次，同样 networkInterceptors 自定义的拦截器也会被调用 N 次。而相对的 Interceptors 则一个请求只会调用一次，所以在OkHttp的内部也将其称之为 Application Interceptor。 </p>
<p>另外还需要注意的一点是，在执行完ConnectInterceptor之后，其实添加了自定义的网络拦截器networkInterceptors，按照顺序执行的规定，所有的networkInterceptor执行时，socket连接其实已经建立了，可以通过realChain拿到socket做一些事情了，这也就是为什么称之为network Interceptor的原因。</p>
<h1 id="四、ConnectionPool连接池"><a href="#四、ConnectionPool连接池" class="headerlink" title="四、ConnectionPool连接池"></a>四、ConnectionPool连接池</h1><p>OkHttp通过ConnectionPool来缓存连接<code>RealConnection</code>，内部有一个connections的ArrayDeque对象就是用来保存缓存的连接池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionPool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> RealConnectionPool delegate;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ConnectionPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认空闲连接个数，有效时间5min</span></span><br><span class="line">    <span class="keyword">this</span>(<span class="number">5</span>, <span class="number">5</span>, TimeUnit.MINUTES);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ConnectionPool</span><span class="params">(<span class="keyword">int</span> maxIdleConnections, <span class="keyword">long</span> keepAliveDuration, TimeUnit timeUnit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.delegate = <span class="keyword">new</span> RealConnectionPool(maxIdleConnections, keepAliveDuration, timeUnit);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RealConnectionPool</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealConnectionPool</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 执行清理的线程</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span> <span class="comment">/* corePoolSize */</span>,</span><br><span class="line">      Integer.MAX_VALUE <span class="comment">/* maximumPoolSize */</span>, <span class="number">60L</span> <span class="comment">/* keepAliveTime */</span>, TimeUnit.SECONDS,</span><br><span class="line">      <span class="keyword">new</span> SynchronousQueue&lt;&gt;(), Util.threadFactory(<span class="string">&quot;OkHttp ConnectionPool&quot;</span>, <span class="keyword">true</span>));</span><br><span class="line">	</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxIdleConnections;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> keepAliveDurationNs;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 队列保存空闲连接</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealConnection&gt; connections = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RealConnectionPool</span><span class="params">(<span class="keyword">int</span> maxIdleConnections, <span class="keyword">long</span> keepAliveDuration, TimeUnit timeUnit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.maxIdleConnections = maxIdleConnections;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveDurationNs = timeUnit.toNanos(keepAliveDuration);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-1、连接保存"><a href="#4-1、连接保存" class="headerlink" title="4.1、连接保存"></a>4.1、连接保存</h2><p><code>RealConnectionPool#put</code>，连接保存代码入口是在<code>Exchange#findConnection</code>中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(RealConnection connection)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> (Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line">  <span class="comment">// 1.如果清理线程没有在运行</span></span><br><span class="line">  <span class="keyword">if</span> (!cleanupRunning) &#123;</span><br><span class="line">    cleanupRunning = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 2.执行清理操作</span></span><br><span class="line">    executor.execute(cleanupRunnable);</span><br><span class="line">  &#125;</span><br><span class="line">  connections.add(connection);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable cleanupRunnable = () -&gt; &#123;</span><br><span class="line">  <span class="comment">// 死循环</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">long</span> waitNanos = cleanup(System.nanoTime());</span><br><span class="line">    <span class="comment">// -1 表示清理线程停止执行</span></span><br><span class="line">    <span class="keyword">if</span> (waitNanos == -<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// &gt;0 表示延迟多久执行</span></span><br><span class="line">    <span class="keyword">if</span> (waitNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">long</span> waitMillis = waitNanos / <span class="number">1000000L</span>;</span><br><span class="line">      waitNanos -= (waitMillis * <span class="number">1000000L</span>);</span><br><span class="line">      <span class="keyword">synchronized</span> (RealConnectionPool.<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          RealConnectionPool.<span class="keyword">this</span>.wait(waitMillis, (<span class="keyword">int</span>) waitNanos);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">cleanup</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> inUseConnectionCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> idleConnectionCount = <span class="number">0</span>;</span><br><span class="line">    RealConnection longestIdleConnection = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">long</span> longestIdleDurationNs = Long.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find either a connection to evict, or the time that the next eviction is due.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="comment">// 遍历队列中所有的连接</span></span><br><span class="line">      <span class="keyword">for</span> (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">        RealConnection connection = i.next();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果正在使用中，则跳过，</span></span><br><span class="line">        <span class="comment">// 判断是否正在使用使用的是 弱引用 的方式</span></span><br><span class="line">        <span class="keyword">if</span> (pruneAndGetAllocationCount(connection, now) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          inUseConnectionCount++;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">// 否则说明是空闲线程</span></span><br><span class="line">        idleConnectionCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确定是不是距离距离当前时间最远的连接</span></span><br><span class="line">        <span class="keyword">long</span> idleDurationNs = now - connection.idleAtNanos;</span><br><span class="line">        <span class="keyword">if</span> (idleDurationNs &gt; longestIdleDurationNs) &#123;</span><br><span class="line">          longestIdleDurationNs = idleDurationNs;</span><br><span class="line">          longestIdleConnection = connection;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">			</span><br><span class="line">      <span class="comment">// 如果该连接超过了设定的空闲时间 且 当前空闲连接的数目大于阈值 </span></span><br><span class="line">      <span class="keyword">if</span> (longestIdleDurationNs &gt;= <span class="keyword">this</span>.keepAliveDurationNs</span><br><span class="line">          || idleConnectionCount &gt; <span class="keyword">this</span>.maxIdleConnections) &#123;</span><br><span class="line">        <span class="comment">// 从队列中移除距当前当前时间最远的连接</span></span><br><span class="line">        connections.remove(longestIdleConnection);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (idleConnectionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 下次执行回收的时间间隔</span></span><br><span class="line">        <span class="keyword">return</span> keepAliveDurationNs - longestIdleDurationNs;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inUseConnectionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="comment">// 如果都在使用中，下次回收的时间为 5s后</span></span><br><span class="line">        <span class="keyword">return</span> keepAliveDurationNs;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有任何连接，队列为空，则停止任务</span></span><br><span class="line">        cleanupRunning = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 关闭回收连接的socket</span></span><br><span class="line">    closeQuietly(longestIdleConnection.socket());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>总结下流程：</p>
<ol>
<li>遍历所有连接，查询每个连接的引用数量，如果大于 0，表示连接正在使用，无需清理，执行下一次循环。</li>
<li>如果找到了一个可以被清理的连接，会尝试去寻找闲置时间最久的连接来释放。</li>
<li>如果空闲连接超过 5 个或者 keepalive 时间大于 5 分钟，则将该连接清理。</li>
<li>闲置的连接的数量大于 0，返回该连接的到期时间（等会儿将其清理掉，现在还不是时候）。</li>
<li>全部都是活跃连接，5 分钟后再进行清理。</li>
<li>没有任何连接，跳出循环。</li>
</ol>
<h2 id="4-2、连接获取"><a href="#4-2、连接获取" class="headerlink" title="4.2、连接获取"></a>4.2、连接获取</h2><p>获取的入口在<code>findConnection</code>中，进行了2次调用做了两次复用检查，对应调用的方法是<code>RealConnectionPool#transmitterAcquirePooledConnection</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">transmitterAcquirePooledConnection</span><span class="params">(Address address, Transmitter transmitter,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="meta">@Nullable</span> List&lt;Route&gt; routes, <span class="keyword">boolean</span> requireMultiplexed)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> (Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line">  <span class="comment">// 1.遍历当前队列，获取所有的连接</span></span><br><span class="line">  <span class="keyword">for</span> (RealConnection connection : connections) &#123;</span><br><span class="line">    <span class="comment">// 2.需要复用连接 &amp;&amp; 该连接不支持复用连接（HTTP2） 则该连接不可用</span></span><br><span class="line">    <span class="keyword">if</span> (requireMultiplexed &amp;&amp; !connection.isMultiplexed()) <span class="keyword">continue</span>;</span><br><span class="line">     <span class="comment">// 3.如果该连接可以给对应的 address 分配stream 则返回true</span></span><br><span class="line">    <span class="keyword">if</span> (!connection.isEligible(address, routes)) <span class="keyword">continue</span>;</span><br><span class="line">    transmitter.acquireConnectionNoEvents(connection);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Transmitter#acquireConnectionNoEvents</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquireConnectionNoEvents</span><span class="params">(RealConnection connection)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> (Thread.holdsLock(connectionPool));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.connection != <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">  <span class="keyword">this</span>.connection = connection;</span><br><span class="line">  <span class="comment">// 将 Transmitter 是对象 包装成一个WeakReference 对象放到 RealConntion</span></span><br><span class="line">  <span class="comment">// 这样 Transmitter 就获取到了 connection</span></span><br><span class="line">  connection.transmitters.add(<span class="keyword">new</span> TransmitterReference(<span class="keyword">this</span>, callStackTrace));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealConnection</span> <span class="keyword">extends</span> <span class="title">Http2Connection</span>.<span class="title">Listener</span> <span class="keyword">implements</span> <span class="title">Connection</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 保存 Transmitter 的弱引用，connection 和 Transmitter是一对多的关系。</span></span><br><span class="line">  <span class="comment">// 用来识别 connection 是不是空闲，没有 Transmitter 使用时，就变为了 idleConnection</span></span><br><span class="line">  <span class="keyword">final</span> List&lt;Reference&lt;Transmitter&gt;&gt; transmitters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>OkHttp的整体架构如图:</p>
<ul>
<li>请求构建时使用了<strong>Builder模式</strong>，可配置了<code>OkHttpClient</code>属性和<code>Request</code>属性；</li>
<li>核心的请求过程应用了<strong>职责链模式</strong>，最重要的拦截器分别是负责连接的<code>ConnectInterceptor</code>和负责缓存的<code>CacheInterceptor</code>；</li>
<li>连接过程中采用了连接池复用，避免频繁的请求和断开；</li>
<li>IO传输时使用的是<a href="https://juejin.cn/post/6844904054099804168">Okio</a>提升传输效率。</li>
</ul>
<img src="/pics/image-20200720204713384.png" alt="image-20200720204713384" style="zoom:70%;" />

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://juejin.im/post/5e324e68f265da3e1e0579a8">OkHttp 4源码</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/116777864">OkHttp源码深度解析</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>开源</category>
      </categories>
  </entry>
  <entry>
    <title>open_06_LRUCache原理分析</title>
    <url>/2021/04/21/Notes/Android/02%E5%BC%80%E6%BA%90/open_06_LRUCache%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="open-06-LRUCache原理分析"><a href="#open-06-LRUCache原理分析" class="headerlink" title="open_06_LRUCache原理分析"></a>open_06_LRUCache原理分析</h1><span id="more"></span>

<h2 id="一、原理介绍"><a href="#一、原理介绍" class="headerlink" title="一、原理介绍"></a>一、原理介绍</h2><p>LruCache的核心算法是通过LinkedHashMap实现，注意要将LinkedHashMap的最后一个参数accessOrder设置为true，表示按照访问顺序排列，否则按照插入顺序排序。也就是说，<strong>最近访问的元素排在Map的最后，当需要删除元素时，将会从头部开始删除</strong>。正是这个特性，使得通过LinkedHashMap可以实现LRU算法。关于LinkedHashMap实现的LRU算法，下一篇分析。</p>
<p><img src="/pics/image-20200512180836150.png" alt="image-20200512180836150"></p>
<h2 id="二、LruCache的创建"><a href="#二、LruCache的创建" class="headerlink" title="二、LruCache的创建"></a>二、LruCache的创建</h2><p>LruCache常见的创建方式如下，以缓存Bitmap为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LruCache&lt;String, String&gt; mMemLruCache = <span class="keyword">new</span> LruCache&lt;String, Bitmap&gt;(size)&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">sizeOf</span><span class="params">(String key, Bitmap value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> value.getByteCount();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>创建时的关键参数有2个：</p>
<ul>
<li><p>maxSize ，缓存阈值上限，超过就会触发回收策略。 </p>
</li>
<li><p>sizeOf  计算单个元素的占用空间大小。sizeOf要和maxSize配合起来使用，所有元素占用的空间大小就是sizeOf之和。</p>
</li>
</ul>
<p>​       LRU还有还有一种创建方式，不复写sizeOf方法，使用默认值1，此时maxSize限制的含义就是元素的个数。</p>
<p>总结一下：创建时要保持sizeOf和maxSize的单位是一致的。</p>
<h2 id="三、LruCache的CRUD"><a href="#三、LruCache的CRUD" class="headerlink" title="三、LruCache的CRUD"></a>三、LruCache的CRUD</h2><h3 id="1-put"><a href="#1-put" class="headerlink" title="1.put"></a>1.put</h3><p>put的过程主要有4个：</p>
<ol>
<li><p> size = size + 当前元素占用的空间大小</p>
</li>
<li><p>put to Map，如果有返回值，表示之前的key是有对象的，相当于是更新，那么size 减去原有元素占用的大小</p>
</li>
<li><p>entryRemoved ，移除元素的回调</p>
</li>
<li><p>trimToSize整理元素，put新的元素后导致size超过maxsize</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;key == null || value == null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    V previous;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        putCount++;</span><br><span class="line">        size += safeSizeOf(key, value);</span><br><span class="line">        previous = map.put(key, value);</span><br><span class="line">        <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">            size -= safeSizeOf(key, previous);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">        entryRemoved(<span class="keyword">false</span>, key, previous, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否达到maxSize的时候，若达到则出队</span></span><br><span class="line">    trimToSize(maxSize);</span><br><span class="line">    <span class="keyword">return</span> previous;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-get"><a href="#2-get" class="headerlink" title="2.get"></a>2.get</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;key == null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    V mapValue;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">// 1.从map里取值，若值不为空，直接放回</span></span><br><span class="line">        mapValue = map.get(key);</span><br><span class="line">        <span class="keyword">if</span> (mapValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            hitCount++;</span><br><span class="line">            <span class="keyword">return</span> mapValue;</span><br><span class="line">        &#125;</span><br><span class="line">        missCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Attempt to create a value. This may take a long time, and the map</span></span><br><span class="line"><span class="comment">     * may be different when create() returns. If a conflicting value was</span></span><br><span class="line"><span class="comment">     * added to the map while create() was working, we leave that value in</span></span><br><span class="line"><span class="comment">     * the map and release the created value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="comment">// 2.值如果为空，尝试创建，createdValue这个方法是暴露给调用者使用的，比如一些数据库对象缓存对象，如果为空了，我们可以通过查询数据库再次创建</span></span><br><span class="line">    V createdValue = create(key);</span><br><span class="line">    <span class="keyword">if</span> (createdValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        createCount++;</span><br><span class="line">        <span class="comment">//3.刚创建值putToMap时，若有返回值，那么说明在创建过程中，同一个key有新的对象被put进来，那么要使用最新的对象，即最后put进入的对象。</span></span><br><span class="line">        mapValue = map.put(key, createdValue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mapValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// There was a conflict so undo that last put</span></span><br><span class="line">            <span class="comment">// 3.1 这里不需要再更新size，因为put时size已经被更新过了</span></span><br><span class="line">            map.put(key, mapValue);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 3.2 size += 新创建的元素大小</span></span><br><span class="line">            size += safeSizeOf(key, createdValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 4.1 mapValue != null，说明一定是创建过的，那么对创建的value发送一次移除的回调</span></span><br><span class="line">    <span class="keyword">if</span> (mapValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        entryRemoved(<span class="keyword">false</span>, key, createdValue, mapValue);</span><br><span class="line">        <span class="keyword">return</span> mapValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 4.2 如果put的是新创建的值，整理下数据</span></span><br><span class="line">        trimToSize(maxSize);</span><br><span class="line">        <span class="keyword">return</span> createdValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-remove"><a href="#3-remove" class="headerlink" title="3.remove"></a>3.remove</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">remove</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;key == null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    V previous;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    	<span class="comment">// 1. 从hashMap中删除元素</span></span><br><span class="line">        previous = map.remove(key);</span><br><span class="line">        <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 2. size减去移除元素的大小</span></span><br><span class="line">            size -= safeSizeOf(key, previous);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.回调元素被移除</span></span><br><span class="line">    <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">        entryRemoved(<span class="keyword">false</span>, key, previous, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> previous;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-trim"><a href="#4-trim" class="headerlink" title="4.trim"></a>4.trim</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        K key;</span><br><span class="line">        V value;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (size &lt; <span class="number">0</span> || (map.isEmpty() &amp;&amp; size != <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(getClass().getName()</span><br><span class="line">                        + <span class="string">&quot;.sizeOf() is reporting inconsistent results!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">// 1.size &lt; maxSize，break掉</span></span><br><span class="line">            <span class="keyword">if</span> (size &lt;= maxSize) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">// 2.头部元素不为空，map.eldest 指的就是当前第一个元素</span></span><br><span class="line">            Map.Entry&lt;K, V&gt; toEvict = map.eldest();</span><br><span class="line">            <span class="keyword">if</span> (toEvict == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//3.移除第一个元素</span></span><br><span class="line">            key = toEvict.getKey();</span><br><span class="line">            value = toEvict.getValue();</span><br><span class="line">            map.remove(key);</span><br><span class="line">            size -= safeSizeOf(key, value);</span><br><span class="line">            evictionCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.通知元素被移除</span></span><br><span class="line">        entryRemoved(<span class="keyword">true</span>, key, value, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h2><h3 id="1-命中率"><a href="#1-命中率" class="headerlink" title="1.命中率"></a>1.命中率</h3><p>LruCache的toString方法比较有意思，可以初略计算get方法命中率。命中率 = 命中 / 命中 + 丢失</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> putCount; <span class="comment">// put元素个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> createCount; <span class="comment">// 创建的元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> evictionCount; <span class="comment">// trim是被移除的元素，不是所有移除的元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> hitCount; <span class="comment">// get时命中的个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> missCount; <span class="comment">// get时没有命中的元素</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> accesses = hitCount + missCount;</span><br><span class="line">	<span class="keyword">int</span> hitPercent = accesses != <span class="number">0</span> ? (<span class="number">100</span> * hitCount / accesses) : <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> String.format(<span class="string">&quot;LruCache[maxSize=%d,hits=%d,misses=%d,hitRate=%d%%]&quot;</span>,</span><br><span class="line">                maxSize, hitCount, missCount, hitPercent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-entryRemoved"><a href="#2-entryRemoved" class="headerlink" title="2.entryRemoved"></a>2.entryRemoved</h3><p>LruCache通常复写的方法有3个，这里总结下。</p>
<ol>
<li><p>sizeOf ：单个元素占用的空间大小</p>
</li>
<li><p>createValue ：get时创建对象</p>
</li>
<li><p>entryRemoved ：元素被移除时进行回调。</p>
</li>
</ol>
<p>除了这些方法以外，trim这些方法也都是可被复写的，定制性非常强。</p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>LruCache通常用来做内存缓存，比如lmageLoader的三级缓存中，内存缓存内部的封装就是使用了LRUcache。</p>
<p>LruCache通常的封装方式也比较灵活，继承和组合都和使用。</p>
<p>整体看来是一个非常轻量级且定制性极强的框架。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://juejin.im/entry/5a20c1026fb9a0452b490707">Android LruCache源码分析</a></p>
<p><a href="https://blog.csdn.net/qq_25806863/article/details/77548468">LruCache原理和用法与LinkedHashMap</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>开源</category>
      </categories>
  </entry>
  <entry>
    <title>open_05_Retrofit源码解析</title>
    <url>/2021/02/20/Notes/Android/02%E5%BC%80%E6%BA%90/open_05_Retrofit%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="open-05-Retrofit源码分析"><a href="#open-05-Retrofit源码分析" class="headerlink" title="open_05_Retrofit源码分析"></a>open_05_Retrofit源码分析</h1><span id="more"></span>

<h1 id="一、基本用法"><a href="#一、基本用法" class="headerlink" title="一、基本用法"></a>一、基本用法</h1><h2 id="1-1、gradle依赖"><a href="#1-1、gradle依赖" class="headerlink" title="1.1、gradle依赖"></a>1.1、gradle依赖</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;com.squareup.retrofit2:retrofit:2.9.0&#x27;</span></span><br><span class="line">implementation <span class="string">&#x27;com.squareup.retrofit2:converter-gson:2.9.0&#x27;</span></span><br><span class="line"><span class="comment">// 配合RxJava</span></span><br><span class="line">implementation <span class="string">&#x27;com.squareup.retrofit2:adapter-rxjava3:2.9.0&#x27;</span></span><br><span class="line"><span class="comment">// RxAndroid的依赖包</span></span><br><span class="line">implementation <span class="string">&#x27;io.reactivex.rxjava3:rxandroid:3.0.0&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="1-2、定义接口"><a href="#1-2、定义接口" class="headerlink" title="1.2、定义接口"></a>1.2、定义接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GetApi</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Query</span> 注解</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GET(&quot;api/getUserInfo&quot;)</span></span><br><span class="line">    <span class="function">Call&lt;UserInfo&gt; <span class="title">getUserInfo</span><span class="params">(<span class="meta">@Query(&quot;id&quot;)</span> List&lt;String&gt; userId)</span></span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3、创建retrofit发送请求"><a href="#1-3、创建retrofit发送请求" class="headerlink" title="1.3、创建retrofit发送请求"></a>1.3、创建retrofit发送请求</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder().baseUrl(URL1).addConverterFactory(GsonConverterFactory.create()).build();</span><br><span class="line"></span><br><span class="line">GetApi getApi = retrofit.create(GetApi.class);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; params = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">params.add(<span class="string">&quot;1234&quot;</span>);</span><br><span class="line">getApi.getUserInfo(params).enqueue(<span class="keyword">new</span> Callback&lt;UserInfo&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;UserInfo&gt; call, Response&lt;UserInfo&gt; response)</span> </span>&#123;</span><br><span class="line">          String tag = response.raw().request().tag().toString();</span><br><span class="line">          Log.d(TAG, <span class="string">&quot;tag = &quot;</span> + tag);</span><br><span class="line">        UserInfo userInfo = response.body();</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;userinfo = &quot;</span> + userInfo + <span class="string">&quot; thread &quot;</span> +  Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;UserInfo&gt; call, Throwable t)</span> </span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onFailure: &quot;</span> + t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h1 id="二、注解介绍"><a href="#二、注解介绍" class="headerlink" title="二、注解介绍"></a>二、注解介绍</h1><h2 id="2-1、请求方法"><a href="#2-1、请求方法" class="headerlink" title="2.1、请求方法"></a>2.1、请求方法</h2><table>
<thead>
<tr>
<th>注解名</th>
<th>参数说明</th>
</tr>
</thead>
<tbody><tr>
<td>HTTP</td>
<td><strong>method：</strong>表示请求的方法GET POST等；<strong>path ：</strong>表示路径  ；<strong>hasBody：</strong>表示请求体。HTTP注解可以代替以下的所有注解。</td>
</tr>
<tr>
<td>GET</td>
<td>value : 通常表示对应的接口，要和baseUrl结合使用</td>
</tr>
<tr>
<td>POST</td>
<td>同GET</td>
</tr>
<tr>
<td>PUT</td>
<td>同GET</td>
</tr>
<tr>
<td>PATCH</td>
<td>同GET</td>
</tr>
<tr>
<td>DELETE</td>
<td>同GET</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>同GET</td>
</tr>
</tbody></table>
<p><a href="https://itbilu.com/other/relate/EkwKysXIl.html">HTTP请求方法</a></p>
<h2 id="2-2、标记类"><a href="#2-2、标记类" class="headerlink" title="2.2、标记类"></a>2.2、标记类</h2><table>
<thead>
<tr>
<th>注解名</th>
<th>参数</th>
</tr>
</thead>
<tbody><tr>
<td>FormUrlEncoded</td>
<td>用于POST请求，表示请求体是一个Form表单，常见的网址登录就是这种类型，对应的HEAD参数是Content-Type：application/x-www-form-urlencoded，<a href="https://www.runoob.com/http/http-content-type.html">HTTP content-type</a></td>
</tr>
<tr>
<td>Multipart</td>
<td>用于POST请求，表单上传文件时使用</td>
</tr>
<tr>
<td>Streaming</td>
<td>表示响应体的数据使用流的方式返回处理，主要用于文件下载</td>
</tr>
</tbody></table>
<h2 id="2-3、参数类"><a href="#2-3、参数类" class="headerlink" title="2.3、参数类"></a>2.3、参数类</h2><h3 id="2-3-1、注解说明"><a href="#2-3-1、注解说明" class="headerlink" title="2.3.1、注解说明"></a>2.3.1、注解说明</h3><table>
<thead>
<tr>
<th>注解名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Url</td>
<td>参数里带了Url注解的会替换掉baseUrl</td>
</tr>
<tr>
<td>Path</td>
<td>替换Url中的某个路径参数</td>
</tr>
<tr>
<td>Headers</td>
<td>多个请求头，作用于方法，<strong>不可作为参数</strong></td>
</tr>
<tr>
<td>Header</td>
<td>单个请求头</td>
</tr>
<tr>
<td>HeaderMap</td>
<td>多个请求头</td>
</tr>
<tr>
<td>Query</td>
<td>GET请求，请求参数，<strong>支持数组或集合</strong>，例如 Call<UserInfo> getUserInfo(@Query(“id”) String[] userId);</td>
</tr>
<tr>
<td>QueryMap</td>
<td>GET请求，多个同类型请求参数</td>
</tr>
<tr>
<td>Field</td>
<td>Post请求，请求参数，和FormUrlEncoded一起使用，<strong>支持数组或集合</strong></td>
</tr>
<tr>
<td>FieldMap</td>
<td>Post请求，多个同类型请求参数，和FormUrlEncoded一起使用</td>
</tr>
<tr>
<td>Part</td>
<td>文件上传，和注解Multipart一起使用，<strong>支持数组或集合</strong></td>
</tr>
<tr>
<td>PartMap</td>
<td>文件上传，和注解Multipart一起使用</td>
</tr>
<tr>
<td>Body</td>
<td>多个不同类型的参数，使用对象包裹参数，包括文件上传时需要的参数，<strong>不能和FormUrlEncoded及Multipart同时使用</strong></td>
</tr>
<tr>
<td>Tag</td>
<td>给这次请求打个Tag，<a href="https://stackoverflow.com/questions/42066885/retrofit-adding-tag-to-the-original-request-object">https://stackoverflow.com/questions/42066885/retrofit-adding-tag-to-the-original-request-object</a></td>
</tr>
</tbody></table>
<h3 id="2-3-2、文件上传"><a href="#2-3-2、文件上传" class="headerlink" title="2.3.2、文件上传"></a>2.3.2、文件上传</h3><p>通常使用Part和PartMap 配合Multipart使用；还有一种方式直接使用Body实现，此时不能增加Multipart。文件上传这里还是比较复杂的，有时间再仔细讲讲。ln</p>
<p><a href="https://www.jianshu.com/p/74b7da380855">Retrofit学习之文件和参数上传</a></p>
<h1 id="三、Retrofit构建过程"><a href="#三、Retrofit构建过程" class="headerlink" title="三、Retrofit构建过程"></a>三、Retrofit构建过程</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder().baseUrl(URL1).addConverterFactory(GsonConverterFactory.create()).build()</span><br></pre></td></tr></table></figure>

<p>Retrofit中主要的几个对象和作用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Retrofit</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, ServiceMethod&lt;?&gt;&gt; serviceMethodCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(); <span class="comment">//包含所有网络请求信息的对象</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> okhttp3.Call.Factory callFactory; <span class="comment">//网络请求工厂</span></span><br><span class="line">  <span class="keyword">final</span> HttpUrl baseUrl; <span class="comment">//网络请求的url地址</span></span><br><span class="line">  <span class="keyword">final</span> List&lt;Converter.Factory&gt; converterFactories; <span class="comment">//数据转换器工厂的集合</span></span><br><span class="line">  <span class="keyword">final</span> List&lt;CallAdapter.Factory&gt; callAdapterFactories; <span class="comment">//网络请求适配器工厂的集合</span></span><br><span class="line">  <span class="keyword">final</span> <span class="meta">@Nullable</span> Executor callbackExecutor; <span class="comment">//回调方法执行器</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Retrofit使用了Builder模式，通过build方法默认创建的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Retrofit <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (baseUrl == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Base URL required.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  okhttp3.Call.Factory callFactory = <span class="keyword">this</span>.callFactory;</span><br><span class="line">  <span class="keyword">if</span> (callFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 1、callFactory 为 OkHttpClient</span></span><br><span class="line">    callFactory = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Executor callbackExecutor = <span class="keyword">this</span>.callbackExecutor;</span><br><span class="line">  <span class="keyword">if</span> (callbackExecutor == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 2、创建默认回调执行器，paltform = Android</span></span><br><span class="line">    callbackExecutor = platform.defaultCallbackExecutor();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make a defensive copy of the adapters and add the default Call adapter.</span></span><br><span class="line">  <span class="comment">// 3、创建默认请求适配器</span></span><br><span class="line">  List&lt;CallAdapter.Factory&gt; callAdapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.callAdapterFactories);</span><br><span class="line">  callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make a defensive copy of the converters.</span></span><br><span class="line">  <span class="comment">// 4、创建默认的数据解析器</span></span><br><span class="line">  List&lt;Converter.Factory&gt; converterFactories =</span><br><span class="line">      <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">          <span class="number">1</span> + <span class="keyword">this</span>.converterFactories.size() + platform.defaultConverterFactoriesSize());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add the built-in converter factory first. This prevents overriding its behavior but also</span></span><br><span class="line">  <span class="comment">// ensures correct behavior when using converters that consume all types.</span></span><br><span class="line">  converterFactories.add(<span class="keyword">new</span> BuiltInConverters());</span><br><span class="line">  converterFactories.addAll(<span class="keyword">this</span>.converterFactories);</span><br><span class="line">  converterFactories.addAll(platform.defaultConverterFactories());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Retrofit(</span><br><span class="line">      callFactory,</span><br><span class="line">      baseUrl,</span><br><span class="line">      unmodifiableList(converterFactories),</span><br><span class="line">      unmodifiableList(callAdapterFactories),</span><br><span class="line">      callbackExecutor,</span><br><span class="line">      validateEagerly);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-1、请求执行器"><a href="#3-1、请求执行器" class="headerlink" title="3.1、请求执行器"></a>3.1、请求执行器</h2><p>负责真正发送请求，其实就是OkHttpClient</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">callFactory = <span class="keyword">new</span> OkHttpClient();</span><br></pre></td></tr></table></figure>

<h2 id="3-2、请求适配器"><a href="#3-2、请求适配器" class="headerlink" title="3.2、请求适配器"></a>3.2、请求适配器</h2><p><strong>负责请求的执行以及回调结果</strong>，默认添加的请求适配器如下，关于。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;CallAdapter.Factory&gt; callAdapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.callAdapterFactories);</span><br><span class="line">callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor));</span><br></pre></td></tr></table></figure>

<h2 id="3-3、数据转换器"><a href="#3-3、数据转换器" class="headerlink" title="3.3、数据转换器"></a>3.3、数据转换器</h2><p>Converter用于构建数据转换器，主要有2个作用：1、将Response转换成我们需要的返回数据类型；2、将输入的请求参数转换为ResquestBody或String。默认添加的converterFactory如下，关于数据转换器的详细说明，后面再介绍：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Converter.Factory&gt; converterFactories =</span><br><span class="line">    <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">        <span class="number">1</span> + <span class="keyword">this</span>.converterFactories.size() + platform.defaultConverterFactoriesSize());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add the built-in converter factory first. This prevents overriding its behavior but also</span></span><br><span class="line"><span class="comment">// ensures correct behavior when using converters that consume all types.</span></span><br><span class="line">converterFactories.add(<span class="keyword">new</span> BuiltInConverters());</span><br><span class="line">converterFactories.addAll(<span class="keyword">this</span>.converterFactories);</span><br><span class="line">converterFactories.addAll(platform.defaultConverterFactories());</span><br></pre></td></tr></table></figure>

<p>注意一下以上添加的请求适配器和请求转化器都是xxxFactory对象。</p>
<h2 id="3-4、回调执行器"><a href="#3-4、回调执行器" class="headerlink" title="3.4、回调执行器"></a>3.4、回调执行器</h2><p>Executor，用于回调网络请求的执行结果，Android中默认是通过创建一个主线程Handler将结果post出来，对于Retrofit的异步请求来说，回调结果是在主线程中的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Android</span> <span class="keyword">extends</span> <span class="title">Platform</span> </span>&#123;</span><br><span class="line">  Android() &#123;</span><br><span class="line">    <span class="keyword">super</span>(Build.VERSION.SDK_INT &gt;= <span class="number">24</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Executor <span class="title">defaultCallbackExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MainThreadExecutor();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function">Object <span class="title">invokeDefaultMethod</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      Method method, Class&lt;?&gt; declaringClass, Object object, Object... args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="number">26</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(</span><br><span class="line">          <span class="string">&quot;Calling default methods on API 24 and 25 is not supported&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.invokeDefaultMethod(method, declaringClass, object, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MainThreadExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 主线程的Handler</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler handler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line">	<span class="comment">// 结果post到主线程</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">      handler.post(r);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过以上几步，retrofit执行时需要的组件基本都添加完毕了。</p>
<h1 id="四、ServiceMethod创建"><a href="#四、ServiceMethod创建" class="headerlink" title="四、ServiceMethod创建"></a>四、ServiceMethod创建</h1><h2 id="4-1、创建接口代理对象"><a href="#4-1、创建接口代理对象" class="headerlink" title="4.1、创建接口代理对象"></a>4.1、创建接口代理对象</h2><p>Retrofit.create，使用动态代理方式创建接口的代理对象，InvocationHandler中定义了代理的规则，在调用到接口时，解析接口方法的注解参数，生成对应的ServiceMethod对象，并在调用到方法时，执行方法的参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">  validateServiceInterface(service);</span><br><span class="line">  <span class="keyword">return</span> (T)</span><br><span class="line">      Proxy.newProxyInstance(</span><br><span class="line">          service.getClassLoader(),</span><br><span class="line">          <span class="keyword">new</span> Class&lt;?&gt;[] &#123;service&#125;,</span><br><span class="line">          <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> Object[] emptyArgs = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">              <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></span><br><span class="line">              <span class="comment">// 1、Object 类的方法直接调用</span></span><br><span class="line">              <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">                <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">              &#125;</span><br><span class="line">              args = args != <span class="keyword">null</span> ? args : emptyArgs;</span><br><span class="line">              <span class="comment">// 2、平台的默认方法直接调用</span></span><br><span class="line">              <span class="keyword">return</span> platform.isDefaultMethod(method)</span><br><span class="line">                  ? platform.invokeDefaultMethod(method, service, proxy, args)</span><br><span class="line">                  : loadServiceMethod(method).invoke(args);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2、loadServiceMethod"><a href="#4-2、loadServiceMethod" class="headerlink" title="4.2、loadServiceMethod"></a>4.2、loadServiceMethod</h2><p>loadServiceMethod，根据方法的相关注解，生成对应的ServiceMethod对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123;</span><br><span class="line">  <span class="comment">// 1、方法缓存中有直接取缓存</span></span><br><span class="line">  ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);</span><br><span class="line">  <span class="keyword">if</span> (result != <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (serviceMethodCache) &#123;</span><br><span class="line">    result = serviceMethodCache.get(method);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 2、解析注解，生成对应的ServiceMethod</span></span><br><span class="line">      result = ServiceMethod.parseAnnotations(<span class="keyword">this</span>, method);</span><br><span class="line">      serviceMethodCache.put(method, result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>loadService有2个入口，一个是在InvocationHandler中，另一个是在上一步的validateServiceInterface中。</p>
<p>若validateEagerly参数为true，那么在生成接口的动态代理对象时，解析接口中所有的方法，生成ServiceMethod对象；否则只会在调用到具体方法时才生成相关的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateServiceInterface</span><span class="params">(Class&lt;?&gt; service)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 提前初始化</span></span><br><span class="line">  <span class="keyword">if</span> (validateEagerly) &#123;</span><br><span class="line">    Platform platform = Platform.get();</span><br><span class="line">    <span class="comment">// 解析接口中所有的方法，生成ServiceMethod对象</span></span><br><span class="line">    <span class="keyword">for</span> (Method method : service.getDeclaredMethods()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!platform.isDefaultMethod(method) &amp;&amp; !Modifier.isStatic(method.getModifiers())) &#123;</span><br><span class="line">        loadServiceMethod(method);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>parseAnnotations 中主要的方法有2个，作用分别是解析方法注解（包含方法参数注解）以及生成对应的请求适配器和网络数据转换器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">ServiceMethod&lt;T&gt; <span class="title">parseAnnotations</span><span class="params">(Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1、负责解析注解中请求时需要的相关参数</span></span><br><span class="line">    RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);</span><br><span class="line"></span><br><span class="line">    Type returnType = method.getGenericReturnType();</span><br><span class="line">    <span class="keyword">if</span> (Utils.hasUnresolvableType(returnType)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> methodError(</span><br><span class="line">          method,</span><br><span class="line">          <span class="string">&quot;Method return type must not include a type variable or wildcard: %s&quot;</span>,</span><br><span class="line">          returnType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (returnType == <span class="keyword">void</span>.class) &#123;</span><br><span class="line">      <span class="keyword">throw</span> methodError(method, <span class="string">&quot;Service methods cannot return void.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2、生成ServiceMethod对象</span></span><br><span class="line">    <span class="keyword">return</span> HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-1、创建RequestFactory"><a href="#4-2-1、创建RequestFactory" class="headerlink" title="4.2.1、创建RequestFactory"></a>4.2.1、创建RequestFactory</h3><p>RequestFactory，负责构造请求参数。通过解析方法注解和方法中的参数注解生成一个RequestFactory对象，<strong>包含请求设定的参数</strong>。我们先看一下RequestFactory中有哪些对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RequestFactory(Builder builder) &#123;</span><br><span class="line">  method = builder.method;<span class="comment">//要解析的方法</span></span><br><span class="line">  baseUrl = builder.retrofit.baseUrl;<span class="comment">//请求地址</span></span><br><span class="line">  httpMethod = builder.httpMethod;<span class="comment">//请求方式</span></span><br><span class="line">  relativeUrl = builder.relativeUrl;<span class="comment">//相对地址</span></span><br><span class="line">  headers = builder.headers;<span class="comment">//header参数</span></span><br><span class="line">  contentType = builder.contentType;</span><br><span class="line">  hasBody = builder.hasBody;</span><br><span class="line">  isFormEncoded = builder.isFormEncoded;</span><br><span class="line">  isMultipart = builder.isMultipart;</span><br><span class="line">  parameterHandlers = builder.parameterHandlers;<span class="comment">//方法参数解析器</span></span><br><span class="line">  isKotlinSuspendFunction = builder.isKotlinSuspendFunction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到RequestFactory中的对象和接口的方法注解对象（Http协议参数）基本是一一对应的，RequestFactory创建时使用了Builder模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> RequestFactory <span class="title">parseAnnotations</span><span class="params">(Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Builder(retrofit, method).build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">RequestFactory <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1、解析方法中的注解</span></span><br><span class="line">  <span class="keyword">for</span> (Annotation annotation : methodAnnotations) &#123;</span><br><span class="line">    parseMethodAnnotation(annotation);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (httpMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> methodError(method, <span class="string">&quot;HTTP method annotation is required (e.g., @GET, @POST, etc.).&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Body不能和Multipart及FormUrlEncoded同时使用</span></span><br><span class="line">  <span class="keyword">if</span> (!hasBody) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isMultipart) &#123;</span><br><span class="line">      <span class="keyword">throw</span> methodError(</span><br><span class="line">          method,</span><br><span class="line">          <span class="string">&quot;Multipart can only be specified on HTTP methods with request body (e.g., @POST).&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isFormEncoded) &#123;</span><br><span class="line">      <span class="keyword">throw</span> methodError(</span><br><span class="line">          method,</span><br><span class="line">          <span class="string">&quot;FormUrlEncoded can only be specified on HTTP methods with &quot;</span></span><br><span class="line">              + <span class="string">&quot;request body (e.g., @POST).&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2、解析方法中参数的注解</span></span><br><span class="line">  <span class="keyword">int</span> parameterCount = parameterAnnotationsArray.length;</span><br><span class="line">  parameterHandlers = <span class="keyword">new</span> ParameterHandler&lt;?&gt;[parameterCount];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>, lastParameter = parameterCount - <span class="number">1</span>; p &lt; parameterCount; p++) &#123;</span><br><span class="line">    parameterHandlers[p] =</span><br><span class="line">        parseParameter(p, parameterTypes[p], parameterAnnotationsArray[p], p == lastParameter);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3、限制分成2部分的主要原因是，部分注解比如Filed是在参数中的，所以只有解析完参数后才能获取到</span></span><br><span class="line">  <span class="comment">// 规则1：方法注解中的相对路径和方法参数中的绝对路径不能同时为空  </span></span><br><span class="line">  <span class="keyword">if</span> (relativeUrl == <span class="keyword">null</span> &amp;&amp; !gotUrl) &#123;</span><br><span class="line">    <span class="keyword">throw</span> methodError(method, <span class="string">&quot;Missing either @%s URL or @Url parameter.&quot;</span>, httpMethod);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 规则2：参数注解中有body的时候（上传表单数据），方法注解中不能包含 FormEncoded，Multipart，hasbody不能为false，</span></span><br><span class="line">  <span class="comment">// hasbody的规则是通过请求方法来识别的，比如GET是false，POST是true</span></span><br><span class="line">  <span class="keyword">if</span> (!isFormEncoded &amp;&amp; !isMultipart &amp;&amp; !hasBody &amp;&amp; gotBody) &#123;</span><br><span class="line">    <span class="keyword">throw</span> methodError(method, <span class="string">&quot;Non-body HTTP method cannot contain @Body.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 规则3：方法注解中包含FormUrlEncoded时，参数中必须包含至少一个Field注解的参数</span></span><br><span class="line">  <span class="keyword">if</span> (isFormEncoded &amp;&amp; !gotField) &#123;</span><br><span class="line">    <span class="keyword">throw</span> methodError(method, <span class="string">&quot;Form-encoded method must contain at least one @Field.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 规则4：方法注解中包含FormUrlEncoded时，参数中必须包含Part参数</span></span><br><span class="line">  <span class="keyword">if</span> (isMultipart &amp;&amp; !gotPart) &#123;</span><br><span class="line">    <span class="keyword">throw</span> methodError(method, <span class="string">&quot;Multipart method must contain at least one @Part.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RequestFactory(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1、解析方法注解"><a href="#1、解析方法注解" class="headerlink" title="1、解析方法注解"></a>1、解析<strong>方法注解</strong></h4><p>​      parseMethodAnnotation，<strong>解析方法注解</strong>，主要是请求方式，HEADER参数等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseMethodAnnotation</span><span class="params">(Annotation annotation)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1、解析请求方法</span></span><br><span class="line">  <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> DELETE) &#123;</span><br><span class="line">    parseHttpMethodAndPath(<span class="string">&quot;DELETE&quot;</span>, ((DELETE) annotation).value(), <span class="keyword">false</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> GET) &#123;</span><br><span class="line">    parseHttpMethodAndPath(<span class="string">&quot;GET&quot;</span>, ((GET) annotation).value(), <span class="keyword">false</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> HEAD) &#123;</span><br><span class="line">    parseHttpMethodAndPath(<span class="string">&quot;HEAD&quot;</span>, ((HEAD) annotation).value(), <span class="keyword">false</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> PATCH) &#123;</span><br><span class="line">    parseHttpMethodAndPath(<span class="string">&quot;PATCH&quot;</span>, ((PATCH) annotation).value(), <span class="keyword">true</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> POST) &#123;</span><br><span class="line">    parseHttpMethodAndPath(<span class="string">&quot;POST&quot;</span>, ((POST) annotation).value(), <span class="keyword">true</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> PUT) &#123;</span><br><span class="line">    parseHttpMethodAndPath(<span class="string">&quot;PUT&quot;</span>, ((PUT) annotation).value(), <span class="keyword">true</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> OPTIONS) &#123;</span><br><span class="line">    parseHttpMethodAndPath(<span class="string">&quot;OPTIONS&quot;</span>, ((OPTIONS) annotation).value(), <span class="keyword">false</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> HTTP) &#123;</span><br><span class="line">    HTTP http = (HTTP) annotation;</span><br><span class="line">    parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> retrofit2.http.Headers) &#123;</span><br><span class="line">    <span class="comment">// 2、处理HEADER</span></span><br><span class="line">    String[] headersToParse = ((retrofit2.http.Headers) annotation).value();</span><br><span class="line">    <span class="keyword">if</span> (headersToParse.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> methodError(method, <span class="string">&quot;@Headers annotation is empty.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    headers = parseHeaders(headersToParse);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> Multipart) &#123;</span><br><span class="line">    <span class="comment">// 3、限制FormUrlEncoded 和 Multipart 同时使用</span></span><br><span class="line">    <span class="keyword">if</span> (isFormEncoded) &#123;</span><br><span class="line">      <span class="keyword">throw</span> methodError(method, <span class="string">&quot;Only one encoding annotation is allowed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    isMultipart = <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> FormUrlEncoded) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isMultipart) &#123;</span><br><span class="line">      <span class="keyword">throw</span> methodError(method, <span class="string">&quot;Only one encoding annotation is allowed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    isFormEncoded = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseHttpMethodAndPath</span><span class="params">(String httpMethod, String value, <span class="keyword">boolean</span> hasBody)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.httpMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(</span><br><span class="line">            method,</span><br><span class="line">            <span class="string">&quot;Only one HTTP method is allowed. Found: %s and %s.&quot;</span>,</span><br><span class="line">            <span class="keyword">this</span>.httpMethod,</span><br><span class="line">            httpMethod);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 1、请求方法赋值</span></span><br><span class="line">      <span class="keyword">this</span>.httpMethod = httpMethod;</span><br><span class="line">      <span class="keyword">this</span>.hasBody = hasBody;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (value.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">       </span><br><span class="line">      <span class="comment">// 2、url中不能同时出现？和&#123;&#125;占位符</span></span><br><span class="line">      <span class="comment">// Get the relative URL path and existing query string, if present.</span></span><br><span class="line">      <span class="keyword">int</span> question = value.indexOf(<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">      <span class="keyword">if</span> (question != -<span class="number">1</span> &amp;&amp; question &lt; value.length() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// Ensure the query string does not have any named parameters.</span></span><br><span class="line">        String queryParams = value.substring(question + <span class="number">1</span>);</span><br><span class="line">        Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams);</span><br><span class="line">        <span class="keyword">if</span> (queryParamMatcher.find()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> methodError(</span><br><span class="line">              method,</span><br><span class="line">              <span class="string">&quot;URL query string \&quot;%s\&quot; must not have replace block. &quot;</span></span><br><span class="line">                  + <span class="string">&quot;For dynamic query parameters use @Query.&quot;</span>,</span><br><span class="line">              queryParams);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.relativeUrl = value;</span><br><span class="line">      <span class="comment">// 3、解析path的占位符参数，在后面解析到方法参数进行匹配</span></span><br><span class="line">      <span class="keyword">this</span>.relativeUrlParamNames = parsePathParameters(value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、解析方法参数注解"><a href="#2、解析方法参数注解" class="headerlink" title="2、解析方法参数注解"></a>2、解析方法参数注解</h4><p>parseParameterAnnotation, 解析方法参数注解，生成对应的<strong>ParameterHandler</strong>；在执行请求时，通过ParameterHandler将相关参数值转化为请求参数；负责转化请求参数的是converter。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ParameterHandler&lt;?&gt; parseParameterAnnotation(</span><br><span class="line">    <span class="keyword">int</span> p, Type type, Annotation[] annotations, Annotation annotation) &#123;</span><br><span class="line">  <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> Url) &#123;</span><br><span class="line">      <span class="comment">//省略...</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ParameterHandler.RelativeUrl(method, p);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> Path) &#123;</span><br><span class="line">    validateResolvableType(p, type);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ParameterHandler.Path&lt;&gt;(method, p, name, converter, path.encoded());</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> Query) &#123;</span><br><span class="line">    <span class="comment">//...  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ParameterHandler.Query&lt;&gt;(name, converter, encoded).iterable();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// Not a Retrofit annotation.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在看下Query参数<code>ParameterHandler</code>的创建，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 省略... </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> QueryName) &#123;</span><br><span class="line">  validateResolvableType(p, type);</span><br><span class="line">  QueryName query = (QueryName) annotation;</span><br><span class="line">  <span class="keyword">boolean</span> encoded = query.encoded();</span><br><span class="line"></span><br><span class="line">  Class&lt;?&gt; rawParameterType = Utils.getRawType(type);</span><br><span class="line">  gotQueryName = <span class="keyword">true</span>;</span><br><span class="line">  <span class="comment">// 1、集合类型</span></span><br><span class="line">  <span class="keyword">if</span> (Iterable.class.isAssignableFrom(rawParameterType)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(type <span class="keyword">instanceof</span> ParameterizedType)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> parameterError(</span><br><span class="line">          method,</span><br><span class="line">          p,</span><br><span class="line">          rawParameterType.getSimpleName()</span><br><span class="line">              + <span class="string">&quot; must include generic type (e.g., &quot;</span></span><br><span class="line">              + rawParameterType.getSimpleName()</span><br><span class="line">              + <span class="string">&quot;&lt;String&gt;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ParameterizedType parameterizedType = (ParameterizedType) type;</span><br><span class="line">    Type iterableType = Utils.getParameterUpperBound(<span class="number">0</span>, parameterizedType);</span><br><span class="line">    <span class="comment">// String converter</span></span><br><span class="line">    Converter&lt;?, String&gt; converter = retrofit.stringConverter(iterableType, annotations);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ParameterHandler.QueryName&lt;&gt;(converter, encoded).iterable();</span><br><span class="line">    <span class="comment">// 2、数组类型</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rawParameterType.isArray()) &#123;</span><br><span class="line">    Class&lt;?&gt; arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());</span><br><span class="line">    Converter&lt;?, String&gt; converter =</span><br><span class="line">        retrofit.stringConverter(arrayComponentType, annotations);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ParameterHandler.QueryName&lt;&gt;(converter, encoded).array();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 3、其他</span></span><br><span class="line">    Converter&lt;?, String&gt; converter = retrofit.stringConverter(type, annotations);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ParameterHandler.QueryName&lt;&gt;(converter, encoded);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 省略...</span></span><br></pre></td></tr></table></figure>

<p>通过以上源码可以清晰的看到，1、Query参数是支持集合和数组；2、Query参数默认的数据转换器StringConverter，将入参全部装换为String，以字符串的方式拼接到请求里。</p>
<h3 id="4-2-2、创建HttpServiceMethod"><a href="#4-2-2、创建HttpServiceMethod" class="headerlink" title="4.2.2、创建HttpServiceMethod"></a>4.2.2、创建HttpServiceMethod</h3><p>HttpServiceMethod继承了ServiceMethod， parseAnnotations 负责创建请求适配器 、数据转化器 、 请求执行器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;ResponseT, ReturnT&gt; <span class="function">HttpServiceMethod&lt;ResponseT, ReturnT&gt; <span class="title">parseAnnotations</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Retrofit retrofit, Method method, RequestFactory requestFactory)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1.确定接口的返回类型，这个参数很重要</span></span><br><span class="line">  adapterType = method.getGenericReturnType();</span><br><span class="line">  <span class="comment">// 2.根据网络请求接口方法的返回类型和注解类型创建请求适配器</span></span><br><span class="line">  CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter =</span><br><span class="line">      createCallAdapter(retrofit, method, adapterType, annotations);</span><br><span class="line">  Type responseType = callAdapter.responseType();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.根据网络请求接口方法的响应类型从Retrofit对象中获取对应的数据转换器 </span></span><br><span class="line">  Converter&lt;ResponseBody, ResponseT&gt; responseConverter =</span><br><span class="line">      createResponseConverter(retrofit, method, responseType); </span><br><span class="line">  <span class="comment">// 4.执行请求OkHttpClient</span></span><br><span class="line">  okhttp3.Call.Factory callFactory = retrofit.callFactory;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6行：createCallAdapter，默认情况下返回的是初始化时的<strong>DefaultCallAdapterFactory</strong>对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;ResponseT, ReturnT&gt; <span class="function">CallAdapter&lt;ResponseT, ReturnT&gt; <span class="title">createCallAdapter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Retrofit retrofit, Method method, Type returnType, Annotation[] annotations)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//noinspection unchecked</span></span><br><span class="line">    <span class="keyword">return</span> (CallAdapter&lt;ResponseT, ReturnT&gt;) retrofit.callAdapter(returnType, annotations);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">    <span class="keyword">throw</span> methodError(method, e, <span class="string">&quot;Unable to create call adapter for %s&quot;</span>, returnType)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>11行：创建数据解析器，默认情况下使用的是传入的BuiltInConverters。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;ResponseT&gt; <span class="function">Converter&lt;ResponseBody, ResponseT&gt; <span class="title">createResponseConverter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Retrofit retrofit, Method method, Type responseType)</span> </span>&#123;</span><br><span class="line">  Annotation[] annotations = method.getAnnotations();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> retrofit.responseBodyConverter(responseType, annotations);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">    <span class="keyword">throw</span> methodError(method, e, <span class="string">&quot;Unable to create converter for %s&quot;</span>, responseType);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>16行：经过以上几步，我们得到一个CallAdapted对象，这个CallAdapted其实是继承自HttpServiceMethod，CallAdapted.adapt方法会返回一个Call对象，用于执行请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);</span><br></pre></td></tr></table></figure>

<p>可以看到CallAdapted的构造方法中包含了请求过程的需要的所有对象。</p>
<h2 id="4-3、HttpServiceMethod-invoke"><a href="#4-3、HttpServiceMethod-invoke" class="headerlink" title="4.3、HttpServiceMethod.invoke"></a>4.3、HttpServiceMethod.invoke</h2><p>动态代理方法执行时会调用到invoke()方法，看下HttpServiceMethod.invoke的具体实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Adapts an invocation of an interface method into an HTTP call. */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServiceMethod</span>&lt;<span class="title">ResponseT</span>, <span class="title">ReturnT</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceMethod</span>&lt;<span class="title">ReturnT</span>&gt; </span>&#123;  </span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">final</span> <span class="meta">@Nullable</span> <span class="function">ReturnT <span class="title">invoke</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1、传入OkHttpCall对象</span></span><br><span class="line">    Call&lt;ResponseT&gt; call = <span class="keyword">new</span> OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter);</span><br><span class="line">    <span class="keyword">return</span> adapt(call, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CallAdapted</span>&lt;<span class="title">ResponseT</span>, <span class="title">ReturnT</span>&gt; <span class="keyword">extends</span> <span class="title">HttpServiceMethod</span>&lt;<span class="title">ResponseT</span>, <span class="title">ReturnT</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter;</span><br><span class="line"></span><br><span class="line">    CallAdapted(</span><br><span class="line">        RequestFactory requestFactory,</span><br><span class="line">        okhttp3.Call.Factory callFactory,</span><br><span class="line">        Converter&lt;ResponseBody, ResponseT&gt; responseConverter,</span><br><span class="line">        CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter) &#123;</span><br><span class="line">      <span class="keyword">super</span>(requestFactory, callFactory, responseConverter);</span><br><span class="line">      <span class="keyword">this</span>.callAdapter = callAdapter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ReturnT <span class="title">adapt</span><span class="params">(Call&lt;ResponseT&gt; call, Object[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 2、传入OkHttpCall对象</span></span><br><span class="line">      <span class="keyword">return</span> callAdapter.adapt(call);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7-8行：构造OkHttpCall对象，调用adapt方法，最终调用到第26行 callAdapter.adapt，传入的参数是OkHttpCall。这里的callAdapter默认是DefaultCallAdapterFactory，结合3.3节的内容，最终请求执行时调用的是OkHttpCall的方法。</p>
<h1 id="五、请求执行过程"><a href="#五、请求执行过程" class="headerlink" title="五、请求执行过程"></a>五、请求执行过程</h1><p>OkHttpCall是Retrofit中封装的用于执行请求的对象，请求过程就是和OkHttp请求过程基本一致，以同步请求为例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  okhttp3.Call call;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Already executed.&quot;</span>);</span><br><span class="line">    executed = <span class="keyword">true</span>;</span><br><span class="line">	<span class="comment">// 1、创建请求</span></span><br><span class="line">    call = getRawCall();</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">    call.cancel();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2、执行请求并返回结果</span></span><br><span class="line">  <span class="keyword">return</span> parseResponse(call.execute());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-1、创建请求对象"><a href="#5-1、创建请求对象" class="headerlink" title="5.1、创建请求对象"></a>5.1、创建请求对象</h2><p>createRawCall，创建<strong>RealCall</strong> 并利用前面创建的RequestFactory生成具体的request请求参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> okhttp3.<span class="function">Call <span class="title">createRawCall</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">//callFactory是OkHttpClient，callFactory.newCall </span></span><br><span class="line">  okhttp3.Call call = callFactory.newCall(requestFactory.create(args));</span><br><span class="line">  <span class="keyword">if</span> (call == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;Call.Factory returned null.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> call;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RequestFactory.create的核心逻辑是利用ParameterHandler解析方法中请求参数的值，最终返回的是一个OkHttp的<strong>Request</strong>对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">okhttp3.<span class="function">Request <span class="title">create</span><span class="params">(Object[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="comment">// It is an error to invoke a method with the wrong arg types.</span></span><br><span class="line">  ParameterHandler&lt;Object&gt;[] handlers = (ParameterHandler&lt;Object&gt;[]) parameterHandlers;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">int</span> argumentCount = args.length;</span><br><span class="line">    </span><br><span class="line">  RequestBuilder requestBuilder =</span><br><span class="line">      <span class="keyword">new</span> RequestBuilder(</span><br><span class="line">          httpMethod,</span><br><span class="line">          baseUrl,</span><br><span class="line">          relativeUrl,</span><br><span class="line">          headers,</span><br><span class="line">          contentType,</span><br><span class="line">          hasBody,</span><br><span class="line">          isFormEncoded,</span><br><span class="line">          isMultipart);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 1、使用ParameterHandler解析请求参数</span></span><br><span class="line">  List&lt;Object&gt; argumentList = <span class="keyword">new</span> ArrayList&lt;&gt;(argumentCount);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; argumentCount; p++) &#123;</span><br><span class="line">    argumentList.add(args[p]);</span><br><span class="line">    handlers[p].apply(requestBuilder, args[p]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2、返回OkHttpRequest对象</span></span><br><span class="line">  <span class="keyword">return</span> requestBuilder.get().tag(Invocation.class, <span class="keyword">new</span> Invocation(method, argumentList)).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-2、请求执行"><a href="#5-2、请求执行" class="headerlink" title="5.2、请求执行"></a>5.2、请求执行</h2><p>call.execute()，同步请求的执行，这里的call是RealCall，内部的执行其实就是OkHttp的同步请求过程。</p>
<h2 id="5-3、处理请求结果"><a href="#5-3、处理请求结果" class="headerlink" title="5.3、处理请求结果"></a>5.3、处理请求结果</h2><p>处理请求结果，通过responseConverter解析对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Response&lt;T&gt; <span class="title">parseResponse</span><span class="params">(okhttp3.Response rawResponse)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  ResponseBody rawBody = rawResponse.body();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove the body&#x27;s source (the only stateful object) so we can pass the response along.</span></span><br><span class="line">  rawResponse =</span><br><span class="line">      rawResponse</span><br><span class="line">          .newBuilder()</span><br><span class="line">          .body(<span class="keyword">new</span> NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))</span><br><span class="line">          .build();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1、请求失败的处理</span></span><br><span class="line">  <span class="keyword">int</span> code = rawResponse.code();</span><br><span class="line">  <span class="keyword">if</span> (code &lt; <span class="number">200</span> || code &gt;= <span class="number">300</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Buffer the entire body to avoid future I/O.</span></span><br><span class="line">      ResponseBody bufferedBody = Utils.buffer(rawBody);</span><br><span class="line">      <span class="keyword">return</span> Response.error(bufferedBody, rawResponse);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      rawBody.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2、204 205 代表请求成功，但是没有资源可返回</span></span><br><span class="line">  <span class="keyword">if</span> (code == <span class="number">204</span> || code == <span class="number">205</span>) &#123;</span><br><span class="line">    rawBody.close();</span><br><span class="line">    <span class="keyword">return</span> Response.success(<span class="keyword">null</span>, rawResponse);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ExceptionCatchingResponseBody catchingBody = <span class="keyword">new</span> ExceptionCatchingResponseBody(rawBody);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">// 3、请求成功，解析请求返回的数据</span></span><br><span class="line">    T body = responseConverter.convert(catchingBody);</span><br><span class="line">    <span class="keyword">return</span> Response.success(body, rawResponse);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">    <span class="comment">// If the underlying source threw an exception, propagate that rather than indicating it was</span></span><br><span class="line">    <span class="comment">// a runtime exception.</span></span><br><span class="line">    catchingBody.throwIfCaught();</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="六、重要对象解析"><a href="#六、重要对象解析" class="headerlink" title="六、重要对象解析"></a>六、重要对象解析</h1><h2 id="6-1、请求适配器"><a href="#6-1、请求适配器" class="headerlink" title="6.1、请求适配器"></a>6.1、请求适配器</h2><p>请求适配器CallAdapter.Factory，数据转换器涉及到2个类分别是CallAdapter 和 CallAdapter.Factory，看下它的核心方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CallAdapter</span>&lt;<span class="title">R</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回值类型</span></span><br><span class="line">  <span class="function">Type <span class="title">responseType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行请求  </span></span><br><span class="line">  <span class="function">T <span class="title">adapt</span><span class="params">(Call&lt;R&gt; call)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 根据returnType返回相应的CallAdapter</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="meta">@Nullable</span> CallAdapter&lt;?, ?&gt; get(</span><br><span class="line">        Type returnType, Annotation[] annotations, Retrofit retrofit);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-1-1、DefaultCallAdapterFactory"><a href="#6-1-1、DefaultCallAdapterFactory" class="headerlink" title="6.1.1、DefaultCallAdapterFactory"></a>6.1.1、DefaultCallAdapterFactory</h3><p>DefaultCallAdapterFactory是Retrofit默认添加的请求适配器，看下它的源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultCallAdapterFactory</span> <span class="keyword">extends</span> <span class="title">CallAdapter</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> Executor callbackExecutor;</span><br><span class="line"></span><br><span class="line">  DefaultCallAdapterFactory(<span class="meta">@Nullable</span> Executor callbackExecutor) &#123;</span><br><span class="line">    <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="meta">@Nullable</span> CallAdapter&lt;?, ?&gt; get(</span><br><span class="line">      Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">    <span class="keyword">final</span> Type responseType = Utils.getParameterUpperBound(<span class="number">0</span>, (ParameterizedType) returnType);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Executor executor =</span><br><span class="line">        Utils.isAnnotationPresent(annotations, SkipCallbackExecutor.class)</span><br><span class="line">            ? <span class="keyword">null</span></span><br><span class="line">            : callbackExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Type <span class="title">responseType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> responseType;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Call&lt;Object&gt; <span class="title">adapt</span><span class="params">(Call&lt;Object&gt; call)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 执行请求</span></span><br><span class="line">        <span class="keyword">return</span> executor == <span class="keyword">null</span> ? call : <span class="keyword">new</span> ExecutorCallbackCall&lt;&gt;(executor, call);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>26行：<strong>ExecutorCallbackCall，</strong>具体处理请求的执行以及callback回调。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCallbackCall</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Call</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Executor callbackExecutor;</span><br><span class="line">  <span class="keyword">final</span> Call&lt;T&gt; delegate;</span><br><span class="line"></span><br><span class="line">  ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</span><br><span class="line">    <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">    <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(callback, <span class="string">&quot;callback == null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    delegate.enqueue(</span><br><span class="line">        <span class="keyword">new</span> Callback&lt;T&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Response&lt;T&gt; response)</span> </span>&#123;</span><br><span class="line">            callbackExecutor.execute(</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                  <span class="keyword">if</span> (delegate.isCanceled()) &#123;</span><br><span class="line">                    <span class="comment">// Emulate OkHttp&#x27;s behavior of throwing/delivering an IOException on</span></span><br><span class="line">                    <span class="comment">// cancellation.</span></span><br><span class="line">                    callback.onFailure(ExecutorCallbackCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">&quot;Canceled&quot;</span>));</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    callback.onResponse(ExecutorCallbackCall.<span class="keyword">this</span>, response);</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Throwable t)</span> </span>&#123;</span><br><span class="line">            callbackExecutor.execute(() -&gt; callback.onFailure(ExecutorCallbackCall.<span class="keyword">this</span>, t));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> delegate.execute();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ... 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>14行：异步请求的执行，执行的是传入call对象的enqueue方法；</p>
<p>18行/31行：分别是请求成功和失败时，通过回调执行器进行回调；</p>
<p>38行：同步请求的执行，执行的是传入call对象的execute方法。</p>
<p>总结下：<strong>CallAdapter负责请求的执行以及回调结果，通过自定义CallAdapter可以方便处理回调结果。</strong>Retrofit通常都是和RxJava组合使用，利用RxJavaXXXAdapter接口的返回结果改为 Observable对象，这里就不过多介绍了，网上资料很多。</p>
<h2 id="6-2、数据转换器"><a href="#6-2、数据转换器" class="headerlink" title="6.2、数据转换器"></a>6.2、数据转换器</h2><p>数据转换器涉及到2个类分别是Converter 和 Converter.Factory，Converter.Factory是converter的工厂类。常见的Converter如下：</p>
<p><img src="/pics/image-20210119151956195.png" alt="image-20210119151956195"></p>
<p>Converter.Factory 中定义了这2种转换方式的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">F</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="function">T <span class="title">convert</span><span class="params">(F value)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 将ReponseBody转换为对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@Nullable</span> Converter&lt;ResponseBody, ?&gt; responseBodyConverter(</span><br><span class="line">        Type type, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 将对象转换为RequestBody</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@Nullable</span> Converter&lt;?, RequestBody&gt; requestBodyConverter(</span><br><span class="line">        Type type,</span><br><span class="line">        Annotation[] parameterAnnotations,</span><br><span class="line">        Annotation[] methodAnnotations,</span><br><span class="line">        Retrofit retrofit) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将对象转换为String</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@Nullable</span> Converter&lt;?, String&gt; stringConverter(</span><br><span class="line">        Type type, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说一个Retrofit请求通常会有2个converter分别是<strong>RequestBodyConverter</strong>和<strong>ResponseBodyConverter</strong>，顾名思义，一个负责请求数据的转换，一个负责返回数据的转换。</p>
<h3 id="6-2-1、RequestBodyConverter"><a href="#6-2-1、RequestBodyConverter" class="headerlink" title="6.2.1、RequestBodyConverter"></a>6.2.1、RequestBodyConverter</h3><p>先来看下RequestBodyConverter，RequestBodyConverter创建的地方是在解析方法注解生成ParameterHandler时，通过Retrofit.stringConverter生成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Converter&lt;T, String&gt; <span class="title">stringConverter</span><span class="params">(Type type, Annotation[] annotations)</span> </span>&#123;</span><br><span class="line">  Objects.requireNonNull(type, <span class="string">&quot;type == null&quot;</span>);</span><br><span class="line">  Objects.requireNonNull(annotations, <span class="string">&quot;annotations == null&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, count = converterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">    Converter&lt;?, String&gt; converter =</span><br><span class="line">        converterFactories.get(i).stringConverter(type, annotations, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (converter != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//noinspection unchecked</span></span><br><span class="line">      <span class="keyword">return</span> (Converter&lt;T, String&gt;) converter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Nothing matched. Resort to default converter which just calls toString().</span></span><br><span class="line">  <span class="comment">//noinspection unchecked</span></span><br><span class="line">  <span class="keyword">return</span> (Converter&lt;T, String&gt;) BuiltInConverters.ToStringConverter.INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6-8行：遍历所有的converter，根据请求的参数类型，匹配到相应的converter，保底返回的是BuiltInConverters.ToStringConverter，ToStringConverter多用于转换注解 @Header, @HeaderMap, @Path, @Query 和 @QueryMap 标记的参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ToStringConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">Object</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> ToStringConverter INSTANCE = <span class="keyword">new</span> ToStringConverter();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-2、ResponseBodyConverter"><a href="#6-2-2、ResponseBodyConverter" class="headerlink" title="6.2.2、ResponseBodyConverter"></a>6.2.2、ResponseBodyConverter</h3><p>ResponseBodyConverter，是在ServiceMethod解析注解过程中创建的（4.3.2），HttpServiceMethod.createResponseConverter经过一系列的调用，最终调用到的是nextResponseBodyConverter。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Converter&lt;ResponseBody, T&gt; <span class="title">nextResponseBodyConverter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="meta">@Nullable</span> Converter.Factory skipPast, Type type, Annotation[] annotations)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(type, <span class="string">&quot;type == null&quot;</span>);</span><br><span class="line">    Objects.requireNonNull(annotations, <span class="string">&quot;annotations == null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start = converterFactories.indexOf(skipPast) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = converterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">      Converter&lt;ResponseBody, ?&gt; converter =</span><br><span class="line">          converterFactories.get(i).responseBodyConverter(type, annotations, <span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">if</span> (converter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//noinspection unchecked</span></span><br><span class="line">        <span class="keyword">return</span> (Converter&lt;ResponseBody, T&gt;) converter;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>7-12行：根据responseType匹配到对应的converter，这些converter在构造Retrofit时都初始化好了。</p>
<h3 id="6-2-3、BuiltInConverters"><a href="#6-2-3、BuiltInConverters" class="headerlink" title="6.2.3、BuiltInConverters"></a>6.2.3、BuiltInConverters</h3><p>BuiltInConverters是Retrofit中默认提供的转换器，分析下源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BuiltInConverters</span> <span class="keyword">extends</span> <span class="title">Converter</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="meta">@Nullable</span> Converter&lt;ResponseBody, ?&gt; responseBodyConverter(</span><br><span class="line">      Type type, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">  <span class="comment">//方法返回值类型type必须为ResponseBody或者Void，转化后的类型为ResponseBody。</span></span><br><span class="line">  <span class="comment">//返回相应的Converter实例，其他的类型都处理不了，直接返回null</span></span><br><span class="line">    <span class="keyword">if</span> (type == ResponseBody.class) &#123;</span><br><span class="line">      <span class="keyword">return</span> Utils.isAnnotationPresent(annotations, Streaming.class)</span><br><span class="line">          ? StreamingResponseBodyConverter.INSTANCE</span><br><span class="line">          : BufferingResponseBodyConverter.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type == Void.class) &#123;</span><br><span class="line">      <span class="keyword">return</span> VoidResponseBodyConverter.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="meta">@Nullable</span> Converter&lt;?, RequestBody&gt; requestBodyConverter(</span><br><span class="line">      Type type,</span><br><span class="line">      Annotation[] parameterAnnotations,</span><br><span class="line">      Annotation[] methodAnnotations,</span><br><span class="line">      Retrofit retrofit) &#123;</span><br><span class="line">    <span class="comment">// 要求方法的请求参数type必须为RequestBody类型，得到的类型也是RequestBody，没有做任何类型转换，</span></span><br><span class="line">    <span class="comment">// 回相应的Converter实例，其他的类型都处理不了，直接返回null  </span></span><br><span class="line">    <span class="keyword">if</span> (RequestBody.class.isAssignableFrom(Utils.getRawType(type))) &#123;</span><br><span class="line">      <span class="keyword">return</span> RequestBodyConverter.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestBodyConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">RequestBody</span>, <span class="title">RequestBody</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> RequestBodyConverter INSTANCE = <span class="keyword">new</span> RequestBodyConverter();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RequestBody <span class="title">convert</span><span class="params">(RequestBody value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamingResponseBodyConverter</span></span></span><br><span class="line"><span class="class">      <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">ResponseBody</span>, <span class="title">ResponseBody</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> StreamingResponseBodyConverter INSTANCE = <span class="keyword">new</span> StreamingResponseBodyConverter();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseBody <span class="title">convert</span><span class="params">(ResponseBody value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 多用于请求参数转化，结合5.2.1节RequestBodyConverter理解</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ToStringConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">Object</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ToStringConverter INSTANCE = <span class="keyword">new</span> ToStringConverter();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> value.toString();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上源码我们可以解释很多Retrofit2的行为，例如 1：如果不添加自定义Converter，我们在定义方法时方法的入参的类型只能是RequestBody或者String，而返回值的泛型参数类型也只能是RequestBody 或者Void的现象。 2：如果不使用@Stream 注解标识方法，那么下载大文件时会发生OOM的问题，因为其会将返回数据一次性载入内存中。</p>
<p>如果是仅仅使用默认的Converter的话Retrofit2的使用将会受到极大的限制，可以通过自定义converter的方式来满足我们的不同数据转换需求，这也是Retrofit的核心功能之一。</p>
<h2 id="6-3、ParameterHandler详解"><a href="#6-3、ParameterHandler详解" class="headerlink" title="6.3、ParameterHandler详解"></a>6.3、ParameterHandler详解</h2><h3 id="6-3-1、介绍"><a href="#6-3-1、介绍" class="headerlink" title="6.3.1、介绍"></a>6.3.1、介绍</h3><p>ParameterHandler对象是在RequestFactory创建时生成的，参考4.3.1节；在请求Request对象创建过程中，使用ParameterHandler.apply 解析方法参数列表，不同的ParameterHandler负责对应类型参数的解析。主要的ParameterHandler类型有如下几种：</p>
<p><img src="/pics/image-20210119145830519.png" alt="image-20210119145830519"></p>
<h3 id="6-3-2、分析"><a href="#6-3-2、分析" class="headerlink" title="6.3.2、分析"></a>6.3.2、分析</h3><p><code>ParameterHandler</code>是一个抽象类，定义的抽象方法是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(RequestBuilder builder, <span class="meta">@Nullable</span> T value)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<p>此外还有2个方法分别用于解析集合和数组类型参数，通过遍历的方式使用apply解析方法参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ParameterHandler</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 方法参数解析</span></span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(RequestBuilder builder, <span class="meta">@Nullable</span> T value)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 集合类型参数ParameterHandler的解析</span></span><br><span class="line">  <span class="keyword">final</span> ParameterHandler&lt;Iterable&lt;T&gt;&gt; iterable() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ParameterHandler&lt;Iterable&lt;T&gt;&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(RequestBuilder builder, <span class="meta">@Nullable</span> Iterable&lt;T&gt; values)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (values == <span class="keyword">null</span>) <span class="keyword">return</span>; <span class="comment">// Skip null values.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (T value : values) &#123;</span><br><span class="line">          ParameterHandler.<span class="keyword">this</span>.apply(builder, value);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 数组类型多个参数的解析</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> ParameterHandler&lt;Object&gt; <span class="title">array</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ParameterHandler&lt;Object&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(RequestBuilder builder, <span class="meta">@Nullable</span> Object values)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (values == <span class="keyword">null</span>) <span class="keyword">return</span>; <span class="comment">// Skip null values.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = Array.getLength(values); i &lt; size; i++) &#123;</span><br><span class="line">          <span class="comment">//noinspection unchecked</span></span><br><span class="line">          ParameterHandler.<span class="keyword">this</span>.apply(builder, (T) Array.get(values, i));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Header</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ParameterHandler</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Converter&lt;T, String&gt; valueConverter;</span><br><span class="line"></span><br><span class="line">    Header(String name, Converter&lt;T, String&gt; valueConverter) &#123;</span><br><span class="line">      <span class="keyword">this</span>.name = Objects.requireNonNull(name, <span class="string">&quot;name == null&quot;</span>);</span><br><span class="line">      <span class="keyword">this</span>.valueConverter = valueConverter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(RequestBuilder builder, <span class="meta">@Nullable</span> T value)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (value == <span class="keyword">null</span>) <span class="keyword">return</span>; <span class="comment">// Skip null values.</span></span><br><span class="line">      <span class="comment">// 1、使用对应的converter解析注解参数</span></span><br><span class="line">      String headerValue = valueConverter.convert(value);</span><br><span class="line">      <span class="keyword">if</span> (headerValue == <span class="keyword">null</span>) <span class="keyword">return</span>; <span class="comment">// Skip converted but null values.</span></span><br><span class="line">      <span class="comment">// 2、将参数添加到requestBuilder中</span></span><br><span class="line">      builder.addHeader(name, headerValue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>所有类型的ParameterHandler都定义在ParameterHandler中，以Header注解的解析器为例介绍下参数解析过程。</p>
<p>46 - 49 行，解析过程中有2个关键步骤：1、使用Converter解析注解参数；2、将参数添加到RequestBuilder中。</p>
<p>总结一下，<strong>ParameterHandler的作用就是将方法参数值转换为Request中相应的请求参数</strong>。</p>
<h1 id="七、整体框架"><a href="#七、整体框架" class="headerlink" title="七、整体框架"></a>七、整体框架</h1><h2 id="7-1、整体框架"><a href="#7-1、整体框架" class="headerlink" title="7.1、整体框架"></a>7.1、整体框架</h2><p>..<img src="/pics/image-20210125203006574.png" alt="image-20210125203006574"></p>
<h2 id="7-2、接口调用过程"><a href="#7-2、接口调用过程" class="headerlink" title="7.2、接口调用过程"></a>7.2、接口调用过程</h2><p><img src="/pics/image-20210220182532939.png" alt="image-20210220182532939"></p>
<p>参考：</p>
<p><a href="https://segmentfault.com/a/1190000005638577">https://segmentfault.com/a/1190000005638577</a></p>
<p><a href="https://yeungeek.github.io/2019/07/25/Network-Retrofit/#Retrofit%E4%B8%AD%E7%9A%84HTTP%E5%AE%9E%E7%8E%B0">https://yeungeek.github.io/2019/07/25/Network-Retrofit/#Retrofit%E4%B8%AD%E7%9A%84HTTP%E5%AE%9E%E7%8E%B0</a></p>
<p><a href="https://blog.csdn.net/carson_ho/article/details/73732076">https://blog.csdn.net/carson_ho/article/details/73732076</a>)</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>开源</category>
      </categories>
  </entry>
  <entry>
    <title>open_07_DiskLruCache</title>
    <url>/2020/12/07/Notes/Android/02%E5%BC%80%E6%BA%90/open_07_DiskLruCache/</url>
    <content><![CDATA[<h1 id="open-07-DiskLruCache原理分析"><a href="#open-07-DiskLruCache原理分析" class="headerlink" title="open_07_DiskLruCache原理分析"></a>open_07_DiskLruCache原理分析</h1><span id="more"></span>

<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>diskLruCache，顾名思义，支持Lru算法的磁盘缓存。<a href="https://github.com/JakeWharton/DiskLruCache">github地址</a></p>
<h2 id="二、构造方法"><a href="#二、构造方法" class="headerlink" title="二、构造方法"></a>二、构造方法</h2><p>DiskLruCache构造方法需要传入4个参数，含义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">DiskLruCache</span><span class="params">(File directory, <span class="keyword">int</span> appVersion, <span class="keyword">int</span> valueCount, <span class="keyword">long</span> maxSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.directory = directory;</span><br><span class="line">    <span class="keyword">this</span>.appVersion = appVersion;</span><br><span class="line">    <span class="keyword">this</span>.journalFile = <span class="keyword">new</span> File(directory, JOURNAL_FILE);</span><br><span class="line">    <span class="keyword">this</span>.journalFileTmp = <span class="keyword">new</span> File(directory, JOURNAL_FILE_TEMP);</span><br><span class="line">    <span class="keyword">this</span>.journalFileBackup = <span class="keyword">new</span> File(directory, JOURNAL_FILE_BACKUP);</span><br><span class="line">    <span class="keyword">this</span>.valueCount = valueCount;</span><br><span class="line">    <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>directory – 缓存路径</p>
</li>
<li><p>appVersion – 缓存版本</p>
</li>
<li><p>valueCount – 一个key可以对应几个值</p>
</li>
<li><p>maxSize – 缓存文件大小</p>
</li>
<li><p>redundantOpCount – 冗余操作数，避免journal文件过大的限制，冗余操作如果大于2000 &amp;&amp; 大于当前所有的缓存文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">journalRebuildRequired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> redundantOpCompactThreshold = <span class="number">2000</span>;</span><br><span class="line">    <span class="keyword">return</span> redundantOpCount &gt;= redundantOpCompactThreshold </span><br><span class="line">        &amp;&amp; redundantOpCount &gt;= lruEntries.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>journalFile、journalFileTmp、journalFileBackup –  日志文件、临时日志文件、备份日志文件。</p>
<p>DiskLruCache创建时，会自动创建一个journal文件，负责缓存数据的维护，journal文件中会保存DiskLrucache版本以及文件的CRUD操作。</p>
</li>
</ul>
<h2 id="三、lruEntries"><a href="#三、lruEntries" class="headerlink" title="三、lruEntries"></a>三、lruEntries</h2><p>介绍日志文件读取之前，Entry和Editor对象。</p>
<p>Entry对象保存再lruEntries中，lruEntries是一个LinkedHashMap，记录着缓存文件（dirty或clean）的信息，文件名、大小，写入状态等等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LinkedHashMap&lt;String, Entry&gt; lruEntries =</span><br><span class="line">    <span class="keyword">new</span> LinkedHashMap&lt;String, Entry&gt;(<span class="number">0</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>accessOrder = true，LRU算法是通过LinkedHashMap实现的。看一下Entry对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String key; <span class="comment">//文件名，也是lruEntries的key</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Lengths of this entry&#x27;s files.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span>[] lengths; <span class="comment">//文件长度 对应clean记录的最后的数字，通常lengths数组的长度都为1；若同一个key若有多条记录，则大于1。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * True if this entry has ever been published. </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> readable; <span class="comment">//标记是否可读，只有clean的记录才可读</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The ongoing edit or null if this entry is not being edited.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Editor currentEditor; <span class="comment">//正在写入的记录，也用来区分clean和dirty数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The sequence number of the most recently committed edit to this entry.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequenceNumber; <span class="comment">//日志提交的次数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// clean文件名的格式：key+“.”+index</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> File <span class="title">getCleanFile</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> File(directory, key + <span class="string">&quot;.&quot;</span> + i);</span><br><span class="line">   	&#125;</span><br><span class="line">    <span class="comment">// dirty文件名:key+“.”+index + &quot;.tmp&quot;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> File <span class="title">getDirtyFile</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> File(directory, key + <span class="string">&quot;.&quot;</span> + i + <span class="string">&quot;.tmp&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、journal文件"><a href="#四、journal文件" class="headerlink" title="四、journal文件"></a>四、journal文件</h2><p>journal文件格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cat journal</span><br><span class="line">libcore.io.DiskLruCache</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">8960</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line">DIRTY bda205e0e3cec1055dc7a5e91960cab5</span><br><span class="line">CLEAN bda205e0e3cec1055dc7a5e91960cab5 <span class="number">5830</span></span><br><span class="line">READ bda205e0e3cec1055dc7a5e91960cab5</span><br><span class="line">REMOVE bda205e0e3cec1055dc7a5e91960cab5</span><br></pre></td></tr></table></figure>

<h3 id="4-1-文件头部分"><a href="#4-1-文件头部分" class="headerlink" title="4.1 文件头部分"></a>4.1 文件头部分</h3><ul>
<li>第一行是个固定的字符串“libcore.io.DiskLruCache”，标志着我们使用的是DiskLruCache技术。</li>
<li>第二行是DiskLruCache的版本号，这个值是恒为1的。</li>
<li>第三行是应用程序的版本号，我们在open()方法里传入的版本号是什么这里就会显示什么。</li>
<li>第四行是valueCount，一个key可以对应几个值。</li>
<li>第五行是一个空行。</li>
</ul>
<h3 id="4-2-内容部分"><a href="#4-2-内容部分" class="headerlink" title="4.2 内容部分"></a>4.2 内容部分</h3><p>  journal 文件的内容部分记录着缓存文件的操作。</p>
<ul>
<li><p>DIRTY表示写入记录，写入成功后面会紧跟一条clean记录，失败会紧跟一条REMOVE记录。也就是说，每一行DIRTY的key，后面都应该有一行对应的CLEAN或者REMOVE的记录，否则这条数据就是“脏”的，会被自动删除掉。</p>
</li>
<li><p>REMOVE记录除了写入失败的场景，手动调用remove时也会写入一条remove记录。</p>
</li>
<li><p>CLEAN记录的最后还有一串数字，表示的是文件的大小，单位是字节。</p>
</li>
<li><p>READ记录，每当我们调用get()方法去读取一条缓存数据时，就会向journal文件中写入一条READ记录。</p>
</li>
</ul>
<h2 id="五、获取"><a href="#五、获取" class="headerlink" title="五、获取"></a>五、获取</h2><p>DiskLruCache的构造方法是私有的，没有向外暴露，获取DiskLruCache需要通过open 方法获取。</p>
<h3 id="5-1-open"><a href="#5-1-open" class="headerlink" title="5.1 open"></a>5.1 open</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DiskLruCache <span class="title">open</span><span class="params">(File directory, <span class="keyword">int</span> appVersion, <span class="keyword">int</span> valueCount, <span class="keyword">long</span> maxSize)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;maxSize &lt;= 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (valueCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;valueCount &lt;= 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If a bkp file exists, use it instead.</span></span><br><span class="line">    File backupFile = <span class="keyword">new</span> File(directory, JOURNAL_FILE_BACKUP);</span><br><span class="line">    <span class="keyword">if</span> (backupFile.exists()) &#123;</span><br><span class="line">        File journalFile = <span class="keyword">new</span> File(directory, JOURNAL_FILE);</span><br><span class="line">        <span class="comment">// If journal file also exists just delete backup file.</span></span><br><span class="line">        <span class="keyword">if</span> (journalFile.exists()) &#123;</span><br><span class="line">            backupFile.delete();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            renameTo(backupFile, journalFile, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prefer to pick up where we left off.</span></span><br><span class="line">    DiskLruCache cache = <span class="keyword">new</span> DiskLruCache(directory, appVersion, valueCount, maxSize);</span><br><span class="line">    <span class="keyword">if</span> (cache.journalFile.exists()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cache.readJournal();</span><br><span class="line">            cache.processJournal();</span><br><span class="line">            <span class="keyword">return</span> cache;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException journalIsCorrupt) &#123;</span><br><span class="line">            System.out</span><br><span class="line">                .println(<span class="string">&quot;DiskLruCache &quot;</span></span><br><span class="line">                    + directory</span><br><span class="line">                    + <span class="string">&quot; is corrupt: &quot;</span></span><br><span class="line">                    + journalIsCorrupt.getMessage()</span><br><span class="line">                    + <span class="string">&quot;, removing&quot;</span>);</span><br><span class="line">            cache.delete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a new empty cache.</span></span><br><span class="line">    directory.mkdirs();</span><br><span class="line">    cache = <span class="keyword">new</span> DiskLruCache(directory, appVersion, valueCount, maxSize);</span><br><span class="line">    cache.rebuildJournal();</span><br><span class="line">    <span class="keyword">return</span> cache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要分为3个流程：</p>
<p>10 - 15行，存在journal备份文件时，若journal文件也存在，删除备份文件；否则将备份文件做为journal文件。</p>
<p>23 - 38行，读取journal文件，初始化lruEntries数组，将标记为clean的文件信息（包括文件名，大小等等）加载到内存lruEntries中；将标记为dirty的文件删除。</p>
<p>41 - 41行, journal 文件不存在，重新创建缓存。</p>
<h3 id="5-2-readJournal"><a href="#5-2-readJournal" class="headerlink" title="5.2 readJournal"></a>5.2 readJournal</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readJournal</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    StrictLineReader reader = <span class="keyword">new</span> StrictLineReader(<span class="keyword">new</span> FileInputStream(journalFile), Util.US_ASCII);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//  读取文件头</span></span><br><span class="line">        String magic = reader.readLine();</span><br><span class="line">        String version = reader.readLine();</span><br><span class="line">        String appVersionString = reader.readLine();</span><br><span class="line">        String valueCountString = reader.readLine();</span><br><span class="line">        String blank = reader.readLine();</span><br><span class="line">        <span class="keyword">if</span> (!MAGIC.equals(magic)</span><br><span class="line">            || !VERSION_1.equals(version)</span><br><span class="line">            || !Integer.toString(appVersion).equals(appVersionString)</span><br><span class="line">            || !Integer.toString(valueCount).equals(valueCountString)</span><br><span class="line">            || !<span class="string">&quot;&quot;</span>.equals(blank)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;unexpected journal header: [&quot;</span> + magic + <span class="string">&quot;, &quot;</span> + version + <span class="string">&quot;, &quot;</span></span><br><span class="line">                + valueCountString + <span class="string">&quot;, &quot;</span> + blank + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lineCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            	<span class="comment">// 读取文件内容部分</span></span><br><span class="line">                readJournalLine(reader.readLine());</span><br><span class="line">                lineCount++;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (EOFException endOfJournal) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        redundantOpCount = lineCount - lruEntries.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we ended on a truncated line, rebuild the journal before appending to it.</span></span><br><span class="line">        <span class="keyword">if</span> (reader.hasUnterminatedLine()) &#123;</span><br><span class="line">            rebuildJournal();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            journalWriter = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(</span><br><span class="line">                <span class="keyword">new</span> FileOutputStream(journalFile, <span class="keyword">true</span>), Util.US_ASCII));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Util.closeQuietly(reader);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>5 - 17行：读取jorunal文件头部分，如果文件信息和初始化传入的信息不存在，直接抛出异常在open中将当前journal文件删除，重新创建</p>
<p>20 - 28行：读取现有journal文件。</p>
<p>32- 36行：如果行尾返回-1，重新构建下文件；否则将已有信息写入journal文件。</p>
<h4 id="5-2-1-readJournalLine"><a href="#5-2-1-readJournalLine" class="headerlink" title="5.2.1 readJournalLine"></a>5.2.1 readJournalLine</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// journal日志格式</span></span><br><span class="line">DIRTY bda205e0e3cec1055dc7a5e91960cab5</span><br><span class="line">CLEAN bda205e0e3cec1055dc7a5e91960cab5 <span class="number">5830</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readJournalLine</span><span class="params">(String line)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> firstSpace = line.indexOf(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (firstSpace == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;unexpected journal line: &quot;</span> + line);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> keyBegin = firstSpace + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> secondSpace = line.indexOf(<span class="string">&#x27; &#x27;</span>, keyBegin);</span><br><span class="line">    <span class="keyword">final</span> String key;</span><br><span class="line">    <span class="comment">// key值为文件名</span></span><br><span class="line">    <span class="keyword">if</span> (secondSpace == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 非clean记录，key值为第一个空格到行尾</span></span><br><span class="line">        key = line.substring(keyBegin);</span><br><span class="line">        <span class="comment">// remove 记录处理</span></span><br><span class="line">        <span class="keyword">if</span> (firstSpace == REMOVE.length() &amp;&amp; line.startsWith(REMOVE)) &#123;</span><br><span class="line">            lruEntries.remove(key);</span><br><span class="line">            <span class="comment">// 注意这里会return，也就是说初始化时remove记录不添加到lruEntries中，否则后面会崩掉</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 对于clean记录，key值，第一个空格到第二个空格间</span></span><br><span class="line">        key = line.substring(keyBegin, secondSpace);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry entry = lruEntries.get(key);</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">        entry = <span class="keyword">new</span> Entry(key);</span><br><span class="line">        lruEntries.put(key, entry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (secondSpace != -<span class="number">1</span> &amp;&amp; firstSpace == CLEAN.length() &amp;&amp; line.startsWith(CLEAN)) &#123;</span><br><span class="line">       <span class="comment">//clean记录处理：</span></span><br><span class="line">       <span class="comment">// 1.读取有多少个记录长度</span></span><br><span class="line">       <span class="comment">// 2.标记readable为true </span></span><br><span class="line">       <span class="comment">// 3.currentEditor 标记为null </span></span><br><span class="line">       <span class="comment">// 4.设置长度数组</span></span><br><span class="line">        String[] parts = line.substring(secondSpace + <span class="number">1</span>).split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        entry.readable = <span class="keyword">true</span>;</span><br><span class="line">        entry.currentEditor = <span class="keyword">null</span>;</span><br><span class="line">        entry.setLengths(parts);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (secondSpace == -<span class="number">1</span> &amp;&amp; firstSpace == DIRTY.length() &amp;&amp; line.startsWith(DIRTY)) &#123;</span><br><span class="line">     <span class="comment">//dirty 记录给currentEditor赋值</span></span><br><span class="line">        entry.currentEditor = <span class="keyword">new</span> Editor(entry);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (secondSpace == -<span class="number">1</span> &amp;&amp; firstSpace == READ.length() &amp;&amp; line.startsWith(READ)) &#123;</span><br><span class="line">        <span class="comment">// This work was already done by calling lruEntries.get().</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;unexpected journal line: &quot;</span> + line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7 - 18行：解析记录的类型和文件名，并将remove记录从lruEntries中删除</p>
<p>28 - 48行：将clean、dirty等记录加到lruEntries中</p>
<h4 id="5-2-2-processJournal"><a href="#5-2-2-processJournal" class="headerlink" title="5.2.2 processJournal"></a>5.2.2 processJournal</h4><p>processJournal会继续对上一步加入到lruEntries中的数据进行处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void processJournal() throws IOException &#123;</span><br><span class="line">    deleteIfExists(journalFileTmp);</span><br><span class="line">    for (Iterator&lt;Entry&gt; i = lruEntries.values().iterator(); i.hasNext(); ) &#123;</span><br><span class="line">        Entry entry = i.next();</span><br><span class="line">        // 1.计算所有cleanfile的大小</span><br><span class="line">        if (entry.currentEditor == null) &#123;</span><br><span class="line">            for (int t = 0; t &lt; valueCount; t++) &#123;</span><br><span class="line">                size += entry.lengths[t];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        // 2.删除所有脏数据</span><br><span class="line">            entry.currentEditor = null;</span><br><span class="line">            for (int t = 0; t &lt; valueCount; t++) &#123;</span><br><span class="line">                deleteIfExists(entry.getCleanFile(t));//?</span><br><span class="line">                deleteIfExists(entry.getDirtyFile(t));</span><br><span class="line">            &#125;</span><br><span class="line">            i.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6 - 8行：统计所有clean数据的大小，也就是当前缓存数据的大小</p>
<p>12 - 13行：删除孤立的dirty数据，clean和dirty记录是配对出现的，且上一步中clean在dirty数据之后，所以currentEditor此时一定为null。    </p>
<h3 id="5-3-rebuildJournal"><a href="#5-3-rebuildJournal" class="headerlink" title="5.3 rebuildJournal"></a>5.3 rebuildJournal</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">rebuildJournal</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (journalWriter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        journalWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Writer writer = <span class="keyword">new</span> BufferedWriter(</span><br><span class="line">        <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(journalFileTmp), Util.US_ASCII));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        writer.write(MAGIC);</span><br><span class="line">        writer.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        writer.write(VERSION_1);</span><br><span class="line">        writer.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        writer.write(Integer.toString(appVersion));</span><br><span class="line">        writer.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        writer.write(Integer.toString(valueCount));</span><br><span class="line">        writer.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Entry entry : lruEntries.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.currentEditor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                writer.write(DIRTY + <span class="string">&#x27; &#x27;</span> + entry.key + <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                writer.write(CLEAN + <span class="string">&#x27; &#x27;</span> + entry.key + entry.getLengths() + <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (journalFile.exists()) &#123;</span><br><span class="line">        renameTo(journalFile, journalFileBackup, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    renameTo(journalFileTmp, journalFile, <span class="keyword">false</span>);</span><br><span class="line">    journalFileBackup.delete();</span><br><span class="line"></span><br><span class="line">    journalWriter = <span class="keyword">new</span> BufferedWriter(</span><br><span class="line">        <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(journalFile, <span class="keyword">true</span>), Util.US_ASCII));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6 - 17行：创建journal临时文件，写journal文件头信息。</p>
<p>19 - 20行：将lruEntries里的所有信息写入到journal,tmp中。</p>
<p>30 - 34行:  处理journal文件，防止当次写入过程中出现异常，避免journal文件丢失。主要过程：1.将当前的journal重命名为备份文件；2.将临时文件命名为journal文件。3.将信息都写入journal文件。</p>
<h2 id="六、写入"><a href="#六、写入" class="headerlink" title="六、写入"></a>六、写入</h2><p>一个标准的写入操作如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DiskLruCache.Editor editor = <span class="keyword">null</span>;</span><br><span class="line">Writer bw = <span class="keyword">null</span>;</span><br><span class="line">key = FileKeyGenerator.hashKeyForDisk(key);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	editor = getDiskCache().edit(key);</span><br><span class="line">	OutputStream os = editor.newOutputStream(<span class="number">0</span>);</span><br><span class="line">	bw = <span class="keyword">new</span> OutputStreamWriter(os);</span><br><span class="line">	bw.write(value);</span><br><span class="line">	bw.flush();</span><br><span class="line">	editor.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      CloseUtils.closeIO(bw);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> DiskLruCache <span class="title">getDiskCache</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mDiskLruCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">		mDiskLruCache = DiskLruCache.open(mDirectory, APP_VERSION, VALUE_COUNT, mFileSize);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> mDiskLruCache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-1-DiskLruCache-edit"><a href="#6-1-DiskLruCache-edit" class="headerlink" title="6.1 DiskLruCache.edit"></a>6.1 DiskLruCache.edit</h3><p>获取editor对象，进行写入操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> Editor <span class="title">edit</span><span class="params">(String key, <span class="keyword">long</span> expectedSequenceNumber)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    checkNotClosed();</span><br><span class="line">    validateKey(key);</span><br><span class="line">    Entry entry = lruEntries.get(key);</span><br><span class="line">    <span class="keyword">if</span> (expectedSequenceNumber != ANY_SEQUENCE_NUMBER &amp;&amp; (entry == <span class="keyword">null</span></span><br><span class="line">        || entry.sequenceNumber != expectedSequenceNumber)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// Snapshot is stale.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">        entry = <span class="keyword">new</span> Entry(key);</span><br><span class="line">        lruEntries.put(key, entry); <span class="comment">// put 到lruEntries </span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry.currentEditor != <span class="keyword">null</span>) &#123; <span class="comment">//editor != null，说明正在被写入</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// Another edit is in progress.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 走到这里有2种可能，新增一条记录或者更新现有的记录</span></span><br><span class="line">    Editor editor = <span class="keyword">new</span> Editor(entry);</span><br><span class="line">    entry.currentEditor = editor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Flush the journal before creating files to prevent file leaks.</span></span><br><span class="line">    journalWriter.write(DIRTY + <span class="string">&#x27; &#x27;</span> + key + <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    journalWriter.flush();</span><br><span class="line">    <span class="keyword">return</span> editor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第3行：验证key，必须是字母、数字、下划线、横线（-）组成，且长度在1-120之间。</p>
<p>9 - 17行：创建一个entry，如果editor 不为空，说明正在被写入。</p>
<p>20 - 23行：journal中写入一条DIRTY记录，并将editor对象返回。</p>
<h3 id="6-2-Editor"><a href="#6-2-Editor" class="headerlink" title="6.2 Editor"></a>6.2 Editor</h3><p>Editor对象是DiskLruCache写入数据时提供给调用者进行写入操作的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Editor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Entry entry; <span class="comment">// </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span>[] written; <span class="comment">// 同一个key多个值的可写状态，只有dirty是才是可写的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasErrors;<span class="comment">//io过程是否出了错</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> committed;<span class="comment">//标记是否提交</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看一下写入的过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   OutputStream os = editor.newOutputStream(<span class="number">0</span>);</span><br><span class="line">bw = <span class="keyword">new</span> OutputStreamWriter(os);</span><br><span class="line">bw.write(value);</span><br><span class="line">bw.flush(); <span class="comment">//一定要刷新，否则文件没有大小</span></span><br><span class="line">editor.commit();</span><br></pre></td></tr></table></figure>

<h4 id="6-2-1-editor-newOutputStream"><a href="#6-2-1-editor-newOutputStream" class="headerlink" title="6.2.1 editor.newOutputStream"></a>6.2.1 editor.newOutputStream</h4><p>将dirty文件和FaultHidingOutputStream绑定，向文件中写缓存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> OutputStream <span class="title">newOutputStream</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= valueCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Expected index &quot;</span> + index + <span class="string">&quot; to &quot;</span></span><br><span class="line">            + <span class="string">&quot;be greater than 0 and less than the maximum value count &quot;</span></span><br><span class="line">            + <span class="string">&quot;of &quot;</span> + valueCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (DiskLruCache.<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.currentEditor != <span class="keyword">this</span>) &#123; <span class="comment">// entry和editor是不是匹配的</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!entry.readable) &#123; <span class="comment">// dirty记录设置为可读</span></span><br><span class="line">            written[index] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        File dirtyFile = entry.getDirtyFile(index); <span class="comment">//获取dirty文件，就是edit是创建的</span></span><br><span class="line">        FileOutputStream outputStream;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            outputStream = <span class="keyword">new</span> FileOutputStream(dirtyFile);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// Attempt to recreate the cache directory.</span></span><br><span class="line">            directory.mkdirs();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                outputStream = <span class="keyword">new</span> FileOutputStream(dirtyFile);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (FileNotFoundException e2) &#123;</span><br><span class="line">                <span class="comment">// We are unable to recover. Silently eat the writes.</span></span><br><span class="line">                <span class="keyword">return</span> NULL_OUTPUT_STREAM;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FaultHidingOutputStream(outputStream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>28行：editor.newOutputStream创建的是一个FaultHidingOutputStream，如果write过程中出现IOException，hasErrors会被置为true。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">FaultHidingOutputStream</span> <span class="keyword">extends</span> <span class="title">FilterOutputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FaultHidingOutputStream</span><span class="params">(OutputStream out)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(out);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> oneByte)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            out.write(oneByte);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            hasErrors = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] buffer, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            out.write(buffer, offset, length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            hasErrors = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-2-2-editor-commit"><a href="#6-2-2-editor-commit" class="headerlink" title="6.2.2 editor.commit"></a>6.2.2 editor.commit</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hasErrors) &#123;</span><br><span class="line">        completeEdit(<span class="keyword">this</span>, <span class="keyword">false</span>);</span><br><span class="line">        remove(entry.key); <span class="comment">// The previous entry is stale.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        completeEdit(<span class="keyword">this</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    committed = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写入过程出现异常hasError == true，就删除这条数据，否则就说明写入成功，那么hasError指的是什么呢？回头看下写入的过程，秘密就在editor.newOutputStream(0)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OutputStream os = editor.newOutputStream(<span class="number">0</span>);</span><br><span class="line">bw = <span class="keyword">new</span> OutputStreamWriter(os);</span><br><span class="line">bw.write(value);</span><br><span class="line">bw.flush();</span><br></pre></td></tr></table></figure>

<p>第3行调用write操作其实调用的是editor.newOutputStream(0).write。</p>
<h4 id="6-2-3-completeEdit"><a href="#6-2-3-completeEdit" class="headerlink" title="6.2.3 completeEdit"></a>6.2.3 completeEdit</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">completeEdit</span><span class="params">(Editor editor, <span class="keyword">boolean</span> success)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Entry entry = editor.entry;</span><br><span class="line">    <span class="keyword">if</span> (entry.currentEditor != editor) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this edit is creating the entry for the first time, every index must have a value.</span></span><br><span class="line">    <span class="keyword">if</span> (success &amp;&amp; !entry.readable) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valueCount; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!editor.written[i]) &#123;</span><br><span class="line">                editor.abort();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Newly created entry didn&#x27;t create value for index &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!entry.getDirtyFile(i).exists()) &#123;</span><br><span class="line">                editor.abort();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valueCount; i++) &#123;</span><br><span class="line">        File dirty = entry.getDirtyFile(i);</span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dirty.exists()) &#123;</span><br><span class="line">                File clean = entry.getCleanFile(i);</span><br><span class="line">                dirty.renameTo(clean);</span><br><span class="line">                <span class="keyword">long</span> oldLength = entry.lengths[i];</span><br><span class="line">                <span class="keyword">long</span> newLength = clean.length();</span><br><span class="line">                entry.lengths[i] = newLength;</span><br><span class="line">                size = size - oldLength + newLength;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            deleteIfExists(dirty);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    redundantOpCount++;<span class="comment">//记录日志文件的长度</span></span><br><span class="line">    entry.currentEditor = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (entry.readable | success) &#123;</span><br><span class="line">        entry.readable = <span class="keyword">true</span>;</span><br><span class="line">        journalWriter.write(CLEAN + <span class="string">&#x27; &#x27;</span> + entry.key + entry.getLengths() + <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            entry.sequenceNumber = nextSequenceNumber++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lruEntries.remove(entry.key);</span><br><span class="line">        journalWriter.write(REMOVE + <span class="string">&#x27; &#x27;</span> + entry.key + <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    journalWriter.flush();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; maxSize || journalRebuildRequired()) &#123;</span><br><span class="line">        executorService.submit(cleanupCallable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>8 - 19行：首次创建时：1.如果有多个记录，那么每一个记录都必须有值，否则抛出异常；2.写入的文件是否存在，若不存在，则删除。</p>
<p>21 - 35行：将dirty文件重命名为clean文件；更新clean文件的长度和所有文件的大小。</p>
<p>39 - 49行：写入成功，journal中插入一条成功的记录；否则插入remove记录。</p>
<p>51 - 53行:  大小超过阈值或者需要重建时，重新整理journal文件。</p>
<h2 id="七、读取"><a href="#七、读取" class="headerlink" title="七、读取"></a>七、读取</h2><p>一个标准的读取流程如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">ByteArrayOutputStream outStream = <span class="keyword">null</span>;</span><br><span class="line">key = FileKeyGenerator.hashKeyForDisk(key);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    DiskLruCache.Snapshot snapshot = getDiskCache().get(key);</span><br><span class="line">    <span class="keyword">if</span> (snapshot == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Log.e(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;Not find entry from disk , or entry.readable = false&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inputStream = snapshot.getInputStream(<span class="number">0</span>);</span><br><span class="line">    outStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">int</span> count = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((count = inputStream.read(data, <span class="number">0</span>, BUFFER_SIZE)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        outStream.write(data, <span class="number">0</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(outStream.toByteArray());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    Log.e(TAG, <span class="string">&quot;readFromDisk&quot;</span>, e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    CloseUtils.closeIO(inputStream, outStream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-1-DiskLruCache-get"><a href="#7-1-DiskLruCache-get" class="headerlink" title="7.1 DiskLruCache.get"></a>7.1 DiskLruCache.get</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Snapshot <span class="title">get</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    checkNotClosed();</span><br><span class="line">    validateKey(key);</span><br><span class="line">    Entry entry = lruEntries.get(key);</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!entry.readable) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open all streams eagerly to guarantee that we see a single published</span></span><br><span class="line">    <span class="comment">// snapshot. If we opened streams lazily then the streams could come</span></span><br><span class="line">    <span class="comment">// from different edits.</span></span><br><span class="line">    InputStream[] ins = <span class="keyword">new</span> InputStream[valueCount];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valueCount; i++) &#123;</span><br><span class="line">            ins[i] = <span class="keyword">new</span> FileInputStream(entry.getCleanFile(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        <span class="comment">// A file must have been deleted manually!</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valueCount; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ins[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Util.closeQuietly(ins[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    redundantOpCount++;</span><br><span class="line">    journalWriter.append(READ + <span class="string">&#x27; &#x27;</span> + key + <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (journalRebuildRequired()) &#123;</span><br><span class="line">        executorService.submit(cleanupCallable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Snapshot(key, entry.sequenceNumber, ins, entry.lengths);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>get方法会返回一个SnapShot（快照）对象，对应是key的Entry对象。获取过程如下：</p>
<p>1.判断lruEntries是否存在且可读(clean的记录才是可读的)，从entry中获取clean文件的对应的InputStream</p>
<p>2.冗余记录 ++ ，journal中增加一条read记录，判断下是否要整理</p>
<p>3.返回snapShot对象</p>
<h3 id="7-2-Snapshot"><a href="#7-2-Snapshot" class="headerlink" title="7.2 Snapshot"></a>7.2 Snapshot</h3><p>Snapshot 中保存着对应key的entry对象及其文件的inputStream，用于上层读取，SnapShot返回数据对象有2个api：</p>
<ul>
<li><p>Snapshot.getInputStream返回的是一个inputStream对象</p>
</li>
<li><p>Snapshot.getString 返回String对象，内部也是调用了getInputStream对象。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Snapshot</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String key;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceNumber;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InputStream[] ins;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span>[] lengths;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Snapshot</span><span class="params">(String key, <span class="keyword">long</span> sequenceNumber, InputStream[] ins, <span class="keyword">long</span>[] lengths)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.sequenceNumber = sequenceNumber;</span><br><span class="line">        <span class="keyword">this</span>.ins = ins;</span><br><span class="line">        <span class="keyword">this</span>.lengths = lengths;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the unbuffered stream with the value for &#123;<span class="doctag">@code</span> index&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InputStream <span class="title">getInputStream</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ins[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the string value for &#123;<span class="doctag">@code</span> index&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inputStreamToString(getInputStream(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the byte length of the value for &#123;<span class="doctag">@code</span> index&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLength</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lengths[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (InputStream in : ins) &#123;</span><br><span class="line">            Util.closeQuietly(in);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="八、其他方法"><a href="#八、其他方法" class="headerlink" title="八、其他方法"></a>八、其他方法</h2><h3 id="8-1-remove方法"><a href="#8-1-remove方法" class="headerlink" title="8.1 remove方法"></a>8.1 remove方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    checkNotClosed();</span><br><span class="line">    validateKey(key);</span><br><span class="line">    Entry entry = lruEntries.get(key);</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span> || entry.currentEditor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valueCount; i++) &#123;</span><br><span class="line">        File file = entry.getCleanFile(i);</span><br><span class="line">        <span class="keyword">if</span> (file.exists() &amp;&amp; !file.delete()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;failed to delete &quot;</span> + file);</span><br><span class="line">        &#125;</span><br><span class="line">        size -= entry.lengths[i];</span><br><span class="line">        entry.lengths[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    redundantOpCount++;</span><br><span class="line">    journalWriter.append(REMOVE + <span class="string">&#x27; &#x27;</span> + key + <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    lruEntries.remove(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (journalRebuildRequired()) &#123;</span><br><span class="line">        executorService.submit(cleanupCallable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果实体存在且不在被编辑，就可以直接进行删除，然后写入一条REMOVE记录。</p>
<h3 id="8-2-close方法"><a href="#8-2-close方法" class="headerlink" title="8.2 close方法"></a>8.2 close方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (journalWriter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// Already closed.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Entry entry : <span class="keyword">new</span> ArrayList&lt;Entry&gt;(lruEntries.values())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.currentEditor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            entry.currentEditor.abort();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    trimToSize();</span><br><span class="line">    journalWriter.close();</span><br><span class="line">    journalWriter = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与open对应，手动关闭缓存。关闭时若还有正在编辑的数据，直接abort掉，最后关闭journalWriter。</p>
<p>trimToSize，size超过阈值后，从lruEntries第一个元素开始删除，直到小于maxSize</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (size &gt; maxSize) &#123;</span><br><span class="line">        Map.Entry&lt;String, Entry&gt; toEvict = lruEntries.entrySet().iterator().next();</span><br><span class="line">        remove(toEvict.getKey());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-3-abort方法"><a href="#8-3-abort方法" class="headerlink" title="8.3 abort方法"></a>8.3 abort方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abort</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    completeEdit(<span class="keyword">this</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是存储失败的时候的逻辑，会向journal文件中写入一条remove记录</p>
<h2 id="九、其他"><a href="#九、其他" class="headerlink" title="九、其他"></a>九、其他</h2><h3 id="9-1-多个value的写入"><a href="#9-1-多个value的写入" class="headerlink" title="9.1 多个value的写入"></a>9.1 多个value的写入</h3><p>以写入String为例，其他数据的写入都可通过OutputStreamWriter。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">editor = getDiskCache().edit(key);</span><br><span class="line">editor.set(<span class="number">0</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">editor.set(<span class="number">1</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">editor.set(<span class="number">2</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">editor.commit();</span><br></pre></td></tr></table></figure>

<p>写入后的journal文件格式如下：clean文件尾带 3个数字字符串，缓存中存在3个缓存文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">journal文件</span><br><span class="line"></span><br><span class="line">DIRTY c431ca75aeea1753604a07b33e6a329a</span><br><span class="line">CLEAN c431ca75aeea1753604a07b33e6a329a <span class="number">3</span> <span class="number">6</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">缓存文件</span><br><span class="line">-rw------- <span class="number">1</span> u0_a394 u0_a394_cache    <span class="number">3</span> <span class="number">2020</span>-<span class="number">05</span>-<span class="number">14</span> <span class="number">20</span>:<span class="number">45</span> c431ca75aeea1753604a07b33e6a329a<span class="number">.0</span></span><br><span class="line">-rw------- <span class="number">1</span> u0_a394 u0_a394_cache    <span class="number">6</span> <span class="number">2020</span>-<span class="number">05</span>-<span class="number">14</span> <span class="number">20</span>:<span class="number">45</span> c431ca75aeea1753604a07b33e6a329a<span class="number">.1</span></span><br><span class="line">-rw------- <span class="number">1</span> u0_a394 u0_a394_cache    <span class="number">6</span> <span class="number">2020</span>-<span class="number">05</span>-<span class="number">14</span> <span class="number">20</span>:<span class="number">45</span> c431ca75aeea1753604a07b33e6a329a<span class="number">.2</span></span><br><span class="line">-rw------- <span class="number">1</span> u0_a394 u0_a394_cache <span class="number">1567</span> <span class="number">2020</span>-<span class="number">05</span>-<span class="number">14</span> <span class="number">20</span>:<span class="number">45</span> journal</span><br></pre></td></tr></table></figure>

<h3 id="9-2-字符串写入"><a href="#9-2-字符串写入" class="headerlink" title="9.2 字符串写入"></a>9.2 字符串写入</h3><p>editor提供了2种写入操作，写入字符流和字符串。</p>
<h4 id="9-2-1-写入字符串"><a href="#9-2-1-写入字符串" class="headerlink" title="9.2.1 写入字符串"></a>9.2.1 写入字符串</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">editor.set(<span class="number">0</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, String value)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Writer writer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        writer = <span class="keyword">new</span> OutputStreamWriter(newOutputStream(index), Util.UTF_8);</span><br><span class="line">        writer.write(value);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Util.closeQuietly(writer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-2-2-流写入"><a href="#9-2-2-流写入" class="headerlink" title="9.2.2 流写入"></a>9.2.2 流写入</h4><p>通过流的形式写入时一定要执行一次flush，否则写入的文件在journal中会没有大小</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OutputStream os = editor.newOutputStream(<span class="number">0</span>);</span><br><span class="line">bw = <span class="keyword">new</span> OutputStreamWriter(os);</span><br><span class="line">bw.write(value);</span><br><span class="line">bw.flush();</span><br></pre></td></tr></table></figure>

<h2 id="十、总结"><a href="#十、总结" class="headerlink" title="十、总结"></a>十、总结</h2><p>DiskLruCache 内部是通过lruEntries保存所有的缓存文件名也就是路径，lruEntries本身是一个LinkedHashMap，Lru机制其实就是通过LinkedHashMap实现的；</p>
<p>缓存的增删改查都会记录到journal文件中，dirty记录表示的是写入的记录，一条有效的缓存会对应一条dirty和一条clean日志，他们是配对出现的；</p>
<p>初始化过程中会读取journal文件，将所有标记为clean和dirty的文件加入lruEntries中；最后计算所有clean文件的大小并删除所有孤立的标记为dirty文件；</p>
<p>记录总大小size在写入记录和删除记录时都会随之发生变化，当达到设定阈值maxSize时，会从头部数据开始删除，直到小于maxSize；</p>
<p>在get、edit、remove时都会检查清理操作，主要过程有2个：1.移除lruEntries多余元素 2.重建journal文件。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/lmj623565791/article/details/47251585">Android DiskLruCache源码解析硬盘缓存的绝佳方案</a></p>
<p><a href="http://blog.csdn.net/guolin_blog/article/details/28863651">Android DiskLruCache完全解析，硬盘缓存的最佳方案</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>开源</category>
      </categories>
  </entry>
  <entry>
    <title>open_09_Matrix 源码分析</title>
    <url>/2022/12/25/Notes/Android/02%E5%BC%80%E6%BA%90/open_09_Matrix%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="open-9-Matrix"><a href="#open-9-Matrix" class="headerlink" title="open_9_Matrix"></a>open_9_Matrix</h1><span id="more"></span>

<p>主线程耗时监控和掉帧原理</p>
<p><a href="https://www.jianshu.com/p/fc77b4807636">https://www.jianshu.com/p/fc77b4807636</a></p>
<p>EvailMethod计算原理</p>
<p><a href="https://juejin.cn/post/7037803417703546911">https://juejin.cn/post/7037803417703546911</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>开源</category>
      </categories>
  </entry>
  <entry>
    <title>FrameWork_02_Binder</title>
    <url>/2021/05/30/Notes/Android/04Framework/FrameWork_02_Binder/</url>
    <content><![CDATA[<h1 id="FrameWork-02-Binder"><a href="#FrameWork-02-Binder" class="headerlink" title="FrameWork_02_Binder"></a>FrameWork_02_Binder</h1><span id="more"></span>

<h2 id="什么是Binder？"><a href="#什么是Binder？" class="headerlink" title="什么是Binder？"></a>什么是Binder？</h2><p>对于<code>Binder</code>的定义，在不同场景下其定义不同。</p>
<ol>
<li>从IPC角度来说：<strong>Binder是Android中的一种跨进程通信方式，该通信方式在linux中没有，是Android独有</strong>；</li>
<li>从Android Driver层：<strong>Binder还可以理解为一种虚拟的物理设备，它的设备驱动是/dev/binder</strong>；</li>
<li>从Android Native层：Binder是创建Service Manager以及BpBinder/BBinder模型，搭建与binder驱动的桥梁；</li>
<li>从Android Framework层：Binder是各种Manager（ActivityManager、WindowManager等）和相应xxxManagerService的桥梁；</li>
<li>从Android APP层：Binder是客户端和服务端进行通信的媒介，当bindService的时候，服务端会返回一个包含了服务端业务调用的 Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或者数据，这里的服务包括普通服务和基于AIDL的服务。</li>
</ol>
<h2 id="IPC-基本概念"><a href="#IPC-基本概念" class="headerlink" title="IPC 基本概念"></a>IPC 基本概念</h2><p><img src="/pics/image-20210530173422907.png" alt="image-20210530173422907" style="zoom:35%;" />..</p>
<p>上图展示了传统进程通信的基本概念：</p>
<ul>
<li>进程隔离</li>
<li>进程空间划分</li>
<li>系统调用</li>
</ul>
<h3 id="进程隔离"><a href="#进程隔离" class="headerlink" title="进程隔离"></a>进程隔离</h3><p>为了保证 安全性 &amp; 独立性，一个进程 不能直接操作或者访问另一个进程，即<code>Android</code>的进程是<strong>相互独立、隔离的</strong>。2个进程之间内存可以随意访问的话，那基本上程序之间就没有任何安全性可言，若可以随意修改其他程序的数据，那计算机世界将陷入混乱。</p>
<p>基于进程之间不可互相访问数据的基础上，为了实现进程间数据共享，这里就必须采用特殊的通信机制：<strong>进程间通信（IPC）</strong></p>
<h3 id="进程空间划分"><a href="#进程空间划分" class="headerlink" title="进程空间划分"></a>进程空间划分</h3><p>一个进程空间分为 **用户空间 和内核空间（Kernel)**，二者区别：</p>
<ul>
<li>进程间，用户空间的数据不可共享</li>
<li>进程间，内核空间的数据可共享</li>
</ul>
<blockquote>
<p>所有进程共用1个内核空间</p>
</blockquote>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>虽然从逻辑上进行了用户空间和内核空间的划分，但是不可避免的用户空间需要访问内核资源，比如文件操作、访问网络等等。为了突破隔离限制，就需要借助系统调用来实现。系统调用是用户空间访问内核空间的唯一方式，保证了所有的内核资源访问都是在内核的控制下进行的，避免了用户程序对系统资源的越权访问，提升系统安全性和稳定性。</p>
<p>进程内 用户空间 &amp; 内核空间 进行交互 需通过 系统调用，主要通过函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">copy_from_user（）：将用户空间的数据拷贝到内核空间</span><br><span class="line">copy_to_user（）：将内核空间的数据拷贝到用户空间</span><br></pre></td></tr></table></figure>

<h3 id="传统IPC通信的缺点"><a href="#传统IPC通信的缺点" class="headerlink" title="传统IPC通信的缺点"></a>传统IPC通信的缺点</h3><ol>
<li>性能低下。一次数据传递需要经历：内存缓存区 –&gt; 内核缓存区 –&gt; 内存缓存区，需要 2 次数据拷贝；</li>
<li>接收数据的缓存区由数据接收进程提供，但是接收进程并不知道需要多大的空间来存放将要传递过来的数据，因此只能开辟尽可能大的内存空间或者先调用 API 接收消息头来获取消息体的大小，这两种做法<strong>不是浪费空间就是浪费时间</strong>。</li>
</ol>
<h2 id="为什么选择Binder通信？"><a href="#为什么选择Binder通信？" class="headerlink" title="为什么选择Binder通信？"></a>为什么选择Binder通信？</h2><img src="/pics/image-20210606161417803.png" alt="image-20210606161417803" style="zoom:50%;" />

<ul>
<li><p>从性能的角度</p>
<p>Binder数据拷贝只需要一次，而管道、消息队列、Socket都需要2次，但共享内存方式一次内存拷贝都不需要；从性能角度看，Binder性能仅次于共享内存。但共享内存控制复杂，难以使用。</p>
<img src="/pics/image-20210606161436142.png" alt="image-20210606161436142" style="zoom:50%;" /></li>
<li><p>从稳定性的角度<br>Binder 基于 C/S 架构，客户端（Client）有什么需求就丢给服务端（Server）去完成，架构清晰、职责明确又相互独立，自然稳定性更好。共享内存虽然无需拷贝，但是控制负责，难以使用。从稳定性的角度讲，Binder 机制是优于内存共享的。</p>
</li>
<li><p>从安全的角度<br>传统Linux IPC的接收方无法获得对方进程可靠的UID/PID，从而无法鉴别对方身份；传统Linux IPC无任何保护措施，完全由上层协议来确保。</p>
<p>Android为每个安装好的应用程序分配了自己的UID，故进程的UID是鉴别进程身份的重要标志，前面提到C/S架构，Android系统中对外只暴露Client端，Client端将任务发送给Server端，Server端会根据权限控制策略，判断UID/PID是否满足访问权限，目前权限控制很多时候是通过弹出权限询问对话框，让用户选择是否运行。</p>
<blockquote>
<p>传统IPC只能由用户在数据包里填入UID/PID；另外，可靠的身份标记只有由IPC机制本身在内核中添加。其次传统IPC访问接入点是开放的，无法建立私有通道。从安全角度，Binder的安全性更高。</p>
</blockquote>
</li>
</ul>
<h2 id="Binder-IPC原理"><a href="#Binder-IPC原理" class="headerlink" title="Binder IPC原理"></a>Binder IPC原理</h2><h3 id="动态内核可加载模块"><a href="#动态内核可加载模块" class="headerlink" title="动态内核可加载模块"></a>动态内核可加载模块</h3><p>跨进程通信是需要内核空间做支持的。传统的 IPC 机制如管道、Socket 都是内核的一部分，因此通过内核支持来实现进程间通信自然是没问题的。但是 Binder 并不是 Linux 系统内核的一部分，那怎么办呢？</p>
<p>这就得益于 Li<strong>nux 的动态内核可加载模块（Loadable Kernel Module，LKM）的机制</strong>；模块是具有独立功能的程序，它可以被单独编译，但是不能独立运行（可以简单类比成一个功能库）。模块在运行时被链接到内核作为内核的一部分运行。这样，Android 系统就可以通过动态添加一个内核模块运行在内核空间，用户进程之间通过这个内核模块作为桥梁来实现通信。</p>
<p>在 Android 系统中，这个运行在内核空间，<strong>负责各个用户进程通过 Binder 实现通信的内核模块就叫 Binder 驱动（Binder Dirver）。</strong></p>
<p>那么在 Android 系统中用户进程之间是如何通过这个内核模块（Binder 驱动）来实现通信的呢？这就不得不通道 Linux 下的另一个概念：内存映射。</p>
<h3 id="内存映射（mmap）"><a href="#内存映射（mmap）" class="headerlink" title="内存映射（mmap）"></a>内存映射（mmap）</h3><p>Binder IPC 机制中涉及到的内存映射通过 mmap() 来实现，mmap() 是操作系统中一种内存映射的方法。</p>
<p>内存映射简单的讲就是将<strong>用户空间的一块内存区域映射到内核空间</strong>。<strong>映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间</strong>。</p>
<p>内存映射能减少数据拷贝次数，实现用户空间和内核空间的高效互动。两个空间各自的修改能直接反映在映射的内存区域，从而被对方空间及时感知。也正因为如此，内存映射能够提供对进程间通信的支持。</p>
<p><a href="https://www.jianshu.com/p/719fc4758813">操作系统：图文详解 内存映射</a></p>
<h3 id="Binder-IPC实现原理"><a href="#Binder-IPC实现原理" class="headerlink" title="Binder IPC实现原理"></a>Binder IPC实现原理</h3><img src="/pics/image-20210606153721575.png" alt="image-20210606153721575" style="zoom:40%;" />

<p>一次完整的 Binder IPC 通信过程通常是这样：</p>
<ol>
<li>首先 Binder 驱动在内核空间创建一个<strong>数据接收缓存区</strong>；</li>
<li>接着在内核空间开辟一块内核缓存区，建立<ol>
<li><strong>内核缓存区 和 内核中数据接收缓存区之间</strong>的映射，</li>
<li><strong>数据接收缓存区 和 接收进程用户空间地址</strong> 的映射关系；</li>
</ol>
</li>
<li>发送方进程通过系统调用 copyfromuser() 将数据 copy 到内核中的内核缓存区，<strong>由于内核缓存区和接收进程的用户空间存在内存映射</strong>，因此也就<strong>相当于把数据发送到了接收进程的用户空间</strong>，这样便完成了一次进程间的通信。</li>
</ol>
<h2 id="Binder-通信模型"><a href="#Binder-通信模型" class="headerlink" title="Binder 通信模型"></a><strong>Binder 通信模型</strong></h2><p>一次完整的进程间通信必然至少包含两个进程，通常我们称通信的双方分别为客户端进程（Client）和服务端进程（Server），由于进程隔离机制的存在，通信双方必然需要借助 Binder 来实现。</p>
<h3 id="Client-Server-ServiceManager-驱动"><a href="#Client-Server-ServiceManager-驱动" class="headerlink" title="Client/Server/ServiceManager/驱动"></a>Client/Server/ServiceManager/驱动</h3><p>前面我们介绍过，Binder 是基于 C/S 架构的。由一系列的组件组成，包括 Client、Server、ServiceManager、Binder 驱动。其中 Client、Server、Service Manager 运行在用户空间，Binder 驱动运行在内核空间。其中 Service Manager 和 Binder 驱动由系统提供，而 Client、Server 由应用程序来实现。Client、Server 和 ServiceManager 均是通过系统调用 open、mmap 和 ioctl 来访问设备文件 /dev/binder，从而实现与 Binder 驱动的交互来间接的实现跨进程通信。</p>
<p><img src="https://pic3.zhimg.com/80/v2-729b3444cd784d882215a24067893d0e_1440w.jpg" alt="img"></p>
<p>Client、Server、ServiceManager、Binder 驱动这几个组件在通信过程中扮演的角色就如同互联网中服务器（Server）、客户端（Client）、DNS域名服务器（ServiceManager）以及路由器（Binder 驱动）之前的关系。</p>
<p><a href="https://link.zhihu.com/?target=http://blog.csdn.net/universus/article/details/6211589">Android Binder 设计与实现</a><em>一文中对 Client、Server、ServiceManager、Binder 驱动有很详细的描述，以下是部分摘录：</em></p>
<blockquote>
<p><strong>Binder 驱动</strong><br>Binder 驱动就如同路由器一样，是整个通信的核心；驱动负责进程之间 Binder 通信的建立，Binder 在进程之间的传递，Binder 引用计数管理，数据包在进程之间的传递和交互等一系列底层支持。</p>
<p><strong>ServiceManager 与实名 Binder</strong><br>ServiceManager 和 DNS 类似，作用是将字符形式的 Binder 名字转化成 Client 中对该 Binder 的引用，使得 Client 能够通过 Binder 的名字获得对 Binder 实体的引用。注册了名字的 Binder 叫实名 Binder，就像网站一样除了除了有 IP 地址意外还有自己的网址。Server 创建了 Binder，并为它起一个字符形式，可读易记得名字，将这个 Binder 实体连同名字一起以数据包的形式通过 Binder 驱动发送给 ServiceManager ，通知 ServiceManager 注册一个名为“张三”的 Binder，它位于某个 Server 中。驱动为这个穿越进程边界的 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager。ServiceManger 收到数据后从中取出名字和引用填入查找表。</p>
<p>细心的读者可能会发现，ServierManager 是一个进程，Server 是另一个进程，Server 向 ServiceManager 中注册 Binder 必然涉及到进程间通信。当前实现进程间通信又要用到进程间通信，这就好像蛋可以孵出鸡的前提却是要先找只鸡下蛋！Binder 的实现比较巧妙，就是预先创造一只鸡来下蛋。ServiceManager 和其他进程同样采用 Bidner 通信，ServiceManager 是 Server 端，有自己的 Binder 实体，其他进程都是 Client，需要通过这个 Binder 的引用来实现 Binder 的注册，查询和获取。ServiceManager 提供的 Binder 比较特殊，它没有名字也不需要注册。当一个进程使用 BINDER<em>SET</em>CONTEXT_MGR 命令将自己注册成 ServiceManager 时 Binder 驱动会自动为它创建 Binder 实体（<strong>这就是那只预先造好的那只鸡</strong>）。其次这个 Binder 实体的引用在所有 Client 中都固定为 0 而无需通过其它手段获得。也就是说，一个 Server 想要向 ServiceManager 注册自己的 Binder 就必须通过这个 0 号引用和 ServiceManager 的 Binder 通信。类比互联网，0 号引用就好比是域名服务器的地址，你必须预先动态或者手工配置好。要注意的是，这里说的 Client 是相对于 ServiceManager 而言的，一个进程或者应用程序可能是提供服务的 Server，但对于 ServiceManager 来说它仍然是个 Client。</p>
<p><strong>Client 获得实名 Binder 的引用</strong><br>Server 向 ServiceManager 中注册了 Binder 以后， Client 就能通过名字获得 Binder 的引用了。Client 也利用保留的 0 号引用向 ServiceManager 请求访问某个 Binder: 我申请访问名字叫张三的 Binder 引用。ServiceManager 收到这个请求后从请求数据包中取出 Binder 名称，在查找表里找到对应的条目，取出对应的 Binder 引用作为回复发送给发起请求的 Client。从面向对象的角度看，Server 中的 Binder 实体现在有两个引用：一个位于 ServiceManager 中，一个位于发起请求的 Client 中。如果接下来有更多的 Client 请求该 Binder，系统中就会有更多的引用指向该 Binder ，就像 Java 中一个对象有多个引用一样。</p>
</blockquote>
<h3 id="Binder-通信过程"><a href="#Binder-通信过程" class="headerlink" title="Binder 通信过程"></a>Binder 通信过程</h3><p>至此，我们大致能总结出 Binder 通信过程：</p>
<ol>
<li>首先，一个进程使用 BINDER<em>SET</em>CONTEXT_MGR 命令通过 Binder 驱动将自己注册成为 ServiceManager；</li>
<li>Server 通过驱动向 ServiceManager 中注册 Binder（Server 中的 Binder 实体），表明可以对外提供服务。驱动为这个 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager，ServiceManger 将其填入查找表。</li>
<li>Client 通过名字，在 Binder 驱动的帮助下从 ServiceManager 中获取到对 Binder 实体的引用，通过这个引用就能实现和 Server 进程的通信。</li>
</ol>
<p>我们看到整个通信过程都需要 Binder 驱动的接入。下图能更加直观的展现整个通信过程(为了进一步抽象通信过程以及呈现上的方便，下图我们忽略了 Binder 实体及其引用的概念)：</p>
<img src="https://pic4.zhimg.com/80/v2-67854cdf14d07a6a4acf9d675354e1ff_1440w.jpg" alt="img" style="zoom:50%;" />

<h3 id="详细过程"><a href="#详细过程" class="headerlink" title="详细过程"></a>详细过程</h3><ol>
<li>**<a href="http://gityuan.com/2015/11/14/binder-add-service/">注册服务(addService)</a>**：Server进程要先注册Service到ServiceManager。该过程：Server是客户端，ServiceManager是服务端。</li>
<li>**<a href="http://gityuan.com/2015/11/15/binder-get-service/">获取服务(getService)</a>**：Client进程使用某个Service前，须先向ServiceManager中获取相应的Service。该过程：Client是客户端，ServiceManager是服务端。</li>
<li><strong>使用服务</strong>：Client根据得到的Service信息建立与Service所在的Server进程通信的通路，然后就可以直接与Service交互。该过程：client是客户端，server是服务端。</li>
</ol>
<img src="/pics/image-20210530205550500.png" alt="image-20210530205550500" style="zoom:48%;" />

<p><a href="https://blog.csdn.net/carson_ho/article/details/73560642">https://blog.csdn.net/carson_ho/article/details/73560642</a></p>
<h2 id="Binder通信过程的代理模式"><a href="#Binder通信过程的代理模式" class="headerlink" title="Binder通信过程的代理模式"></a>Binder通信过程的代理模式</h2><p>跨进程通信的过程都有 Binder 驱动的参与，因此在数据流经 Binder 驱动的时候驱动会对数据做一层转换。当 A 进程想要获取 B 进程中的 object 时，驱动并不会真的把 object 返回给 A，<strong>而是返回了一个跟 object 看起来一模一样的代理对象 objectProxy</strong>，这个 objectProxy 具有和 object 一摸一样的方法，但是这些方法并没有 B 进程中 object 对象那些方法的能力，<strong>这些方法只需要把把请求参数交给驱动即可</strong>。对于 A 进程来说和直接调用 object 中的方法是一样的。</p>
<p>当 Binder 驱动接收到 A 进程的消息后，发现这是个 objectProxy 就去查询自己维护的表单，一查发现这是 B 进程 object 的代理对象。<code>于是就会去通知</code> B 进程调用 object 的方法，并要求 B 进程把返回结果发给自己。当驱动拿到 B 进程的返回结果后就会转发给 A 进程，一次通信就完成了。</p>
<img src="/pics/image-20210606150728973.png" alt="image-20210606150728973" style="zoom:40%;" />

<h2 id="Binder进程与线程"><a href="#Binder进程与线程" class="headerlink" title="Binder进程与线程"></a>Binder进程与线程</h2><p>每个Server进程在启动时会创建一个binder线程池，用来处理Binder请求；Binder的线程管理由Binder驱动自身进行管理，<strong>而不是由Server进程来管理</strong>。</p>
<p>对于一个Server进程有一个最大Binder线程数限制，默认为16个binder线程，例如Android的system_server进程就存在16个线程，超过的请求会被阻塞等待空闲的Binder线程。</p>
<p>参考：</p>
<p><a href="https://zhuanlan.zhihu.com/p/35519585">https://zhuanlan.zhihu.com/p/35519585</a></p>
<p><a href="https://blog.csdn.net/carson_ho/article/details/73560642">https://blog.csdn.net/carson_ho/article/details/73560642</a></p>
<p><a href="http://gityuan.com/2015/11/28/binder-summary/">http://gityuan.com/2015/11/28/binder-summary/</a></p>
<p><a href="https://blog.csdn.net/xhf_123/article/details/108471394">https://blog.csdn.net/xhf_123/article/details/108471394</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>Framework</category>
      </categories>
  </entry>
  <entry>
    <title>FrameWork_01_Handler消息机制</title>
    <url>/2021/02/27/Notes/Android/04Framework/FrameWork_01_Handler%20%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="FrameWork-01-Handler消息机制"><a href="#FrameWork-01-Handler消息机制" class="headerlink" title="FrameWork_01_Handler消息机制"></a>FrameWork_01_Handler消息机制</h1><span id="more"></span>

<p>Handler是Android中一种线程间传递消息的机制。主要应用的场景，将子线程中待更新的UI信息传递到主线程。本文将从以下几个方面介绍Handler：</p>
<ol>
<li>Handler的消息发送和分发过程</li>
<li>Looper，Message 以及和Handler的关系</li>
<li>Message组成和类型以及复用机制</li>
<li>IdleHandler等一些不常见的知识</li>
</ol>
<p>下面正式开始，故事从sendMessage开始讲起。</p>
<h1 id="一、消息分发过程"><a href="#一、消息分发过程" class="headerlink" title="一、消息分发过程"></a>一、消息分发过程</h1><h2 id="1-1、从sendMessage开始"><a href="#1-1、从sendMessage开始" class="headerlink" title="1.1、从sendMessage开始"></a>1.1、从sendMessage开始</h2><p>Handler常见的用法如下，主线程中创建Handler，子线程中使用sendMessage发送消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Handler mHandler;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        mHandler = <span class="keyword">new</span> Handler()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//收到消息后，更新 ui</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//发送消息</span></span><br><span class="line">                    mHandler.sendMessage();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了上面这种写法外，常见的写法还有post这种：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mHandler = <span class="keyword">new</span> Handler();</span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//ui操作</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;); </span><br><span class="line">       &#125;</span><br><span class="line">   &#125;).start();</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>以上2种方式最终都是殊途同归，最终调用的都是Handler的<strong>sendMessageAtTime</strong>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    MessageQueue queue = mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="keyword">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">        Log.w(<span class="string">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不同地方在于post 将Runnable赋值给msg.callback，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    Message m = Message.obtain();</span><br><span class="line">    m.callback = r;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后在dispatchMessage处理消息时，post方式msg.callback不为空，会执行handleCalback，最终回调Runnable的run方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// post的执行</span></span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleCalback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// sendMessage的执行</span></span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    message.callback.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>细心的读者可能会问mCallback又是什么呢？其实mCallback就是你在new Handler时可以传的一个参数，如果你像下面这样在Handler.Callback中返回true，就可以拦截消息不让消息在Handler的handler的handleMessage中处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Handler handler1 = <span class="keyword">new</span> Handler(<span class="keyword">new</span> Handler.Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="1-2、发送消息"><a href="#1-2、发送消息" class="headerlink" title="1.2、发送消息"></a>1.2、发送消息</h2><p>sendMessageAtTime后发生了什么？继续分析sendMessageAtTime方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    MessageQueue queue = mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="keyword">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">        Log.w(<span class="string">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(<span class="meta">@NonNull</span> MessageQueue queue, <span class="meta">@NonNull</span> Message msg,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将Handler赋值给msg.target,消息分发的时候会用到</span></span><br><span class="line">        msg.target = <span class="keyword">this</span>;</span><br><span class="line">        msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>经过一系列的调用sendMessageAtTime最终调用到了MessagQueue.enqueueMessage。</p>
<p>enqueueMessage将所有收到的消息按发送时间进行排序，加入到MessageQueue（消息队列）中，MessageQueue更多的细节后面再讲。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Message must have a target.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">&quot; This message is already in use.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">            IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    msg.target + <span class="string">&quot; sending message to a Handler on a dead thread&quot;</span>);</span><br><span class="line">            Log.w(TAG, e.getMessage(), e);</span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        <span class="comment">//1、拿到队列头部消息</span></span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="comment">//2、如果消息不需要延时，或者消息的执行时间比头部消息早，插到队列头部</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span></span><br><span class="line">            <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">            <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="comment">// 3、根据时间，将消息插到队列中合适的位置</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="comment">// 4、唤醒机制</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>22 - 24行：对收到的消息按发送时间进行排序，如果当前消息不需要延时，放到头部；若是延时消息，则根据发送时间放到队列合适位置。</p>
<p><strong>总结一下：sendMessage就是讲消息加到MessageQueue的队列中。</strong></p>
<p>至此，消息的发送过程全部结束了，什么！那消息是怎么分发的呢？我们先给出答案，是通过Looper.loop。</p>
<h2 id="1-3、消息分发"><a href="#1-3、消息分发" class="headerlink" title="1.3、消息分发"></a>1.3、消息分发</h2><p>刚才说了Handler的消息分发是通过Looper.loop，接下来看下代码，上车！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">     <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 1、从Looper中消息队列</span></span><br><span class="line">     <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">         <span class="comment">// 2、从消息队列中取出消息</span></span><br><span class="line">         Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">         <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"><span class="comment">// 省略 ...</span></span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">// 3、调用handler.dispatchMessage</span></span><br><span class="line">             msg.target.dispatchMessage(msg);</span><br><span class="line">             end = (slowDispatchThresholdMs == <span class="number">0</span>) ? <span class="number">0</span> : SystemClock.uptimeMillis();</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                 Trace.traceEnd(traceTag);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     </span><br><span class="line"><span class="comment">//省略 ...</span></span><br><span class="line">         msg.recycleUnchecked();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>主要步骤如下：</p>
<p>6行：从Looper中取出消息队列</p>
<p>9行：开启死循环，然后不断地调用的MessageQueue的next()方法，这个next()方法就是消息队列的出队方法。如果当前MessageQueue中存在待处理的消息，就将这个消息出队，否则就进入一个阻塞状态，一直等到有新的消息入队。</p>
<p>19行：消息分发msg.target的dispatchMessage()方法中，那这里msg.target又是什么呢？其实就是handler，回头看下enqueueMessage。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Handle system messages here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>28行：消息回收过程，这里涉及到Message的回收和复用，后面再讲。</p>
<p><strong>总结一下：Handler通过sendMessage将消息加入到消息队列中，最后在通过Looper.loop从消息队列中逐个取出消息执行。</strong>整体原理如下图所示：</p>
<p><img src="../../pics/image-20210226151751578.png" alt="image-20210226151751578"></p>
<p>好了，Handler的消息分发机制就介绍完了。如果只是想简单了解下Handler机制，到这里就可以了。</p>
<p>就这？当然不！上述介绍过程中涉及到几个概念Looper，MessageQueue，还没详细说呢？我们先来看下Looper。</p>
<h1 id="二、Looper"><a href="#二、Looper" class="headerlink" title="二、Looper"></a>二、Looper</h1><p>通过以上的介绍我们知道Looper是handler中消息分发的核心，那它是怎么来的？我们先来看下Handler的构造函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="meta">@Nullable</span> Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// loop赋值</span></span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()</span><br><span class="line">                    + <span class="string">&quot; that has not called Looper.prepare()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Looper的赋值是通过looper.myLooper()，最终调到了sThreadLocal.get()。这个sThreadLocal又是什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sThreadLocal.get() will return null unless you&#x27;ve called prepare().</span></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br></pre></td></tr></table></figure>

<p>这个sThreadLocal是一个ThreadLocal对象，存的是Looper对象。什么？ThreadLocal也不懂？来来来，先记住个概念，后面再解释：ThreadLocal提供了线程的局部变量，每个线程都可以通过set()和get()来对这个局部变量进行操作，但不会和其他线程的局部变量进行冲突，实现了线程的数据隔离。也就说通<strong>过ThreadLocal可以存取当前线程的Looper对象</strong>。</p>
<p>仔细看sThreadLocal的注释，除非您已调用prepare()，否则sThreadLocal.get()将返回null。那就看下loop.prepare吧。</p>
<h2 id="2-1、loop-prepare"><a href="#2-1、loop-prepare" class="headerlink" title="2.1、loop.prepare"></a>2.1、loop.prepare</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 每个线程只能初始化一次looper</span></span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 注意，这是messageQueue初始化的地方</span></span><br><span class="line">   mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">   mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>10行：新建一个Looper对象并存到sThreadLocal中。</p>
<p>14行：注意这里，handler中的MessageQuee就是Looper初始化时构造出来的。</p>
<p>也就是说，new Hanlder 之前必须要调用 Looper.prepare方法，那为何在主线程中使用是不需要呢？其实Android在程序启动的时候，通过ActivityThread帮我们创建主线程时已经初始化好了，代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line">    <span class="comment">// 1、 主线程Looper.parpare!</span></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">    thread.attach(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">        Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                LogPrinter(Log.DEBUG, <span class="string">&quot;ActivityThread&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2、看这里looper.loop</span></span><br><span class="line">    Looper.loop();</span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3行：调用了 Looper.prepareMainLooper()，再调用到Looper的prepare。</p>
<p>14行：<strong>Looper.looper，开启循环，不停取出消息。主线程中其实先开启循环不停取消息，再才是发送消息。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the current thread as a looper, marking it as an</span></span><br><span class="line"><span class="comment"> * application&#x27;s main looper. See also: &#123;<span class="doctag">@link</span> #prepare()&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@deprecated</span> The main looper for your application is created by the Android environment,</span></span><br><span class="line"><span class="comment"> *   so you should never need to call this function yourself.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The main Looper has already been prepared.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意prepareMainLooper的注释，prepare只能调用一次，ActivityThread中已经调用过了，再调用到这里会报异常（12行）。到这里我们已经搞明白主线程中的looper是怎么来的。刚才遗留了一个问题ThreadLocal是怎么存取Loope，下面就来介绍下ThreadLocal。</p>
<h2 id="2-2、ThreadLocal"><a href="#2-2、ThreadLocal" class="headerlink" title="2.2、ThreadLocal"></a>2.2、ThreadLocal</h2><p>先来看下ThreadLocal的set过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1、获取当前线程</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">// 2、获取当前线程的ThreadMap对象</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 2.1、map不为空存value到map中</span></span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 2.2、map为空则创建map并value存进去</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">                              </span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ThreadLocalMap存储的值是弱引用</span></span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要步骤有2点：</p>
<ol>
<li>获取当前线程的ThreadMap对象 , ThreadMap其实是Thread的一个成员变量，但是是通过ThreadLocal来维护的。Thread.threadLocals为空时先创建。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* ThreadLocal values pertaining to this thread. This map is maintained</span><br><span class="line"> * by the ThreadLocal class. */</span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = null;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>将value值存到ThreadMap中，key是当前threadLocal对象，也就是说一个Thread可以存多个不同ThreadLocal的值，一个ThreadLocal只能存一个值。</li>
</ol>
<p>我们再理解下Looper.myLooper对应的get过程，先获取线程的threadLocals（ThreadMap对象），再通过get（key是当前ThreadLocal对象）获取到looper。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                T result = (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结一下：Looper通过prepare会初始化一个Looper对象，通过ThreadLocal将Thread和Looper对象绑定在一起。Looper.loop会从MessageQueue中不断取出消息，进行分发。</strong></p>
<h1 id="三、MessageQueue"><a href="#三、MessageQueue" class="headerlink" title="三、MessageQueue"></a>三、MessageQueue</h1><p>MessagQueue，顾名思义，消息队列，在Looper的介绍中，我们提到了MessageQueue其实是在Looper构造创建生成的，Handler中的mQueue其实就是Looper.mQueue，Looper和MessageQueue是一一对应的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="meta">@Nullable</span> Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()</span><br><span class="line">                    + <span class="string">&quot; that has not called Looper.prepare()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 看这里</span></span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在前面章节我们讲了sengMessage最终会调用到MessageQueue.enqueueMessage，下面具体分析enqueueMessage的代码。</p>
<h2 id="3-1、消息入队"><a href="#3-1、消息入队" class="headerlink" title="3.1、消息入队"></a>3.1、消息入队</h2><p>关于enqueueMessage消息入队逻辑在1.2节已经介绍过了；除此之外，消息加入队列时，两种情况会唤醒looper.loop，为什么要唤醒，后面再说：</p>
<ol>
<li>（队列为空，消息无需延时或消息执行时间比队列头部消息早) &amp;&amp; (线程处于挂起状态时（mBlocked = true）)</li>
<li>【线程挂起（mBlocked = true）&amp;&amp; 消息循环处于同步屏障状态】，这时如果插入的是一个异步消息，则需要唤醒。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">          <span class="keyword">boolean</span> needWake;</span><br><span class="line">         <span class="comment">//1、队列为空，消息无需延时或消息执行时间比队列头部消息早) &amp;&amp; (线程处于挂起状态时（mBlocked = true）)</span></span><br><span class="line">          <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">              <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">              msg.next = p;</span><br><span class="line">              mMessages = msg;</span><br><span class="line">              needWake = mBlocked;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span></span><br><span class="line">              <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">              <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">              <span class="comment">// 2、线程挂起（mBlocked = true）&amp;&amp; 消息循环处于同步屏障状态】，这时如果插入的是一个异步消息，则需要唤醒。</span></span><br><span class="line">              needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">              Message prev;</span><br><span class="line">              <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                  prev = p;</span><br><span class="line">                  p = p.next;</span><br><span class="line">                  <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                      needWake = <span class="keyword">false</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">              prev.next = msg;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">          <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">              nativeWake(mPtr);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2、消息出队"><a href="#3-2、消息出队" class="headerlink" title="3.2、消息出队"></a>3.2、消息出队</h2><p>在1.3节我们介绍过Looper.Looper负责消息出队，其实是通过Queue.next()取队列中的消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">    <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">    <span class="comment">// which is not supported.</span></span><br><span class="line">    <span class="comment">// 1、通过Looper.quit调用到Message.quit后会执行到这里</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2、nextPollTimeoutMillis = -1 阻塞</span></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">            Message msg = mMessages;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 3、屏障消息</span></span><br><span class="line">                <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// 4、时间没到，设定下次唤醒的时间</span></span><br><span class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Got a message.</span></span><br><span class="line">                    mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">           <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">           <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">          	<span class="comment">// 第一次执行时，确定IdleHandler的数目</span></span><br><span class="line">           <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                   &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">               pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">               mBlocked = <span class="keyword">true</span>;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">               mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">           &#125;</span><br><span class="line">           mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run the idle handlers.</span></span><br><span class="line">        <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">        <span class="comment">// 遍历执行idleHandler</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="comment">// 非keep的执行完后移除掉</span></span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">        <span class="comment">// idleHandler</span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line">        <span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要的步骤：</p>
<ol>
<li><p>判断MessageQueue是不是退出了，如果退出，整个Looper.loop都退出，通常是通过调用Looper.quit退出。</p>
</li>
<li><p>nativePollOnce，我们知道Looper.looper是一个死循环，如果没有消息，还会继续执行吗？显然不可能，在消息队列为空的时候，Looper实际上处于休眠状态，当nextPollTimeoutMillis =-1 时阻塞，CPU进入休眠；对于deleyMessage，nextPollTimeoutMillis&gt;0，时间到了后唤醒。Message Queue共有2种情况唤醒：1.加入消息新消息时唤醒（上一节介绍过） ；2.delayMsg时间到了唤醒。</p>
<p>那么是怎么实现的呢？这里涉及到linux的epoll机制，handler这里就不展开讲了，参考（<a href="https://mp.weixin.qq.com/s/H8mHoYHyTe6oOaUwfYh6_g%EF%BC%89%E3%80%82">https://mp.weixin.qq.com/s/H8mHoYHyTe6oOaUwfYh6_g）。</a></p>
</li>
<li><p>屏障消息和idleHandler相关，后面介绍。</p>
</li>
</ol>
<p><strong>总结一下：MessageQueue负责消息的存取，Looper的looper并不会一直执行，当nativePollOnce的参数nextPollTimeoutMillis=-1时会休眠，唤醒有2种方式一种是队列有新消息入队时；另一种是delayMsg时刻到了。</strong></p>
<h1 id="四、Message"><a href="#四、Message" class="headerlink" title="四、Message"></a>四、Message</h1><p>先看下Message的数据结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> what;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> arg1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> arg2;</span><br><span class="line">    <span class="keyword">public</span> Object obj;</span><br><span class="line">    <span class="keyword">public</span> Messenger replyTo; <span class="comment">// Messager对象</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">long</span> when; <span class="comment">//消息发送时间</span></span><br><span class="line">    <span class="comment">/*package*/</span> <span class="keyword">int</span> flags; <span class="comment">// 标记消息消息类型是否是异步</span></span><br><span class="line">    <span class="comment">/*package*/</span> Handler target; <span class="comment">//指向接收消息的handler</span></span><br><span class="line">    <span class="comment">/*package*/</span> Message next; <span class="comment">//指向下一个消息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Message sPool; <span class="comment">// Message内部复用队列的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Message对象都有一个同类型的next字段，这个next字段指向的就是下一个可用的Message，最后Message的next为空，组成Message链表，sPool 永远指向的是整个链表的第一个元素。</p>
<h2 id="4-1、Message的复用机制"><a href="#4-1、Message的复用机制" class="headerlink" title="4.1、Message的复用机制"></a>4.1、Message的复用机制</h2><p>通常我们获取一个Message都是通过Message的obtain方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// sometimes we store linked lists of these things</span></span><br><span class="line">    <span class="comment">/*package*/</span> Message next;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object sPoolSync = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Message sPool;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sPoolSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * Return a new Message instance from the global pool. Allows us to</span></span><br><span class="line"><span class="comment">      * avoid allocating new objects in many cases.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Message m = sPool;</span><br><span class="line">                sPool = m.next;</span><br><span class="line">                m.next = <span class="keyword">null</span>;</span><br><span class="line">                m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">                sPoolSize--;</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Message();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>17 - 18行，当使用obtain方法获取一个Message对象时，其实获取的就是链表中的第一个元素，同时将sPool在指向下一个Message。</p>
<p>那么这些Message对象是在什么时候被放到链表中的呢，在Message类的说明中有这样一句话：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">While the constructor of Message is public, the best way to getone of these is to call &#123;@link #obtain Message.obtain()&#125; or one of the methods, which will pull them from a pool of recycled objects。</span><br></pre></td></tr></table></figure>

<p>原来在创建Message时不会将Message放入队列而是在recycle时才会加入到队列，让我们先来看下recylce方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isInUse()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (gCheckRecycle) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;This message cannot be recycled because it &quot;</span></span><br><span class="line">                    + <span class="string">&quot;is still in use.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    recycleUnchecked();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recycles a Message that may be in-use.</span></span><br><span class="line"><span class="comment"> * Used internally by the MessageQueue and Looper when disposing of queued Messages.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Mark the message as in use while it remains in the recycled object pool.</span></span><br><span class="line">    <span class="comment">// Clear out all other details.</span></span><br><span class="line">    flags = FLAG_IN_USE;</span><br><span class="line">    what = <span class="number">0</span>;</span><br><span class="line">    arg1 = <span class="number">0</span>;</span><br><span class="line">    arg2 = <span class="number">0</span>;</span><br><span class="line">    obj = <span class="keyword">null</span>;</span><br><span class="line">    replyTo = <span class="keyword">null</span>;</span><br><span class="line">    sendingUid = -<span class="number">1</span>;</span><br><span class="line">    when = <span class="number">0</span>;</span><br><span class="line">    target = <span class="keyword">null</span>;</span><br><span class="line">    callback = <span class="keyword">null</span>;</span><br><span class="line">    data = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">            next = sPool;</span><br><span class="line">            sPool = <span class="keyword">this</span>;</span><br><span class="line">            sPoolSize++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>12- 8行：判断Message是否在被使用中，如果没有，则执行回收操作。</p>
<p>19-35行：回收先清空Message的各字段，并将flag置为FLAG_IN_USE，这个flag在obtain时会被置为0。然后继续判断是否要将该消息放17到回收池中，如果池的大小小于MAX_POOL_SIZE（50），那么就进行链表操作，将这个Message放到链表的表头。</p>
<p>总结一下：Message 通过在内部构建一个链表维护一个被回收的Message对象的对象池，当用户调用obtain函数时优先从池中获取，如果池中没有可以复用的对象则创建一个新的Message对象。这些新创建的Message对象再被使用完之后会被回收到这个对象池中，当下次再调用obtain函数时，他们就会被复用。<br>结合的Looper.loop方法，在使用完一个Message对象后就将会将它回收，避免系统中创建太多Message对象。</p>
<h2 id="4-2、同步消息、屏障消息和异步消息"><a href="#4-2、同步消息、屏障消息和异步消息" class="headerlink" title="4.2、同步消息、屏障消息和异步消息"></a>4.2、同步消息、屏障消息和异步消息</h2><p>在Handler构造函数，如果看到的足够仔细的话</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="meta">@Nullable</span> Callback callback, <span class="keyword">boolean</span> async)</span> </span></span><br></pre></td></tr></table></figure>

<p>我们会发现构造参数里有个async，异步？这个参数代表什么意思？</p>
<p>其实在MessageQueue中消息有三种类型：同步消息，异步消息以及屏障消息。</p>
<h3 id="4-1-1、同步消息"><a href="#4-1-1、同步消息" class="headerlink" title="4.1.1、同步消息"></a>4.1.1、同步消息</h3><p>默认的消息类型，同步消息在MessageQueue里的存和取完全就是按照时间（msg.when）排序的。</p>
<h3 id="4-1-2、异步消息"><a href="#4-1-2、异步消息" class="headerlink" title="4.1.2、异步消息"></a>4.1.2、异步消息</h3><p>异步消息有2种构造方式：</p>
<ol>
<li>handler构造参数指定 async =true</li>
<li>Message构造时，指定setAsynchronous（true）</li>
</ol>
<p>在sendMessage中，我们可以看到这2者的关系</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(<span class="meta">@NonNull</span> MessageQueue queue, <span class="meta">@NonNull</span> Message msg,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    msg.target = <span class="keyword">this</span>;</span><br><span class="line">    msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line">	<span class="comment">// mAsynchronous 就是构造参数中的 async </span></span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若Handler的构造参数中的async设置为true，该Handler所有的消息都会被设置为异步消息。</p>
<h3 id="4-1-3、屏障消息"><a href="#4-1-3、屏障消息" class="headerlink" title="4.1.3、屏障消息"></a>4.1.3、屏障消息</h3><p>屏障(Barrier) 是一种特殊的Message，它最大的特征就是target为null(只有屏障的target可以为null，如果我们自己设置Message的target为null的话会报异常)，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Message must have a target.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且arg1属性被用作屏障的标识符来区别不同的屏障。屏障的作用是用于拦截队列中同步消息，放行异步消息。</p>
<p>那么屏障消息是怎么被添加和删除的呢？ 我们可以看到在MessageQueue里有添加和删除屏障消息的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">(<span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Enqueue a new sync barrier token.</span></span><br><span class="line">    <span class="comment">// We don&#x27;t need to wake the queue because the purpose of a barrier is to stall it.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> token = mNextBarrierToken++;</span><br><span class="line">        <span class="keyword">final</span> Message msg = Message.obtain();</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        msg.arg1 = token;</span><br><span class="line"></span><br><span class="line">        Message prev = <span class="keyword">null</span>;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">         <span class="comment">// 根据时间找到第一个比屏障消息晚的消息，将屏障消息插入到该消息之前；</span></span><br><span class="line">         <span class="comment">// 屏障只会影响到队列中它之后的消息</span></span><br><span class="line">        <span class="keyword">if</span> (when != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.when &lt;= when) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果prev是null,屏障消息插入到消息队列的头部</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeSyncBarrier</span><span class="params">(<span class="keyword">int</span> token)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Remove a sync barrier token from the queue.</span></span><br><span class="line">        <span class="comment">// If the queue is no longer stalled by a barrier then wake it.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            Message prev = <span class="keyword">null</span>;</span><br><span class="line">            Message p = mMessages;</span><br><span class="line">        <span class="comment">// 前面在插入屏障消息后会生成一个token，这个token就是用来删除该屏障消息用的。</span></span><br><span class="line">        <span class="comment">// 所以这里通过判断target和token来找到该屏障消息，从而进行删除操作</span></span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; (p.target != <span class="keyword">null</span> || p.arg1 != token)) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The specified message queue synchronization &quot;</span></span><br><span class="line">                        + <span class="string">&quot; barrier token has not been posted or has already been removed.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> needWake;</span><br><span class="line">            <span class="comment">// 删除屏障消息，原理是链表的删除</span></span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                prev.next = p.next;</span><br><span class="line">                needWake = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mMessages = p.next;</span><br><span class="line">                needWake = mMessages == <span class="keyword">null</span> || mMessages.target != <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p.recycleUnchecked();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the loop is quitting then it is already awake.</span></span><br><span class="line">            <span class="comment">// We can assume mPtr != 0 when mQuitting is false.</span></span><br><span class="line">            <span class="comment">// 屏障消息删除后可再次之前的同步消息</span></span><br><span class="line">            <span class="keyword">if</span> (needWake &amp;&amp; !mQuitting) &#123;</span><br><span class="line">                nativeWake(mPtr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>介绍完屏障消息的插入和删除，那么屏障消息的作用是什么？和同步及异步消息有何关系呢？ 我们可以看到MessageQueue的next方法里有这么一段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前消息是屏障消息时（msg.target==null）, 如果存在屏障消息，那么在它之后进来的消息中，只放行异步消息</span></span><br><span class="line"><span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prevMsg = msg;</span><br><span class="line">        msg = msg.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入屏障消息后，只放行队列中的异步消息，在Android系统里面为了更快响应UI刷新在<strong>ViewRootImpl.scheduleTraversals</strong>也有应用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 1、为主线程的MessageQueue设置了个消息屏障</span></span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        <span class="comment">// 2、这里发送了个异步消息mTraversalRunnable，这个mTraversalRunnable最终会执行doTraversal(),也就是会触发View的绘制流程</span></span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line"> 		</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// postCallback 经过层层调用到这里Choreographer.postCallbackDelayedInternal</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postCallbackDelayedInternal</span><span class="params">(<span class="keyword">int</span> callbackType,</span></span></span><br><span class="line"><span class="params"><span class="function">        Object action, Object token, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">  		<span class="comment">// 省略...</span></span><br><span class="line">        <span class="keyword">if</span> (dueTime &lt;= now) &#123;</span><br><span class="line">            scheduleFrameLocked(now);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">            msg.arg1 = callbackType;</span><br><span class="line">            <span class="comment">// 设置为异步消息</span></span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">            mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>scheduleTraversals时通过设置屏障消息，会把主线程的同步消息先阻塞，优先执行View绘制这个异步消息进行界面绘制。让界面绘制的任务优先执行，避免出现界面卡顿。</p>
<p>另外App层如果发送同步屏障postSyncBarrier需要反射才能使用，Android不建议使用，主线程中滥用的话就是和界面绘制抢资源了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postSyncBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Method method = MessageQueue.class.getDeclaredMethod(<span class="string">&quot;postSyncBarrier&quot;</span>);</span><br><span class="line">  token = (<span class="keyword">int</span>) method.invoke(Looper.getMainLooper().getQueue());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeSyncBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Method method = MessageQueue.class.getDeclaredMethod(<span class="string">&quot;removeSyncBarrier&quot;</span>, <span class="keyword">int</span>.class);</span><br><span class="line">   method.invoke(Looper.getMainLooper().getQueue(), token);&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="五、IdleHandler"><a href="#五、IdleHandler" class="headerlink" title="五、IdleHandler"></a>五、IdleHandler</h1><p>IdleHandler，空闲的处理器（就是说我是在消息队列空闲的时候才会执行的，如果消息队列里有其他非IdleHandler消息在执行，则我先不执行），它其实就是一个接口，我们就认为它是空闲消息吧，只不过它不是存在MessageQueue里，而是以数组的形式保存的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Callback interface for discovering when a thread is going to block</span><br><span class="line"> * waiting for more messages.</span><br><span class="line"> */</span><br><span class="line">public static interface IdleHandler &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Called when the message queue has run out of messages and will now</span><br><span class="line">     * wait for more.  Return true to keep your idle handler active, false</span><br><span class="line">     * to have it removed.  This may be called if there are still messages</span><br><span class="line">     * pending in the queue, but they are all scheduled to be dispatched</span><br><span class="line">     * after the current time.</span><br><span class="line">     */</span><br><span class="line">    boolean queueIdle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MessageQueue有添加和删除IdleHandler的方法，IdleHandler被保存在一个ArrayList里：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;IdleHandler&gt; mIdleHandlers = <span class="keyword">new</span> ArrayList&lt;IdleHandler&gt;();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addIdleHandler</span><span class="params">(<span class="meta">@NonNull</span> IdleHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;Can&#x27;t add a null IdleHandler&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        mIdleHandlers.add(handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeIdleHandler</span><span class="params">(<span class="meta">@NonNull</span> IdleHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        mIdleHandlers.remove(handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，它是怎么实现在消息队列空闲的间隙得到执行的呢？细心的同学应该注意到了，也是在MessageQueue.next()方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">    <span class="comment">// 1、这个参数很重要，控制</span></span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">          	<span class="comment">// 省略...</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">            <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">            <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">            <span class="comment">// 首次for循环 &amp;&amp; 消息队列处于空闲 当前消息队列没有消息或者要执行的消息晚于当前时间</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                <span class="comment">// 赋值</span></span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run the idle handlers.</span></span><br><span class="line">        <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果queueIdle返回true，则该空闲消息不会被自动删除，在下次执行next的时候，如果还出现队列空闲，会再次执行。</span></span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果返回false，则该空闲消息会在执行完后，被自动删除掉。</span></span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">        <span class="comment">// 这里把空闲消息标志置为0，而不置为-1，防止一直执行；一直到下一次调用 MessageQueue.next() 方法.</span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当执行了 IdleHander 之后, 会消耗一段时间, 这时候消息队列里可能已经有消息到达可执行时间, 所以重置 nextPollTimeoutMillis 回去重新检查消息队列.</span></span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下：<code>IdleHandler</code>是在<code>MessageQueuer</code>队列空闲时执行的且只会执行一次，但如果将<code>queueIdle</code>的返回值改为<code>true</code>，会在每一次<code>MessageQueue.next</code>方法执行时在执行一次，也就是说如果队列中有新的消息到达就会再次执行。</p>
<h1 id="六、常见问题"><a href="#六、常见问题" class="headerlink" title="六、常见问题"></a>六、常见问题</h1><h2 id="6-1、子线程中更新UI的方法"><a href="#6-1、子线程中更新UI的方法" class="headerlink" title="6.1、子线程中更新UI的方法"></a>6.1、子线程中更新UI的方法</h2><p>除了Handler的sendMessage和post之外，我们还有以下2种方法可以在子线程中进行UI操作，一句话解释完，请看注释！！！</p>
<h3 id="6-1-1、View的post-方法"><a href="#6-1-1、View的post-方法" class="headerlink" title="6.1.1、View的post()方法"></a>6.1.1、View的post()方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Causes the Runnable to be added to the message queue.</span></span><br><span class="line"><span class="comment"> * The runnable will be run on the user interface thread.&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class="line">    <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> attachInfo.mHandler.post(action);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Postpone the runnable until we know on which thread it needs to run.</span></span><br><span class="line">    <span class="comment">// Assume that the runnable will be successfully placed after attach.</span></span><br><span class="line">    getRunQueue().post(action);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-1-2、Activity的runOnUiThread-方法"><a href="#6-1-2、Activity的runOnUiThread-方法" class="headerlink" title="6.1.2、Activity的runOnUiThread()方法"></a>6.1.2、Activity的runOnUiThread()方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Runs the specified action on the UI thread. If the current thread is the UI</span></span><br><span class="line"><span class="comment">* thread, then the action is executed immediately. If the current thread is</span></span><br><span class="line"><span class="comment">* not the UI thread, the action is posted to the event queue of the UI thread.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> action the action to run on the UI thread</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runOnUiThread</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (Thread.currentThread() != mUiThread) &#123;</span><br><span class="line">           mHandler.post(action);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           action.run();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-2、主线程中Looper-Loop的不会卡死？"><a href="#6-2、主线程中Looper-Loop的不会卡死？" class="headerlink" title="6.2、主线程中Looper.Loop的不会卡死？"></a>6.2、主线程中Looper.Loop的不会卡死？</h2><p>1、Looper.Loop会调用到MessageQueue.next()方法，没有消息时会阻塞在nativePollOnce，此时主线程会释放CPU进入休眠状态，并不会消耗CPU资源。直到有下个消息到达，这里依赖的是Linux pipe/epoll机制。</p>
<p>2、ANR的原理，任务再特定时间内没有执行完。以Service ANR原理为例，首先startService之后，经过一系列的调用，最终会调用到AMS的startService相关方法，发送一个SERVICE_TIMEOUT_MSG的延时消息；紧接着再通过消息机制调用到ActivityThread.H.handleMessag中先执行Service的onCreate，再回到AMS找中，执行serviceDoneExecuting，移除SERVICE_TIMEOUT_MSG消息。也就是说如果onCreate执行时间过长导致SERVICE_TIMEOUT_MSG消息没有被及时移除，就会触发ANR。这里涉及到2个handler，一个ActivityThread，一个是AMS的，ActivityThread的Handler是和应用主线程绑定的；而AMS.MainHandler是SystemServer的ServerThread绑定的，用于处理service、process、provider的超时问题。另外input的超时处理过程并非发生在ActivityManager线程，而是inputDispatcher线程发生的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>Looper 作为消息循环的核心，其内部包含了一个消息队列 MessageQueue ，用于记录所有待处理的消息；Handler通过sendMessage添加消息，通过Looper.loop()不断地从MessageQueue中抽取Message，按分发机制将消息分发给目标处理者，可以看成是消息泵。注意，线程切换就是在这一步完成的。</li>
<li>MessageQueue 则作为一个消息队列，则包含了一系列链接在一起的 Message ；不要被这个Queue的名字给迷惑了，就以为它是一个队列，但其实内部通过单链表的数据结构来维护消息列表，等待Looper的抽取。</li>
<li>Message 则是消息体，内部又包含了一个目标处理器 target ，这个 target 正是最终处理它的 Handler。</li>
<li><strong>Looper和Thread以及MessageQueue是一一对应的</strong>，<strong>而一个Handler只能关联一个Looper，一个Looper可以关联多个Handler</strong>, Handler的messagequeue就是Looper的messagequeue。  </li>
</ul>
<p><strong>参考资料：</strong><br><a href="http://blog.csdn.net/guolin_blog/article/details/9991569">http://blog.csdn.net/guolin_blog/article/details/9991569</a></p>
<p><a href="https://juejin.cn/post/6844904068129751047">https://juejin.cn/post/6844904068129751047</a></p>
<p><a href="https://mp.weixin.qq.com/s/H8mHoYHyTe6oOaUwfYh6_g">https://mp.weixin.qq.com/s/H8mHoYHyTe6oOaUwfYh6_g</a></p>
<p><a href="https://mp.weixin.qq.com/s/71OV_K7YJas7pLtsPY-jeQ">https://mp.weixin.qq.com/s/71OV_K7YJas7pLtsPY-jeQ</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>Framework</category>
      </categories>
  </entry>
  <entry>
    <title>FrameWork_03_Binder架构</title>
    <url>/2021/06/06/Notes/Android/04Framework/FrameWork_03_Binder%20%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h1 id="FrameWork-03-Binder-架构"><a href="#FrameWork-03-Binder-架构" class="headerlink" title="FrameWork_03_Binder 架构"></a>FrameWork_03_Binder 架构</h1><span id="more"></span>

<p>Binder通信采用C/S架构，从组件视角来说，包含Client、Server、ServiceManager以及Binder驱动，其中ServiceManager用于管理系统中的各种服务。架构图如下所示：</p>
<img src="/pics/image-20210606151407737.png" alt="image-20210606151407737" style="zoom:50%;" />

<p>可以看出无论是注册服务和获取服务的过程都需要ServiceManager，需要注意的是此处的Service Manager是指Native层的ServiceManager（C++），并非指framework层的ServiceManager(Java)。ServiceManager是整个Binder通信机制的大管家，是Android进程间通信机制Binder的守护进程，要掌握Binder机制，首先需要了解系统是如何首次<a href="http://gityuan.com/2015/11/07/binder-start-sm/">启动Service Manager</a>。当Service Manager启动之后，Client端和Server端通信时都需要先<a href="http://gityuan.com/2015/11/08/binder-get-sm/">获取Service Manager</a>接口，才能开始通信服务。</p>
<p>图中Client/Server/ServiceManage之间的相互通信都是基于Binder机制。既然基于Binder机制通信，那么同样也是C/S架构，则图中的3大步骤都有相应的Client端与Server端。</p>
<ol>
<li>**<a href="http://gityuan.com/2015/11/14/binder-add-service/">注册服务(addService)</a>**：Server进程要先注册Service到ServiceManager。该过程：Server是客户端，ServiceManager是服务端。</li>
<li>**<a href="http://gityuan.com/2015/11/15/binder-get-service/">获取服务(getService)</a>**：Client进程使用某个Service前，须先向ServiceManager中获取相应的Service。该过程：Client是客户端，ServiceManager是服务端。</li>
<li><strong>使用服务</strong>：Client根据得到的Service信息建立与Service所在的Server进程通信的通路，然后就可以直接与Service交互。该过程：client是客户端，server是服务端。</li>
</ol>
<p>图中的Client,Server,Service Manager之间交互都是虚线表示，是由于它们彼此之间不是直接交互的，而是都通过与<a href="http://gityuan.com/2015/11/01/binder-driver/">Binder驱动</a>进行交互的，从而实现IPC通信方式。其中Binder驱动位于内核空间，Client,Server,Service Manager位于用户空间。Binder驱动和Service Manager可以看做是Android平台的基础架构，而Client和Server是Android的应用层，开发人员只需自定义实现client、Server端，借助Android的基本平台架构便可以直接进行IPC通信。</p>
<p>下面我们先来了解下Android 中binder驱动的核心方法。</p>
<h3 id="Binder驱动"><a href="#Binder驱动" class="headerlink" title="Binder驱动"></a>Binder驱动</h3><p>Client进程通过RPC(Remote Procedure Call Protocol)与Server通信，可以简单地划分为三层，驱动层、IPC层、业务层。<code>demo()</code>便是Client端和Server共同协商好的统一方法；handle、RPC数据、代码、协议这4项组成了IPC层的数据，通过IPC层进行数据传输；而真正在Client和Server两端建立通信的基础设施便是Binder Driver。</p>
<img src="/pics/image-20210606153003357.png" alt="image-20210606153003357" style="zoom:40%;" />

<p>Binder驱动是Android专用的，但底层的驱动架构与Linux驱动一样。binder驱动在以misc设备进行注册，作为虚拟字符设备，没有直接操作硬件，只是对设备内存的处理。主要是驱动设备的初始化(binder_init)，打开 (binder_open)，映射(binder_mmap)，数据操作(binder_ioctl)。</p>
<img src="/pics/image-20210606152124763.png" alt="image-20210606152124763" style="zoom:50%;" />

<ul>
<li>binder_init：初始化字符设备</li>
<li>binder_open：打开驱动设备</li>
<li>binder_mmap：首先在内核虚拟地址空间，申请一块与用户虚拟内存相同大小的内存；然后再申请1个page大小的物理内存，再将<strong>同一块物理内存分别映射到内核虚拟地址空间和用户虚拟内存空间</strong>，从而实现了用户空间的Buffer和内核空间的Buffer同步操作的功能。</li>
<li>binder_ioctl：binder_ioctl()函数负责在两个进程间收发IPC数据和IPC reply数据。</li>
</ul>
<p><strong>系统调用</strong></p>
<p>用户态的程序调用Kernel层驱动是需要陷入内核态，进行系统调用(<code>syscall</code>)，比如打开Binder驱动方法的调用链为： open-&gt; __open() -&gt; binder_open()。 open()为用户空间的方法，__open()便是系统调用中相应的处理方法，通过查找，对应调用到内核binder驱动的binder_open()方法，至于其他的从用户态陷入内核态的流程也基本一致。</p>
<img src="/pics/image-20210606152245305.png" alt="image-20210606152245305" style="zoom:40%;" />

<p>简单说，当用户空间调用open()方法，最终会调用binder驱动的binder_open()方法；mmap()/ioctl()方法也是同理，在BInder系列的后续文章从用户态进入内核态，都依赖于系统调用过程。</p>
<h3 id="ServiceManager"><a href="#ServiceManager" class="headerlink" title="ServiceManager"></a>ServiceManager</h3><p>ServiceManger集中管理系统内的所有服务，通过权限控制进程是否有权注册服务,通过字符串名称来查找对应的Service; 由于ServiceManger进程建立跟所有向其注册服务的死亡通知, 那么当服务所在进程死亡后, 会只需告知ServiceManager. 每个Client通过查询ServiceManager可获取Server进程的情况，降低所有Client进程直接检测会导致负载过重。</p>
<h4 id="ServiceManager启动过程"><a href="#ServiceManager启动过程" class="headerlink" title="ServiceManager启动过程"></a>ServiceManager启动过程</h4><p>ServiceManager是Binder IPC通信过程中的守护进程，本身也是一个Binder服务，但并没有采用libbinder中的多线程模型来与Binder驱动通信，而是自行编写了binder.c直接和Binder驱动来通信，并且只有一个循环binder_loop来进行读取和处理事务，这样的好处是简单而高效。</p>
<p><strong>ServiceManager启动流程：</strong></p>
<ol>
<li>打开binder驱动，并调用mmap()方法分配128k的内存映射空间：binder_open();</li>
<li>通知binder驱动使其成为守护进程：binder_become_context_manager()；</li>
<li>验证selinux权限，判断进程是否有权注册或查看指定服务；</li>
<li>进入循环状态，等待Client端的请求：binder_loop()。</li>
<li>注册服务的过程，根据服务名称，但同一个服务已注册，重新注册前会先移除之前的注册信息；</li>
<li>死亡通知: 当binder所在进程死亡后,会调用binder_release方法,然后调用binder_node_release.这个过程便会发出死亡通知的回调.</li>
</ol>
<p>ServiceManager最核心的两个功能为查询和注册服务：</p>
<ul>
<li>注册服务：记录服务名和handle信息，保存到svclist列表；</li>
<li>查询服务：根据服务名查询相应的的handle信息。</li>
</ul>
<h4 id="获取ServiceManager"><a href="#获取ServiceManager" class="headerlink" title="获取ServiceManager"></a>获取ServiceManager</h4><p>获取Service Manager是通过<code>defaultServiceManager()</code>方法来完成，当进程<a href="http://gityuan.com/2015/11/14/binder-add-service/">注册服务(addService)</a>或 <a href="http://gityuan.com/2015/11/15/binder-get-service/">获取服务(getService)</a>的过程之前，都需要先调用defaultServiceManager()方法来获取<code>gDefaultServiceManager</code>对象。对于gDefaultServiceManager对象，如果存在则直接返回；如果不存在则创建该对象，创建过程包括调用open()打开binder驱动设备，利用mmap()映射内核的地址空间。</p>
<h3 id="注册服务"><a href="#注册服务" class="headerlink" title="注册服务"></a>注册服务</h3><p>Media服务注册的过程涉及到MediaPlayerService(作为Client进程)和Service Manager(作为Service进程)，通信流程图如下所示</p>
<img src="/pics/image-20210606155146718.png" alt="image-20210606155146718" style="zoom:50%;" />

<ol>
<li><code>BINDER_COMMAND_PROTOCOL</code>：binder请求码，以”BC_“开头，简称BC码，用于从IPC层传递到Binder Driver层；</li>
<li><code>BINDER_RETURN_PROTOCOL</code> ：binder响应码，以”BR_“开头，简称BR码，用于从Binder Driver层传递到IPC层；</li>
</ol>
<h3 id="获取服务"><a href="#获取服务" class="headerlink" title="获取服务"></a>获取服务</h3><p>BpBinder(客户端)和BBinder(服务端)都是Android中Binder通信相关的代表，它们都从IBinder类中派生而来，关系图如下：</p>
<img src="/pics/image-20210606161156966.png" alt="image-20210606161156966" style="zoom:50%;" />

<ul>
<li>client端：BpBinder.transact()来发送事务请求；</li>
<li>server端：BBinder.onTransact()会接收到相应事务。</li>
</ul>
<p>请求服务(getService)过程，就是向servicemanager进程查询指定服务，当执行binder_transaction()时，会区分请求服务所属进程情况。</p>
<ol>
<li>当请求服务的进程与服务属于不同进程，则为请求服务所在进程创建binder_ref对象，指向服务进程中的binder_node;<ul>
<li>最终readStrongBinder()，返回的是BpBinder对象；</li>
</ul>
</li>
<li>当请求服务的进程与服务属于同一进程，则不再创建新对象，只是引用计数加1，并且修改type为BINDER_TYPE_BINDER或BINDER_TYPE_WEAK_BINDER。<ul>
<li>最终readStrongBinder()，返回的是BBinder对象的真实子类；</li>
</ul>
</li>
</ol>
<h3 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h3><p>binder在framework层，采用JNI技术来调用native(C/C++)层的binder架构，从而为上层应用程序提供服务。 看过binder系列之前的文章，我们知道native层中，binder是C/S架构，分为Bn端(Server)和Bp端(Client)。对于java层在命名与架构上非常相近，同样实现了一套IPC通信架构。</p>
<img src="/pics/image-20210606161741080.png" alt="image-20210606161741080" style="zoom:40%;" />

<ul>
<li>图中红色代表整个framework层 binder架构相关组件；<ul>
<li>Binder类代表Server端，BinderProxy类代码Client端；</li>
</ul>
</li>
<li>图中蓝色代表Native层Binder架构相关组件；</li>
<li>上层framework层的Binder逻辑是建立在Native层架构基础之上的，核心逻辑都是交予Native层方法来处理。</li>
<li>framework层的ServiceManager类与Native层的功能并不完全对应，framework层的ServiceManager类的实现最终是通过BinderProxy传递给Native层来完成的，后面会详细说明。</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
        <category>Framework</category>
      </categories>
  </entry>
  <entry>
    <title>FrameWork_04_AMS</title>
    <url>/2021/06/06/Notes/Android/04Framework/FrameWork_04_Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="FrameWork-04-Activity启动流程"><a href="#FrameWork-04-Activity启动流程" class="headerlink" title="FrameWork_04_Activity启动流程"></a>FrameWork_04_Activity启动流程</h1><span id="more"></span>

<h2 id="Launcher-启动App过程"><a href="#Launcher-启动App过程" class="headerlink" title="Launcher 启动App过程"></a>Launcher 启动App过程</h2><p>以桌面（Launcher）启动Activity为例，Activity启动过程可以分为如下步骤：</p>
<p><img src="/pics/image-20210613151222905.png" alt="image-20210613151222905"></p>
<p>图解：</p>
<ol>
<li><p>Launcher 通知 AMS</p>
<p>通过<code> AMN （ActivityManagerNative）/ AMP（ActivityManagerProxy）</code>调用到<code>sytem_server</code>进程的<code>AMS</code>，使用的是Binder通信。</p>
</li>
<li><p>AMS 处理 Launcher 传递过来的信息，有3步:</p>
<ul>
<li>通过 <code>PMS(PackageManagerService)</code> 校验intent是否有效</li>
<li>通知<code>Launcher</code> pause，这里也涉及一次Binder通信，使用的是<code>ATN（ApplicationThreadNative）ATP（ApplicationThreadProxy）</code>，此时的client是AMS，server端 是Launcher。</li>
<li>启动Activity，在Activity 所在进程没启动的情况下，需要先启动activity进程。</li>
</ul>
</li>
<li><p>AMS启动新的进程</p>
<p>AMS 通过 <code>startProcessLocked </code>调用到 <code>zygote</code> 进程，通过<code>fork</code> 方式创建一个新App进程。这个过程使用的是 socket 通信</p>
<img src="/pics/image-20210613151425352.png" alt="image-20210613151425352" style="zoom:30%;" />

<p>​                                (<a href="http://gityuan.com/2016/10/09/app-process-create-2/">Android四大组件与进程启动的关系</a>)</p>
</li>
<li><p>新进程启动，绑定AMS</p>
<p>App启动后，首先进入<code>ActivityThread</code>的main 方法中：</p>
<ol>
<li>创建主线程Looper </li>
<li>创建 Application</li>
<li>最后通过Binder IPC向<code>sytem_server</code>进程<code>AMS</code>发起<code>attachApplication</code>请求；</li>
</ol>
</li>
<li><p>AMS中确定要启动的Activity</p>
<p>AMS 中保存的 第一个阶段 获取到要启动的Activity信息，经过多次调用，最后会通过ATP，使用Binder IPC向App进程发送scheduleLaunchActivity请求；</p>
</li>
<li><p>启动相应的Activtity</p>
<p>主线程在收到Message后，通过反射机制创建目标Activity，并回调Activity.onCreate()等方法</p>
</li>
</ol>
<h2 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h2><h3 id="ActivityThread"><a href="#ActivityThread" class="headerlink" title="ActivityThread"></a>ActivityThread</h3><h3 id="ApplicationThread"><a href="#ApplicationThread" class="headerlink" title="ApplicationThread"></a>ApplicationThread</h3><h4 id="ApplicationThreadProxy"><a href="#ApplicationThreadProxy" class="headerlink" title="ApplicationThreadProxy"></a>ApplicationThreadProxy</h4><h4 id="ApplicationThreadNative"><a href="#ApplicationThreadNative" class="headerlink" title="ApplicationThreadNative"></a>ApplicationThreadNative</h4><h3 id="ActivityMangerService"><a href="#ActivityMangerService" class="headerlink" title="ActivityMangerService"></a>ActivityMangerService</h3><h4 id="ActivityMangerProxy"><a href="#ActivityMangerProxy" class="headerlink" title="ActivityMangerProxy"></a>ActivityMangerProxy</h4><h4 id="ActivityManagerNative"><a href="#ActivityManagerNative" class="headerlink" title="ActivityManagerNative"></a>ActivityManagerNative</h4><h3 id="ActivityStackSupervisor"><a href="#ActivityStackSupervisor" class="headerlink" title="ActivityStackSupervisor"></a>ActivityStackSupervisor</h3><h3 id="ActivityStack"><a href="#ActivityStack" class="headerlink" title="ActivityStack"></a>ActivityStack</h3><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>上述的过程是基于 Android 6.0，Andorid 11 上 AMN/AMP 的 实现变为了<code>ActivityTaskManagerService</code>,但核心的流程并未发生变化。</p>
<p><a href="http://gityuan.com/2016/03/12/start-activity/">Android6.0 startActivity启动过程分析</a></p>
<p><a href="https://calmcenter.club/2020/android-framework-activity">Android 11 Activity 启动分析</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>Framework</category>
      </categories>
  </entry>
  <entry>
    <title>FrameWork_05_View绘制流程</title>
    <url>/2021/06/20/Notes/Android/04Framework/FrameWork_05_View%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="FrameWork-05-View绘制流程"><a href="#FrameWork-05-View绘制流程" class="headerlink" title="FrameWork_05_View绘制流程"></a>FrameWork_05_View绘制流程</h1><span id="more"></span>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li><strong>Activity :</strong> 对于每一个 activity 都会有拥有一个 PhoneWindow。</li>
<li><strong>PhoneWindow</strong> ：该类继承于 Window 类，是 Window 类的具体实现，即我们可以通过该类具体去绘制窗口。并且，该类内部包含了一个 DecorView 对象，该 DectorView 对象是所有应用窗口的根 View。</li>
<li><strong>DecorView</strong> 是一个应用窗口的根容器，它本质上是一个 FrameLayout。DecorView 有唯一一个子 View，它是一个垂直 LinearLayout，包含两个子元素，一个是 TitleView（ ActionBar 的容器），另一个是 ContentView（窗口内容的容器）。</li>
<li><strong>ContentView</strong> ：是一个 FrameLayout（android.R.id.content)，我们平常用的 setContentView 就是设置它的子 View 。</li>
<li><strong>WindowManager :</strong> 是一个接口，里面常用的方法有：添加View，更新View和删除View。主要是用来管理 Window 的。WindowManager 具体的实现类是WindowManagerImpl。最终，WindowManagerImpl 会将业务交给 WindowManagerGlobal 来处理。</li>
<li><strong>WindowManagerService (WMS)</strong> ： 负责管理各 app 窗口的创建，更新，删除， 显示顺序。运行在 system_server 进程。</li>
<li><strong>ViewRootImpl</strong> ：拥有 DecorView 的实例，通过该实例来控制 DecorView 绘制。ViewRootImpl 的一个内部类 W，实现了 IWindow 接口，IWindow 接口是供 WMS 使用的，WSM 通过调用 IWindow 一些方法，通过 Binder 通信的方式，最后执行到了 W 中对应的方法中。同样的，ViewRootImpl 通过 IWindowSession 来调用 WMS 的 Session 一些方法。Session 类继承自 <code>IWindowSession.Stub</code>，每一个应用进程都有一个唯一的 Session 对象与 WMS 通信。</li>
</ul>
<p><code>Activity</code>的布局层次整体从上到下看来，如下图所示</p>
<img src="/pics/image-20210620184143390.png" alt="image-20210620184143390" style="zoom:50%;" />

<h1 id="一、布局创建过程"><a href="#一、布局创建过程" class="headerlink" title="一、布局创建过程"></a>一、布局创建过程</h1><p><code>ActivityLayout</code>的绘制和显示是伴随着<code>Activity</code>的生命周期而进行的。</p>
<img src="/pics/image-20220717190750406.png" alt="image-20220717190750406" style="zoom:50%;" />

<p><code>Activity</code>的启动过程中，<code>ActivityThread</code>类中的<code>handleLaunchActivity</code>，<code>performLaunchActivity</code>，<code>handleResumeActivity</code>这3个主要的方法完成了</p>
<p><code>Activity</code>的<strong>创建到启动工作</strong>，同时这个过程也伴随着View的绘制。下面我们从源码角度角度分析下这个流程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 👉 此方法中完成 Activity 生命周期的 onCreate 和 onStart 方法</span></span><br><span class="line">    Activity a = performLaunchActivity(r, customIntent);  </span><br><span class="line">    <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">// 👉 此方法中完成 Activity 生命周期的 onResume 方法</span></span><br><span class="line">        <span class="comment">// &gt;= Android 9 上 handleResumeActivity 不是这里，但主要流程顺序不变 </span></span><br><span class="line">        handleResumeActivity(r.token, <span class="keyword">false</span>, r.isForward,</span><br><span class="line">                !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);   </span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-1、ActivityThread-performLaunchActivity"><a href="#1-1、ActivityThread-performLaunchActivity" class="headerlink" title="1.1、ActivityThread#performLaunchActivity"></a>1.1、<code>ActivityThread#performLaunchActivity</code></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 👉 通过反射创建 Activity 实例</span></span><br><span class="line">    java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">    activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 👉 通过反射构建 Application，如果已经构建则不会重复构建，一个进程只能有一个 Application</span></span><br><span class="line">    Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Context appContext = createBaseContextForActivity(r, activity);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 👉 在这里实例化了 PhoneWindow，并将该 Activity 设置为 PhoneWindow 的 Callback 回调；</span></span><br><span class="line">        <span class="comment">// 初始化 WindowManager</span></span><br><span class="line">        activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</span><br><span class="line">                r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                r.embeddedID, r.lastNonConfigurationInstances, config);</span><br><span class="line">        </span><br><span class="line">				<span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 👉 调用了 Activity 的 performCreate 方法，间接调用了 Activity 的 onCreate 方法</span></span><br><span class="line">        mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 👉 调用 Activity 的 onStart 方法</span></span><br><span class="line">        <span class="keyword">if</span> (!r.activity.mFinished) &#123;</span><br><span class="line">            activity.performStart();</span><br><span class="line">            r.stopped = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-1、-Activity-attach"><a href="#1-1-1、-Activity-attach" class="headerlink" title="1.1.1、 Activity#attach"></a>1.1.1、 <code>Activity#attach</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context, ActivityThread aThread,</span></span></span><br><span class="line"><span class="params"><span class="function">        Instrumentation instr, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="params"><span class="function">        Application application, Intent intent, ActivityInfo info,</span></span></span><br><span class="line"><span class="params"><span class="function">        CharSequence title, Activity parent, String id,</span></span></span><br><span class="line"><span class="params"><span class="function">        NonConfigurationInstances lastNonConfigurationInstances,</span></span></span><br><span class="line"><span class="params"><span class="function">        Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="params"><span class="function">        Window window, ActivityConfigCallback activityConfigCallback)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 👉 实例化 PhoneWindow</span></span><br><span class="line">    mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>, window, activityConfigCallback);</span><br><span class="line">    mWindow.setWindowControllerCallback(<span class="keyword">this</span>);</span><br><span class="line">    mWindow.setCallback(<span class="keyword">this</span>);</span><br><span class="line">    mWindow.setOnWindowDismissedCallback(<span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 👉 为 Activity 的 Window 设置 WindowManager</span></span><br><span class="line">    mWindow.setWindowManager(</span><br><span class="line">            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">            mToken, mComponent.flattenToString(),</span><br><span class="line">            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    mWindowManager = mWindow.getWindowManager();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-2、Instrumentation-callActivityOnCreate"><a href="#1-1-2、Instrumentation-callActivityOnCreate" class="headerlink" title="1.1.2、Instrumentation#callActivityOnCreate"></a>1.1.2、<code>Instrumentation#callActivityOnCreate</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnCreate</span><span class="params">(Activity activity, Bundle icicle)</span> </span>&#123;</span><br><span class="line">    prePerformCreate(activity);</span><br><span class="line">    activity.performCreate(icicle);</span><br><span class="line">    postPerformCreate(activity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 👉 然后调用 Activity 的 performCreate 方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performCreate</span><span class="params">(Bundle icicle)</span> </span>&#123;</span><br><span class="line">    performCreate(icicle, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 👉 执行 onCreate 生命周期</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performCreate</span><span class="params">(Bundle icicle, PersistableBundle persistentState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (persistentState != <span class="keyword">null</span>) &#123;</span><br><span class="line">        onCreate(icicle, persistentState);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        onCreate(icicle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1、Activity-setContentView"><a href="#1、Activity-setContentView" class="headerlink" title="1、Activity#setContentView"></a>1、<code>Activity#setContentView</code></h4><img src="/pics/image-20210620220355400.png" alt="image-20210620220355400" style="zoom:40%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 👉 最常用的 setContentView 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Window#setContentView</span></span><br><span class="line">    getWindow().setContentView(layoutResID);</span><br><span class="line">    initWindowDecorActionBar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、PhoneWindow-setContentView"><a href="#2、PhoneWindow-setContentView" class="headerlink" title="2、PhoneWindow#setContentView"></a>2、<code>PhoneWindow#setContentView</code></h4><ol>
<li>创建DecorView </li>
<li>将Activity 布局添加到 mContentParent 中</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 布局顺序</span></span><br><span class="line">    setContentView(view, <span class="keyword">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// step1: 创建decorView</span></span><br><span class="line">        installDecor();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        mContentParent.removeAllViews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        <span class="keyword">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class="line">                getContext());</span><br><span class="line">        transitionTo(newScene);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// step2: 加载布局</span></span><br><span class="line">        mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParent.requestApplyInsets();</span><br><span class="line">    <span class="keyword">final</span> Callback cb = getCallback();</span><br><span class="line">    <span class="keyword">if</span> (cb != <span class="keyword">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">        cb.onContentChanged();</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParentExplicitlySet = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、PhoneWindow-installDecor"><a href="#3、PhoneWindow-installDecor" class="headerlink" title="3、PhoneWindow#installDecor"></a>3、<code>PhoneWindow#installDecor</code></h4><p><code>installDecor</code>方法主要做了以下几步工作：</p>
<ul>
<li> 初始化<code>mDecor</code>：调用<code>generateDecor</code>方法来创建<code>mDecor</code>对象；</li>
<li> 初始化<code>mContentParent</code>：调用<code>generateLayout</code>方法创建<code>mContentParent</code>对象；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 👉 初始化 mDecor</span></span><br><span class="line">    <span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 mDecor 为空，则生成一个 DecorView 对象</span></span><br><span class="line">        mDecor = generateDecor(-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将 PhoneWindow 设置给 mDecor</span></span><br><span class="line">        mDecor.setWindow(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 👉 初始化 mContentParent</span></span><br><span class="line">        mContentParent = generateLayout(mDecor);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 👉 generateDecor：初始化 DecorView</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> DecorView <span class="title">generateDecor</span><span class="params">(<span class="keyword">int</span> featureId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DecorView(context, featureId, <span class="keyword">this</span>, getAttributes());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 👉 generateLayout：根据窗口的风格，为 DecorView 选择对应的布局文件</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ViewGroup <span class="title">generateLayout</span><span class="params">(DecorView decor)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取窗口属性</span></span><br><span class="line">    TypedArray a = getWindowStyle();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> layoutResource;</span><br><span class="line">    <span class="keyword">int</span> features = getLocalFeatures();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 👉 根据设定好的 features 值选择不同的窗口布局文件，得到 layoutResource 值，前文中曾以 screen_simple 举例</span></span><br><span class="line">    <span class="comment">// 注意：此处还有很多分支判断代码省略了</span></span><br><span class="line">    <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != <span class="number">0</span>) &#123;</span><br><span class="line">        layoutResource = R.layout.screen_swipe_dismiss;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 👉 把选中的窗口布局文件解析成 View 树，并添加到 DecorView 中</span></span><br><span class="line">    <span class="comment">// [从LayoutInflater分析XML布局解析成View的树形结构的过程](http://blog.csdn.net/feiduclear_up/article/details/46732879) </span></span><br><span class="line">    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 👉 指定 contentParent 值，对应的是布局文件中 id 为 content 的 View</span></span><br><span class="line">    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);</span><br><span class="line">    <span class="keyword">if</span> (contentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Window couldn&#x27;t find content container view&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 👉 返回 contentParent，赋值给 mContentParent，所以 mContentParent 对应的是 R.id.content</span></span><br><span class="line">    <span class="keyword">return</span> contentParent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>installDecor方法实质就是产生mDecor和mContentParent对象。</strong></p>
<h2 id="1-2、ActivityThread-handleResumeActivity"><a href="#1-2、ActivityThread-handleResumeActivity" class="headerlink" title="1.2、ActivityThread#handleResumeActivity"></a><code>1.2、ActivityThread#handleResumeActivity</code></h2><p>执行完<code>onCreate</code>生命周期后，来到了<code>handleResumeActivity()</code>方法中执行<code>onResume</code>生命周期，有一点需要注意的是，到目前为止，我们也仅是生成了一个<code>Activity</code>，一个<code>PhoneWindow</code>，一个<code>DecorView</code>，而<strong>并未真正的将我们需要显示的内容和Android系统进行交互，以进行View绘制</strong>。</p>
<ol>
<li><strong>执onResume生命周期</strong>：调用 <code>performResumeActivity</code> 来间接执行 Activity 的 <code>onResume</code> 生命周期；</li>
<li> <strong>获取Activity的Window和DecorView</strong>：获取这两个变量赋值给相关变量，同时暂时使 <code>DecorView</code> 不可见；</li>
<li><strong>获取 WindowManager</strong>：在<code>Activity.attach()</code>方法中，我们为Activity设置了<code>WindowManager</code>；</li>
<li> <strong>WindowManager添加DecorView</strong>：调用<code>WindowManager.addView</code>方法为Window添加<code>DecorView</code>；</li>
<li> <strong>使得 DecorView 可见</strong>：调用<code>Activity.makeVisible</code>方法使得<code>DecorView</code>重新可见。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">boolean</span> clearHide, <span class="keyword">boolean</span> isForward, <span class="keyword">boolean</span> reallyResume, <span class="keyword">int</span> seq, String reason)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 👉 在其内部间接执行 Activity 的 onResume 方法，此时界面还不可见</span></span><br><span class="line">    ActivityClientRecord r = performResumeActivity(token, clearHide, reason);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> Activity a = r.activity;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 👉 获取 Window，DecorView 等对象</span></span><br><span class="line">    r.window = r.activity.getWindow();</span><br><span class="line">    View decor = r.window.getDecorView();</span><br><span class="line">    <span class="comment">// 👉 使 DecorView 不可见</span></span><br><span class="line">    decor.setVisibility(View.INVISIBLE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 👉 获取 WindowManager</span></span><br><span class="line">    ViewManager wm = a.getWindowManager();</span><br><span class="line">    WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">    a.mDecor = decor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a.mVisibleFromClient &amp;&amp; !a.mWindowAdded) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">// 👉 WindowManager 添加 DecorView，此时依然不可见</span></span><br><span class="line">        wm.addView(decor, l);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">        <span class="comment">// 👉 使得 DecorView 可见</span></span><br><span class="line">        r.activity.makeVisible();</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 👉 Activity.makeVisible方法：使得 DecorView 可见</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeVisible</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    mDecor.setVisibility(View.VISIBLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-1、WindowManager-addView"><a href="#1-2-1、WindowManager-addView" class="headerlink" title="1.2.1、WindowManager#addView"></a><code>1.2.1、WindowManager#addView</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WindowManager</span> <span class="keyword">extends</span> <span class="title">ViewManager</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ViewManager</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateViewLayout</span><span class="params">(View view, ViewGroup.LayoutParams params)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeView</span><span class="params">(View view)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowManagerImpl</span> <span class="keyword">implements</span> <span class="title">WindowManager</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(<span class="meta">@NonNull</span> View view, <span class="meta">@NonNull</span> ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">        applyDefaultToken(params);</span><br><span class="line">        mGlobal.addView(view, params, mContext.getDisplayNoVerify(), mParentWindow,</span><br><span class="line">                mContext.getUserId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowManagerGlobal</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="params"><span class="function">            Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 👉 ViewRootImpl 对象</span></span><br><span class="line">        ViewRootImpl root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 👉 初始化 ViewRootImpl </span></span><br><span class="line">            root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="comment">// 👉 调用 ViewRootImpl.setView 方法</span></span><br><span class="line">            root.setView(view, wparams, panelParentView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-2、ViewRootImpl-setView"><a href="#1-2-2、ViewRootImpl-setView" class="headerlink" title="1.2.2、ViewRootImpl#setView"></a><code>1.2.2、ViewRootImpl#setView</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 👉 ViewRootImpl.setView 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">        👇</span><br><span class="line">    requestLayout();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">                            👇</span><br><span class="line">    res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                            getHostVisibility(), mDisplay.getDisplayId(), mTmpFrame,</span><br><span class="line">                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">                            mAttachInfo.mOutsets, mAttachInfo.mDisplayCutout, mInputChannel,</span><br><span class="line">                            mTempInsets);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">            👇 将 DecorView 的 parent 设置为 ViewRootImpl</span><br><span class="line">    view.assignParent(<span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//... </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此方法中做的工作主要包括以下两个方面：</p>
<ul>
<li>1️⃣ <strong>requestLayout()方法</strong>：<strong>调用View的测量，布局，绘制三个流程</strong>；</li>
<li>2️⃣ <strong>mWindowSession.addToDisplay()方法</strong>：<strong>mWindowSession 是一个aidl，ViewRootImpl 利用它来和 WindowManagerService 进行跨进程交互</strong>，这里先不过多介绍有关 <code>WindowManagerService</code> 内容，只简单介绍下其作用，如下。</li>
</ul>
<blockquote>
<p>WindowManagerService(WMS)的作用有很多：</p>
<ul>
<li><strong>窗口的管理者</strong>：负责窗口的启动、添加和删除，另外窗口的大小和层级也是由WMS进行管理；</li>
<li><strong>事件的管理和派发工作</strong>：通过对窗口的触摸从而产生触摸事件，InputManagerService（IMS）会对触摸事件进行处理，它会寻找一个最合适的窗口来处理触摸反馈信息，WMS是窗口的管理者，因此，WMS“理所应当”的成为了事件的中转站。</li>
<li><strong>Surface管理</strong>：窗口并不具备有绘制的功能，因此每个窗口都需要有一块Surface来供自己绘制。为每个窗口分配Surface是由WMS来完成的。</li>
</ul>
</blockquote>
<blockquote>
<p>摘自<a href="https://link.juejin.cn/?target=https://blog.csdn.net/itachi85/java/article/details/78186741">Android解析WindowManagerService（一）WMS的诞生</a></p>
</blockquote>
<p>我们重点看看 <code>requestLayout()</code> 方法，源码如下：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">public void requestLayout() &#123;</span><br><span class="line">    if (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">        <span class="comment">// 👉 检查是不是主线程</span></span><br><span class="line">        checkThread();</span><br><span class="line">        mLayoutRequested = true;</span><br><span class="line">        <span class="comment">// 👉 view绘制三大流程入口</span></span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>熟悉View绘制流程的同学应该知道，<strong>当View的大小、形状发生了变化的时候，可以调用此方法来进行重新绘制，此方法会从View树重新进行一次测量、布局、绘制这三个流程</strong>。此方法主要做了两步工作：</p>
<ul>
<li>1️⃣ <strong>检查当前线程</strong>：如果调用此方法的现场不是主线程，那么就在<code>checkThread()</code>方法中抛出异常，这一点与我们”通常意义”上所说的：<strong>只能在主线程更新UI相吻合</strong>，具体checkThread()方法稍后写明；</li>
<li>2️⃣ <strong>调用 scheduleTraversals 方法</strong>：此方法后续<strong>完成了View的三大流程（测量（measure），布局（layout），绘制（draw））</strong>，具体分析见后续 。</li>
</ul>
<p>再看下 <code>checkThread()</code> 方法：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkThread</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">          👇</span><br><span class="line">    <span class="keyword">if</span> (mThread != Thread.currentThread()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CalledFromWrongThreadException(</span><br><span class="line">                <span class="string">&quot;Only the original thread that created a view hierarchy can touch its views.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mThread</code> 的初始化是在 <code>ViewRootImpl</code> 的构造函数中完成的：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ViewRootImpl 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewRootImpl</span><span class="params">(Context context, Display display)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">      👇</span><br><span class="line">    mThread = Thread.<span class="built_in">currentThread</span>();</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回忆下前文， <strong>ViewRootImpl 的初始化是在 WindowManagerGlobal.addView 方法中完成的，因此mThread 肯定对应的是主线程，因为 ActivityThread.handleLaunchActivity 方法就是在主线程中执行的，而其中并未切换过线程。因此如果我们在子线程中更新UI，那么最终会走到 requestLayout 方法进行重绘制，但此时会发现 mThread（主线程） 和 Thread.currentThread()（子线程）不是同一个线程，那么便会抛出异常</strong>。</p>
<p>再来说说 <strong>ViewRootImpl</strong> ，其作用非常重大。<strong>所有View的绘制以及事件分发等交互都是通过它来执行或传递的。View的三大流程（测量（measure），布局（layout），绘制（draw））均通过ViewRootImpl来完成。Android的所有触屏事件、按键事件、界面刷新等事件都是通过ViewRootImpl进行分发的。</strong></p>
<blockquote>
<ul>
<li><a href="https://link.juejin.cn/?target=https://www.jianshu.com/p/8766babc40e0">www.jianshu.com/p/8766babc4…</a></li>
</ul>
</blockquote>
<p><strong>从源码实现上来看，ViewRooImpl 既非View的子类，也非View的父类，但是，它实现了ViewParent接口，这让它可以作为View的名义上的父视图。</strong> 在 <code>ViewRootImpl.setView</code> 方法中调用了 <code>View.assignParent</code> 方法：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">void assignParent(ViewParent parent) &#123;</span><br><span class="line">    if (<span class="attr">mParent</span> == null) &#123;</span><br><span class="line">        <span class="attr">mParent</span> = parent<span class="comment">;</span></span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>View是以View树组织的，每个View都有其Parent，DecorView作为最顶层的View，其Parent被设置为ViewRootImpl对象</strong>。<strong>这样它可以作为View的名义上的父视图，实质上完成了View的更新，绘制等工作</strong>。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/14/17213311a7877e9c~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="View Tree"></p>
<p>View类中也有<code>requestLayout</code>方法：<strong>用于 View 的位置，大小、形状发生了变化的时候进行调用</strong>。当一个<strong>子 View 调用此方法时，便会令 View 树重新进行一次测量、布局、绘制这三个流程</strong>，具体源码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 👉 View#requestLayout：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="literal">null</span> &amp;&amp; !mParent.isLayoutRequested()) &#123;</span><br><span class="line">        <span class="comment">// 👉 调用父容器的 `requestLayout` 方法</span></span><br><span class="line">        mParent.requestLayout();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法中最重要的是调用<code>mParent.requestLayout</code>方法，是<strong>向父容器请求布局</strong>，即调用父容器的 <code>requestLayout</code> 方法，<strong>此方法沿着View树向上传递，最终来到了 DecorView#requestLayout中，而DecorView是顶层View，其mParent便是ViewRootImpl，所以子View的requestLayout方法，经过层层传递，最终会被ViewRootImpl 接收并处理</strong>。</p>
<p>DecorView是怎么添加到窗口的呢？真正的入口是在handleActivityResume 时，将DecorView和 Activity建立联系</p>
<img src="/pics/image-20210620214953160.png" alt="image-20210620214953160" style="zoom:50%;" />

<p>经过层层调用，DecorView的绘制会进入到ViewRootImpl类中的performTraversals()成员方法，这个过程可以参考上面的代码流程图。现在我们主要来分析下 ViewRootImpl类中的performTraversals方法。</p>
<h1 id="二、view-的绘制和渲染过程"><a href="#二、view-的绘制和渲染过程" class="headerlink" title="二、view 的绘制和渲染过程"></a>二、view 的绘制和渲染过程</h1><p><a href="http://blog.csdn.net/feiduclear_up/article/details/46772477">从ViewRootImpl类分析View绘制的流程</a></p>
<img src="/pics/image-20210620221717118.png" alt="image-20210620221717118" style="zoom:40%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="comment">//执行测量操作</span></span><br><span class="line">  performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">//执行布局操作</span></span><br><span class="line">  performLayout(lp, desiredWindowWidth, desiredWindowHeight);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//执行绘制操作</span></span><br><span class="line">	performDraw();</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-1、MeasureSpec"><a href="#2-1、MeasureSpec" class="headerlink" title="2.1、MeasureSpec"></a>2.1、MeasureSpec</h2><p>MeasureSpec表示的是一个32位的整形值，<code>它的高2位表示测量模式SpecMode，低30位表示某种测量模式下的规格大小SpecSize</code>。MeasureSpec是View类的一个静态内部类，用来说明应该如何测量这个View。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_SHIFT = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_MASK = <span class="number">0x3</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNSPECIFIED = <span class="number">0</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXACTLY = <span class="number">1</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_MOST = <span class="number">2</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeMeasureSpec</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sUseBrokenMakeMeasureSpec) &#123;</span><br><span class="line">        <span class="keyword">return</span> size + mode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (size &amp; ～MODE_MASK) | (mode &amp; MODE_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMode</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (measureSpec &amp; MODE_MASK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (measureSpec &amp; ～MODE_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MeasureSpec</code>通过将<code>SpecMode</code>和<code>SpecSize</code>打包成一个<code>int</code>值来避免过多的对象内存分配，为了方便操作，其提供了打包和解包方法。</p>
<p><code>SpecMode</code>有三类，每一类都表示特殊的含义，如下所示。</p>
<ul>
<li><p><strong>UNSPECIFIED</strong></p>
<p>父容器不对View有任何限制，要多大给多大，这种情况一般用于系统内部，表示一种测量的状态。</p>
</li>
<li><p><strong>EXACTLY</strong></p>
<p>父容器已经检测出View所需要的精确大小，这个时候View的最终大小就是SpecSize所指定的值。它对应于LayoutParams中的match_parent和具体的数值这两种模式。</p>
</li>
<li><p><strong>AT_MOST</strong><br>父容器指定了一个可用大小即SpecSize, View的大小不能大于这个值，具体是什么值要看不同View的具体实现。它对应于LayoutParams中的wrap_content。</p>
</li>
</ul>
<h3 id="2-1-1、DecorView-的MeasureSpec"><a href="#2-1-1、DecorView-的MeasureSpec" class="headerlink" title="2.1.1、DecorView 的MeasureSpec"></a>2.1.1、DecorView 的MeasureSpec</h3><p>对于DecorView，其MeasureSpec由<code>窗口的尺寸和其自身的LayoutParams</code>来共同确定；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRootMeasureSpec</span><span class="params">(<span class="keyword">int</span> windowSize, <span class="keyword">int</span> rootDimension)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> measureSpec;</span><br><span class="line">    <span class="keyword">switch</span> (rootDimension) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT:</span><br><span class="line">        <span class="comment">// Window can&#x27;t resize. Force root view to be windowSize.</span></span><br><span class="line">        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ViewGroup.LayoutParams.WRAP_CONTENT:</span><br><span class="line">        <span class="comment">// Window can resize. Set max size for root view.</span></span><br><span class="line">        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// Window wants to be an exact size. Force root view to be that size.</span></span><br><span class="line">        measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> measureSpec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常来说，DecorView根布局宽和高都是MATCH_PARENT，因此DecorView根布局的测量模式就是MeasureSpec.EXACTLY，测量大小一般都是整个屏幕大小，所以一般我们的Activity窗口都是全屏的。</p>
<h3 id="2-1-2、普通view的MeasureSpec"><a href="#2-1-2、普通view的MeasureSpec" class="headerlink" title="2.1.2、普通view的MeasureSpec"></a>2.1.2、普通view的MeasureSpec</h3><p>对于普通View，<code>其MeasureSpec由父容器的MeasureSpec和自身的LayoutParams来共同决定</code>，MeasureSpec一旦确定后，<code>onMeasure</code>中就可以确定View的测量宽/高。</p>
<p>对于普通<code>View</code>来说，View的<code>measure</code>过程由<code>ViewGroup</code>传递而来（所有的<code>view</code>根布局都是<code>DecorView</code>，而<code>DecorView</code>本身是个<code>FrameLayout</code>），先看一下<code>ViewGroup</code>的<code>measureChildWithMargins</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line">		<span class="comment">// 1.根据父view 的Measure 和 子view 的LayoutParams 确定子view的 MeasureSpec</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">            mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</span><br><span class="line">                    + widthUsed, lp.width);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">            mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</span><br><span class="line">                    + heightUsed, lp.height);</span><br><span class="line">		<span class="comment">// 2.最终调用到子view 的 measure方法</span></span><br><span class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>getChildMeasureSpec</strong></p>
<p>根据父view 的Measure 和 子view 的LayoutParams 确定子view的 MeasureSpec。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(spec);</span><br><span class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(spec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size = Math.max(<span class="number">0</span>, specSize - padding);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> resultSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> resultMode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">    <span class="comment">// Parent has imposed an exact size on us</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to be our size. So be it.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to determine its own size. It can&#x27;t be</span></span><br><span class="line">            <span class="comment">// bigger than us.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parent has imposed a maximum size on us</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Child wants a specific size... so be it</span></span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to be our size, but our size is not fixed.</span></span><br><span class="line">            <span class="comment">// Constrain child to not be bigger than us.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to determine its own size. It can&#x27;t be</span></span><br><span class="line">            <span class="comment">// bigger than us.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parent asked to see how big we want to be</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Child wants a specific size... let them have it</span></span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to be our size... find out how big it should</span></span><br><span class="line">            <span class="comment">// be</span></span><br><span class="line">            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</span><br><span class="line">            resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to determine its own size.... find out how</span></span><br><span class="line">            <span class="comment">// big it should be</span></span><br><span class="line">            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</span><br><span class="line">            resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//noinspection ResourceType</span></span><br><span class="line">    <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结下：</p>
<p>&lt;img src=””/pics/image-20210626173859241.png” alt=”image-20210626173859241” style=”zoom:50%;” /&gt;</p>
<h2 id="2-2、measure流程"><a href="#2-2、measure流程" class="headerlink" title="2.2、measure流程"></a>2.2、measure流程</h2><img src="/pics/image-20210620224045177.png" alt="image-20210620224045177" style="zoom:50%;" />



<h3 id="2-2-1、View-的绘制流程"><a href="#2-2-1、View-的绘制流程" class="headerlink" title="2.2.1、View 的绘制流程"></a>2.2.1、View 的绘制流程</h3><p>View的measure过程由其measure方法来完成，measure方法是一个final类型的方法，这意味着子类不能重写此方法，在View的measure方法中会去调用View的onMeasure方法，因此只需要看onMeasure的实现即可，View的onMeasure方法如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>getDefaultSize</strong></p>
<p>可以看出，getDefaultSize这个方法的逻辑很简单，对于我们来说，我们只需要看AT_MOST和．EXACTLY这两种情况。简单地理解，其实getDefaultSize返回的大小就是measureSpec中的specSize，而这个specSize就是View测量后的大小，这里多次提到测量后的大小，是因为View最终的大小是在layout阶段确定的，所以这里必须要加以区分，但是几乎所有情况下View的测量大小和最终大小是相等的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = size;</span><br><span class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">        result = size;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">        result = specSize;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>getSuggestedMinimumWidth</strong></p>
<p>getSuggestedMinimumWidth和getSuggestedMinimumHeight的返回值就是View在UNSPECIFIED情况下的测量宽/高。</p>
<ul>
<li>如果View没有设置背景，那么返回android:minWidth这个属性所指定的值，这个值可以为0；</li>
<li>如果View设置了背景，则返回android:minWidth和背景的最小宽度这两者中的最大值；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>wrap_content需要定义默认宽高？</strong></p>
<p>从getDefaultSize方法的实现来看，View的宽/高由specSize决定，所以我们可以得出如下结论：<code>直接继承View的自定义控件需要重写onMeasure方法并设置wrap_content时的自身大小，否则在布局中使用wrap_content就相当于使用match_parent。</code>为什么呢？</p>
<p>如果View在布局中使用wrap_content，那么它的specMode是AT_MOST模式，在这种模式下，它的宽/高等于specSize；查表4-1可知，此时specSize就是parentSize，而parentSize是父容器中目前可以使用的大小，也就是父容器当前剩余的空间大小。</p>
<p>很显然，View的宽/高就等于父容器当前剩余的空间大小，这种效果和在布局中使用match_parent完全一致。如何解决这个问题呢？也很简单，代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> heightSpecSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">    <span class="keyword">if</span> (widthSpecMode == MeasureSpec.AT_MOST &amp;&amp; heightSpecMode ==</span><br><span class="line">    MeasureSpec.AT_MOST) &#123;</span><br><span class="line">        setMeasuredDimension(mWidth, mHeight);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (widthSpecMode == MeasureSpec.AT_MOST) &#123;</span><br><span class="line">        setMeasuredDimension(mWidth, heightSpecSize);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (heightSpecMode == MeasureSpec.AT_MOST) &#123;</span><br><span class="line">        setMeasuredDimension(widthSpecSize, mHeight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，<code>我们只需要给View指定一个默认的内部宽/高（mWidth和mHeight）</code>，并在wrap_content时设置此宽/高即可。</p>
<p>对于非wrap_content情形，我们沿用系统的测量值即可，至于这个默认的内部宽/高的大小如何指定，这个没有固定的依据，根据需要灵活指定即可。如果查看TextView、ImageView等的源码就可以知道，针对wrap_content情形，它们的onMeasure方法均做了特殊处理，读者可以自行查看它们的源码。</p>
<h3 id="2-2-2、ViewGroup的绘制流程"><a href="#2-2-2、ViewGroup的绘制流程" class="headerlink" title="2.2.2、ViewGroup的绘制流程"></a>2.2.2、ViewGroup的绘制流程</h3><p>对于ViewGroup来说，除了完成自己的measure过程以外，还会遍历去调用所有子元素的measure方法，各个子元素再递归去执行这个过程。和View不同的是，ViewGroup是一个抽象类，它没有重写View的onMeasure方法，由各个具体的ViewGroup比如 FrameLayout去实现，但是它提供了一个叫measureChildren的方法，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildren</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = mChildrenCount;</span><br><span class="line">    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = children[i];</span><br><span class="line">        <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;</span><br><span class="line">            measureChild(child, widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>measureChild</strong></p>
<p>measureChild的思想就是取出子元素的LayoutParams，然后再通过getChildMeasureSpec来创建子元素的MeasureSpec，接着将MeasureSpec直接传递给View的measure方法来进行测量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> parentHeightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> LayoutParams lp = child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">            mPaddingLeft + mPaddingRight, lp.width);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">            mPaddingTop + mPaddingBottom, lp.height);</span><br><span class="line"></span><br><span class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么ViewGroup不像View一样对其onMeasure方法做统一的实现呢？</strong></p>
<p>因为不同的ViewGroup子类有不同的布局特性，这导致它们的测量细节各不相同，比如LinearLayout和RelativeLayout这两者的布局特性显然不同，因此ViewGroup无法做统一实现</p>
<h3 id="2-2-3、view-宽高获取"><a href="#2-2-3、view-宽高获取" class="headerlink" title="2.2.3、view 宽高获取?"></a>2.2.3、view 宽高获取?</h3><p>Activity生命周期<code>onCreate和onStart()，onResume</code>方法中调用<code>View.getWidth()</code>和<code>View.getMeasuredHeight()</code>返回值为0 ?</p>
<p>&lt;img src=””/pics/image-20210626162038865.png” alt=”image-20210626162038865” style=”zoom:50%;” /&gt;</p>
<p>从上面的代码片段执行顺序来看，Activity的onStart和onResume被执行的时候，其实界面还没有开始进行绘制（wm.addView(decor, l)还没执行到），这里就可以解释为什么用Handler.post在onCreate里拿不到宽高。因为Handler机制，Activity生命周期onCreate 和 onResume的都是通过主线程handler 的回调。而view 的绘制流程也是通过向主线程发送消息的方式执行的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 也就是说启动时，主线程队列中的消息执行顺序 为 onCreate -&gt; handleResumeActivity（onResume） -&gt; </p>
<p>doTraversal 。自然而然，view都没有绘制完的情况下是不可能获取到宽高的。</p>
<p><strong>解决方案：</strong></p>
<ol>
<li><p>view.post </p>
<p>本质上也是基于handler的消息机制，比如我们在onCreate 中执行 post</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 位置1</span></span><br><span class="line">    Log.i(<span class="string">&quot;view_w_&amp;_h&quot;</span>, <span class="string">&quot;onCreate &quot;</span> + mView.getWidth() + <span class="string">&quot; &quot;</span> + mView.getHeight());</span><br><span class="line">    mView.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 位置2</span></span><br><span class="line">            Log.i(<span class="string">&quot;view_w_&amp;_h&quot;</span>, <span class="string">&quot;onCreate postRun &quot;</span> + mView.getWidth() + <span class="string">&quot; &quot;</span> + mView.getHeight());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>最终这个runnable 任务会在 <code>performTraversals</code> 完成后被调用，<a href="https://mp.weixin.qq.com/s/71OV_K7YJas7pLtsPY-jeQ">详见</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void performTraversals() &#123;</span><br><span class="line">    ...</span><br><span class="line">    // 这里再次添加到消息中</span><br><span class="line">    host.dispatchAttachedToWindow(mAttachInfo, 0);</span><br><span class="line">    ...</span><br><span class="line">    performMeasure();</span><br><span class="line">    ...</span><br><span class="line">    performLayout();</span><br><span class="line">    ...</span><br><span class="line">    performDraw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>ViewTreeObserver</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">view.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() &#123;  </span><br><span class="line">        @Override  </span><br><span class="line">        public void onGlobalLayout() &#123;  </span><br><span class="line">            mScrollView.post(new Runnable() &#123;  </span><br><span class="line">                public void run() &#123;  </span><br><span class="line">                    view.getHeight(); </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;);  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure></li>
<li><p>重写Activity的onWindowFocusChanged()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onWindowFocusChanged</span><span class="params">(<span class="keyword">boolean</span> hasFocus)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">super</span>.onWindowFocusChanged(hasFocus);  </span><br><span class="line">		<span class="keyword">if</span> (hasFocus) &#123;</span><br><span class="line">				getHeight();</span><br><span class="line">		&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="2-3、Layout流程"><a href="#2-3、Layout流程" class="headerlink" title="2.3、Layout流程"></a>2.3、Layout流程</h2><img src="/pics/image-20210620224422346.png" alt="image-20210620224422346" style="zoom:50%;" />



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//判断是否需要重新测量</span></span><br><span class="line">     <span class="keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class="number">0</span>) &#123;</span><br><span class="line">         onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</span><br><span class="line">         mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//保存上一次View的四个位置</span></span><br><span class="line">     <span class="keyword">int</span> oldL = mLeft;</span><br><span class="line">     <span class="keyword">int</span> oldT = mTop;</span><br><span class="line">     <span class="keyword">int</span> oldB = mBottom;</span><br><span class="line">     <span class="keyword">int</span> oldR = mRight;</span><br><span class="line">     <span class="comment">//设置当前视图View的左，顶，右，底的位置，并且判断布局是否有改变</span></span><br><span class="line">     <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</span><br><span class="line">             setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line">     <span class="comment">//如果布局有改变，条件成立，则视图View重新布局</span></span><br><span class="line">         <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class="line">         <span class="comment">//调用onLayout，将具体布局逻辑留给子类实现</span></span><br><span class="line">         onLayout(changed, l, t, r, b);</span><br><span class="line">         mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</span><br><span class="line"></span><br><span class="line">         ListenerInfo li = mListenerInfo;</span><br><span class="line">         <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">             ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</span><br><span class="line">                     (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</span><br><span class="line">             <span class="keyword">int</span> numListeners = listenersCopy.size();</span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</span><br><span class="line">                 listenersCopy.get(i).onLayoutChange(<span class="keyword">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</span><br><span class="line">     mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-1、setFrame"><a href="#2-3-1、setFrame" class="headerlink" title="2.3.1、setFrame"></a>2.3.1、<strong>setFrame</strong></h3><p>layout 中调用<code>setFrame</code>确定当前View的布局位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">setFrame</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//当上，下，左，右四个位置有一个和上次的值不一样都会重新布局</span></span><br><span class="line">        <span class="keyword">if</span> (mLeft != left || mRight != right || mTop != top || mBottom != bottom) &#123;</span><br><span class="line">            changed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// Remember our drawn bit</span></span><br><span class="line">        <span class="keyword">int</span> drawn = mPrivateFlags &amp; PFLAG_DRAWN;</span><br><span class="line">        <span class="comment">//得到本次和上次的宽和高</span></span><br><span class="line">        <span class="keyword">int</span> oldWidth = mRight - mLeft;</span><br><span class="line">        <span class="keyword">int</span> oldHeight = mBottom - mTop;</span><br><span class="line">        <span class="keyword">int</span> newWidth = right - left;</span><br><span class="line">        <span class="keyword">int</span> newHeight = bottom - top;</span><br><span class="line">        <span class="comment">//判断本次View的宽高和上次View的宽高是否相等</span></span><br><span class="line">        <span class="keyword">boolean</span> sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Invalidate our old position</span></span><br><span class="line">        <span class="comment">//清楚上次布局的位置</span></span><br><span class="line">        invalidate(sizeChanged);</span><br><span class="line">        <span class="comment">//保存当前View的最新位置</span></span><br><span class="line">        mLeft = left;</span><br><span class="line">        mTop = top;</span><br><span class="line">        mRight = right;</span><br><span class="line">        mBottom = bottom;</span><br><span class="line">        mRenderNode.setLeftTopRightBottom(mLeft, mTop, mRight, mBottom);</span><br><span class="line"></span><br><span class="line">        mPrivateFlags |= PFLAG_HAS_BOUNDS;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果当前View的尺寸有所变化</span></span><br><span class="line">        <span class="keyword">if</span> (sizeChanged) &#123;</span><br><span class="line">            sizeChange(newWidth, newHeight, oldWidth, oldHeight);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...............</span><br><span class="line">    <span class="keyword">return</span> changed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-2、onLayout"><a href="#2-3-2、onLayout" class="headerlink" title="2.3.2、onLayout"></a>2.3.2、onLayout</h3><p>对于<code>View</code>来说，经过<code>setFrame</code>，<code>view</code>的位置就已经确定了，<code>onLayout</code>是一个空方法。</p>
<p>对于<code>ViewGroup</code>来说，位置通过<code>setFrame</code>已经实现，<code>onLayout</code>是个抽象的方法，所有继承自<code>ViewGroup</code>的对象都必须实现，确定子<code>view</code>的位置。以<code>FrameLayout</code> 为例，真正的实现在中<code>layoutChildren</code>。</p>
<p>不像<code>View</code>视图的<code>measure</code>测量，通过子类实现<code>onMeasure</code>方法来实现测量逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">    layoutChildren(left, top, right, bottom, <span class="keyword">false</span> <span class="comment">/* no force left gravity */</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutChildren</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom, <span class="keyword">boolean</span> forceLeftGravity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = getChildCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> parentLeft = getPaddingLeftWithForeground();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> parentRight = right - left - getPaddingRightWithForeground();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> parentTop = getPaddingTopWithForeground();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> parentBottom = bottom - top - getPaddingBottomWithForeground();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = getChildAt(i);</span><br><span class="line">        <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">            <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> width = child.getMeasuredWidth();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> height = child.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> childLeft;</span><br><span class="line">            <span class="keyword">int</span> childTop;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> gravity = lp.gravity;</span><br><span class="line">            <span class="keyword">if</span> (gravity == -<span class="number">1</span>) &#123;</span><br><span class="line">                gravity = DEFAULT_CHILD_GRAVITY;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = getLayoutDirection();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> verticalGravity = gravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</span><br><span class="line">                <span class="keyword">case</span> Gravity.CENTER_HORIZONTAL:</span><br><span class="line">                    childLeft = parentLeft + (parentRight - parentLeft - width) / <span class="number">2</span> +</span><br><span class="line">                    lp.leftMargin - lp.rightMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Gravity.RIGHT:</span><br><span class="line">                    <span class="keyword">if</span> (!forceLeftGravity) &#123;</span><br><span class="line">                        childLeft = parentRight - width - lp.rightMargin;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">case</span> Gravity.LEFT:</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    childLeft = parentLeft + lp.leftMargin;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (verticalGravity) &#123;</span><br><span class="line">                <span class="keyword">case</span> Gravity.TOP:</span><br><span class="line">                    childTop = parentTop + lp.topMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Gravity.CENTER_VERTICAL:</span><br><span class="line">                    childTop = parentTop + (parentBottom - parentTop - height) / <span class="number">2</span> +</span><br><span class="line">                    lp.topMargin - lp.bottomMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Gravity.BOTTOM:</span><br><span class="line">                    childTop = parentBottom - height - lp.bottomMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    childTop = parentTop + lp.topMargin;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            child.layout(childLeft, childTop, childLeft + width, childTop + height);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4、draw流程"><a href="#2-4、draw流程" class="headerlink" title="2.4、draw流程"></a>2.4、draw流程</h2><p>View视图绘制流程中的最后一步绘制draw是由ViewRootImpl中的performDraw成员方法开始的，跟踪代码，最后会在<code>ViewRootImpl.drawSoftware</code>方法绘制View：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">drawSoftware</span><span class="params">(Surface surface, AttachInfo attachInfo, <span class="keyword">int</span> xoff, <span class="keyword">int</span> yoff,</span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="keyword">boolean</span> scalingRequired, Rect dirty)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Draw with software renderer.</span></span><br><span class="line">      <span class="keyword">final</span> Canvas canvas;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//从surface对象中获得canvas变量</span></span><br><span class="line">          canvas = mSurface.lockCanvas(dirty);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// If this bitmap&#x27;s format includes an alpha channel, we</span></span><br><span class="line">          <span class="comment">// need to clear it before drawing so that the child will</span></span><br><span class="line">          <span class="comment">// properly re-composite its drawing on a transparent</span></span><br><span class="line">          <span class="comment">// background. This automatically respects the clip/dirty region</span></span><br><span class="line">          <span class="comment">// or</span></span><br><span class="line">          <span class="comment">// If we are applying an offset, we need to clear the area</span></span><br><span class="line">          <span class="comment">// where the offset doesn&#x27;t appear to avoid having garbage</span></span><br><span class="line">          <span class="comment">// left in the blank areas.</span></span><br><span class="line">          <span class="keyword">if</span> (!canvas.isOpaque() || yoff != <span class="number">0</span> || xoff != <span class="number">0</span>) &#123;</span><br><span class="line">              canvas.drawColor(<span class="number">0</span>, PorterDuff.Mode.CLEAR);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">         ......................</span><br><span class="line"></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">//调整画布的位置</span></span><br><span class="line">              canvas.translate(-xoff, -yoff);</span><br><span class="line">              <span class="keyword">if</span> (mTranslator != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  mTranslator.translateCanvas(canvas);</span><br><span class="line">              &#125;</span><br><span class="line">              canvas.setScreenDensity(scalingRequired ? mNoncompatDensity : <span class="number">0</span>);</span><br><span class="line">              attachInfo.mSetIgnoreDirtyState = <span class="keyword">false</span>;</span><br><span class="line">              <span class="comment">//调用View类中的成员方法draw开始绘制View视图</span></span><br><span class="line">              mView.draw(canvas);</span><br><span class="line">          &#125; </span><br><span class="line"></span><br><span class="line">      .....................</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可知，我们的视图View最终是绘制到Surface中去的，关于Surface相关的知识，可以参考这篇大神的博客：</p>
<p><a href="http://blog.csdn.net/luoshengyang/article/details/8303098">Android应用程序窗口（Activity）的绘图表面（Surface）的创建过程分析</a></p>
<p>跟踪代码，进入View的draw方法分析源码：</p>
<h3 id="2-4-1、Draw"><a href="#2-4-1、Draw" class="headerlink" title="2.4.1、Draw"></a>2.4.1、Draw</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void draw(Canvas canvas) &#123;</span><br><span class="line">      final int privateFlags = mPrivateFlags;</span><br><span class="line">      final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) ==</span><br><span class="line">      PFLAG_DIRTY_OPAQUE &amp;&amp;</span><br><span class="line">              (mAttachInfo == null || ! mAttachInfo.mIgnoreDirtyState);</span><br><span class="line">      mPrivateFlags = (privateFlags &amp; ～PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">      /＊</span><br><span class="line">      ＊ Draw traversal performs several drawing steps which must be executed</span><br><span class="line">      ＊ in the appropriate order:</span><br><span class="line">      ＊ in the appropriate order:</span><br><span class="line">    ＊</span><br><span class="line">    ＊       1. Draw the background</span><br><span class="line">    ＊       2. If necessary, save the canvas&#x27; layers to prepare for fading</span><br><span class="line">    ＊       3. Draw view&#x27;s content</span><br><span class="line">    ＊       4. Draw children</span><br><span class="line">    ＊       5. If necessary, draw the fading edges and restore layers</span><br><span class="line">    ＊       6. Draw decorations (scrollbars for instance)</span><br><span class="line">    ＊/</span><br><span class="line"></span><br><span class="line">   // Step 1, draw the background, if needed</span><br><span class="line">   int saveCount;</span><br><span class="line"></span><br><span class="line">   if (! dirtyOpaque) &#123;</span><br><span class="line">        drawBackground(canvas);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // skip step 2 &amp; 5 if possible (common case)</span><br><span class="line">   final int viewFlags = mViewFlags;</span><br><span class="line">   boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) ! = 0;</span><br><span class="line">   boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) ! = 0;</span><br><span class="line">   if (! verticalEdges &amp;&amp; ! horizontalEdges) &#123;</span><br><span class="line">        // Step 3, draw the content</span><br><span class="line">        if (! dirtyOpaque) onDraw(canvas);</span><br><span class="line"></span><br><span class="line">        // Step 4, draw the children</span><br><span class="line">        dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">        // Step 6, draw decorations (scrollbars)</span><br><span class="line">        onDrawScrollBars(canvas);</span><br><span class="line"></span><br><span class="line">        if (mOverlay ! = null &amp;&amp; ! mOverlay.isEmpty()) &#123;</span><br><span class="line">            mOverlay.getOverlayView().dispatchDraw(canvas);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // we&#x27;re done...</span><br><span class="line">        return;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下：</p>
<ol>
<li>绘制当前视图的背景。</li>
<li>保存canvas的图层，为fading做准备</li>
<li>绘制View的内容</li>
<li>绘制View的子View</li>
<li>绘制当前视图在滑动时的边框渐变效果。</li>
<li>绘制View的装饰(例如滚动条等等)</li>
</ol>
<img src="/pics/image-20210620231436212.png" alt="image-20210620231436212" style="zoom:50%;" />



<h3 id="2-4-2、View-的树形结构绘制流程"><a href="#2-4-2、View-的树形结构绘制流程" class="headerlink" title="2.4.2、View 的树形结构绘制流程"></a>2.4.2、View 的树形结构绘制流程</h3><p>View绘制过程的传递是通过dispatchDraw来实现的，dispatchDraw会遍历调用所有子元素的draw方法，如此draw事件就一层层地传递了下去。View有一个特殊的方法setWillNotDraw，先看一下它的源码，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/＊＊</span><br><span class="line"> ＊ If <span class="keyword">this</span> view doesn<span class="string">&#x27;t do any drawing on its own, set this flag to</span></span><br><span class="line"><span class="string"> ＊ allow further optimizations. By default, this flag is not set on</span></span><br><span class="line"><span class="string"> ＊ View, but could be set on some View subclasses such as ViewGroup.</span></span><br><span class="line"><span class="string"> ＊</span></span><br><span class="line"><span class="string"> ＊ Typically, if you override &#123;@link #onDraw(android.graphics.Canvas)&#125;</span></span><br><span class="line"><span class="string"> ＊ you should clear this flag.</span></span><br><span class="line"><span class="string"> ＊</span></span><br><span class="line"><span class="string"> ＊ @param willNotDraw whether or not this View draw on its own</span></span><br><span class="line"><span class="string"> ＊/</span></span><br><span class="line"><span class="string">public void setWillNotDraw(boolean willNotDraw) &#123;</span></span><br><span class="line"><span class="string">    setFlags(willNotDraw ? WILL_NOT_DRAW : 0, DRAW_MASK);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>从setWillNotDraw这个方法的注释中可以看出，如果一个View不需要绘制任何内容，那么设置这个标记位为true以后，系统会进行相应的优化。默认情况下，View没有启用这个优化标记位，但是ViewGroup会默认启用这个优化标记位。</p>
<p>这个标记位对实际开发的意义是：<code>当我们的自定义控件继承于ViewGroup并且本身不具备绘制功能时，就可以开启这个标记位从而便于系统进行后续的优化。</code>当然，当明确知道一个ViewGroup需要通过onDraw来绘制内容时，我们需要显式地关闭WILL_NOT_DRAW这个标记位。</p>
<img src="/pics/image-20210620232417701.png" alt="image-20210620232417701" style="zoom:50%;" />

<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><ol>
<li><p><code>ActivityThread#performLaunchActivity</code> 启动过程中</p>
<ol>
<li><code>Activity#attch</code>流程，创建<code>PhoneWindow</code></li>
<li><code>Activity#onCreate#setContentView</code>，先创建<code>DecorView</code>，将<code>DecorView</code>和<code>PhoneWindow</code>进行关联；并且将<code>activity</code>的布局文件添加到 <code>DecorView#content</code>中</li>
</ol>
</li>
<li><p><code>ActivityThread#handleResumeActivity</code>流程中</p>
<ol>
<li>通过<code>WindowManagerImpl#addView</code>创建<code>ViewRootImpl</code></li>
<li>将<code>ViewRootImpl</code>与<code>DecorView</code>进行关联，并通过<code>ViewRootImpl#setView</code>对<code>view</code>进行绘制</li>
</ol>
</li>
<li><p><code>ViewRootImpl#setView</code>流程中，进入 <code>view</code>的<code>Measure + Layout + Draw</code> 流程。</p>
</li>
<li><p>最后 通过<code>Activity.makeVisible</code>使得view 可见。</p>
</li>
</ol>
<h1 id="四、Qustion"><a href="#四、Qustion" class="headerlink" title="四、Qustion"></a>四、Qustion</h1><p> invaliate 和 requestlayout 方法的区别？</p>
<p>前面我们说到，ViewRootImpl 作为顶级 View 负责 View 的绘制。所以简单来说，requestlayout 和 invaliate 最终都会向上回溯调用到 ViewRootImpl 的 postTranversals 方法来绘制 View。</p>
<p>不同的是 requestlayout 会绘制 View 的 measure，layout 和 draw 过程。invaliate 因为只添加了绘制 draw 的标志位，只会绘制 draw 过程。 </p>
<p><a href="https://juejin.cn/post/6844904131136618510">https://juejin.cn/post/6844904131136618510</a></p>
<p><a href="https://blog.csdn.net/ITRenj/article/details/53819583">invalidate()和requestLayout()方法调用过程</a></p>
<p><a href="https://www.cnblogs.com/baiqiantao/p/2a3fccd829120089d24547929175ae29.html">invalidate和requestLayout方法源码分析</a></p>
<p><a href="https://juejin.cn/post/6844904159230033928#heading-11">https://juejin.cn/post/6844904159230033928#heading-11</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>Framework</category>
      </categories>
  </entry>
  <entry>
    <title>FrameWork_06_View事件分发</title>
    <url>/2021/06/26/Notes/Android/04Framework/FrameWork_06_View%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/</url>
    <content><![CDATA[<h1 id="FrameWork-06-View事件分发"><a href="#FrameWork-06-View事件分发" class="headerlink" title="FrameWork_06_View事件分发"></a>FrameWork_06_View事件分发</h1><span id="more"></span>

<h2 id="一、MotionEvent"><a href="#一、MotionEvent" class="headerlink" title="一、MotionEvent"></a>一、MotionEvent</h2><p>在手指接触屏幕后所产生的一系列事件中，典型的事件类型有如下几种：</p>
<ul>
<li>ACTION_DOWN——手指刚接触屏幕；</li>
<li>ACTION_MOVE——手指在屏幕上移动；</li>
<li>ACTION_UP——手机从屏幕上松开的一瞬间。</li>
</ul>
<p>正常情况下，一次手指触摸屏幕的行为会触发一系列点击事件，典型的事件序列有以下2种：</p>
<ul>
<li>点击屏幕后离开松开，事件序列为DOWN -&gt; UP；</li>
<li>点击屏幕滑动一会再松开，事件序列为DOWN -&gt; MOVE -&gt; … &gt; MOVE -&gt; UP。</li>
</ul>
<h2 id="二、点击事件的传递规则"><a href="#二、点击事件的传递规则" class="headerlink" title="二、点击事件的传递规则"></a>二、点击事件的传递规则</h2><p>点击事件的事件分发，其实就是对<code>MotionEvent</code>事件的分发过程，即当一个MotionEvent产生了以后，系统需要把这个事件传递给一个具体的View，而这个传递的过程就是分发过程。点击事件的分发过程由三个很重要的方法来共同完成：<code>dispatchTouchEvent</code>、<code>onInterceptTouchEvent</code>和<code>onTouchEvent</code>，下面我们先介绍一下这几个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span></span></span><br></pre></td></tr></table></figure>

<p>用来进行事件的分发。如果事件能够传递给当前View，那么此方法一定会被调用，返回结果受当前View的onTouchEvent和下级View的dispatchTouchEvent方法的影响，表示是否消耗当前事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span></span></span><br></pre></td></tr></table></figure>

<p>在上述方法内部调用，用来判断是否拦截某个事件，如果当前View拦截了某个事件，那么在同一个事件序列当中，此方法不会被再次调用，返回结果表示是否拦截当前事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span></span></span><br></pre></td></tr></table></figure>

<p>在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一个事件序列中，当前View无法再次接收到事件。<br>上述三个方法到底有什么区别呢？它们是什么关系呢？其实它们的关系可以用如下伪代码表示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> consume = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (onInterceptTouchEvent(ev)) &#123;</span><br><span class="line">        consume = onTouchEvent(ev);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        consume = child.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> consume;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于一个根ViewGroup来说，点击事件产生后，首先会传递给它，这时它的dispatchTouchEvent就会被调用，</p>
<ul>
<li>如果这个ViewGroup的onInterceptTouchEvent方法返回true就表示它要拦截当前事件，接着事件就会交给这个ViewGroup处理，即它的onTouchEvent方法就会被调用；</li>
<li>如果这个ViewGroup的onInterceptTouchEvent方法返回false就表示它不拦截当前事件，这时当前事件就会继续传递给它的子元素，接着子元素的dispatchTouchEvent方法就会被调用，如此反复直到事件被最终处理。</li>
</ul>
<h2 id="三、activity中事件的分发过程"><a href="#三、activity中事件的分发过程" class="headerlink" title="三、activity中事件的分发过程"></a>三、activity中事件的分发过程</h2><p>当一个点击事件产生后，它的传递过程遵循如下顺序：Activity -&gt; Window -&gt; View，即事件总是先传递给Activity, Activity再传递给Window，最后Window再传递给顶级View。顶级View接收到事件后，就会按照事件分发机制去分发事件。</p>
<img src="/pics/image-20210626214517837.png" alt="image-20210626214517837" style="zoom:40%;" />



<h3 id="3-1、Activity-dispatchTouchEvent"><a href="#3-1、Activity-dispatchTouchEvent" class="headerlink" title="3.1、Activity#dispatchTouchEvent"></a>3.1、Activity#dispatchTouchEvent</h3><p>首先事件开始交给<code>Activity</code>所附属的<code>Window</code>进行分发，如果返回true，整个事件循环就结束了，返回false意味着事件没人处理，所有View的<code>onTouchEvent</code>都返回了false，那么Activity的<code>onTouchEvent</code>就会被调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        onUserInteraction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> onTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2、PhoneWindow-superDispatchTouchEvent"><a href="#3-2、PhoneWindow-superDispatchTouchEvent" class="headerlink" title="3.2、PhoneWindow#superDispatchTouchEvent"></a>3.2、PhoneWindow#superDispatchTouchEvent</h3><p><code>PhoneWindow</code>将事件直接传递给了<code>DecorView</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3、DecorView-superDispatchTouchEvent"><a href="#3-3、DecorView-superDispatchTouchEvent" class="headerlink" title="3.3、DecorView#superDispatchTouchEvent"></a>3.3、DecorView#superDispatchTouchEvent</h3><p>DecorView继承自FrameLayout，事件会传递给ViewGroup</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean superDispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">    return super.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4、ViewGroup-dispatchTouchEvent"><a href="#3-4、ViewGroup-dispatchTouchEvent" class="headerlink" title="3.4、ViewGroup#dispatchTouchEvent"></a>3.4、ViewGroup#dispatchTouchEvent</h3><p>ViewGroup 的事件分发逻辑较长，可以分为三部分讲解。</p>
<h2 id="四、事件分发"><a href="#四、事件分发" class="headerlink" title="四、事件分发"></a>四、事件分发</h2><h3 id="4-1、判断是否要拦截事件"><a href="#4-1、判断是否要拦截事件" class="headerlink" title="4.1、判断是否要拦截事件"></a>4.1、判断是否要拦截事件</h3><p>ViewGroup在如下两种情况下会判断是否要拦截当前事件：</p>
<ul>
<li><p>事件类型为ACTION_DOWN</p>
</li>
<li><p>mFirstTouchTarget ! = null，当ViewGroup不拦截事件并将事件交由子元素处理时。</p>
<p>如果事件由当前ViewGroup拦截时<code>（mFirstTouchTarget == null 成立）</code>。那么当ACTION_MOVE和ACTION_UP事件到来时，由于<code>(actionMasked == MotionEvent. ACTION_DOWN || mFirstTouchTarget ! = null) 不成立</code>，将导致ViewGroup的onInterceptTouchEvent不会再被调用，同一序列中的其他事件都会由ViewGroup处理。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Check for interception.</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">        || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">        intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">        ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        intercepted = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// There are no touch targets and this action is not an initial down</span></span><br><span class="line">    <span class="comment">// so this view group continues to intercept touches.</span></span><br><span class="line">    intercepted = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>FLAG_DISALLOW_INTERCEPT</strong></p>
<p>一般用于子View中，FLAG_DISALLOW_INTERCEPT一旦设置后，<strong>ViewGroup将无法拦截除了ACTION_DOWN以外的其他点击事件</strong>。为什么说是除了ACTION_DOWN以外的其他事件呢？这是因为ViewGroup在分发事件时，如果是ACTION_DOWN就会重置FLAG_DISALLOW_INTERCEPT这个标记位，将导致子View中设置的这个标记位无效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">    <span class="comment">// Throw away all previous state when starting a new touch gesture.</span></span><br><span class="line">    <span class="comment">// The framework may have dropped the up or cancel event for the previous gesture</span></span><br><span class="line">    <span class="comment">// due to an app switch, ANR, or some other state change.</span></span><br><span class="line">    cancelAndClearTouchTargets(ev);</span><br><span class="line">    resetTouchState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结下：</p>
<img src="/pics/image-20210627235048935.png" alt="image-20210627235048935" style="zoom:50%;" />

<p>我们可以得出结论：</p>
<blockquote>
<ol>
<li><p><strong>当ViewGroup决定拦截事件后，那么后续的点击事件将会默认交给它处理并且不再调用它的<code>onInterceptTouchEvent</code>方法。</strong></p>
</li>
<li><p>当面对ACTION_DOWN事件时，ViewGroup总是会调用自己的onInterceptTouchEvent方法来询问自己是否要拦截事件，FLAG_DISALLOW_INTERCEPT影响不到<strong>ACTION_DOWN</strong></p>
</li>
</ol>
</blockquote>
<h3 id="4-2、事件分发给子view"><a href="#4-2、事件分发给子view" class="headerlink" title="4.2、事件分发给子view"></a>4.2、事件分发给子view</h3><p>遍历ViewGroup的所有子元素，然后判断子元素是否能够接收到点击事件，</p>
<ul>
<li>如果子元素的dispatchTouchEvent返回false, ViewGroup就会把事件分发给下一个子元素（如果还有下一个子元素的话）</li>
<li>如果遍历所有的子元素后事件都没有被合适地处理，ViewGroup会自己处理点击事件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> canceled = resetCancelNextUpFlag(<span class="keyword">this</span>)</span><br><span class="line">        || actionMasked == MotionEvent.ACTION_CANCEL;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">boolean</span> alreadyDispatchedToNewTouchTarget = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">				<span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">        <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> x =</span><br><span class="line">                    isMouseEvent ? ev.getXCursorPosition() : ev.getX(actionIndex);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> y =</span><br><span class="line">                    isMouseEvent ? ev.getYCursorPosition() : ev.getY(actionIndex);</span><br><span class="line">            <span class="comment">// Find a child that can receive the event.</span></span><br><span class="line">            <span class="comment">// Scan children from front to back.</span></span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> customOrder = preorderedList == <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; isChildrenDrawingOrderEnabled();</span><br><span class="line">            <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(</span><br><span class="line">                        childrenCount, i, customOrder);</span><br><span class="line">                <span class="keyword">final</span> View child = getAndVerifyPreorderedView(</span><br><span class="line">                        preorderedList, children, childIndex);</span><br><span class="line">              	<span class="comment">// 1.判断子view 是否在播动画 或 点击事件的坐标是否落在子元素的区域内。</span></span><br><span class="line">                <span class="keyword">if</span> (!child.canReceivePointerEvents()</span><br><span class="line">                        || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                newTouchTarget = getTouchTarget(child);</span><br><span class="line">                <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Child is already receiving touch within its bounds.</span></span><br><span class="line">                    <span class="comment">// Give it the new pointer in addition to the ones it is handling.</span></span><br><span class="line">                    newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                resetCancelNextUpFlag(child);</span><br><span class="line">                <span class="comment">// 2.子view 处理事件</span></span><br><span class="line">                <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">                    <span class="comment">// Child wants to receive touch within its bounds.</span></span><br><span class="line">                    mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">                    <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// childIndex points into presorted list, find original index</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                                mLastTouchDownIndex = j;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mLastTouchDownIndex = childIndex;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mLastTouchDownX = ev.getX();</span><br><span class="line">                    mLastTouchDownY = ev.getY();</span><br><span class="line">                    <span class="comment">// 3.拦截后的处理</span></span><br><span class="line">                    newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                    alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-1、dispatchTransformedTouchEvent"><a href="#4-2-1、dispatchTransformedTouchEvent" class="headerlink" title="4.2.1、dispatchTransformedTouchEvent"></a>4.2.1、dispatchTransformedTouchEvent</h4><p><code>dispatchTransformedTouchEvent</code>实际上调用的就是子元素的<code>dispatchTouchEvent</code>方法，上面的代码中child传递的不是null，因此它会直接调用子元素的<code>dispatchTouchEvent</code>方法，这样事件就交由子元素处理了，从而完成了一轮事件分发。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,</span></span></span><br><span class="line"><span class="params"><span class="function">        View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> handled;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldAction = event.getAction();</span><br><span class="line">    <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">        event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">            handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          	<span class="comment">// 传递给子view处理</span></span><br><span class="line">            handled = child.dispatchTouchEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        event.setAction(oldAction);</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果子元素的<code>dispatchTouchEvent</code>返回true，那么<code>mFirstTouchTarget</code>就会被赋值同时跳出for循环，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>这几行代码完成了mFirstTouchTarget的赋值并终止对子元素的遍历。</p>
<h4 id="4-2-2、addTouchTarget"><a href="#4-2-2、addTouchTarget" class="headerlink" title="4.2.2、addTouchTarget"></a>4.2.2、addTouchTarget</h4><p><code>mFirstTouchTarget</code>真正的赋值过程是在addTouchTarget内部完成的，mFirstTouchTarget是否被赋值，将直接影响到ViewGroup对事件的拦截策略，如果mFirstTouchTarget为null，那么ViewGroup就默认拦截接下来同一序列中所有的点击事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> TouchTarget <span class="title">addTouchTarget</span><span class="params">(View child, <span class="keyword">int</span> pointerIdBits)</span> </span>&#123;</span><br><span class="line">    TouchTarget target = TouchTarget.obtain(child, pointerIdBits);</span><br><span class="line">    target.next = mFirstTouchTarget;</span><br><span class="line">    mFirstTouchTarget = target;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果遍历所有的子元素后事件都没有被合适地处理，这包含两种情况：</p>
<ul>
<li>第一种是ViewGroup没有子元素；</li>
<li>第二种是子元素处理了点击事件，但是在dispatchTouchEvent中返回了false，这一般是因为子元素在onTouchEvent中返回了false。</li>
</ul>
<p>在这两种情况下，ViewGroup会自己处理点击事件。</p>
<h3 id="4-3、事件处理"><a href="#4-3、事件处理" class="headerlink" title="4.3、事件处理"></a>4.3、事件处理</h3><p>当mFirstTouchTarget == null，viewGroup会自己处理点击事件，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Dispatch to touch targets.</span></span><br><span class="line"><span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">  	<span class="comment">// viewGroup的分发</span></span><br><span class="line">    handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">            TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    TouchTarget predecessor = <span class="keyword">null</span>;</span><br><span class="line">    TouchTarget target = mFirstTouchTarget;</span><br><span class="line">    <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123; <span class="comment">// 多指的处理</span></span><br><span class="line">    		<span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会调用dispatchTransformedTouchEvent，此时child 参数为null，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">		handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		handled = child.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从前面的分析可以知道，很显然，这里就转到了View的dispatchTouchEvent方法，即点击事件开始交由View来处理，请看下面的分析。</p>
<h2 id="五、事件处理"><a href="#五、事件处理" class="headerlink" title="五、事件处理"></a>五、事件处理</h2><p>View的事件的处理是<code>dispatchTouchEvent</code>中，由于ViewGroup的重写的<code>dispatchTouchEvent</code>中主要负责的是事件分发，事件的处理也是调用了super.dispatchTouchEvent,    也就是说，调用的也是view的dispatchTouchEvent。</p>
<p>下面来分析下view的<code>dispatchTouchEvent</code>中事件的处理。</p>
<h3 id="5-1、View-dispatchTouchEvent"><a href="#5-1、View-dispatchTouchEvent" class="headerlink" title="5.1、View#dispatchTouchEvent"></a>5.1、View#dispatchTouchEvent</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//... 	</span></span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1. mOnTouchListener 处理</span></span><br><span class="line">        ListenerInfo li = mListenerInfo;</span><br><span class="line">        <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">                &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">// 2. onTouchEvent 处理</span></span><br><span class="line">        <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的源码可以看出View对点击事件的处理过程，可见OnTouchListener的优先级高于onTouchEvent。</p>
<h3 id="5-2、OnTouchListener-onTouch"><a href="#5-2、OnTouchListener-onTouch" class="headerlink" title="5.2、OnTouchListener.onTouch"></a>5.2、OnTouchListener.onTouch</h3><p>如果OnTouchListener中的onTouch方法返回true，那么onTouchEvent就不会被调用，可见OnTouchListener的优先级高于onTouchEvent。</p>
<h3 id="5-3、View-onTouchEvent"><a href="#5-3、View-onTouchEvent" class="headerlink" title="5.3、View#onTouchEvent"></a>5.3、View#onTouchEvent</h3><p>接着再分析onTouchEvent的实现。先看当View处于不可用状态下点击事件的处理过程，如下所示。很显然，不可用状态下的View照样会消耗点击事件，尽管它看起来不可用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE</span><br><span class="line">            || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</span><br><span class="line">            || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</span><br><span class="line">            setPressed(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class="line">        <span class="comment">// A disabled view that is clickable still consumes the touch</span></span><br><span class="line">        <span class="comment">// events, it just doesn&#x27;t respond to them.</span></span><br><span class="line">        <span class="keyword">return</span> clickable;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2、如果View设置有代理，那么还会执行TouchDelegate的onTouchEvent方法，这个onTouchEvent的工作机制看起来和OnTouchListener类似，这里不深入研究了。</span></span><br><span class="line">    <span class="keyword">if</span> (mTouchDelegate != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mTouchDelegate.onTouchEvent(event)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>View的enable属性不影响onTouchEvent的默认返回值。哪怕一个View是disable状态的，只要它的clickable或者longClickable有一个为true，那么它的onTouchEvent就返回true。</p>
</blockquote>
<h3 id="5-4、Click事件的处理"><a href="#5-4、Click事件的处理" class="headerlink" title="5.4、Click事件的处理"></a>5.4、Click事件的处理</h3><p>下面再看一下<code>onTouchEvent</code>中对点击事件的具体处理，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</span><br><span class="line">            (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                <span class="keyword">boolean</span> prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) ! = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) ! = <span class="number">0</span> || prepressed) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                    <span class="keyword">if</span> (! mHasPerformedLongPress) &#123;</span><br><span class="line">                        <span class="comment">// This is a tap, so remove the longpress check</span></span><br><span class="line">                        removeLongPressCallback();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//  Only  perform  take  click  actions  if  we  were  in  the</span></span><br><span class="line"><span class="function">pressed state</span></span><br><span class="line"><span class="function">                        <span class="title">if</span> <span class="params">(! focusTaken)</span> </span>&#123;</span><br><span class="line">                            <span class="comment">// Use a Runnable and post this rather than calling</span></span><br><span class="line">                            <span class="comment">// performClick directly. This lets other visual</span></span><br><span class="line">                                state</span><br><span class="line">                            <span class="comment">// of the view update before click actions start.</span></span><br><span class="line">                            <span class="keyword">if</span> (mPerformClick == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                mPerformClick = <span class="keyword">new</span> PerformClick();</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (! post(mPerformClick)) &#123;</span><br><span class="line">                                performClick();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码来看，只要View的CLICKABLE和LONG_CLICKABLE有一个为true，那么它就会消耗这个事件，即onTouchEvent方法返回true，不管它是不是DISABLE状态。</p>
<blockquote>
<p>View的onTouchEvent默认都会消耗事件（返回true），除非它是不可点击的（clickable和longClickable同时为false）。View的longClickable属性默认都为false, clickable属性要分情况，比如Button的clickable属性默认为true，而TextView的clickable属性默认为false。</p>
</blockquote>
<h4 id="performClick"><a href="#performClick" class="headerlink" title="performClick"></a>performClick</h4><p>当ACTION_UP事件发生时，会触发performClick方法，如果View设置了OnClickListener，那么performClick方法内部会调用它的onClick方法，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> result;</span><br><span class="line">    <span class="keyword">final</span> ListenerInfo li = mListenerInfo;</span><br><span class="line">    <span class="keyword">if</span> (li ! = <span class="keyword">null</span> &amp;&amp; li.mOnClickListener ! = <span class="keyword">null</span>) &#123;</span><br><span class="line">        playSoundEffect(SoundEffectConstants.CLICK);</span><br><span class="line">        li.mOnClickListener.onClick(<span class="keyword">this</span>);</span><br><span class="line">        result = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>onClick会发生的前提是当前View是可点击的，并且它收到了down和up的事件。</p>
</blockquote>
<p>总结下：</p>
<p>当一个View需要处理事件时，如果它设置了OnTouchListener，那么OnTouchListener中的<code>onTouch</code>方法会被回调。</p>
<ul>
<li><p>如果onTouch返回true，那么onTouchEvent方法将不会被调用。</p>
</li>
<li><p>如果onTouch返回false，则当前View的onTouchEvent方法会被调用，由此可见，给View设置的OnTouchListener，其优先级比onTouchEvent要高。</p>
<p>在<code>onTouchEvent</code>方法中，如果当前设置的有OnClickListener，那么它的onClick方法会被调用。可以看出，平时我们常用的OnClickListener，其优先级最低，即处于事件传递的尾端。</p>
</li>
</ul>
<h2 id="六、滑动冲突解决"><a href="#六、滑动冲突解决" class="headerlink" title="六、滑动冲突解决"></a>六、滑动冲突解决</h2><p>假设我们现在要处理的事 ViewPager 内部嵌套 ListView 的场景，此时外部是要响应横向滑动而内部要响应纵向滑动，那该如何处理呢？</p>
<p>首先可以明确的条件是，当 x 轴 滑动的距离大于 Y 轴时，需要ViewPager（父view）响应横向滑动；反之，就需要子view 响应 纵向滑动了。</p>
<h3 id="6-1、外部拦截法"><a href="#6-1、外部拦截法" class="headerlink" title="6.1、外部拦截法"></a>6.1、外部拦截法</h3><p>所谓外部拦截法是指点击事情都先经过父容器的拦截处理，如果父容器需要此事件就拦截，如果不需要此事件就不拦截，这种方法比较符合点击事件的分发机制。</p>
<p>外部拦截法需要重写父容器的<code>onInterceptTouchEvent</code>方法，在内部做相应的拦截即可，这种方法的代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> intercepted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</span><br><span class="line">    <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            intercepted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            <span class="comment">// 父容器需要当前事件</span></span><br><span class="line">            <span class="keyword">if</span> (Math.abs(x - mLastXIntercept) &gt; Math.abs(y - mLastYIntercept)) &#123;</span><br><span class="line">                intercepted = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                intercepted = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">            intercepted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mLastXIntercept = x;</span><br><span class="line">    mLastYIntercept = y;</span><br><span class="line">    <span class="keyword">return</span> intercepted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-1-1、MotionEvent-ACTION-DOWN"><a href="#6-1-1、MotionEvent-ACTION-DOWN" class="headerlink" title="6.1.1、MotionEvent.ACTION_DOWN"></a>6.1.1、MotionEvent.ACTION_DOWN</h4><p>按钮按下时，action = MotionEvent.ACTION_DOWN，父view中，初始状态为：</p>
<p><code>mFirstTouchTarget=null，onInterceptTouchEvent=false，</code></p>
<p>所以事件会分发到子view 中，由子view响应。</p>
<p>分发完毕后，父view中状态为：<code>mFirstTouchTarget = 子view</code>。</p>
<h4 id="6-1-2、第一次处理ACTION-MOVE"><a href="#6-1-2、第一次处理ACTION-MOVE" class="headerlink" title="6.1.2、第一次处理ACTION_MOVE"></a>6.1.2、第一次处理ACTION_MOVE</h4><p>父view中，初始状态为，mFirstTouchTarget = 子view，</p>
<p>当 横向滚动时，intercepted = true，最终事件会进入到 dispatchTransformedTouchEvent 中，此时有2个步骤：</p>
<ol>
<li>通过<code>dispatchTransformedTouchEvent</code>向子view中分发<code>ACTION_CANCEL</code>事件</li>
<li>将 mFirstTouchTarget 置为 null。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> TouchTarget next = target.next;</span><br><span class="line">    <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">        handled = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      	<span class="comment">// intercepted = true</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class="line">                || intercepted;</span><br><span class="line">      	<span class="comment">// step1: 分发cancelChild 到子view中</span></span><br><span class="line">        <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                target.child, target.pointerIdBits)) &#123; </span><br><span class="line">            handled = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cancelChild) &#123; <span class="comment">// true</span></span><br><span class="line">            <span class="keyword">if</span> (predecessor == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// step2：mFirstTouchTarget 被置为 null</span></span><br><span class="line">                mFirstTouchTarget = next; </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                predecessor.next = next;</span><br><span class="line">            &#125;</span><br><span class="line">            target.recycle();</span><br><span class="line">            target = next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    predecessor = target;</span><br><span class="line">    target = next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下这种情况下 <code>dispatchTransformedTouchEvent</code>中时如何分发事件的，此时<code>cancel=true</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,</span></span></span><br><span class="line"><span class="params"><span class="function">        View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> handled;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldAction = event.getAction();</span><br><span class="line">    <span class="comment">// 1.canceled = true</span></span><br><span class="line">    <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">       <span class="comment">// 事件改为 ACTION_CANCEL</span></span><br><span class="line">        event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">            handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		<span class="comment">// 2. 子view 分发 ACTION_CANCEL</span></span><br><span class="line">            handled = child.dispatchTouchEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.事件改回为 ACTION_MOVE</span></span><br><span class="line">        event.setAction(oldAction);</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>以上代码中：canceled = true 时，子view会将MOVE事件改为<code>ACTION_CANCEL</code>事件分发出去。</p>
<p>经过这步后，将 mFirstTouchTarget 值变为 null。</p>
<h4 id="6-1-3、第二次处理ACTION-MOVE"><a href="#6-1-3、第二次处理ACTION-MOVE" class="headerlink" title="6.1.3、第二次处理ACTION_MOVE"></a>6.1.3、第二次处理ACTION_MOVE</h4><p>当继续横向滚动时，由于mFirstTouchTarget == null &amp;&amp; onInterceptTouchEvent = true，所以会执行到如下代码，由父view 进行分发此事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// No touch targets so treat this as an ordinary view.</span></span><br><span class="line">    handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">            TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2、内部拦截法"><a href="#6-2、内部拦截法" class="headerlink" title="6.2、内部拦截法"></a>6.2、内部拦截法</h3><p>内部拦截法是指父容器不拦截任何事件，所有的事件都传递给子元素，如果子元素需要此事件就直接消耗掉，否则就交由父容器进行处理，需要配合<code>requestDisallowInterceptTouchEvent</code>才能正常工作，使用起来较外部拦截法稍显复杂。它的代码如下，我们需要重写子元素的dispatchTouchEvent方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</span><br><span class="line">    <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</span><br><span class="line">    Log.d(TAG, <span class="string">&quot;子view dispatchTouchEvent = &quot;</span> + event.getAction());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">            getParent().requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">            <span class="keyword">int</span> deltaX = x - mLastX;</span><br><span class="line">            <span class="keyword">int</span> deltaY = y - mLastY;</span><br><span class="line">            <span class="comment">// 容器需要此类点击事件</span></span><br><span class="line">            <span class="comment">// 横向交给父view 处理</span></span><br><span class="line">            <span class="keyword">if</span> (Math.abs(deltaX) &gt; Math.abs(deltaY)) &#123;</span><br><span class="line">                getParent().requestDisallowInterceptTouchEvent(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLastX = x;</span><br><span class="line">    mLastY = y;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了子元素需要做处理以外，父元素也要默认拦截除了ACTION_DOWN以外的其他事件，这样当子元素调用<code>parent.requestDisallowInterceptTouchEvent(false)</code>方法时，父元素才能继续拦截所需的事件。</p>
<p><strong>为什么父容器不能拦截ACTION_DOWN事件呢？</strong></p>
<p>那是因为ACTION_DOWN事件并不受FLAG_DISALLOW_INTERCEPT这个标记位的控制，所以一旦父容器拦截ACTION_DOWN事件，那么所有的事件都无法传递到子元素中去，这样内部拦截就无法起作用了。父元素所做的修改如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> action = event.getAction();</span><br><span class="line">		<span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> 	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面逐步分析下为何以上代码可以处理<strong>响应外部响应横向滑动，内部响应纵向滑动</strong>的情况？或者说子view中是如何处理横向滑动的呢？</p>
<h4 id="6-2-1、ACTION-DOWN处理"><a href="#6-2-1、ACTION-DOWN处理" class="headerlink" title="6.2.1、ACTION_DOWN处理"></a>6.2.1、ACTION_DOWN处理</h4><p>按钮按下时，action = MotionEvent.ACTION_DOWN，父view中，初始状态为：</p>
<p><code>mFirstTouchTarget=null，onInterceptTouchEvent=false, disallowIntercept=false</code></p>
<p>所以事件会分发到子view 中，由子view响应。分</p>
<p>发完毕后，父view中状态为：<code>mFirstTouchTarget = 子view， disallowIntercept = true</code>，</p>
<p>接下来看下ACTION_MOVE的处理。</p>
<h4 id="6-2-2、第一次处理ACTION-MOVE"><a href="#6-2-2、第一次处理ACTION-MOVE" class="headerlink" title="6.2.2、第一次处理ACTION_MOVE"></a><strong>6.2.2、第一次处理ACTION_MOVE</strong></h4><p>父view中，初始状态为：<code>mFirstTouchTarget=子view，disallowIntercept = true,onInterceptTouchEvent = true</code>，但是由于父view中<code>disallowIntercept = true</code>，所以还是由子view处理。</p>
<p>子view中识别到横向滑动后，会将</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (Math.abs(deltaX) &gt; Math.abs(deltaY)) &#123;</span><br><span class="line">		getParent().requestDisallowInterceptTouchEvent(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>父view中设置<code>disallowIntercept = false</code>。</p>
<h4 id="6-2-3、第二次处理ACTION-MOVE"><a href="#6-2-3、第二次处理ACTION-MOVE" class="headerlink" title="6.2.3、第二次处理ACTION_MOVE"></a>6.2.3、第二次处理ACTION_MOVE</h4><p>下一次MOVE事件到来之后，由于 <code>disallowIntercept = false</code>，<code>onInterceptTouchEvent=true，mFirstTouchTarget = 子view</code>，事件会由父view 进行处理。</p>
<p>分发事件时，intercepted = true，主要有2个步骤：</p>
<ol>
<li>通过<code>dispatchTransformedTouchEvent</code>向子view中分发<code>ACTION_CANCEL</code>事件</li>
<li>将 mFirstTouchTarget 置为 null。</li>
</ol>
<p>上面已经分析过<a href="#6.1.2%E3%80%81%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%A4%84%E7%90%86ACTION_MOVE">MOVE 变 取消</a></p>
<h4 id="6-2-4、第三次处理ACTION-MOVE"><a href="#6-2-4、第三次处理ACTION-MOVE" class="headerlink" title="6.2.4、第三次处理ACTION_MOVE"></a>6.2.4、第三次处理ACTION_MOVE</h4><p>下一次MOVE事件到来之后，父view中 <code>disallowIntercept = false</code>，<code>onInterceptTouchEvent=true，mFirstTouchTarget = null</code>，所以事件不会分发给子view 会由父view 进行处理。</p>
<h3 id="6-3、MotionEvent-UP"><a href="#6-3、MotionEvent-UP" class="headerlink" title="6.3、MotionEvent.UP"></a>6.3、MotionEvent.UP</h3><p>对于MotionEvent.UP事件来说，无论是内部拦截或是外部拦截方式，即MotionEvent.UP 只响应拦截</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>Framework</category>
      </categories>
  </entry>
  <entry>
    <title>open_08_GLIDE</title>
    <url>/2022/01/15/Notes/Android/02%E5%BC%80%E6%BA%90/open_08_GLIDE/</url>
    <content><![CDATA[<h1 id="open-08-GLIDE"><a href="#open-08-GLIDE" class="headerlink" title="open_08_GLIDE"></a>open_08_GLIDE</h1><span id="more"></span>

<p>本文源码分析，基于<a href="https://github.com/bumptech/glide">Glide:4.12.0</a></p>
<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>整体架构：</p>
<img src="/pics/image-20220206123520298.png" alt="image-20220206123520298" style="zoom:50%;" />

<p>涉及到几个概念：</p>
<ul>
<li>Model：数据源，Url 等等，对应Glide组件ModelLoader</li>
<li>Data：原始数据，InputStream等等，对应 Glide 组件 DataFetcher</li>
<li>cache：三级缓存，内存，磁盘和网络；内存缓存包括 弱引用 + LRUCache</li>
<li>Resource：解码后的原始数据 </li>
<li>TransformedResource：转换后的资源</li>
<li>Transcoded Resource：转码后的资源</li>
<li>Target：显示资源组件，比如 ImageViewTarget</li>
</ul>
<p>加载过程如下：</p>
<img src="/pics/image-20220205205518836.png" alt="image-20220205205518836" style="zoom:50%;" />

<h1 id="二、使用方法"><a href="#二、使用方法" class="headerlink" title="二、使用方法"></a>二、使用方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Glide.with(<span class="keyword">this</span>) <span class="comment">// 生命周期</span></span><br><span class="line">        .load(url) <span class="comment">// 网络图片，本地资源，二进制流等等</span></span><br><span class="line">        .placeholder(R.drawable.ic_ultraviolet) <span class="comment">// 占位符，不能用网络资源做占位符</span></span><br><span class="line">        .error(R.drawable.bg_clear_day) <span class="comment">//</span></span><br><span class="line">        .override(<span class="number">300</span>, <span class="number">300</span>) <span class="comment">// 限制图片尺寸，根据imageView</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 填充策略</span></span><br><span class="line">        .fitCenter() <span class="comment">// 完全显示，但是不一定能填充整个imageView</span></span><br><span class="line">        .centerCrop() <span class="comment">// 填充整个imageView 但是不能完全显示</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缓存策略</span></span><br><span class="line">        .skipMemoryCache(<span class="keyword">true</span>) <span class="comment">// 跳过内存缓存</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 磁盘缓存的 4 种策略</span></span><br><span class="line">        <span class="comment">// 磁盘不缓存</span></span><br><span class="line">        .diskCacheStrategy(DiskCacheStrategy.NONE)</span><br><span class="line">        <span class="comment">// 原始图片</span></span><br><span class="line">        .diskCacheStrategy(DiskCacheStrategy.SOURCE)</span><br><span class="line">        <span class="comment">// 降低分辨率后的图片</span></span><br><span class="line">        .diskCacheStrategy(DiskCacheStrategy.RESULT)</span><br><span class="line">        <span class="comment">// 缓存所有版本的图片</span></span><br><span class="line">        .diskCacheStrategy(DiskCacheStrategy.ALL)</span><br><span class="line">        <span class="comment">// 图片加载优先级，但是不一定能够完全安装这个优先级加载</span></span><br><span class="line">        .priority(Priority.HIGH)</span><br><span class="line"></span><br><span class="line">        .into(mImageView);</span><br></pre></td></tr></table></figure>

<h1 id="三、源码分析"><a href="#三、源码分析" class="headerlink" title="三、源码分析"></a>三、源码分析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Glide.with(<span class="keyword">this</span>)</span><br><span class="line">  .load(url)</span><br><span class="line">  .diskCacheStrategy(DiskCacheStrategy.NONE) <span class="comment">// 开启缓存后，数据加载过程比较复杂，我们后面回说明</span></span><br><span class="line">  .into();</span><br></pre></td></tr></table></figure>

<h2 id="3-1、with"><a href="#3-1、with" class="headerlink" title="3.1、with"></a>3.1、with</h2><p>with 的主要作用有2个：</p>
<ul>
<li>初始化Glide配置和各种组件（ModelLoader）</li>
<li>根据不同的<code>context</code>绑定相应的生命周期组件（Application/Fragment）</li>
</ul>
<img src="/pics/image-20220206110607731.png" alt="image-20220206110607731" style="zoom:33%;" />

<p>with 共有6个重载函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getRetriever(context).get(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getRetriever(activity).get(activity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(<span class="meta">@NonNull</span> FragmentActivity activity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getRetriever(activity).get(activity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(<span class="meta">@NonNull</span> Fragment fragment)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getRetriever(fragment.getContext()).get(fragment);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(<span class="meta">@NonNull</span> android.app.Fragment fragment)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getRetriever(fragment.getActivity()).get(fragment);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(<span class="meta">@NonNull</span> View view)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getRetriever(view.getContext()).get(view);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们<code>with(@NonNull FragmentActivity context)</code>为例分析。</p>
<p>主要流程分为2步：</p>
<ol>
<li>初始化Glide 并构造出 <code>RequestManagerRetriever</code> </li>
<li>通过<code>RequestManagerRetriever</code>构造出RequestManager 并绑定LifeCycle。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(<span class="meta">@NonNull</span> FragmentActivity activity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getRetriever(activity)<span class="comment">//1、初始化glide </span></span><br><span class="line">  </span><br><span class="line">  .get(activity); <span class="comment">//2、绑定LifeCycle。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-1、Glide-初始化"><a href="#3-1-1、Glide-初始化" class="headerlink" title="3.1.1、Glide 初始化"></a>3.1.1、Glide 初始化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> RequestManagerRetriever <span class="title">getRetriever</span><span class="params">(<span class="meta">@Nullable</span> Context context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Glide.get(context).getRequestManagerRetriever();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1、Glide-get"><a href="#1、Glide-get" class="headerlink" title="1、Glide#get"></a>1、Glide#get</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单例方式创建Glide</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Glide <span class="title">get</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (glide == <span class="keyword">null</span>) &#123;</span><br><span class="line">    GeneratedAppGlideModule annotationGeneratedModule =</span><br><span class="line">        getAnnotationGeneratedGlideModules(context.getApplicationContext());</span><br><span class="line">    <span class="keyword">synchronized</span> (Glide.class) &#123;</span><br><span class="line">      <span class="keyword">if</span> (glide == <span class="keyword">null</span>) &#123;</span><br><span class="line">        checkAndInitializeGlide(context, annotationGeneratedModule);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> glide;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GuardedBy(&quot;Glide.class&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkAndInitializeGlide</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="meta">@NonNull</span> Context context, <span class="meta">@Nullable</span> GeneratedAppGlideModule generatedAppGlideModule)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...省略</span></span><br><span class="line">  isInitializing = <span class="keyword">true</span>;</span><br><span class="line">  initializeGlide(context, generatedAppGlideModule);</span><br><span class="line">  isInitializing = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、Glide-initializeGlide"><a href="#2、Glide-initializeGlide" class="headerlink" title="2、Glide#initializeGlide"></a>2、Glide#initializeGlide</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initializeGlide</span><span class="params">(<span class="meta">@NonNull</span> Context context, <span class="meta">@NonNull</span> GlideBuilder builder)</span> </span>&#123;</span><br><span class="line">      Context applicationContext = context.getApplicationContext();</span><br><span class="line">      <span class="comment">//通过反射找到GeneratedAppGlideModuleImpl 类，如果能找到，就说明自定义了GlideModule</span></span><br><span class="line">      <span class="comment">//那么就需要在合适的地方调用applyOptions、registerComponents 来实现自定义的功能</span></span><br><span class="line">      GeneratedAppGlideModule annotationGeneratedModule = getAnnotationGeneratedGlideModules();</span><br><span class="line">      List&lt;com.bumptech.glide.<span class="keyword">module</span>.GlideModule&gt; manifestModules = Collections.emptyList();</span><br><span class="line">      <span class="keyword">if</span> (annotationGeneratedModule == <span class="keyword">null</span> || annotationGeneratedModule.isManifestParsingEnabled()) &#123;</span><br><span class="line">          <span class="comment">// 从AndroidManifest.xml 获取自定义的GlideModule（这是另外一种自定义GlideModule的方式）</span></span><br><span class="line">          manifestModules = <span class="keyword">new</span> ManifestParser(applicationContext).parse();</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//如果在注解中指明了要排除的GlideModule，则把GlideModule删除，在GlideModule中 从AndroidManifest.xml 中获取的 </span></span><br><span class="line">      <span class="keyword">if</span> (annotationGeneratedModule != <span class="keyword">null</span></span><br><span class="line">              &amp;&amp; !annotationGeneratedModule.getExcludedModuleClasses().isEmpty()) &#123;</span><br><span class="line">          Set&lt;Class&lt;?&gt;&gt; excludedModuleClasses =</span><br><span class="line">                  annotationGeneratedModule.getExcludedModuleClasses();</span><br><span class="line">          Iterator&lt;com.bumptech.glide.<span class="keyword">module</span>.GlideModule&gt; iterator = manifestModules.iterator();</span><br><span class="line">          <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">              com.bumptech.glide.<span class="keyword">module</span>.GlideModule current = iterator.next();</span><br><span class="line">              <span class="keyword">if</span> (!excludedModuleClasses.contains(current.getClass())) &#123;</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">                  Log.d(TAG, <span class="string">&quot;AppGlideModule excludes manifest GlideModule: &quot;</span> + current);</span><br><span class="line">              &#125;</span><br><span class="line">              iterator.remove();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 获取工厂，用于创建RequestManager（该工厂用于，如果with（）参数传递的是application）</span></span><br><span class="line">      RequestManagerRetriever.RequestManagerFactory factory =</span><br><span class="line">              annotationGeneratedModule != <span class="keyword">null</span></span><br><span class="line">                      ? annotationGeneratedModule.getRequestManagerFactory() : <span class="keyword">null</span>;</span><br><span class="line">      builder.setRequestManagerFactory(factory);</span><br><span class="line">      <span class="comment">//执行用户在 manifest 中配置的 GlideModule 接口中的方法</span></span><br><span class="line">      <span class="keyword">for</span> (com.bumptech.glide.<span class="keyword">module</span>.GlideModule <span class="keyword">module</span> : manifestModules) &#123;</span><br><span class="line">          <span class="keyword">module</span>.applyOptions(applicationContext, builder);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//执行使用注解配置的GlideModule 接口中的方法</span></span><br><span class="line">      <span class="keyword">if</span> (annotationGeneratedModule != <span class="keyword">null</span>) &#123;</span><br><span class="line">          annotationGeneratedModule.applyOptions(applicationContext, builder);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//创建Glide，代码4分析</span></span><br><span class="line">      Glide glide = builder.build(applicationContext);</span><br><span class="line">      <span class="comment">//下面registerComponents 方法的执行，需要传递Registry对象，而该对象是在创建Glide 的时候，被赋值，并设置一系列的参数</span></span><br><span class="line">      <span class="comment">//执行用户在 manifest 中配置的 GlideModule 接口中的registerComponents 方法</span></span><br><span class="line">      <span class="keyword">for</span> (com.bumptech.glide.<span class="keyword">module</span>.GlideModule <span class="keyword">module</span> : manifestModules) &#123;</span><br><span class="line">          <span class="keyword">module</span>.registerComponents(applicationContext, glide, glide.registry);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//执行 使用注解配置的GlideModule 接口中的registerComponents 方法</span></span><br><span class="line">      <span class="keyword">if</span> (annotationGeneratedModule != <span class="keyword">null</span>) &#123;</span><br><span class="line">          annotationGeneratedModule.registerComponents(applicationContext, glide, glide.registry);</span><br><span class="line">      &#125;</span><br><span class="line">      applicationContext.registerComponentCallbacks(glide);</span><br><span class="line">      <span class="comment">//向单例赋值</span></span><br><span class="line">      Glide.glide = glide;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、GlideBuilder-build"><a href="#3、GlideBuilder-build" class="headerlink" title="3、GlideBuilder#build"></a>3、GlideBuilder#build</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Glide <span class="title">build</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//创建执行器，用于从数据源获取数据，例如网络请求</span></span><br><span class="line">       <span class="keyword">if</span> (sourceExecutor == <span class="keyword">null</span>) &#123;</span><br><span class="line">           sourceExecutor = GlideExecutor.newSourceExecutor();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//创建执行器，用于从本地缓存获取数据</span></span><br><span class="line">       <span class="keyword">if</span> (diskCacheExecutor == <span class="keyword">null</span>) &#123;</span><br><span class="line">           diskCacheExecutor = GlideExecutor.newDiskCacheExecutor();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (animationExecutor == <span class="keyword">null</span>) &#123;</span><br><span class="line">           animationExecutor = GlideExecutor.newAnimationExecutor();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//根据当前机器参数计算需要设置的缓存大小</span></span><br><span class="line">       <span class="keyword">if</span> (memorySizeCalculator == <span class="keyword">null</span>) &#123;</span><br><span class="line">           memorySizeCalculator = <span class="keyword">new</span> MemorySizeCalculator.Builder(context).build();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (connectivityMonitorFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">           connectivityMonitorFactory = <span class="keyword">new</span> DefaultConnectivityMonitorFactory();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//创建 Bitmap 池，用于回收LruCache缓存的图片，把图片回收到bitmapPool中，这样下次再创建图片时，可服用该内存，避免连续创建回收内存，造成的内存抖动</span></span><br><span class="line">       <span class="keyword">if</span> (bitmapPool == <span class="keyword">null</span>) &#123;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">int</span> size = memorySizeCalculator.getBitmapPoolSize();</span><br><span class="line">           <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               bitmapPool = <span class="keyword">new</span> LruBitmapPool(size);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               bitmapPool = <span class="keyword">new</span> BitmapPoolAdapter();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//创建数组池</span></span><br><span class="line">       <span class="keyword">if</span> (arrayPool == <span class="keyword">null</span>) &#123;</span><br><span class="line">           arrayPool = <span class="keyword">new</span> LruArrayPool(memorySizeCalculator.getArrayPoolSizeInBytes());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//创建内存缓存</span></span><br><span class="line">       <span class="keyword">if</span> (memoryCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">           memoryCache = <span class="keyword">new</span> LruResourceCache(memorySizeCalculator.getMemoryCacheSize());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//创建磁盘缓存</span></span><br><span class="line">       <span class="keyword">if</span> (diskCacheFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">           diskCacheFactory = <span class="keyword">new</span> InternalCacheDiskCacheFactory(context);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//创建Engine，真正处理request的类，例如发起网络请求图片，从磁盘读取图片等</span></span><br><span class="line">       <span class="keyword">if</span> (engine == <span class="keyword">null</span>) &#123;</span><br><span class="line">           engine =</span><br><span class="line">                   <span class="keyword">new</span> Engine(</span><br><span class="line">                           memoryCache,</span><br><span class="line">                           diskCacheFactory,</span><br><span class="line">                           diskCacheExecutor,</span><br><span class="line">                           sourceExecutor,</span><br><span class="line">                           GlideExecutor.newUnlimitedSourceExecutor(),</span><br><span class="line">                           animationExecutor,</span><br><span class="line">                           isActiveResourceRetentionAllowed);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (defaultRequestListeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">           defaultRequestListeners = Collections.emptyList();</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           defaultRequestListeners = Collections.unmodifiableList(defaultRequestListeners);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//代码2 getRetriever() 返回的就是该对象</span></span><br><span class="line">       RequestManagerRetriever requestManagerRetriever =</span><br><span class="line">               <span class="keyword">new</span> RequestManagerRetriever(requestManagerFactory);</span><br><span class="line">	<span class="comment">//创建Glide</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Glide(</span><br><span class="line">               context,</span><br><span class="line">               engine,</span><br><span class="line">               memoryCache,</span><br><span class="line">               bitmapPool,</span><br><span class="line">               arrayPool,</span><br><span class="line">               requestManagerRetriever,</span><br><span class="line">               connectivityMonitorFactory,</span><br><span class="line">               logLevel,</span><br><span class="line">               defaultRequestOptions.lock(),</span><br><span class="line">               defaultTransitionOptions,</span><br><span class="line">               defaultRequestListeners,</span><br><span class="line">               isLoggingRequestOriginsEnabled);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4、Glide-Glide"><a href="#4、Glide-Glide" class="headerlink" title="4、Glide#Glide"></a>4、Glide#Glide</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">代码五 类Glide.<span class="function">java </span></span><br><span class="line"><span class="function">   <span class="title">Glide</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="meta">@NonNull</span> Context context,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="meta">@NonNull</span> Engine engine,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="meta">@NonNull</span> MemoryCache memoryCache,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="meta">@NonNull</span> BitmapPool bitmapPool,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="meta">@NonNull</span> ArrayPool arrayPool,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="meta">@NonNull</span> RequestManagerRetriever requestManagerRetriever,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="meta">@NonNull</span> ConnectivityMonitorFactory connectivityMonitorFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">int</span> logLevel,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="meta">@NonNull</span> RequestOptions defaultRequestOptions,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="meta">@NonNull</span> Map&lt;Class&lt;?&gt;, TransitionOptions&lt;?, ?&gt;&gt; defaultTransitionOptions,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="meta">@NonNull</span> List&lt;RequestListener&lt;Object&gt;&gt; defaultRequestListeners,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">boolean</span> isLoggingRequestOriginsEnabled)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.engine = engine;</span><br><span class="line">        <span class="keyword">this</span>.bitmapPool = bitmapPool;</span><br><span class="line">        <span class="keyword">this</span>.arrayPool = arrayPool;</span><br><span class="line">        <span class="keyword">this</span>.memoryCache = memoryCache;</span><br><span class="line">        <span class="keyword">this</span>.requestManagerRetriever = requestManagerRetriever;</span><br><span class="line">        <span class="keyword">this</span>.connectivityMonitorFactory = connectivityMonitorFactory;</span><br><span class="line"></span><br><span class="line">        DecodeFormat decodeFormat = defaultRequestOptions.getOptions().get(Downsampler.DECODE_FORMAT);</span><br><span class="line">        bitmapPreFiller = <span class="keyword">new</span> BitmapPreFiller(memoryCache, bitmapPool, decodeFormat);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Resources resources = context.getResources();</span><br><span class="line"></span><br><span class="line">        registry = <span class="keyword">new</span> Registry();</span><br><span class="line">        registry.register(<span class="keyword">new</span> DefaultImageHeaderParser());</span><br><span class="line"></span><br><span class="line">          ...省略若干代码，创建需要加入到registry 的类...</span><br><span class="line"></span><br><span class="line">        ContentResolver contentResolver = context.getContentResolver();</span><br><span class="line">		<span class="comment">//添加各种Encoder（把数据存为File）、ResourceDecoder（把数据从类型A转为类型B）、</span></span><br><span class="line">		<span class="comment">//ModelLoaderFactory（用于创建ModelLoader，它用于将任意复杂的数据模型转换为可由 DataFetcher 获取模型所代表的资源数据的具体数据类型。用来加载资源的。 ）</span></span><br><span class="line">        registry</span><br><span class="line">                .append(ByteBuffer.class, <span class="keyword">new</span> ByteBufferEncoder())</span><br><span class="line">                ...省略若干代码...</span><br><span class="line">                .append(Drawable.class, Drawable.class, <span class="keyword">new</span> UnitDrawableDecoder())</span><br><span class="line">                <span class="comment">/* Transcoders */</span></span><br><span class="line">                .register(</span><br><span class="line">                        Bitmap.class,</span><br><span class="line">                        BitmapDrawable.class,</span><br><span class="line">                        <span class="keyword">new</span> BitmapDrawableTranscoder(resources))</span><br><span class="line">                .register(Bitmap.class, <span class="keyword">byte</span>[].class, bitmapBytesTranscoder)</span><br><span class="line">                .register(</span><br><span class="line">                        Drawable.class,</span><br><span class="line">                        <span class="keyword">byte</span>[].class,</span><br><span class="line">                        <span class="keyword">new</span> DrawableBytesTranscoder(</span><br><span class="line">                                bitmapPool, bitmapBytesTranscoder, gifDrawableBytesTranscoder))</span><br><span class="line">                .register(GifDrawable.class, <span class="keyword">byte</span>[].class, gifDrawableBytesTranscoder);</span><br><span class="line">        <span class="comment">//该工厂用于生产ImageViewTarget，最终通过ImageViewTarget对象把图片addView到界面上 </span></span><br><span class="line">        ImageViewTargetFactory imageViewTargetFactory = <span class="keyword">new</span> ImageViewTargetFactory();</span><br><span class="line">        glideContext =</span><br><span class="line">                <span class="keyword">new</span> GlideContext(</span><br><span class="line">                        context,</span><br><span class="line">                        arrayPool,</span><br><span class="line">                        registry,</span><br><span class="line">                        imageViewTargetFactory,</span><br><span class="line">                        defaultRequestOptions,</span><br><span class="line">                        defaultTransitionOptions,</span><br><span class="line">                        defaultRequestListeners,</span><br><span class="line">                        engine,</span><br><span class="line">                        isLoggingRequestOriginsEnabled,</span><br><span class="line">                        logLevel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，代码主要逻辑是通过Registry 对象添加图片的加载、解析组件。以下是registry中的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Registry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.modelLoaderRegistry = <span class="keyword">new</span> ModelLoaderRegistry(throwableListPool);</span><br><span class="line">  <span class="keyword">this</span>.encoderRegistry = <span class="keyword">new</span> EncoderRegistry();</span><br><span class="line">  <span class="keyword">this</span>.decoderRegistry = <span class="keyword">new</span> ResourceDecoderRegistry();</span><br><span class="line">  <span class="keyword">this</span>.resourceEncoderRegistry = <span class="keyword">new</span> ResourceEncoderRegistry();</span><br><span class="line">  <span class="keyword">this</span>.dataRewinderRegistry = <span class="keyword">new</span> DataRewinderRegistry();</span><br><span class="line">  <span class="keyword">this</span>.transcoderRegistry = <span class="keyword">new</span> TranscoderRegistry();</span><br><span class="line">  <span class="keyword">this</span>.imageHeaderParserRegistry = <span class="keyword">new</span> ImageHeaderParserRegistry();</span><br><span class="line">  setResourceDecoderBucketPriorityList(</span><br><span class="line">      Arrays.asList(BUCKET_GIF, BUCKET_BITMAP, BUCKET_BITMAP_DRAWABLE));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-2、绑定LifeCycle组件"><a href="#3-1-2、绑定LifeCycle组件" class="headerlink" title="3.1.2、绑定LifeCycle组件"></a>3.1.2、绑定LifeCycle组件</h3><h4 id="1、RequestManagerRetriever-get"><a href="#1、RequestManagerRetriever-get" class="headerlink" title="1、RequestManagerRetriever#get"></a>1、RequestManagerRetriever#get</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class="line">    <span class="keyword">return</span> retriever.get(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestManager <span class="title">get</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;You cannot start a load on a null Context&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Util.isOnMainThread() &amp;&amp; !(context <span class="keyword">instanceof</span> Application)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (context <span class="keyword">instanceof</span> FragmentActivity) &#123;</span><br><span class="line">            <span class="keyword">return</span> get((FragmentActivity) context);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context <span class="keyword">instanceof</span> Activity) &#123;</span><br><span class="line">            <span class="keyword">return</span> get((Activity) context);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context <span class="keyword">instanceof</span> ContextWrapper) &#123;</span><br><span class="line">            <span class="keyword">return</span> get(((ContextWrapper) context).getBaseContext());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> getApplicationManager(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> RequestManager <span class="title">getApplicationManager</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Either an application context or we&#x27;re on a background thread.</span></span><br><span class="line">  <span class="keyword">if</span> (applicationManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (applicationManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Glide glide = Glide.get(context.getApplicationContext());</span><br><span class="line">        applicationManager =</span><br><span class="line">            factory.build(</span><br><span class="line">                glide,</span><br><span class="line">                <span class="keyword">new</span> ApplicationLifecycle(),</span><br><span class="line">                <span class="keyword">new</span> EmptyRequestManagerTreeNode(),</span><br><span class="line">                context.getApplicationContext());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestManager <span class="title">get</span><span class="params">(<span class="meta">@NonNull</span> FragmentActivity activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">      <span class="keyword">return</span> get(activity.getApplicationContext());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      assertNotDestroyed(activity);</span><br><span class="line">      frameWaiter.registerSelf(activity);</span><br><span class="line">      FragmentManager fm = activity.getSupportFragmentManager();</span><br><span class="line">      <span class="comment">// fragment</span></span><br><span class="line">      <span class="keyword">return</span> supportFragmentGet(activity, fm, <span class="comment">/*parentHint=*/</span> <span class="keyword">null</span>, isActivityVisible(activity));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> RequestManager <span class="title">supportFragmentGet</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="meta">@NonNull</span> Context context,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="meta">@NonNull</span> FragmentManager fm,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="meta">@Nullable</span> Fragment parentHint,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">boolean</span> isParentVisible)</span> </span>&#123;</span><br><span class="line">    SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm, parentHint);</span><br><span class="line">    RequestManager requestManager = current.getRequestManager();</span><br><span class="line">    <span class="keyword">if</span> (requestManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// TODO(b/27524013): Factor out this Glide.get() call.</span></span><br><span class="line">      Glide glide = Glide.get(context);</span><br><span class="line">      requestManager =</span><br><span class="line">          factory.build(</span><br><span class="line">              glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);</span><br><span class="line">      <span class="comment">// This is a bit of hack, we&#x27;re going to start the RequestManager, but not the</span></span><br><span class="line">      <span class="comment">// corresponding Lifecycle. It&#x27;s safe to start the RequestManager, but starting the</span></span><br><span class="line">      <span class="comment">// Lifecycle might trigger memory leaks. See b/154405040</span></span><br><span class="line">      <span class="keyword">if</span> (isParentVisible) &#123;</span><br><span class="line">        requestManager.onStart();</span><br><span class="line">      &#125;</span><br><span class="line">      current.setRequestManager(requestManager);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> requestManager;</span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure>

<p>RequestManagerRetriever类中看似有很多个get()方法的重载，什么Context参数，Activity参数，Fragment参数等等，实际上只有两种情况而已，即传入Application类型的参数，和传入非Application类型的参数。</p>
<ol>
<li><p>传入非Application参数的情况</p>
<p>不管你在Glide.with()方法中传入的是Activity、FragmentActivity、v4包下的Fragment、还是app包下的Fragment，最终的流程都是一样的，那就是会向当前的Activity当中添加一个隐藏的Fragment。<code>RequestManager</code> 关联的是 <code>ActivityFragmentLifecycle</code></p>
</li>
<li><p>传入Application参数的情况，<code>RequestManager</code>关联<code>ApplicationLifecycle</code></p>
</li>
</ol>
<p>至此with 函数就算分析完了，得到了RequestManager 对象。从命名就能看出来，它是请求管理者</p>
<h2 id="3-2、load"><a href="#3-2、load" class="headerlink" title="3.2、load"></a>3.2、load</h2><h3 id="3-2-1、RequestManager-load"><a href="#3-2-1、RequestManager-load" class="headerlink" title="3.2.1、RequestManager#load"></a>3.2.1、RequestManager#load</h3><p>这里的load 设置图片来源，有多种方式，从本地资源Drawable，String，Uri，File等，我们这里仅分析从网络请求图片的过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title">load</span><span class="params">(<span class="meta">@Nullable</span> String string)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> asDrawable().load(string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-2、RequestManager-asDrawable"><a href="#3-2-2、RequestManager-asDrawable" class="headerlink" title="3.2.2、RequestManager#asDrawable"></a>3.2.2、RequestManager#asDrawable</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果是其它的类型，就使用其它的asXXXX函数（例如asGif）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title">asDrawable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//这里传入Drawable.class,</span></span><br><span class="line">    <span class="keyword">return</span> as(Drawable.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;ResourceType&gt; <span class="function">RequestBuilder&lt;ResourceType&gt; <span class="title">as</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@NonNull</span> Class&lt;ResourceType&gt; resourceClass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建RequestBuilder</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RequestBuilder&lt;&gt;(glide, <span class="keyword">this</span>, resourceClass, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-3、RequestBuilder-load"><a href="#3-2-3、RequestBuilder-load" class="headerlink" title="3.2.3、RequestBuilder#load"></a>3.2.3、RequestBuilder#load</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;TranscodeType&gt; <span class="title">load</span><span class="params">(<span class="meta">@Nullable</span> Object model)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 这里的model 是一个url</span></span><br><span class="line">    <span class="keyword">return</span> loadGeneric(model);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> RequestBuilder&lt;TranscodeType&gt; <span class="title">loadGeneric</span><span class="params">(<span class="meta">@Nullable</span> Object model)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里的model 是一个url</span></span><br><span class="line">    <span class="keyword">this</span>.model = model;</span><br><span class="line">    <span class="comment">// 记录url已设置</span></span><br><span class="line">    isModelSet = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3、into"><a href="#3-3、into" class="headerlink" title="3.3、into"></a>3.3、into</h2><p>into 的入口是在RequestBuilder中。<code>RequestBuilder#into</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ViewTarget&lt;ImageView, TranscodeType&gt; <span class="title">into</span><span class="params">(<span class="meta">@NonNull</span> ImageView view)</span> </span>&#123;</span><br><span class="line">    BaseRequestOptions&lt;?&gt; requestOptions = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (!requestOptions.isTransformationSet()</span><br><span class="line">            &amp;&amp; requestOptions.isTransformationAllowed()</span><br><span class="line">            &amp;&amp; view.getScaleType() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Clone in this method so that if we use this RequestBuilder to load into a View and then</span></span><br><span class="line">        <span class="comment">// into a different target, we don&#x27;t retain the transformation applied based on the previous</span></span><br><span class="line">        <span class="comment">// View&#x27;s scale type.</span></span><br><span class="line">        <span class="comment">//根据ImageView 的ScaleType 类型，进行参数设置，注意这里是clone 一个新的对象，在新对象上操作的</span></span><br><span class="line">        <span class="keyword">switch</span> (view.getScaleType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> CENTER_CROP:</span><br><span class="line">                requestOptions = requestOptions.clone().optionalCenterCrop();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CENTER_INSIDE:</span><br><span class="line">                requestOptions = requestOptions.clone().optionalCenterInside();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FIT_CENTER:</span><br><span class="line">            <span class="keyword">case</span> FIT_START:</span><br><span class="line">            <span class="keyword">case</span> FIT_END:</span><br><span class="line">                requestOptions = requestOptions.clone().optionalFitCenter();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FIT_XY:</span><br><span class="line">                requestOptions = requestOptions.clone().optionalCenterInside();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CENTER:</span><br><span class="line">            <span class="keyword">case</span> MATRIX:</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// Do nothing.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> into(</span><br><span class="line">            <span class="comment">//这个transcodeClass是指的drawable或bitmap,就是前面as函数传入的类型</span></span><br><span class="line">            glideContext.buildImageViewTarget(view, transcodeClass),</span><br><span class="line">            <span class="comment">/*targetListener=*/</span> <span class="keyword">null</span>,</span><br><span class="line">            requestOptions,</span><br><span class="line">            <span class="comment">//在主线程，也就是通过 主线程的Handler 执行</span></span><br><span class="line">            Executors.mainThreadExecutor());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-1、构造ImageviewTarget"><a href="#3-3-1、构造ImageviewTarget" class="headerlink" title="3.3.1、构造ImageviewTarget"></a>3.3.1、构造ImageviewTarget</h3><p>into 中做的第一件事情就是构造出一个 <code>ImageviewTarget </code>对象，具体过程如下。</p>
<h4 id="1、GlideContext-buildImageViewTarget"><a href="#1、GlideContext-buildImageViewTarget" class="headerlink" title="1、GlideContext # buildImageViewTarget"></a>1、GlideContext # buildImageViewTarget</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;X&gt; <span class="function">ViewTarget&lt;ImageView, X&gt; <span class="title">buildImageViewTarget</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@NonNull</span> ImageView imageView, <span class="meta">@NonNull</span> Class&lt;X&gt; transcodeClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> imageViewTargetFactory.buildTarget(imageView, transcodeClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、ImageViewTargetFactory-buildTarget"><a href="#2、ImageViewTargetFactory-buildTarget" class="headerlink" title="2、ImageViewTargetFactory # buildTarget"></a>2、ImageViewTargetFactory # buildTarget</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;Z&gt; <span class="function">ViewTarget&lt;ImageView, Z&gt; <span class="title">buildTarget</span><span class="params">(<span class="meta">@NonNull</span> ImageView view,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="meta">@NonNull</span> Class&lt;Z&gt; clazz)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Bitmap.class.equals(clazz)) &#123;</span><br><span class="line">    <span class="keyword">return</span> (ViewTarget&lt;ImageView, Z&gt;) <span class="keyword">new</span> BitmapImageViewTarget(view);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Drawable.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">    <span class="comment">//因为前面调用asDrawable ，所以会创建这个ViewTarget</span></span><br><span class="line">    <span class="keyword">return</span> (ViewTarget&lt;ImageView, Z&gt;) <span class="keyword">new</span> DrawableImageViewTarget(view);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">        <span class="string">&quot;Unhandled class: &quot;</span> + clazz + <span class="string">&quot;, try .as*(Class).transcode(ResourceTranscoder)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Glide内部只维护了两种target，一种是BitmapImageViewTarget，另一种则是DrawableImageViewTarget。这个class参数其实基本上只有两种情况，如果你在使用Glide加载图片的时候调用了<code>asBitmap()</code>方法，那么这里就会构建出<code>BitmapImageViewTarget</code>对象，否则的话构建的都是<code>DrawableImageViewTarget</code>对象。</p>
<p>接着我们继续看第二个重载的 into 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;Y extends Target&lt;TranscodeType&gt;&gt; <span class="function">Y <span class="title">into</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@NonNull</span> Y target,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Nullable</span> RequestListener&lt;TranscodeType&gt; targetListener,</span></span></span><br><span class="line"><span class="params"><span class="function">        BaseRequestOptions&lt;?&gt; options,</span></span></span><br><span class="line"><span class="params"><span class="function">        Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line">    Preconditions.checkNotNull(target);</span><br><span class="line">    <span class="keyword">if</span> (!isModelSet) &#123;</span><br><span class="line">        <span class="comment">//调用过load 函数，这个变量是true</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;You must call #load() before calling #into()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	 <span class="comment">//1.创建请求，用于显示图片。图片有可能是从缓存中，也有可能是从网络获取</span></span><br><span class="line">    Request request = buildRequest(target, targetListener, options, callbackExecutor);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//获取该目标 对应的request，和当前的request进行比较</span></span><br><span class="line">    Request previous = target.getRequest();</span><br><span class="line">  <span class="comment">// 如果连续两次请求是相同的话，就会被复用，不管有没有开启缓存</span></span><br><span class="line">    <span class="keyword">if</span> (request.isEquivalentTo(previous)</span><br><span class="line">            &amp;&amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) &#123;</span><br><span class="line">        request.recycle();</span><br><span class="line">        <span class="comment">// If the request is completed, beginning again will ensure the result is re-delivered,</span></span><br><span class="line">        <span class="comment">// triggering RequestListeners and Targets. If the request is failed, beginning again will</span></span><br><span class="line">        <span class="comment">// restart the request, giving it another chance to complete. If the request is already</span></span><br><span class="line">        <span class="comment">// running, we can let it continue running without interruption.</span></span><br><span class="line">        <span class="keyword">if</span> (!Preconditions.checkNotNull(previous).isRunning()) &#123;</span><br><span class="line">            <span class="comment">// Use the previous request rather than the new one to allow for optimizations like skipping</span></span><br><span class="line">            <span class="comment">// setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions</span></span><br><span class="line">            <span class="comment">// that are done in the individual Request.</span></span><br><span class="line">            previous.begin();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    requestManager.clear(target);</span><br><span class="line">    <span class="comment">//把当前的request，设置到target（ViewTarget）</span></span><br><span class="line">    target.setRequest(request);</span><br><span class="line">    <span class="comment">//2.进行图片请求操作</span></span><br><span class="line">    requestManager.track(target, request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-2、构造Request请求"><a href="#3-3-2、构造Request请求" class="headerlink" title="3.3.2、构造Request请求"></a>3.3.2、构造Request请求</h3><p><code>RequestBuilder#buildRequest</code>构造Request请求，调用过程如下，最终调用到的是<code>SingleRequest构造函数</code>创建SingleRequest。</p>
<img src="/pics/image-20220208225151406.png" alt="image-20220208225151406" style="zoom:50%;" />

<p><code>buildRequestRecursive</code>设置成功及失败时的request。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Request <span class="title">buildRequestRecursive</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Object requestLock,</span></span></span><br><span class="line"><span class="params"><span class="function">    Target&lt;TranscodeType&gt; target,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="meta">@Nullable</span> RequestListener&lt;TranscodeType&gt; targetListener,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="meta">@Nullable</span> RequestCoordinator parentCoordinator,</span></span></span><br><span class="line"><span class="params"><span class="function">    TransitionOptions&lt;?, ? <span class="keyword">super</span> TranscodeType&gt; transitionOptions,</span></span></span><br><span class="line"><span class="params"><span class="function">    Priority priority,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> overrideWidth,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> overrideHeight,</span></span></span><br><span class="line"><span class="params"><span class="function">    BaseRequestOptions&lt;?&gt; requestOptions,</span></span></span><br><span class="line"><span class="params"><span class="function">    Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Build the ErrorRequestCoordinator first if necessary so we can update parentCoordinator.</span></span><br><span class="line">  <span class="comment">//判断是否设置了，发生错误时，显示的图片</span></span><br><span class="line">  ErrorRequestCoordinator errorRequestCoordinator = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (errorBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line">    errorRequestCoordinator = <span class="keyword">new</span> ErrorRequestCoordinator(requestLock, parentCoordinator);</span><br><span class="line">    parentCoordinator = errorRequestCoordinator;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建缩略图和原图的Request</span></span><br><span class="line">  Request mainRequest =</span><br><span class="line">      buildThumbnailRequestRecursive(</span><br><span class="line">          requestLock,</span><br><span class="line">          target,</span><br><span class="line">          targetListener,</span><br><span class="line">          parentCoordinator,</span><br><span class="line">          transitionOptions,</span><br><span class="line">          priority,</span><br><span class="line">          overrideWidth,</span><br><span class="line">          overrideHeight,</span><br><span class="line">          requestOptions,</span><br><span class="line">          callbackExecutor);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (errorRequestCoordinator == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> mainRequest;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> errorOverrideWidth = errorBuilder.getOverrideWidth();</span><br><span class="line">  <span class="keyword">int</span> errorOverrideHeight = errorBuilder.getOverrideHeight();</span><br><span class="line">  <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight) &amp;&amp; !errorBuilder.isValidOverride()) &#123;</span><br><span class="line">    errorOverrideWidth = requestOptions.getOverrideWidth();</span><br><span class="line">    errorOverrideHeight = requestOptions.getOverrideHeight();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建错误时图片的内容</span></span><br><span class="line">  Request errorRequest =</span><br><span class="line">      errorBuilder.buildRequestRecursive(</span><br><span class="line">          requestLock,</span><br><span class="line">          target,</span><br><span class="line">          targetListener,</span><br><span class="line">          errorRequestCoordinator,</span><br><span class="line">          errorBuilder.transitionOptions,</span><br><span class="line">          errorBuilder.getPriority(),</span><br><span class="line">          errorOverrideWidth,</span><br><span class="line">          errorOverrideHeight,</span><br><span class="line">          errorBuilder,</span><br><span class="line">          callbackExecutor);</span><br><span class="line">  errorRequestCoordinator.setRequests(mainRequest, errorRequest);</span><br><span class="line">  <span class="keyword">return</span> errorRequestCoordinator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-3、执行Request请求"><a href="#3-3-3、执行Request请求" class="headerlink" title="3.3.3、执行Request请求"></a>3.3.3、执行Request请求</h3><p> <code>RequestManager#track</code>负责执行Request请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">track</span><span class="params">(<span class="meta">@NonNull</span> Target&lt;?&gt; target, <span class="meta">@NonNull</span> Request request)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//把填充目标（这里是ImageView）加入跟踪器里，如果activity生命周期发生变化，就会执行填充目标相应的生命周期</span></span><br><span class="line">    targetTracker.track(target);</span><br><span class="line">    <span class="comment">//执行Request</span></span><br><span class="line">    requestTracker.runRequest(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1、RequestTracker-runRequest"><a href="#1、RequestTracker-runRequest" class="headerlink" title="1、RequestTracker#runRequest"></a>1、RequestTracker#runRequest</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runRequest</span><span class="params">(<span class="meta">@NonNull</span> Request request)</span> </span>&#123;</span><br><span class="line">  requests.add(request);</span><br><span class="line">  <span class="keyword">if</span> (!isPaused) &#123;</span><br><span class="line">    <span class="comment">// 执行请求</span></span><br><span class="line">    request.begin();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    request.clear();</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">      Log.v(TAG, <span class="string">&quot;Paused, delaying request&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pendingRequests.add(request);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、SingleRequest-begin"><a href="#2、SingleRequest-begin" class="headerlink" title="2、SingleRequest#begin"></a>2、SingleRequest#begin</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (requestLock) &#123;</span><br><span class="line">    assertNotCallingCallbacks();</span><br><span class="line">    stateVerifier.throwIfRecycled();</span><br><span class="line">    startTime = LogTime.getLogTime();</span><br><span class="line">    <span class="comment">// model（url）为空，回调加载失败</span></span><br><span class="line">    <span class="keyword">if</span> (model == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class="line">        width = overrideWidth;</span><br><span class="line">        height = overrideHeight;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Only log at more verbose log levels if the user has set a fallback drawable, because</span></span><br><span class="line">      <span class="comment">// fallback Drawables indicate the user expects null models occasionally.</span></span><br><span class="line">      <span class="keyword">int</span> logLevel = getFallbackDrawable() == <span class="keyword">null</span> ? Log.WARN : Log.DEBUG;</span><br><span class="line">      onLoadFailed(<span class="keyword">new</span> GlideException(<span class="string">&quot;Received null model&quot;</span>), logLevel);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status == Status.RUNNING) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Cannot restart a running request&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存图加载成功</span></span><br><span class="line">    <span class="keyword">if</span> (status == Status.COMPLETE) &#123;</span><br><span class="line">      onResourceReady(</span><br><span class="line">          resource, DataSource.MEMORY_CACHE, <span class="comment">/* isLoadedFromAlternateCacheKey= */</span> <span class="keyword">false</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status = Status.WAITING_FOR_SIZE;</span><br><span class="line">  <span class="comment">//glide 会根据显示图片的宽高进行缓存，所以这里需要获得View的宽高，overrideWidth，overrideHeight默认为-1，所以第一次会到else分支，获取View的宽高</span></span><br><span class="line">    <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class="line">      <span class="comment">// 当使用override() API为图片指定了一个固定的宽高时直接执行onSizeReady，</span></span><br><span class="line">      <span class="comment">// 最终的核心处理位于onSizeReady</span></span><br><span class="line">      onSizeReady(overrideWidth, overrideHeight);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 根据imageView的宽高算出图片的宽高，最终也会走到onSizeReady</span></span><br><span class="line">      target.getSize(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)</span><br><span class="line">        &amp;&amp; canNotifyStatusChanged()) &#123;</span><br><span class="line">      <span class="comment">// 预先加载设置的占位图</span></span><br><span class="line">      target.onLoadStarted(getPlaceholderDrawable());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (IS_VERBOSE_LOGGABLE) &#123;</span><br><span class="line">      logV(<span class="string">&quot;finished run method in &quot;</span> + LogTime.getElapsedMillis(startTime));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真正的请求 是在 onSizeReady 开始的</p>
<h4 id="3、SingleRequest-onSizeReady"><a href="#3、SingleRequest-onSizeReady" class="headerlink" title="3、SingleRequest #onSizeReady"></a>3、SingleRequest #onSizeReady</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">onSizeReady</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status != Status.WAITING_FOR_SIZE) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置状态为正在请求</span></span><br><span class="line">    status = Status.RUNNING;</span><br><span class="line">	<span class="comment">//设置宽高</span></span><br><span class="line">    <span class="keyword">float</span> sizeMultiplier = requestOptions.getSizeMultiplier();</span><br><span class="line">    <span class="keyword">this</span>.width = maybeApplySizeMultiplier(width, sizeMultiplier);</span><br><span class="line">    <span class="keyword">this</span>.height = maybeApplySizeMultiplier(height, sizeMultiplier);</span><br><span class="line">	</span><br><span class="line">	 <span class="comment">//这里的engine 是在创建Glide的时候，build() 创建的，engine封装了各种Executor，内存缓存等</span></span><br><span class="line">    loadStatus =</span><br><span class="line">            engine.load(</span><br><span class="line">                    glideContext,</span><br><span class="line">                    model,</span><br><span class="line">                    requestOptions.getSignature(),</span><br><span class="line">                    <span class="keyword">this</span>.width,</span><br><span class="line">                    <span class="keyword">this</span>.height,</span><br><span class="line">                    requestOptions.getResourceClass(),</span><br><span class="line">                    transcodeClass,</span><br><span class="line">                    priority,</span><br><span class="line">                    requestOptions.getDiskCacheStrategy(),</span><br><span class="line">                    requestOptions.getTransformations(),</span><br><span class="line">                    requestOptions.isTransformationRequired(),</span><br><span class="line">                    requestOptions.isScaleOnlyOrNoTransform(),</span><br><span class="line">                    requestOptions.getOptions(),</span><br><span class="line">                    requestOptions.isMemoryCacheable(),</span><br><span class="line">                    requestOptions.getUseUnlimitedSourceGeneratorsPool(),</span><br><span class="line">                    requestOptions.getUseAnimationPool(),</span><br><span class="line">                    requestOptions.getOnlyRetrieveFromCache(),</span><br><span class="line">                    <span class="keyword">this</span>,</span><br><span class="line">                    callbackExecutor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is a hack that&#x27;s only useful for testing right now where loads complete synchronously</span></span><br><span class="line">    <span class="comment">// even though under any executor running on any thread but the main thread, the load would</span></span><br><span class="line">    <span class="comment">// have completed asynchronously.</span></span><br><span class="line">    <span class="keyword">if</span> (status != Status.RUNNING) &#123;</span><br><span class="line">        loadStatus = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-4、Engine-load"><a href="#3-3-4、Engine-load" class="headerlink" title="3.3.4、Engine # load"></a>3.3.4、Engine # load</h3><p>开始图片请求，包含图片的三级缓存机制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R&gt; Engine.<span class="function">LoadStatus <span class="title">load</span><span class="params">(GlideContext glideContext, Object model, Key signature, <span class="keyword">int</span> width, <span class="keyword">int</span> height, Class&lt;?&gt; resourceClass, Class&lt;R&gt; transcodeClass, Priority priority, DiskCacheStrategy diskCacheStrategy, Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations, <span class="keyword">boolean</span> isTransformationRequired, <span class="keyword">boolean</span> isScaleOnlyOrNoTransform, Options options, <span class="keyword">boolean</span> isMemoryCacheable, <span class="keyword">boolean</span> useUnlimitedSourceExecutorPool, <span class="keyword">boolean</span> useAnimationPool, <span class="keyword">boolean</span> onlyRetrieveFromCache, ResourceCallback cb, Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTime = VERBOSE_IS_LOGGABLE ? LogTime.getLogTime() : <span class="number">0L</span>;</span><br><span class="line">    <span class="comment">// 1、构造缓存的key </span></span><br><span class="line">    EngineKey key = <span class="keyword">this</span>.keyFactory.buildKey(model, signature, width, height, transformations, resourceClass, transcodeClass, options);</span><br><span class="line">    EngineResource memoryResource;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">         <span class="comment">// 2、查找内存缓存</span></span><br><span class="line">        memoryResource = <span class="keyword">this</span>.loadFromMemory(key, isMemoryCacheable, startTime);</span><br><span class="line">        <span class="keyword">if</span> (memoryResource == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//3、查找磁盘缓存，如果没有通过网络加载</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.waitForExistingOrStartNewJob(glideContext, model, signature, width, height, resourceClass, transcodeClass, priority, diskCacheStrategy, transformations, isTransformationRequired, isScaleOnlyOrNoTransform, options, isMemoryCacheable, useUnlimitedSourceExecutorPool, useAnimationPool, onlyRetrieveFromCache, cb, callbackExecutor, key, startTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cb.onResourceReady(memoryResource, DataSource.MEMORY_CACHE, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-5、内存缓存加载"><a href="#3-3-5、内存缓存加载" class="headerlink" title="3.3.5、内存缓存加载"></a>3.3.5、内存缓存加载</h3><p><code>Engine # loadFromMemory</code>内存缓存分为：</p>
<ol>
<li>弱引用缓存<code>ActiveResources</code>，缓存正在使用中的图片。</li>
<li>内存缓存<code>LruCache</code>， 缓存不在使用中的图片（防止因Lru的策略，图片正在使用，但是被LRU策略回收掉的问题）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> EngineResource&lt;?&gt; loadFromMemory(EngineKey key, <span class="keyword">boolean</span> isMemoryCacheable, <span class="keyword">long</span> startTime) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isMemoryCacheable) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 1、加载正在使用的缓存（弱引用）</span></span><br><span class="line">        EngineResource&lt;?&gt; active = <span class="keyword">this</span>.loadFromActiveResources(key);</span><br><span class="line">        <span class="keyword">if</span> (active != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;</span><br><span class="line">                logWithTimeAndKey(<span class="string">&quot;Loaded resource from active resources&quot;</span>, startTime, key);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> active;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">// 2、加载正在使用的缓存（弱引用）</span></span><br><span class="line">            EngineResource&lt;?&gt; cached = <span class="keyword">this</span>.loadFromCache(key);</span><br><span class="line">            <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;</span><br><span class="line">                    logWithTimeAndKey(<span class="string">&quot;Loaded resource from cache&quot;</span>, startTime, key);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> cached;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1、加载弱引用缓存"><a href="#1、加载弱引用缓存" class="headerlink" title="1、加载弱引用缓存"></a>1、加载弱引用缓存</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> EngineResource&lt;?&gt; loadFromActiveResources(Key key) &#123;</span><br><span class="line">    EngineResource&lt;?&gt; active = <span class="keyword">this</span>.activeResources.get(key);</span><br><span class="line">    <span class="keyword">if</span> (active != <span class="keyword">null</span>) &#123;</span><br><span class="line">        active.acquire();<span class="comment">// 图片引用计数，&gt;0 说明正在被使用中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> active;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、加载Lru-缓存"><a href="#2、加载Lru-缓存" class="headerlink" title="2、加载Lru 缓存"></a>2、加载Lru 缓存</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> EngineResource&lt;?&gt; loadFromCache(Key key) &#123;</span><br><span class="line">    EngineResource&lt;?&gt; cached = <span class="keyword">this</span>.getEngineResourceFromCache(key);</span><br><span class="line">    <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 移动到弱引用缓存，计数 +1</span></span><br><span class="line">        cached.acquire();</span><br><span class="line">        <span class="keyword">this</span>.activeResources.activate(key, cached);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cached;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> EngineResource&lt;?&gt; getEngineResourceFromCache(Key key) &#123;</span><br><span class="line">    <span class="comment">// 正在使用的从 LRU 移除</span></span><br><span class="line">    Resource&lt;?&gt; cached = <span class="keyword">this</span>.cache.remove(key);</span><br><span class="line">    EngineResource result;</span><br><span class="line">    <span class="keyword">if</span> (cached == <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cached <span class="keyword">instanceof</span> EngineResource) &#123;</span><br><span class="line">        result = (EngineResource)cached;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = <span class="keyword">new</span> EngineResource(cached, <span class="keyword">true</span>, <span class="keyword">true</span>, key, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-6、从磁盘或网络加载"><a href="#3-3-6、从磁盘或网络加载" class="headerlink" title="3.3.6、从磁盘或网络加载"></a>3.3.6、从磁盘或网络加载</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;R&gt; Engine.<span class="function">LoadStatus <span class="title">waitForExistingOrStartNewJob</span><span class="params">(GlideContext glideContext, Object model, Key signature, <span class="keyword">int</span> width, <span class="keyword">int</span> height, Class&lt;?&gt; resourceClass, Class&lt;R&gt; transcodeClass, Priority priority, DiskCacheStrategy diskCacheStrategy, Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations, <span class="keyword">boolean</span> isTransformationRequired, <span class="keyword">boolean</span> isScaleOnlyOrNoTransform, Options options, <span class="keyword">boolean</span> isMemoryCacheable, <span class="keyword">boolean</span> useUnlimitedSourceExecutorPool, <span class="keyword">boolean</span> useAnimationPool, <span class="keyword">boolean</span> onlyRetrieveFromCache, ResourceCallback cb, Executor callbackExecutor, EngineKey key, <span class="keyword">long</span> startTime)</span> </span>&#123;</span><br><span class="line">    EngineJob&lt;?&gt; current = <span class="keyword">this</span>.jobs.get(key, onlyRetrieveFromCache);</span><br><span class="line">    <span class="keyword">if</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">        current.addCallback(cb, callbackExecutor);</span><br><span class="line">        <span class="keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;</span><br><span class="line">            logWithTimeAndKey(<span class="string">&quot;Added to existing load&quot;</span>, startTime, key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Engine.LoadStatus(cb, current);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 engineJob</span></span><br><span class="line">        EngineJob&lt;R&gt; engineJob = <span class="keyword">this</span>.engineJobFactory.build(key, isMemoryCacheable, useUnlimitedSourceExecutorPool, useAnimationPool, onlyRetrieveFromCache);</span><br><span class="line">        <span class="comment">// 解码的Job</span></span><br><span class="line">        DecodeJob&lt;R&gt; decodeJob = <span class="keyword">this</span>.decodeJobFactory.build(glideContext, model, key, signature, width, height, resourceClass, transcodeClass, priority, diskCacheStrategy, transformations, isTransformationRequired, isScaleOnlyOrNoTransform, onlyRetrieveFromCache, options, engineJob);</span><br><span class="line">        <span class="comment">// 放在Jobs内部维护的HashMap中</span></span><br><span class="line">        <span class="keyword">this</span>.jobs.put(key, engineJob);</span><br><span class="line">       <span class="comment">// 注册ResourceCallback接口，就是在成功获取图片后，需要显示到ImageView 上的回调，这个接口回调到SingleRequest 中</span></span><br><span class="line">        engineJob.addCallback(cb, callbackExecutor);</span><br><span class="line">        <span class="comment">// 开始执行</span></span><br><span class="line">        engineJob.start(decodeJob);</span><br><span class="line">        <span class="keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;</span><br><span class="line">            logWithTimeAndKey(<span class="string">&quot;Started new load&quot;</span>, startTime, key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Engine.LoadStatus(cb, engineJob);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1、EngineJob-start"><a href="#1、EngineJob-start" class="headerlink" title="1、EngineJob#start"></a>1、EngineJob#start</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(DecodeJob&lt;R&gt; decodeJob)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.decodeJob = decodeJob;</span><br><span class="line">    <span class="comment">//若能从磁盘缓存获取数据，就使用diskCacheExecutor</span></span><br><span class="line">    <span class="comment">//否则在根据其他的条件判断使用哪个Executor</span></span><br><span class="line">    GlideExecutor executor = decodeJob.willDecodeFromCache()</span><br><span class="line">            ? diskCacheExecutor</span><br><span class="line">            : getActiveSourceExecutor();</span><br><span class="line">    <span class="comment">// 执行 decodeJob</span></span><br><span class="line">    executor.execute(decodeJob);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、EngineJob-willDecodeFromCache"><a href="#2、EngineJob-willDecodeFromCache" class="headerlink" title="2、EngineJob#willDecodeFromCache"></a>2、EngineJob#willDecodeFromCache</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">willDecodeFromCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先看下面的getNextStage 分析</span></span><br><span class="line">    Stage firstStage = getNextStage(Stage.INITIALIZE);</span><br><span class="line">    <span class="comment">//那这里就很明了了，如果可以从磁盘缓存读取，就返回true</span></span><br><span class="line">    <span class="keyword">return</span> firstStage == Stage.RESOURCE_CACHE || firstStage == Stage.DATA_CACHE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、EngineJob-getNextStage"><a href="#3、EngineJob-getNextStage" class="headerlink" title="3、EngineJob#getNextStage"></a>3、EngineJob#getNextStage</h4><p>获取下一个阶段，应该从哪里获取数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Stage <span class="title">getNextStage</span><span class="params">(Stage current)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (current) &#123;</span><br><span class="line">        <span class="keyword">case</span> INITIALIZE:</span><br><span class="line">        <span class="comment">//当前是初始阶段，则看磁盘缓存策略，是否可以在磁盘中获取资源缓存（也就是解析后的缓存）</span></span><br><span class="line">            <span class="keyword">return</span> diskCacheStrategy.decodeCachedResource()</span><br><span class="line">                    ? Stage.RESOURCE_CACHE : getNextStage(Stage.RESOURCE_CACHE);</span><br><span class="line">        <span class="keyword">case</span> RESOURCE_CACHE:</span><br><span class="line">        <span class="comment">//当前是资源缓存，看下一步能不能从磁盘缓存中获取源数据缓存</span></span><br><span class="line">            <span class="keyword">return</span> diskCacheStrategy.decodeCachedData()</span><br><span class="line">                    ? Stage.DATA_CACHE : getNextStage(Stage.DATA_CACHE);</span><br><span class="line">        <span class="keyword">case</span> DATA_CACHE:</span><br><span class="line">            <span class="comment">// Skip loading from source if the user opted to only retrieve the resource from cache.</span></span><br><span class="line">            <span class="comment">//当前是数据缓存，下一步能不能从源数据处获取数据，例如从服务器获取</span></span><br><span class="line">            <span class="keyword">return</span> onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;</span><br><span class="line">        <span class="keyword">case</span> SOURCE:</span><br><span class="line">        <span class="keyword">case</span> FINISHED:</span><br><span class="line">            <span class="keyword">return</span> Stage.FINISHED;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unrecognized stage: &quot;</span> + current);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、DecodeJob-runWrapped"><a href="#4、DecodeJob-runWrapped" class="headerlink" title="4、DecodeJob#runWrapped"></a>4、DecodeJob#runWrapped</h4><p>DecodeJob 实现了Runnable接口，真正执行的是runWrapped。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.isCancelled) &#123;</span><br><span class="line">            <span class="keyword">this</span>.runWrapped();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化之后第一次运行时 runReason 为 INITIALIZE</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runWrapped</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    runWrappedCount++;</span><br><span class="line">    <span class="keyword">switch</span> (runReason) &#123;</span><br><span class="line">        <span class="keyword">case</span> INITIALIZE:</span><br><span class="line">            <span class="comment">//初始化之后第一次运行时, stage 返回的是source</span></span><br><span class="line">            stage = getNextStage(Stage.INITIALIZE);</span><br><span class="line">            <span class="comment">//根据下一阶段状态，判断具体由哪个类执行，source 对应是 SourceGenerator</span></span><br><span class="line">            currentGenerator = getNextGenerator();</span><br><span class="line">            runGenerators();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SWITCH_TO_SOURCE_SERVICE:</span><br><span class="line">            runGenerators();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DECODE_DATA:</span><br><span class="line">            decodeFromRetrievedData();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unrecognized run reason: &quot;</span> + runReason);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> DataFetcherGenerator <span class="title">getNextGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (stage) &#123;</span><br><span class="line">        <span class="comment">//从磁盘缓存获取资源数据</span></span><br><span class="line">        <span class="keyword">case</span> RESOURCE_CACHE:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ResourceCacheGenerator(decodeHelper, <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//从磁盘缓存获取源数据</span></span><br><span class="line">        <span class="keyword">case</span> DATA_CACHE:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DataCacheGenerator(decodeHelper, <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//从数据源获取数据，例如 从服务器获取数据</span></span><br><span class="line">        <span class="keyword">case</span> SOURCE:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SourceGenerator(decodeHelper, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">case</span> FINISHED:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unrecognized stage: &quot;</span> + stage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 采用用网络加载时这里的 Generator 是<code>SourceGenerator</code> ；采用缓存加载时是另外2个。</p>
<h4 id="5、DecodeJob-runGenerators"><a href="#5、DecodeJob-runGenerators" class="headerlink" title="5、DecodeJob#runGenerators"></a>5、DecodeJob#runGenerators</h4><p><code>currentGenerator.startNext()</code>加载数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runGenerators</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.currentThread = Thread.currentThread();</span><br><span class="line">    <span class="keyword">this</span>.startFetchTime = LogTime.getLogTime();</span><br><span class="line">    <span class="keyword">boolean</span> isStarted = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!<span class="keyword">this</span>.isCancelled &amp;&amp; <span class="keyword">this</span>.currentGenerator != <span class="keyword">null</span> &amp;&amp; !(isStarted =                                                                   <span class="keyword">this</span>.currentGenerator.startNext())) &#123; <span class="comment">// 加载数据</span></span><br><span class="line">        <span class="keyword">this</span>.stage = <span class="keyword">this</span>.getNextStage(<span class="keyword">this</span>.stage);</span><br><span class="line">        <span class="keyword">this</span>.currentGenerator = <span class="keyword">this</span>.getNextGenerator();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.stage == DecodeJob.Stage.SOURCE) &#123;</span><br><span class="line">            <span class="keyword">this</span>.reschedule();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">this</span>.stage == DecodeJob.Stage.FINISHED || <span class="keyword">this</span>.isCancelled) &amp;&amp; !isStarted) &#123;</span><br><span class="line">        <span class="keyword">this</span>.notifyFailed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="3-3-7、数据加载和回调"><a href="#3-3-7、数据加载和回调" class="headerlink" title="3.3.7、数据加载和回调"></a>3.3.7、数据加载和回调</h3><h4 id="1、SourceGenerator-startNext"><a href="#1、SourceGenerator-startNext" class="headerlink" title="1、SourceGenerator#startNext"></a>1、SourceGenerator#startNext</h4><p><code>startNext</code> 主要分为2步：</p>
<ol>
<li>获取合适的<code>LoadData</code>（里面封装了 DataFetche 包含我们在 GlideModule 中注册的ModelLoader</li>
<li>使用 DataFetcher 加载数据，这里的DataFetcher 就是 <code>HttpUrlFetcher</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (dataToCache != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Object data = dataToCache;</span><br><span class="line">    dataToCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 缓存原始数据</span></span><br><span class="line">    cacheData(data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sourceCacheGenerator != <span class="keyword">null</span> &amp;&amp; sourceCacheGenerator.startNext()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  sourceCacheGenerator = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  loadData = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) &#123;</span><br><span class="line">    <span class="comment">//helper.getLoadData() 获取所有符合条件的ModelLoader，这些ModelLoader 包括默认的和自定义的</span></span><br><span class="line">           <span class="comment">// 这里的符合条件，也就是ModelLoader 中的handles函数是否返回true，再说直白点，就是判断在load()传入的对象类型，是否可以被ModelLoader所处理</span></span><br><span class="line">    loadData = helper.getLoadData().get(loadDataListIndex++);</span><br><span class="line">    <span class="keyword">if</span> (loadData != <span class="keyword">null</span></span><br><span class="line">        &amp;&amp; (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())</span><br><span class="line">            || helper.hasLoadPath(loadData.fetcher.getDataClass()))) &#123;</span><br><span class="line">      started = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">//通过LoadData对象内部的 fetcher ，来进行实际的请求操作（例如发起网络请求）</span></span><br><span class="line">      startNextLoad(loadData);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> started;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、SourceGenerator-startNextLoad"><a href="#2、SourceGenerator-startNextLoad" class="headerlink" title="2、SourceGenerator#startNextLoad"></a>2、SourceGenerator#startNextLoad</h4><p><code>SourceGenerator#startNextLoad</code>包含了数据加载和回调过程。这里的fetcher 是<code>HttpUrlFetcher</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startNextLoad</span><span class="params">(<span class="keyword">final</span> LoadData&lt;?&gt; toStart)</span> </span>&#123;</span><br><span class="line">  loadData.fetcher.loadData(</span><br><span class="line">      helper.getPriority(),</span><br><span class="line">      <span class="keyword">new</span> DataCallback&lt;Object&gt;() &#123;<span class="comment">//传入回调的callback</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataReady</span><span class="params">(<span class="meta">@Nullable</span> Object data)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (isCurrentRequest(toStart)) &#123;</span><br><span class="line">            onDataReadyInternal(toStart, data);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoadFailed</span><span class="params">(<span class="meta">@NonNull</span> Exception e)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (isCurrentRequest(toStart)) &#123;</span><br><span class="line">            onLoadFailedInternal(toStart, e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、HttpUrlFetcher-loadData"><a href="#3、HttpUrlFetcher-loadData" class="headerlink" title="3、HttpUrlFetcher#loadData"></a>3、HttpUrlFetcher#loadData</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="meta">@NonNull</span> Priority priority, <span class="meta">@NonNull</span> DataCallback&lt;? <span class="keyword">super</span> InputStream&gt; callback)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 1、请求网络数据</span></span><br><span class="line">    InputStream result = loadDataWithRedirects(glideUrl.toURL(), <span class="number">0</span>, <span class="keyword">null</span>, glideUrl.getHeaders());</span><br><span class="line">    <span class="comment">// 2、进行回调</span></span><br><span class="line">    callback.onDataReady(result);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">      Log.d(TAG, <span class="string">&quot;Failed to load data for url&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    callback.onLoadFailed(e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">      Log.v(TAG, <span class="string">&quot;Finished http url fetcher fetch in &quot;</span> + LogTime.getElapsedMillis(startTime));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> InputStream <span class="title">loadDataWithRedirects</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    URL url, <span class="keyword">int</span> redirects, URL lastUrl, Map&lt;String, String&gt; headers)</span> <span class="keyword">throws</span> HttpException </span>&#123;</span><br><span class="line">  <span class="comment">// 重定向次数限制</span></span><br><span class="line">  <span class="keyword">if</span> (redirects &gt;= MAXIMUM_REDIRECTS) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(</span><br><span class="line">        <span class="string">&quot;Too many (&gt; &quot;</span> + MAXIMUM_REDIRECTS + <span class="string">&quot;) redirects!&quot;</span>, INVALID_STATUS_CODE);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  urlConnection = buildAndConfigureConnection(url, headers);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// Connect explicitly to avoid errors in decoders if connection fails.</span></span><br><span class="line">    urlConnection.connect();</span><br><span class="line">    <span class="comment">// Set the stream so that it&#x27;s closed in cleanup to avoid resource leaks. See #2352.</span></span><br><span class="line">    stream = urlConnection.getInputStream();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(</span><br><span class="line">        <span class="string">&quot;Failed to connect or obtain data&quot;</span>, getHttpStatusCodeOrInvalid(urlConnection), e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isCancelled) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> statusCode = getHttpStatusCodeOrInvalid(urlConnection);</span><br><span class="line">  <span class="keyword">if</span> (isHttpOk(statusCode)) &#123;</span><br><span class="line">    <span class="keyword">return</span> getStreamForSuccessfulRequest(urlConnection);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isHttpRedirect(statusCode)) &#123;</span><br><span class="line">    String redirectUrlString = urlConnection.getHeaderField(REDIRECT_HEADER_FIELD);</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(redirectUrlString)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(<span class="string">&quot;Received empty or null redirect url&quot;</span>, statusCode);</span><br><span class="line">    &#125;</span><br><span class="line">    URL redirectUrl;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      redirectUrl = <span class="keyword">new</span> URL(url, redirectUrlString);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(<span class="string">&quot;Bad redirect url: &quot;</span> + redirectUrlString, statusCode, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Closing the stream specifically is required to avoid leaking ResponseBodys in addition</span></span><br><span class="line">    <span class="comment">// to disconnecting the url connection below. See #2352.</span></span><br><span class="line">    cleanup();</span><br><span class="line">    <span class="comment">// 递归,多次重定向</span></span><br><span class="line">    <span class="keyword">return</span> loadDataWithRedirects(redirectUrl, redirects + <span class="number">1</span>, url, headers);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-8、数据回调过程"><a href="#3-3-8、数据回调过程" class="headerlink" title="3.3.8、数据回调过程"></a>3.3.8、数据回调过程</h3><h4 id="1、SourceGenerator-onDataReady"><a href="#1、SourceGenerator-onDataReady" class="headerlink" title="1、SourceGenerator#onDataReady"></a>1、SourceGenerator#onDataReady</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startNextLoad</span><span class="params">(<span class="keyword">final</span> LoadData&lt;?&gt; toStart)</span> </span>&#123;</span><br><span class="line">  loadData.fetcher.loadData(</span><br><span class="line">      helper.getPriority(),</span><br><span class="line">      <span class="keyword">new</span> DataCallback&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataReady</span><span class="params">(<span class="meta">@Nullable</span> Object data)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (isCurrentRDEequest(toStart)) &#123;</span><br><span class="line">            onDataReadyInternal(toStart, data);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoadFailed</span><span class="params">(<span class="meta">@NonNull</span> Exception e)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (isCurrentRequest(toStart)) &#123;</span><br><span class="line">            onLoadFailedInternal(toStart, e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onDataReadyInternal</span><span class="params">(LoadData&lt;?&gt; loadData, Object data)</span> </span>&#123;</span><br><span class="line">  DiskCacheStrategy diskCacheStrategy = helper.getDiskCacheStrategy();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (data != <span class="keyword">null</span> &amp;&amp; diskCacheStrategy.isDataCacheable(loadData.fetcher.getDataSource())) &#123;</span><br><span class="line">    <span class="comment">//如果该数据类型，有启用磁盘缓存，就把值付给dataToCache </span></span><br><span class="line">    dataToCache = data;</span><br><span class="line">   <span class="comment">//调用DecodeJob的reschedule，用线程池执行任务，实际上就是再次调用SourceGenerator的startNext</span></span><br><span class="line">    cb.reschedule();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 没有启用调用到DecodeJob中，我们先看没有开启磁盘缓存的过程</span></span><br><span class="line">    cb.onDataFetcherReady(</span><br><span class="line">        loadData.sourceKey,</span><br><span class="line">        data,</span><br><span class="line">        loadData.fetcher,</span><br><span class="line">        loadData.fetcher.getDataSource(),</span><br><span class="line">        originalKey);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、DecodeJob-onDataFetcherReady"><a href="#2、DecodeJob-onDataFetcherReady" class="headerlink" title="2、DecodeJob#onDataFetcherReady"></a>2、DecodeJob#onDataFetcherReady</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataFetcherReady</span><span class="params">(Key sourceKey, Object data, DataFetcher&lt;?&gt; fetcher, DataSource dataSource, Key attemptedKey)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.currentSourceKey = sourceKey;</span><br><span class="line">    <span class="keyword">this</span>.currentData = data;</span><br><span class="line">    <span class="keyword">this</span>.currentFetcher = fetcher;</span><br><span class="line">    <span class="keyword">this</span>.currentDataSource = dataSource;</span><br><span class="line">    <span class="keyword">this</span>.currentAttemptingKey = attemptedKey;</span><br><span class="line">    <span class="keyword">this</span>.isLoadingFromAlternateCacheKey = sourceKey != <span class="keyword">this</span>.decodeHelper.getCacheKeys().get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != <span class="keyword">this</span>.currentThread) &#123;</span><br><span class="line">        <span class="keyword">this</span>.runReason = DecodeJob.RunReason.DECODE_DATA;</span><br><span class="line">        <span class="keyword">this</span>.callback.reschedule(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        GlideTrace.beginSection(<span class="string">&quot;DecodeJob.decodeFromRetrievedData&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 解码过程</span></span><br><span class="line">            <span class="keyword">this</span>.decodeFromRetrievedData();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            GlideTrace.endSection();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、DecodeJob-decodeFromRetrievedData"><a href="#3、DecodeJob-decodeFromRetrievedData" class="headerlink" title="3、DecodeJob#decodeFromRetrievedData"></a>3、DecodeJob#decodeFromRetrievedData</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decodeFromRetrievedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(<span class="string">&quot;DecodeJob&quot;</span>, <span class="number">2</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.logWithTimeAndKey(<span class="string">&quot;Retrieved data&quot;</span>, <span class="keyword">this</span>.startFetchTime, <span class="string">&quot;data: &quot;</span> + <span class="keyword">this</span>.currentData + <span class="string">&quot;, cache key: &quot;</span> + <span class="keyword">this</span>.currentSourceKey + <span class="string">&quot;, fetcher: &quot;</span> + <span class="keyword">this</span>.currentFetcher);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Resource resource = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    		<span class="comment">// 1.从数据中解码得到资源，这个3.3.10讲</span></span><br><span class="line">        resource = <span class="keyword">this</span>.decodeFromData(<span class="keyword">this</span>.currentFetcher, <span class="keyword">this</span>.currentData, <span class="keyword">this</span>.currentDataSource);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (GlideException var3) &#123;</span><br><span class="line">        var3.setLoggingDetails(<span class="keyword">this</span>.currentAttemptingKey, <span class="keyword">this</span>.currentDataSource);</span><br><span class="line">        <span class="keyword">this</span>.throwables.add(var3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resource != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.通知编码和发布，最终得到的Resource&lt;Bitmap&gt;对象，第24步</span></span><br><span class="line">        <span class="keyword">this</span>.notifyEncodeAndRelease(resource, <span class="keyword">this</span>.currentDataSource, <span class="keyword">this</span>.isLoadingFromAlternateCacheKey);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.runGenerators();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、DecodeJob-notifyEncodeAndRelease"><a href="#4、DecodeJob-notifyEncodeAndRelease" class="headerlink" title="4、DecodeJob#notifyEncodeAndRelease"></a>4、DecodeJob#notifyEncodeAndRelease</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyEncodeAndRelease</span><span class="params">(Resource&lt;R&gt; resource, DataSource dataSource)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (resource <span class="keyword">instanceof</span> Initializable) &#123;</span><br><span class="line">            ((Initializable) resource).initialize();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Resource&lt;R&gt; result = resource;</span><br><span class="line">        LockedResource&lt;R&gt; lockedResource = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (deferredEncodeManager.hasResourceToEncode()) &#123;</span><br><span class="line">            lockedResource = LockedResource.obtain(resource);</span><br><span class="line">            result = lockedResource;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1、通知主线程回调，加载图片</span></span><br><span class="line">        notifyComplete(result, dataSource);</span><br><span class="line">        <span class="comment">// 更新状态为编码</span></span><br><span class="line">        stage = Stage.ENCODE;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2、缓存转换后的图片</span></span><br><span class="line">            <span class="keyword">if</span> (deferredEncodeManager.hasResourceToEncode()) &#123;</span><br><span class="line">                <span class="comment">//磁盘缓存入口</span></span><br><span class="line">                deferredEncodeManager.encode(diskCacheProvider, options);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lockedResource != <span class="keyword">null</span>) &#123;</span><br><span class="line">                lockedResource.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Call onEncodeComplete outside the finally block so that it&#x27;s not called if the encode process</span></span><br><span class="line">        <span class="comment">// throws.</span></span><br><span class="line">        <span class="comment">// 资源释放</span></span><br><span class="line">        onEncodeComplete();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="5、EngineJob-notifyComplete"><a href="#5、EngineJob-notifyComplete" class="headerlink" title="5、EngineJob#notifyComplete"></a>5、EngineJob#notifyComplete</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyComplete</span><span class="params">(Resource&lt;R&gt; resource, DataSource dataSource, <span class="keyword">boolean</span> isLoadedFromAlternateCacheKey)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setNotifiedOrThrow();</span><br><span class="line">    <span class="comment">// 这个callback 是 EngineJob对象</span></span><br><span class="line">    <span class="keyword">this</span>.callback.onResourceReady(resource, dataSource, isLoadedFromAlternateCacheKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6、EngineJob-onResourceReady"><a href="#6、EngineJob-onResourceReady" class="headerlink" title="6、EngineJob#onResourceReady"></a>6、EngineJob#onResourceReady</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(Resource&lt;R&gt; resource, DataSource dataSource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.resource = resource;</span><br><span class="line">        <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">    notifyCallbacksOfResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7、EngineJob-notifyCallbacksOfResult"><a href="#7、EngineJob-notifyCallbacksOfResult" class="headerlink" title="7、EngineJob#notifyCallbacksOfResult"></a>7、EngineJob#notifyCallbacksOfResult</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notifyCallbacksOfResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ResourceCallbacksAndExecutors copy;</span><br><span class="line">  Key localKey;</span><br><span class="line">  EngineResource&lt;?&gt; localResource;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		</span><br><span class="line">    engineResource = engineResourceFactory.build(resource, isCacheable, key, resourceListener);</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    hasResource = <span class="keyword">true</span>;</span><br><span class="line">    copy = cbs.copy();</span><br><span class="line">    incrementPendingCallbacks(copy.size() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    localKey = key;</span><br><span class="line">    localResource = engineResource;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//这里就是把解析后的图片，也就是即将要显示出来的图片，缓存到弱引用缓存中</span></span><br><span class="line">  engineJobListener.onEngineJobComplete(<span class="keyword">this</span>, localKey, localResource);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//遍历每一个回调接口，entry.cb 就是SingleRequest 对象，执行接口ResourceCallback</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">final</span> ResourceCallbackAndExecutor entry : copy) &#123;</span><br><span class="line">    entry.executor.execute(<span class="keyword">new</span> CallResourceReady(entry.cb));</span><br><span class="line">  &#125;</span><br><span class="line">  decrementPendingCallbacks();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8、内部类CallResourceReady-run"><a href="#8、内部类CallResourceReady-run" class="headerlink" title="8、内部类CallResourceReady # run"></a>8、内部类CallResourceReady # run</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (EngineJob.<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cbs.contains(cb)) &#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">//执行回调</span></span><br><span class="line">            callCallbackOnResourceReady(cb);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">callCallbackOnResourceReady</span><span class="params">(ResourceCallback cb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//cb 就是SingleRequest 对象，所以下面去它里面看onResourceReady</span></span><br><span class="line">	</span><br><span class="line">        cb.onResourceReady(engineResource, dataSource);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CallbackException(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9、SingleRequest-onResourceReady"><a href="#9、SingleRequest-onResourceReady" class="headerlink" title="9、SingleRequest#onResourceReady"></a>9、SingleRequest#onResourceReady</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Resource&lt;?&gt; resource, DataSource dataSource, <span class="keyword">boolean</span> isLoadedFromAlternateCacheKey)</span> </span>&#123;</span><br><span class="line">  stateVerifier.throwIfRecycled();</span><br><span class="line">  Resource&lt;?&gt; toRelease = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (requestLock) &#123;</span><br><span class="line"> 				</span><br><span class="line">			<span class="comment">//...</span></span><br><span class="line">      onResourceReady(</span><br><span class="line">          (Resource&lt;R&gt;) resource, (R) received, dataSource, isLoadedFromAlternateCacheKey);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (toRelease != <span class="keyword">null</span>) &#123;</span><br><span class="line">      engine.release(toRelease);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Resource&lt;R&gt; resource, R result, DataSource dataSource, <span class="keyword">boolean</span> isAlternateCacheKey)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// We must call isFirstReadyResource before setting status.</span></span><br><span class="line">  <span class="keyword">boolean</span> isFirstResource = isFirstReadyResource();</span><br><span class="line">  status = Status.COMPLETE;</span><br><span class="line">  <span class="keyword">this</span>.resource = resource;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  isCallingCallbacks = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="comment">// 这个target 是DrawableImageViewTarget</span></span><br><span class="line">      target.onResourceReady(result, animation);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    isCallingCallbacks = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  notifyLoadSuccess();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-9、-设置图像到View"><a href="#3-3-9、-设置图像到View" class="headerlink" title="3.3.9、 设置图像到View"></a>3.3.9、 设置图像到View</h3><p><code>DrawableImageViewTarget</code>继承自<code>ImageViewTarget</code>，调用到的是<code>ImageViewTarget</code>的方法</p>
<h4 id="1、ImageViewTarget-onResourceReady"><a href="#1、ImageViewTarget-onResourceReady" class="headerlink" title="1、ImageViewTarget#onResourceReady"></a>1、ImageViewTarget#onResourceReady</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(<span class="meta">@NonNull</span> Z resource, <span class="meta">@Nullable</span> Transition&lt;? <span class="keyword">super</span> Z&gt; transition)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (transition == <span class="keyword">null</span> || !transition.transition(resource, <span class="keyword">this</span>)) &#123;</span><br><span class="line">    <span class="comment">// 调用到set方法</span></span><br><span class="line">    setResourceInternal(resource);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    maybeUpdateAnimatable(resource);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setResourceInternal</span><span class="params">(<span class="meta">@Nullable</span> Z resource)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 设置图像到view</span></span><br><span class="line">  setResource(resource);</span><br><span class="line">  maybeUpdateAnimatable(resource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setResource</span><span class="params">(<span class="meta">@Nullable</span> Z resource)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="2、DrawableImageViewTarget-setResource"><a href="#2、DrawableImageViewTarget-setResource" class="headerlink" title="2、DrawableImageViewTarget#setResource"></a>2、DrawableImageViewTarget#setResource</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setResource</span><span class="params">(<span class="meta">@Nullable</span> Drawable resource)</span> </span>&#123;</span><br><span class="line">  view.setImageDrawable(resource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此Glide仅使用网络数据加载流程就分析结束了。下面补充下解码和缓存和图片转换的过程。</p>
<h3 id="3-3-10、数据解码为图片过程"><a href="#3-3-10、数据解码为图片过程" class="headerlink" title="3.3.10、数据解码为图片过程"></a>3.3.10、数据解码为图片过程</h3><p>上面流程中，我们跳过了图片转换过程，这里补充下。代码入口是在：</p>
<h4 id="1、DecodeJob-decodeFromData"><a href="#1、DecodeJob-decodeFromData" class="headerlink" title="1、DecodeJob#decodeFromData"></a>1、DecodeJob#decodeFromData</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;Data&gt; <span class="function">Resource&lt;R&gt; <span class="title">decodeFromData</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    DataFetcher&lt;?&gt; fetcher, Data data, DataSource dataSource)</span> <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line">    Resource&lt;R&gt; result = decodeFromFetcher(data, dataSource);</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">      logWithTimeAndKey(<span class="string">&quot;Decoded result &quot;</span> + result, startTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    fetcher.cleanup();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;Data&gt; <span class="function">Resource&lt;R&gt; <span class="title">decodeFromFetcher</span><span class="params">(Data data, DataSource dataSource)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">  LoadPath&lt;Data, ?, R&gt; path = decodeHelper.getLoadPath((Class&lt;Data&gt;) data.getClass());</span><br><span class="line">  <span class="keyword">return</span> runLoadPath(data, dataSource, path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、DecodeJob-runLoadPath"><a href="#2、DecodeJob-runLoadPath" class="headerlink" title="2、DecodeJob#runLoadPath"></a>2、DecodeJob#runLoadPath</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;Data, ResourceType&gt; <span class="function">Resource&lt;R&gt; <span class="title">runLoadPath</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Data data, DataSource dataSource, LoadPath&lt;Data, ResourceType, R&gt; path)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">  Options options = getOptionsWithHardwareConfig(dataSource);</span><br><span class="line">  DataRewinder&lt;Data&gt; rewinder = glideContext.getRegistry().getRewinder(data);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ResourceType in DecodeCallback below is required for compilation to work with gradle.</span></span><br><span class="line">    <span class="keyword">return</span> path.load(</span><br><span class="line">        rewinder, options, width, height, <span class="keyword">new</span> DecodeCallback&lt;ResourceType&gt;(dataSource));</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    rewinder.cleanup();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Resource&lt;Transcode&gt; <span class="title">load</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    DataRewinder&lt;Data&gt; rewinder,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="meta">@NonNull</span> Options options,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">    DecodePath.DecodeCallback&lt;ResourceType&gt; decodeCallback)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">  List&lt;Throwable&gt; throwables = Preconditions.checkNotNull(listPool.acquire());</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> loadWithExceptionList(rewinder, options, width, height, decodeCallback, throwables);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    listPool.release(throwables);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Resource&lt;Transcode&gt; <span class="title">loadWithExceptionList</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    DataRewinder&lt;Data&gt; rewinder,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="meta">@NonNull</span> Options options,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">    DecodePath.DecodeCallback&lt;ResourceType&gt; decodeCallback,</span></span></span><br><span class="line"><span class="params"><span class="function">    List&lt;Throwable&gt; exceptions)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">  Resource&lt;Transcode&gt; result = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">//noinspection ForLoopReplaceableByForEach to improve perf</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = decodePaths.size(); i &lt; size; i++) &#123;</span><br><span class="line">    DecodePath&lt;Data, ResourceType, Transcode&gt; path = decodePaths.get(i);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      result = path.decode(rewinder, width, height, options, decodeCallback);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (GlideException e) &#123;</span><br><span class="line">      exceptions.add(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> GlideException(failureMessage, <span class="keyword">new</span> ArrayList&lt;&gt;(exceptions));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、DecodePath-decode"><a href="#3、DecodePath-decode" class="headerlink" title="3、DecodePath#decode"></a>3、DecodePath#decode</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Resource&lt;Transcode&gt; <span class="title">decode</span><span class="params">(DataRewinder&lt;DataType&gt; rewinder, <span class="keyword">int</span> width, <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="meta">@NonNull</span> Options options, DecodeCallback&lt;ResourceType&gt; callback)</span> <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">    <span class="comment">//解码                              </span></span><br><span class="line">    Resource&lt;ResourceType&gt; decoded = decodeResource(rewinder, width, height, options);</span><br><span class="line">    <span class="comment">// 这个方法是回调到Decodejob.onResourceDecoded ,作用是调用RequestOptions中的Transform处理图片，然后将ResourceCache的Key和Encode准备好（放在变量 deferEncoderManager中），稍后进行写入缓存。</span></span><br><span class="line">    Resource&lt;ResourceType&gt; transformed = callback.onResourceDecoded(decoded);</span><br><span class="line">    <span class="comment">//图片的转码过程，进行数据类型的转换</span></span><br><span class="line">    <span class="keyword">return</span> transcoder.transcode(transformed, options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Resource&lt;ResourceType&gt; <span class="title">decodeResourceWithList</span><span class="params">(DataRewinder&lt;DataType&gt; rewinder, <span class="keyword">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      <span class="keyword">int</span> height, <span class="meta">@NonNull</span> Options options, List&lt;Throwable&gt; exceptions)</span> <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">    Resource&lt;ResourceType&gt; result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//noinspection ForLoopReplaceableByForEach to improve perf</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = decoders.size(); i &lt; size; i++) &#123;</span><br><span class="line">        ResourceDecoder&lt;DataType, ResourceType&gt; decoder = decoders.get(i);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DataType data = rewinder.rewindAndGet();</span><br><span class="line">            <span class="keyword">if</span> (decoder.handles(data, options)) &#123;</span><br><span class="line">                data = rewinder.rewindAndGet();</span><br><span class="line">                <span class="comment">//根据DataType和ResourceType的类型分发给不同的解码器Decoder     </span></span><br><span class="line">                result = decoder.decode(data, width, height, options);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>decode是一个ResourceDecoder接口（资源解码器），根据不同的DataType和ResourceType它会有不同的实现类，这里的实现类是ByteBufferBitmapDecoder，下面看看它的decode 流程</p>
<h4 id="4、ByteBufferBitmapDecoder-decode"><a href="#4、ByteBufferBitmapDecoder-decode" class="headerlink" title="4、ByteBufferBitmapDecoder # decode"></a>4、ByteBufferBitmapDecoder # decode</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Resource&lt;Bitmap&gt; <span class="title">decode</span><span class="params">(<span class="meta">@NonNull</span> ByteBuffer source, <span class="keyword">int</span> width, <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="meta">@NonNull</span> Options options)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  InputStream is = ByteBufferUtil.toStream(source);</span><br><span class="line">  <span class="keyword">return</span> downsampler.decode(is, width, height, options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="5、DownSampler-decode"><a href="#5、DownSampler-decode" class="headerlink" title="5、DownSampler#decode"></a>5、DownSampler#decode</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Resource&lt;Bitmap&gt; <span class="title">decode</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ImageReader imageReader,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> requestedWidth,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> requestedHeight,</span></span></span><br><span class="line"><span class="params"><span class="function">    Options options,</span></span></span><br><span class="line"><span class="params"><span class="function">    DecodeCallbacks callbacks)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">byte</span>[] bytesForOptions = byteArrayPool.get(ArrayPool.STANDARD_BUFFER_SIZE_BYTES, <span class="keyword">byte</span>[].class);</span><br><span class="line">  BitmapFactory.Options bitmapFactoryOptions = getDefaultOptions();</span><br><span class="line">  bitmapFactoryOptions.inTempStorage = bytesForOptions;</span><br><span class="line"></span><br><span class="line">  DecodeFormat decodeFormat = options.get(DECODE_FORMAT);</span><br><span class="line">  PreferredColorSpace preferredColorSpace = options.get(PREFERRED_COLOR_SPACE);</span><br><span class="line">  DownsampleStrategy downsampleStrategy = options.get(DownsampleStrategy.OPTION);</span><br><span class="line">  <span class="keyword">boolean</span> fixBitmapToRequestedDimensions = options.get(FIX_BITMAP_SIZE_TO_REQUESTED_DIMENSIONS);</span><br><span class="line">  <span class="keyword">boolean</span> isHardwareConfigAllowed =</span><br><span class="line">      options.get(ALLOW_HARDWARE_CONFIG) != <span class="keyword">null</span> &amp;&amp; options.get(ALLOW_HARDWARE_CONFIG);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Bitmap result =</span><br><span class="line">        decodeFromWrappedStreams(</span><br><span class="line">            imageReader,</span><br><span class="line">            bitmapFactoryOptions,</span><br><span class="line">            downsampleStrategy,</span><br><span class="line">            decodeFormat,</span><br><span class="line">            preferredColorSpace,</span><br><span class="line">            isHardwareConfigAllowed,</span><br><span class="line">            requestedWidth,</span><br><span class="line">            requestedHeight,</span><br><span class="line">            fixBitmapToRequestedDimensions,</span><br><span class="line">            callbacks);</span><br><span class="line">     <span class="comment">//把bitmap 封装进Resource ，返回Resource 对象</span></span><br><span class="line">    <span class="keyword">return</span> BitmapResource.obtain(result, bitmapPool);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    releaseOptions(bitmapFactoryOptions);</span><br><span class="line">    <span class="comment">// BitmapOptions 缓存池</span></span><br><span class="line">    byteArrayPool.put(bytesForOptions);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6、DownSampler-decodeFromWrappedStreams"><a href="#6、DownSampler-decodeFromWrappedStreams" class="headerlink" title="6、DownSampler#decodeFromWrappedStreams"></a>6、DownSampler#decodeFromWrappedStreams</h4><p>这里涉及到bitmap在bitmapPool中的复用，目的是 如果bitmapPool 有可用的bitmap，就复用该bitmap。避免为Bitmap 分配内存，导致内存抖动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> Bitmap <span class="title">decodeFromWrappedStreams</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">     ImageReader imageReader,</span></span></span><br><span class="line"><span class="params"><span class="function">     BitmapFactory.Options options,</span></span></span><br><span class="line"><span class="params"><span class="function">     DownsampleStrategy downsampleStrategy,</span></span></span><br><span class="line"><span class="params"><span class="function">     DecodeFormat decodeFormat,</span></span></span><br><span class="line"><span class="params"><span class="function">     PreferredColorSpace preferredColorSpace,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">boolean</span> isHardwareConfigAllowed,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">int</span> requestedWidth,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">int</span> requestedHeight,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">boolean</span> fixBitmapToRequestedDimensions,</span></span></span><br><span class="line"><span class="params"><span class="function">     DecodeCallbacks callbacks)</span></span></span><br><span class="line"><span class="function">     <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span>[] sourceDimensions = getDimensions(imageReader, options, callbacks, bitmapPool);</span><br><span class="line">   <span class="keyword">int</span> sourceWidth = sourceDimensions[<span class="number">0</span>];</span><br><span class="line">   <span class="keyword">int</span> sourceHeight = sourceDimensions[<span class="number">1</span>];</span><br><span class="line">   String sourceMimeType = options.outMimeType;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// If we failed to obtain the image dimensions, we may end up with an incorrectly sized Bitmap,</span></span><br><span class="line">   <span class="comment">// so we want to use a mutable Bitmap type. One way this can happen is if the image header is so</span></span><br><span class="line">   <span class="comment">// large (10mb+) that our attempt to use inJustDecodeBounds fails and we&#x27;re forced to decode the</span></span><br><span class="line">   <span class="comment">// full size image.</span></span><br><span class="line">   <span class="keyword">if</span> (sourceWidth == -<span class="number">1</span> || sourceHeight == -<span class="number">1</span>) &#123;</span><br><span class="line">     isHardwareConfigAllowed = <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> orientation = imageReader.getImageOrientation();</span><br><span class="line">   <span class="keyword">int</span> degreesToRotate = TransformationUtils.getExifOrientationDegrees(orientation);</span><br><span class="line">   <span class="keyword">boolean</span> isExifOrientationRequired = TransformationUtils.isExifOrientationRequired(orientation);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> targetWidth =</span><br><span class="line">       requestedWidth == Target.SIZE_ORIGINAL</span><br><span class="line">           ? (isRotationRequired(degreesToRotate) ? sourceHeight : sourceWidth)</span><br><span class="line">           : requestedWidth;</span><br><span class="line">   <span class="keyword">int</span> targetHeight =</span><br><span class="line">       requestedHeight == Target.SIZE_ORIGINAL</span><br><span class="line">           ? (isRotationRequired(degreesToRotate) ? sourceWidth : sourceHeight)</span><br><span class="line">           : requestedHeight;</span><br><span class="line"></span><br><span class="line">   ImageType imageType = imageReader.getImageType();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//计算缩放比例，结果会体现在options参数中</span></span><br><span class="line">   calculateScaling(</span><br><span class="line">       imageType,</span><br><span class="line">       imageReader,</span><br><span class="line">       callbacks,</span><br><span class="line">       bitmapPool,</span><br><span class="line">       downsampleStrategy,</span><br><span class="line">       degreesToRotate,</span><br><span class="line">       sourceWidth,</span><br><span class="line">       sourceHeight,</span><br><span class="line">       targetWidth,</span><br><span class="line">       targetHeight,</span><br><span class="line">       options);</span><br><span class="line">       </span><br><span class="line">   calculateConfig(</span><br><span class="line">       imageReader,</span><br><span class="line">       decodeFormat,</span><br><span class="line">       isHardwareConfigAllowed,</span><br><span class="line">       isExifOrientationRequired,</span><br><span class="line">       options,</span><br><span class="line">       targetWidth,</span><br><span class="line">       targetHeight);</span><br><span class="line"><span class="comment">//计算sdk版本是否大于KITKAT，在该系统及之前 图片复用仅支持大小相同的位图 </span></span><br><span class="line">   <span class="keyword">boolean</span> isKitKatOrGreater = Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT;</span><br><span class="line">   <span class="comment">//下面的判断，来计算是否在BitmapPool中 是否有bitmap可以被复用，如果有就把bitmap 设置到options.inBitmap</span></span><br><span class="line">   <span class="comment">//这样在根据options 去解析生成bitmap的时候，就不需要再次分配内存了，避免了内存抖动</span></span><br><span class="line">   <span class="comment">// Prior to KitKat, the inBitmap size must exactly match the size of the bitmap we&#x27;re decoding.</span></span><br><span class="line">   <span class="keyword">if</span> ((options.inSampleSize == <span class="number">1</span> || isKitKatOrGreater) &amp;&amp; shouldUsePool(imageType)) &#123;</span><br><span class="line">     <span class="keyword">int</span> expectedWidth;</span><br><span class="line">     <span class="keyword">int</span> expectedHeight;</span><br><span class="line">     <span class="keyword">if</span> (sourceWidth &gt;= <span class="number">0</span></span><br><span class="line">         &amp;&amp; sourceHeight &gt;= <span class="number">0</span></span><br><span class="line">         &amp;&amp; fixBitmapToRequestedDimensions</span><br><span class="line">         &amp;&amp; isKitKatOrGreater) &#123;</span><br><span class="line">       expectedWidth = targetWidth;</span><br><span class="line">       expectedHeight = targetHeight;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">float</span> densityMultiplier =</span><br><span class="line">           isScaling(options) ? (<span class="keyword">float</span>) options.inTargetDensity / options.inDensity : <span class="number">1f</span>;</span><br><span class="line">       <span class="keyword">int</span> sampleSize = options.inSampleSize;</span><br><span class="line">       <span class="keyword">int</span> downsampledWidth = (<span class="keyword">int</span>) Math.ceil(sourceWidth / (<span class="keyword">float</span>) sampleSize);</span><br><span class="line">       <span class="keyword">int</span> downsampledHeight = (<span class="keyword">int</span>) Math.ceil(sourceHeight / (<span class="keyword">float</span>) sampleSize);</span><br><span class="line">       expectedWidth = Math.round(downsampledWidth * densityMultiplier);</span><br><span class="line">       expectedHeight = Math.round(downsampledHeight * densityMultiplier);</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// If this isn&#x27;t an image, or BitmapFactory was unable to parse the size, width and height</span></span><br><span class="line">     <span class="comment">// will be -1 here.</span></span><br><span class="line">     <span class="keyword">if</span> (expectedWidth &gt; <span class="number">0</span> &amp;&amp; expectedHeight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">//该函数会在bitmapPool中查找符合大小的bitmap ，如果找到了就设置给inBitmap</span></span><br><span class="line">       setInBitmap(options, bitmapPool, expectedWidth, expectedHeight);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.P) &#123;</span><br><span class="line">     <span class="keyword">boolean</span> isP3Eligible =</span><br><span class="line">         preferredColorSpace == PreferredColorSpace.DISPLAY_P3</span><br><span class="line">             &amp;&amp; options.outColorSpace != <span class="keyword">null</span></span><br><span class="line">             &amp;&amp; options.outColorSpace.isWideGamut();</span><br><span class="line">     options.inPreferredColorSpace =</span><br><span class="line">         ColorSpace.get(isP3Eligible ? ColorSpace.Named.DISPLAY_P3 : ColorSpace.Named.SRGB);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">     options.inPreferredColorSpace = ColorSpace.get(ColorSpace.Named.SRGB);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//根据options 把流解析为Bitmap</span></span><br><span class="line">   Bitmap downsampled = decodeStream(imageReader, options, callbacks, bitmapPool);</span><br><span class="line">   callbacks.onDecodeComplete(bitmapPool, downsampled);</span><br><span class="line"></span><br><span class="line">   Bitmap rotated = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (downsampled != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="comment">// If we scaled, the Bitmap density will be our inTargetDensity. Here we correct it back to</span></span><br><span class="line">     <span class="comment">// the expected density dpi.</span></span><br><span class="line">     downsampled.setDensity(displayMetrics.densityDpi);</span><br><span class="line"></span><br><span class="line">     rotated = TransformationUtils.rotateImageExif(bitmapPool, downsampled, orientation);</span><br><span class="line">     <span class="keyword">if</span> (!downsampled.equals(rotated)) &#123;</span><br><span class="line">       bitmapPool.put(downsampled);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> rotated;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>至此已经得到了解析后的资源了，接下来就是要显示到指定的ImageView控件上，回到<code>notifyEncodeAndRelease</code>流程中。</p>
<h3 id="3-3-12、开启缓存"><a href="#3-3-12、开启缓存" class="headerlink" title="3.3.12、开启缓存"></a>3.3.12、开启缓存</h3><p>当我们开启去不缓存后，加载过程就变为如下。</p>
<img src="/pics/image-20220213215722486.png" alt="image-20220213215722486" style="zoom:50%;" />

<h4 id="1、DecodeJob-runWrapped"><a href="#1、DecodeJob-runWrapped" class="headerlink" title="1、DecodeJob#runWrapped"></a>1、DecodeJob#runWrapped</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runWrapped</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    runWrappedCount++;</span><br><span class="line">    <span class="keyword">switch</span> (runReason) &#123;</span><br><span class="line">        <span class="keyword">case</span> INITIALIZE:</span><br><span class="line">            <span class="comment">//初始化之后第一次运行时, stage 返回的是source</span></span><br><span class="line">            stage = getNextStage(Stage.INITIALIZE);</span><br><span class="line">            <span class="comment">//根据下一阶段状态，判断具体由哪个类执行，source 对应是 SourceGenerator</span></span><br><span class="line">            currentGenerator = getNextGenerator();</span><br><span class="line">            runGenerators();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SWITCH_TO_SOURCE_SERVICE:</span><br><span class="line">            runGenerators();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DECODE_DATA:</span><br><span class="line">            decodeFromRetrievedData();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unrecognized run reason: &quot;</span> + runReason);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Stage <span class="title">getNextStage</span><span class="params">(Stage current)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (current) &#123;</span><br><span class="line">        <span class="keyword">case</span> INITIALIZE:</span><br><span class="line">        <span class="comment">//当前是初始阶段，则看磁盘缓存策略，是否可以在磁盘中获取资源缓存（也就是解析后的缓存）</span></span><br><span class="line">            <span class="keyword">return</span> diskCacheStrategy.decodeCachedResource()</span><br><span class="line">                    ? Stage.RESOURCE_CACHE : getNextStage(Stage.RESOURCE_CACHE);</span><br><span class="line">        <span class="keyword">case</span> RESOURCE_CACHE:</span><br><span class="line">        <span class="comment">//当前是资源缓存，看下一步能不能从磁盘缓存中获取源数据缓存</span></span><br><span class="line">            <span class="keyword">return</span> diskCacheStrategy.decodeCachedData()</span><br><span class="line">                    ? Stage.DATA_CACHE : getNextStage(Stage.DATA_CACHE);</span><br><span class="line">        <span class="keyword">case</span> DATA_CACHE:</span><br><span class="line">            <span class="comment">// Skip loading from source if the user opted to only retrieve the resource from cache.</span></span><br><span class="line">            <span class="comment">//当前是数据缓存，下一步能不能从源数据处获取数据，例如从服务器获取</span></span><br><span class="line">            <span class="keyword">return</span> onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;</span><br><span class="line">        <span class="keyword">case</span> SOURCE:</span><br><span class="line">        <span class="keyword">case</span> FINISHED:</span><br><span class="line">            <span class="keyword">return</span> Stage.FINISHED;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unrecognized stage: &quot;</span> + current);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runGenerators</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.currentThread = Thread.currentThread();</span><br><span class="line">    <span class="keyword">this</span>.startFetchTime = LogTime.getLogTime();</span><br><span class="line">    <span class="keyword">boolean</span> isStarted = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!<span class="keyword">this</span>.isCancelled &amp;&amp; <span class="keyword">this</span>.currentGenerator != <span class="keyword">null</span> &amp;&amp; !(isStarted =                                                                   <span class="keyword">this</span>.currentGenerator.startNext())) &#123; <span class="comment">// 加载数据</span></span><br><span class="line">        <span class="keyword">this</span>.stage = <span class="keyword">this</span>.getNextStage(<span class="keyword">this</span>.stage);</span><br><span class="line">        <span class="keyword">this</span>.currentGenerator = <span class="keyword">this</span>.getNextGenerator();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.stage == DecodeJob.Stage.SOURCE) &#123;</span><br><span class="line">            <span class="keyword">this</span>.reschedule();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">this</span>.stage == DecodeJob.Stage.FINISHED || <span class="keyword">this</span>.isCancelled) &amp;&amp; !isStarted) &#123;</span><br><span class="line">        <span class="keyword">this</span>.notifyFailed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、SourceGenerator-onDataReadyInternal"><a href="#2、SourceGenerator-onDataReadyInternal" class="headerlink" title="2、SourceGenerator#onDataReadyInternal"></a>2、SourceGenerator#onDataReadyInternal</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onDataReadyInternal</span><span class="params">(LoadData&lt;?&gt; loadData, Object data)</span> </span>&#123;</span><br><span class="line">  DiskCacheStrategy diskCacheStrategy = helper.getDiskCacheStrategy();</span><br><span class="line">  <span class="keyword">if</span> (data != <span class="keyword">null</span> &amp;&amp; diskCacheStrategy.isDataCacheable(loadData.fetcher.getDataSource())) &#123;</span><br><span class="line">    dataToCache = data;</span><br><span class="line">		<span class="comment">// 缓存选项开启</span></span><br><span class="line">    cb.reschedule();</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DecodeJob#reschedule</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reschedule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  runReason = RunReason.SWITCH_TO_SOURCE_SERVICE;</span><br><span class="line">  <span class="comment">//执行到DecodeJob#runWrapped，再调用到SourceGenerator</span></span><br><span class="line">  callback.reschedule(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cacheData</span><span class="params">(Object dataToCache)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     Encoder&lt;Object&gt; encoder = helper.getSourceEncoder(dataToCache);</span><br><span class="line">     DataCacheWriter&lt;Object&gt; writer =</span><br><span class="line">         <span class="keyword">new</span> DataCacheWriter&lt;&gt;(encoder, dataToCache, helper.getOptions());</span><br><span class="line">     originalKey = <span class="keyword">new</span> DataCacheKey(loadData.sourceKey, helper.getSignature());</span><br><span class="line">     helper.getDiskCache().put(originalKey, writer);</span><br><span class="line">   	<span class="comment">//...</span></span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     loadData.fetcher.cleanup();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   sourceCacheGenerator =</span><br><span class="line">       <span class="keyword">new</span> DataCacheGenerator(Collections.singletonList(loadData.sourceKey), helper, <span class="keyword">this</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SourceGenerator#startNext</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (dataToCache != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Object data = dataToCache;</span><br><span class="line">    dataToCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//缓存原始数据</span></span><br><span class="line">    cacheData(data);</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// 此处的sourceCacheGenerator是DataCacheGenerator，继续调用它的方法进行数据加载</span></span><br><span class="line">  <span class="keyword">if</span> (sourceCacheGenerator != <span class="keyword">null</span> &amp;&amp; sourceCacheGenerator.startNext()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、DataCacheGenerator-startNext"><a href="#3、DataCacheGenerator-startNext" class="headerlink" title="3、DataCacheGenerator#startNext"></a>3、DataCacheGenerator#startNext</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (modelLoaders == <span class="keyword">null</span> || !hasNextModelLoader()) &#123;</span><br><span class="line">    sourceIdIndex++;</span><br><span class="line">    <span class="keyword">if</span> (sourceIdIndex &gt;= cacheKeys.size()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Key sourceId = cacheKeys.get(sourceIdIndex);</span><br><span class="line">    <span class="comment">// PMD.AvoidInstantiatingObjectsInLoops The loop iterates a limited number of times</span></span><br><span class="line">    <span class="comment">// and the actions it performs are much more expensive than a single allocation.</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;PMD.AvoidInstantiatingObjectsInLoops&quot;)</span></span><br><span class="line">    Key originalKey = <span class="keyword">new</span> DataCacheKey(sourceId, helper.getSignature());</span><br><span class="line">    cacheFile = helper.getDiskCache().get(originalKey);</span><br><span class="line">    <span class="keyword">if</span> (cacheFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.sourceKey = sourceId;</span><br><span class="line">      modelLoaders = helper.getModelLoaders(cacheFile);</span><br><span class="line">      modelLoaderIndex = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  loadData = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) &#123;</span><br><span class="line">    ModelLoader&lt;File, ?&gt; modelLoader = modelLoaders.get(modelLoaderIndex++);</span><br><span class="line">    loadData =</span><br><span class="line">        modelLoader.buildLoadData(</span><br><span class="line">            cacheFile, helper.getWidth(), helper.getHeight(), helper.getOptions());</span><br><span class="line">    <span class="keyword">if</span> (loadData != <span class="keyword">null</span> &amp;&amp; helper.hasLoadPath(loadData.fetcher.getDataClass())) &#123;</span><br><span class="line">      started = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">// ByteBufferFetcher</span></span><br><span class="line">      loadData.fetcher.loadData(helper.getPriority(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> started;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、ByteBufferFetcher-loadData"><a href="#4、ByteBufferFetcher-loadData" class="headerlink" title="4、ByteBufferFetcher#loadData"></a>4、ByteBufferFetcher#loadData</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="meta">@NonNull</span> Priority priority, <span class="meta">@NonNull</span> DataCallback&lt;? <span class="keyword">super</span> ByteBuffer&gt; callback)</span> </span>&#123;</span><br><span class="line">  ByteBuffer result;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    result = ByteBufferUtil.fromFile(file);</span><br><span class="line">    callback.onDataReady(result);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">      Log.d(TAG, <span class="string">&quot;Failed to obtain ByteBuffer for file&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    callback.onLoadFailed(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(</span><br><span class="line">    <span class="meta">@NonNull</span> Priority priority, <span class="meta">@NonNull</span> DataCallback&lt;? <span class="keyword">super</span> ByteBuffer&gt; callback) &#123;</span><br><span class="line">  ByteBuffer result;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    result = ByteBufferUtil.fromFile(file);</span><br><span class="line">     <span class="comment">// 这个callback是DataCacheGenerator</span></span><br><span class="line">    callback.onDataReady(result);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">      Log.d(TAG, <span class="string">&quot;Failed to obtain ByteBuffer for file&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    callback.onLoadFailed(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="5、DataCacheGenerator-onDataReady"><a href="#5、DataCacheGenerator-onDataReady" class="headerlink" title="5、DataCacheGenerator#onDataReady"></a>5、DataCacheGenerator#onDataReady</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataReady</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// cb 是decodeJob</span></span><br><span class="line">  cb.onDataFetcherReady(sourceKey, data, loadData.fetcher, DataSource.DATA_DISK_CACHE, sourceKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终又回到了DeocodeJob中。也就是说采用缓存时，会先将网络数据保存起来再读取缓存进行加载。</p>
<h3 id="3-3-13、图片转换和转码"><a href="#3-3-13、图片转换和转码" class="headerlink" title="3.3.13、图片转换和转码"></a>3.3.13、图片转换和转码</h3><p>入口都在<code>DecodePath#decode</code>中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Resource&lt;Transcode&gt; <span class="title">decode</span><span class="params">(DataRewinder&lt;DataType&gt; rewinder, <span class="keyword">int</span> width, <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="meta">@NonNull</span> Options options, DecodeCallback&lt;ResourceType&gt; callback)</span> <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">    <span class="comment">//解码                              </span></span><br><span class="line">    Resource&lt;ResourceType&gt; decoded = decodeResource(rewinder, width, height, options);</span><br><span class="line">    <span class="comment">// 这个方法是回调到Decodejob.onResourceDecoded ,作用是调用RequestOptions中的Transform处理图片，然后将ResourceCache的Key和Encode准备好（放在变量 deferEncoderManager中），稍后进行写入缓存。</span></span><br><span class="line">    Resource&lt;ResourceType&gt; transformed = callback.onResourceDecoded(decoded);</span><br><span class="line">    <span class="comment">//图片的转码过程，进行数据类型的转换</span></span><br><span class="line">    <span class="keyword">return</span> transcoder.transcode(transformed, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1、图片转换"><a href="#1、图片转换" class="headerlink" title="1、图片转换"></a>1、图片转换</h4><h5 id="DecodeJob-onResourceDecoded"><a href="#DecodeJob-onResourceDecoded" class="headerlink" title="DecodeJob#onResourceDecoded"></a>DecodeJob#onResourceDecoded</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;Z&gt; <span class="function">Resource&lt;Z&gt; <span class="title">onResourceDecoded</span><span class="params">(DataSource dataSource, <span class="meta">@NonNull</span> Resource&lt;Z&gt; decoded)</span> </span>&#123;</span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  Class&lt;Z&gt; resourceSubClass = (Class&lt;Z&gt;) decoded.get().getClass();</span><br><span class="line">  Transformation&lt;Z&gt; appliedTransformation = <span class="keyword">null</span>;</span><br><span class="line">  Resource&lt;Z&gt; transformed = decoded;</span><br><span class="line">  <span class="keyword">if</span> (dataSource != DataSource.RESOURCE_DISK_CACHE) &#123;</span><br><span class="line">    appliedTransformation = decodeHelper.getTransformation(resourceSubClass);</span><br><span class="line">    <span class="comment">// 图片转换，和我们初始化设置有关，假设我们设置的是centercrop</span></span><br><span class="line">    transformed = appliedTransformation.transform(glideContext, decoded, width, height);</span><br><span class="line">  &#125;</span><br><span class="line"> 	<span class="comment">//...</span></span><br><span class="line">    <span class="keyword">final</span> Key key;</span><br><span class="line">    <span class="keyword">switch</span> (encodeStrategy) &#123;</span><br><span class="line">      <span class="comment">// 缓存的可以有2种，分别用来保存原始数据和转换后的图片数据</span></span><br><span class="line">      <span class="keyword">case</span> SOURCE:</span><br><span class="line">        key = <span class="keyword">new</span> DataCacheKey(currentSourceKey, signature);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> TRANSFORMED:</span><br><span class="line">        key =</span><br><span class="line">            <span class="keyword">new</span> ResourceCacheKey(</span><br><span class="line">                decodeHelper.getArrayPool(),</span><br><span class="line">                currentSourceKey,</span><br><span class="line">                signature,</span><br><span class="line">                width,</span><br><span class="line">                height,</span><br><span class="line">                appliedTransformation,</span><br><span class="line">                resourceSubClass,</span><br><span class="line">                options);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unknown strategy: &quot;</span> + encodeStrategy);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="CenterCrop-transform"><a href="#CenterCrop-transform" class="headerlink" title="CenterCrop#transform"></a>CenterCrop#transform</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Bitmap <span class="title">transform</span><span class="params">(<span class="meta">@NonNull</span> BitmapPool pool, <span class="meta">@NonNull</span> Bitmap toTransform, <span class="keyword">int</span> outWidth, <span class="keyword">int</span> outHeight)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> TransformationUtils.centerCrop(pool, toTransform, outWidth, outHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="TransformationUtils-centerCrop"><a href="#TransformationUtils-centerCrop" class="headerlink" title="TransformationUtils#centerCrop"></a>TransformationUtils#centerCrop</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">centerCrop</span><span class="params">(<span class="meta">@NonNull</span> BitmapPool pool, <span class="meta">@NonNull</span> Bitmap inBitmap, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (inBitmap.getWidth() == width &amp;&amp; inBitmap.getHeight() == height) &#123;</span><br><span class="line">        <span class="keyword">return</span> inBitmap;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Matrix m = <span class="keyword">new</span> Matrix();</span><br><span class="line">        <span class="keyword">float</span> scale;</span><br><span class="line">        <span class="keyword">float</span> dx;</span><br><span class="line">        <span class="keyword">float</span> dy;</span><br><span class="line">        <span class="keyword">if</span> (inBitmap.getWidth() * height &gt; width * inBitmap.getHeight()) &#123;</span><br><span class="line">            scale = (<span class="keyword">float</span>)height / (<span class="keyword">float</span>)inBitmap.getHeight();</span><br><span class="line">            dx = ((<span class="keyword">float</span>)width - (<span class="keyword">float</span>)inBitmap.getWidth() * scale) * <span class="number">0.5F</span>;</span><br><span class="line">            dy = <span class="number">0.0F</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            scale = (<span class="keyword">float</span>)width / (<span class="keyword">float</span>)inBitmap.getWidth();</span><br><span class="line">            dx = <span class="number">0.0F</span>;</span><br><span class="line">            dy = ((<span class="keyword">float</span>)height - (<span class="keyword">float</span>)inBitmap.getHeight() * scale) * <span class="number">0.5F</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m.setScale(scale, scale);</span><br><span class="line">        m.postTranslate((<span class="keyword">float</span>)((<span class="keyword">int</span>)(dx + <span class="number">0.5F</span>)), (<span class="keyword">float</span>)((<span class="keyword">int</span>)(dy + <span class="number">0.5F</span>)));</span><br><span class="line">        Bitmap result = pool.get(width, height, getNonNullConfig(inBitmap));</span><br><span class="line">        setAlpha(inBitmap, result);</span><br><span class="line">        applyMatrix(inBitmap, result, m);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、转码"><a href="#2、转码" class="headerlink" title="2、转码"></a>2、转码</h4><p>转码就是将转化后的图片转成相应的Gif或其他，默认的transcoder是<code>BitmapDrawableTranscoder</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Resource&lt;BitmapDrawable&gt; <span class="title">transcode</span><span class="params">(<span class="meta">@NonNull</span> Resource&lt;Bitmap&gt; toTranscode, <span class="meta">@NonNull</span> Options options)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> LazyBitmapDrawableResource.obtain(<span class="keyword">this</span>.resources, toTranscode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/pics/image-20220213223212792.png" alt="image-20220213223212792" style="zoom:50%;" />

<h1 id="四、参考"><a href="#四、参考" class="headerlink" title="四、参考"></a>四、参考</h1><p><a href="https://blog.csdn.net/guolin_blog/category_9268670.html">https://blog.csdn.net/guolin_blog/category_9268670.html</a></p>
<p><a href="https://blog.csdn.net/xx326664162/article/details/107663872">https://blog.csdn.net/xx326664162/article/details/107663872</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>开源</category>
      </categories>
  </entry>
  <entry>
    <title>FrameWork_08_SharedPreferences</title>
    <url>/2021/02/24/Notes/Android/04Framework/FrameWork_07_SharePreference%20%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="FrameWork-07-SharedPreference"><a href="#FrameWork-07-SharedPreference" class="headerlink" title="FrameWork_07_SharedPreference"></a>FrameWork_07_SharedPreference</h1><span id="more"></span>

<p>SharePreferences是一个轻量级的存储类，特别适合用于保存软件配置参数。使用SharedPreferences保存数据，其背后是用xml文件存放数据，文件存放在/data/data/ &lt; package name &gt; /shared_prefs目录下，本文主要介绍下sp的用法并且从源码的角度分析下sp的写入过程。</p>
<h2 id="1-获取sp的三种方式"><a href="#1-获取sp的三种方式" class="headerlink" title="1.获取sp的三种方式"></a>1.获取sp的三种方式</h2><p>1.this.getPreferences (int mode)<br>    通过Activity对象获取，获取的是本Activity私有的Preference，保存在系统中的xml形式的文件的名称为这个Activity的名字，因此一个Activity只能有一个，属于这个Activity。</p>
<p>2.context.getSharedPreferences (String name, int mode)<br>    因为Activity继承了ContextWrapper，因此也是通过Activity对象获取，但是属于整个应用程序，可以有多个，以第一参数的name为文件名保存在系统中。</p>
<p>3.PreferenceManager.getDefaultSharedPreferences(this);<br>    PreferenceManager的静态函数，保存PreferenceActivity中的设置，属于整个应用程序，但是只有一个，命名为packagename_preferences。</p>
<h2 id="2-写入模式"><a href="#2-写入模式" class="headerlink" title="2. 写入模式"></a>2. 写入模式</h2><pre><code>Activity.MODE_PRIVATE,//默认操作模式，代表该文件是私有数据，只能被应用本身访问，在该模式下，写入的内容会覆盖原文件的内容，如果想把新写入的内容追加到原文件中，可以使用Activity.MODE_APPEND 
Activity.MODE_APPEND //该模式会检查文件是否存在，存在就往文件追加内容，否则就创建新文件
以下2种模式已废弃，不安全
Activity.MODE_WORLD_READABLE,//表示当前文件可以被其他应用读取，  
Activity.MODE_WORLD_WRITEABLE,//表示当前文件可以被其他应用写入；
</code></pre>
<h2 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3.源码分析"></a>3.源码分析</h2><h3 id="1-获取SharedPreferences对象"><a href="#1-获取SharedPreferences对象" class="headerlink" title="1.获取SharedPreferences对象"></a>1.获取SharedPreferences对象</h3><p>contextImpl.getSharedPreferences()，这里使用到了单例模式，涉及到的几个对象如下：</p>
<pre><code>ArrayMap&lt;String, File&gt; mSharedPrefsPaths ： 保存sp的路径和文件
ArrayMap&lt;String, ArrayMap&lt;File, SharedPreferencesImpl&gt;&gt; sSharedPrefsCache key 是packageName， vlaue是 file 和 对应的spImpl对象。
</code></pre>
<p>整个过程分为2步，先获取对应name的sp文件，如果没有就new一个文件放到 mSharedPrefsPaths 中，<br>再根据文件名获取对应的spImpl对象。</p>
<p>对于一个相同的SharedPreferences name，获取到的都是同一个SharedPreferences对象，也就是SharedPreferencesImpl对象。</p>
<pre><code>public SharedPreferences getSharedPreferences(String name, int mode) &#123;
    // At least one application in the world actually passes in a null
    // name.  This happened to work because when we generated the file name
    // we would stringify it to &quot;null.xml&quot;.  Nice.
    if (mPackageInfo.getApplicationInfo().targetSdkVersion &lt;
            Build.VERSION_CODES.KITKAT) &#123;
        if (name == null) &#123;
            name = &quot;null&quot;;
        &#125;
    &#125;
    
    File file;
    synchronized (ContextImpl.class) &#123;
        if (mSharedPrefsPaths == null) &#123;
            mSharedPrefsPaths = new ArrayMap&lt;&gt;();
        &#125;
        file = mSharedPrefsPaths.get(name);
        if (file == null) &#123;
            file = getSharedPreferencesPath(name);
            mSharedPrefsPaths.put(name, file);
        &#125;
    &#125;
    return getSharedPreferences(file, mode);
&#125;

 public SharedPreferences getSharedPreferences(File file, int mode) &#123;
    ...
    SharedPreferencesImpl sp;
    synchronized (ContextImpl.class) &#123;
        final ArrayMap&lt;File, SharedPreferencesImpl&gt; cache = getSharedPreferencesCacheLocked();
        sp = cache.get(file);
        if (sp == null) &#123;
            sp = new SharedPreferencesImpl(file, mode);
            cache.put(file, sp);
            return sp;
        &#125;
    &#125;
    if ((mode &amp; Context.MODE_MULTI_PROCESS) != 0 ||
        getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) &#123;
        // If somebody else (some other process) changed the prefs
        // file behind our back, we reload it.  This has been the
        // historical (if undocumented) behavior.
        sp.startReloadIfChangedUnexpectedly();
    &#125;
    return sp;
&#125;

private ArrayMap&lt;File, SharedPreferencesImpl&gt; getSharedPreferencesCacheLocked() &#123;
    if (sSharedPrefsCache == null) &#123;
        sSharedPrefsCache = new ArrayMap&lt;&gt;();
    &#125;

    final String packageName = getPackageName();
    ArrayMap&lt;File, SharedPreferencesImpl&gt; packagePrefs = sSharedPrefsCache.get(packageName);
    if (packagePrefs == null) &#123;
        packagePrefs = new ArrayMap&lt;&gt;();
        sSharedPrefsCache.put(packageName, packagePrefs);
    &#125;

    return packagePrefs;
&#125;
</code></pre>
<h3 id="2-sp-的初始化"><a href="#2-sp-的初始化" class="headerlink" title="2.sp 的初始化"></a>2.sp 的初始化</h3><p>对于一个SharedPreferences文件name，第一次调用getSharedPreferences时会去创建一个SharedPreferencesImpl对象，它会开启一个子线程，将所有的数据以Map的形式保存在内存中。</p>
<pre><code> SharedPreferencesImpl(File file, int mode) &#123;
    mFile = file;
    mBackupFile = makeBackupFile(file);
    mMode = mode;
    mLoaded = false;
    mMap = null;
    startLoadFromDisk();
&#125;

private void startLoadFromDisk() &#123;
    synchronized (mLock) &#123;
        mLoaded = false;
    &#125;
    new Thread(&quot;SharedPreferencesImpl-load&quot;) &#123;
        public void run() &#123;
            loadFromDisk();
        &#125;
    &#125;.start();
&#125;

private void loadFromDisk() &#123;
    synchronized (mLock) &#123;
        if (mLoaded) &#123;
            return;
        &#125;
        if (mBackupFile.exists()) &#123;
            mFile.delete();
            mBackupFile.renameTo(mFile);
        &#125;
    &#125;

    // Debugging
    if (mFile.exists() &amp;&amp; !mFile.canRead()) &#123;
        Log.w(TAG, &quot;Attempt to read preferences file &quot; + mFile + &quot; without permission&quot;);
    &#125;

    Map map = null;
    StructStat stat = null;
    try &#123;
        stat = Os.stat(mFile.getPath());
        if (mFile.canRead()) &#123;
            BufferedInputStream str = null;
            try &#123;
                str = new BufferedInputStream(
                        new FileInputStream(mFile), 16*1024);
                map = XmlUtils.readMapXml(str);
            &#125; catch (Exception e) &#123;
                Log.w(TAG, &quot;Cannot read &quot; + mFile.getAbsolutePath(), e);
            &#125; finally &#123;
                IoUtils.closeQuietly(str);
            &#125;
        &#125;
    &#125; catch (ErrnoException e) &#123;
        /* ignore */
    &#125;

    synchronized (mLock) &#123;
        mLoaded = true;
        if (map != null) &#123;
            mMap = map;
            mStatTimestamp = stat.st_mtime;
            mStatSize = stat.st_size;
        &#125; else &#123;
            mMap = new HashMap&lt;&gt;();
        &#125;
        mLock.notifyAll();
    &#125;
&#125;
</code></pre>
<h2 id="3-sp的读取"><a href="#3-sp的读取" class="headerlink" title="3. sp的读取"></a>3. sp的读取</h2><p>当我们在ui线程种这样调用时：</p>
<pre><code>SharedPreferences sp = getSharedPreferences(&quot;test&quot;, Context.MODE_PRIVATE);
String name = sp.getString(&quot;name&quot;, null)
</code></pre>
<p>调用getString时那个SharedPreferencesImpl构造方法开启的子线程可能还没执行完（比如文件比较大时全部读取会比较久），这时getString当然还不能获取到相应的值，必须阻塞到那个子线程读取完为止，getString方法：</p>
<pre><code>public String getString(String key, @Nullable String defValue) &#123;
    synchronized (this) &#123;
        awaitLoadedLocked();
        String v = (String)mMap.get(key);
        return v != null ? v : defValue;
    &#125;
&#125;
</code></pre>
<p>显然这个awaitLoadedLocked方法就是用来等this这个锁的，在loadFromDiskLocked方法的最后我们也可以看到它调用了notifyAll方法，这时如果getString之前阻塞了就会被唤醒。那么现在这里有一个问题，我们的getString是写在UI线程中，如果那个getString被阻塞太久了，比如60s，这时就会出现ANR，因此要根据具体情况考虑是否需要把SharedPreferences的读写放在子线程中。这里回答第二个 问题，在UI线程中调用getXXX可能会导致ANR。同时可以回答第三个问题，SharedPreferences只能用来存放少量数据，如果一个SharedPreferences对应的xml文件很大的话，在初始化时会把这个文件的所有数据都加载到内存中，这样就会占用大量的内存，有时我们只是想读取某个xml文件中一个key的value，结果它把整个文件都加载进来了，显然如果必要的话这里需要进行相关优化处理。</p>
<h2 id="4-sp的写入"><a href="#4-sp的写入" class="headerlink" title="4.sp的写入"></a>4.sp的写入</h2><pre><code>SharedPreferences.Editor editor = getSharedPreferences(&quot;test&quot;, Context.MODE_PRIVATE).edit();
editor.putString(&quot;name&quot;, &quot;test&quot;);
editor.commit();
</code></pre>
<p>首先写一个SharedPreferences文件都是先要调用edit方法获取到一个Editor对象：   </p>
<pre><code>public Editor edit() &#123;
    synchronized (this) &#123;
        awaitLoadedLocked();
    &#125;
    return new EditorImpl();
&#125;
</code></pre>
<p>这个Editor对象是SharedPreferencesImpl的一个内部类：</p>
<pre><code>public final class EditorImpl implements Editor &#123;
    private final Map&lt;String, Object&gt; mModified = Maps.newHashMap();
    private boolean mClear = false;
    public Editor putString(String key, @Nullable String value) &#123;
        synchronized (this) &#123;
            mModified.put(key, value);
            return this;
        &#125;
    &#125;
    ...
&#125;
</code></pre>
<p>可以看到它有一个Map对象mModified，用来保存修改的数据，也就是你每次put的时候其实是把那个键值对放到这个mModified 中，最后调用apply或者commit才会真正把数据写入文件中。调用commit 和 apply时都会调用到commitToMemory 和 enqueueDiskWrite这2个方法。这里我们以commit 为例先看下整个写入的过程。 </p>
<h3 id="4-1-commit"><a href="#4-1-commit" class="headerlink" title="4.1 commit"></a>4.1 commit</h3><pre><code>public boolean commit() &#123;
    MemoryCommitResult mcr = commitToMemory();
    SharedPreferencesImpl.this.enqueueDiskWrite(
        mcr, null /* sync write on this thread okay */);
    try &#123;
        mcr.writtenToDiskLatch.await();
    &#125; catch (InterruptedException e) &#123;
        return false;
    &#125;
    notifyListeners(mcr);
    return mcr.writeToDiskResult;
&#125;
</code></pre>
<h3 id="4-2-commitToMemory"><a href="#4-2-commitToMemory" class="headerlink" title="4.2 commitToMemory"></a>4.2 commitToMemory</h3><p>这个方法对应了editor的增删改查方法，这里涉及了2个对象，mMap 和mModified，一个保存当前sp中的键值对，一个保存了修改的键值对。遍历mModified键值对时可以看到这个方法中首先处理了clear标志，它调用的是mMap.clear()，然后再遍历mModified将新的键值对put进mMap，也就是说在一次commit事务中，如果同时put一些键值对和调用clear，那么clear掉的只是之前的键值对，这次put进去的键值对还是会被写入的。</p>
<pre><code>// Returns true if any changes were made
private MemoryCommitResult commitToMemory() &#123;
    MemoryCommitResult mcr = new MemoryCommitResult();
    ...
        synchronized (this) &#123;
            if (mClear) &#123;
                if (!mMap.isEmpty()) &#123;
                    mcr.changesMade = true;
                    mMap.clear();
                &#125;
                mClear = false;
            &#125;

            for (Map.Entry&lt;String, Object&gt; e : mModified.entrySet()) &#123;
                String k = e.getKey();
                Object v = e.getValue();
                // &quot;this&quot; is the magic value for a removal mutation. In addition,
                // setting a value to &quot;null&quot; for a given key is specified to be
                // equivalent to calling remove on that key.
                if (v == this || v == null) &#123;
                    if (!mMap.containsKey(k)) &#123;
                        continue;
                    &#125;
                    mMap.remove(k);
                &#125; else &#123;
                    if (mMap.containsKey(k)) &#123;
                        Object existingValue = mMap.get(k);
                        if (existingValue != null &amp;&amp; existingValue.equals(v)) &#123;
                            continue;
                        &#125;
                    &#125;
                    mMap.put(k, v);
                &#125;

                mcr.changesMade = true;
                if (hasListeners) &#123;
                    mcr.keysModified.add(k);
                &#125;
            &#125;

            mModified.clear();
        &#125;
    &#125;
    return mcr;
&#125;
</code></pre>
<p>遍历mModified时，需要处理一个特殊情况，就是如果一个键值对的value是this（SharedPreferencesImpl）或者是null那么表示将此键值对删除，这个在remove方法中可以看到： </p>
<pre><code>public Editor remove(String key) &#123;
    synchronized (this) &#123;
        mModified.put(key, this);
        return this;
    &#125;
&#125;
</code></pre>
<h2 id="4-3-enqueueDiskWrite"><a href="#4-3-enqueueDiskWrite" class="headerlink" title="4.3 enqueueDiskWrite"></a>4.3 enqueueDiskWrite</h2><p>先定义一个Runnable，注意实现Runnable与继承Thread的区别，Runnable表示一个任务，不一定要在子线程中执行，一般优先考虑使用Runnable。这个Runnable中先调用writeToFile进行写操作，写操作需要先获得mWritingToDiskLock，也就是写锁。然后执行mDiskWritesInFlight–，表示正在等待写的操作减少1。最后判断postWriteRunnable是否为null，调用commit时它为null，而调用apply时它不为null。<br>Runnable定义完，就判断这次是commit还是apply，如果是commit，即isFromSyncCommit为true，而且有1个写操作需要执行，那么就调用writeToDiskRunnable.run()，注意这个调用是在当前线程中进行的。如果不是commit，那就是apply，这时调用QueuedWork.singleThreadExecutor().execute(writeToDiskRunnable)，这个QueuedWork类其实很简单，里面有一个SingleThreadExecutor，用于异步执行这个writeToDiskRunnable。 </p>
<pre><code>private void enqueueDiskWrite(final MemoryCommitResult mcr,
                              final Runnable postWriteRunnable) &#123;
    final Runnable writeToDiskRunnable = new Runnable() &#123;
            public void run() &#123;
                synchronized (mWritingToDiskLock) &#123;
                    writeToFile(mcr);
                &#125;
                synchronized (SharedPreferencesImpl.this) &#123;
                    mDiskWritesInFlight--;
                &#125;
                if (postWriteRunnable != null) &#123;
                    postWriteRunnable.run();
                &#125;
            &#125;
        &#125;;

    final boolean isFromSyncCommit = (postWriteRunnable == null);

    // Typical #commit() path with fewer allocations, doing a write on
    // the current thread.
    if (isFromSyncCommit) &#123;
        boolean wasEmpty = false;
        synchronized (SharedPreferencesImpl.this) &#123;
            wasEmpty = mDiskWritesInFlight == 1;
        &#125;
        if (wasEmpty) &#123;
            writeToDiskRunnable.run();
            return;
        &#125;
    &#125;

    QueuedWork.singleThreadExecutor().execute(writeToDiskRunnable);
&#125;
</code></pre>
<h3 id="4-4-writeToFile"><a href="#4-4-writeToFile" class="headerlink" title="4.4 writeToFile"></a>4.4 writeToFile</h3><p>SharedPreferences在写入时会先把之前的xml文件改成名成一个备份文件mBackupFile，然后再将要写入的数据写到一个新的文件中，如果这个过程执行成功的话，就会把备份文件删除。由此可见每次即使只是添加一个键值对，也会重新写入整个文件的数据，这也说明SharedPreferences只适合保存少量数据，文件太大会有性能问题。</p>
<pre><code>private void writeToFile(MemoryCommitResult mcr) &#123;
    // Rename the current file so it may be used as a backup during the next read
    if (mFile.exists()) &#123;
        if (!mcr.changesMade) &#123;
            // If the file already exists, but no changes were
            // made to the underlying map, it&#39;s wasteful to
            // re-write the file.  Return as if we wrote it
            // out.
            mcr.setDiskWriteResult(true);
            return;
        &#125;
        if (!mBackupFile.exists()) &#123;
            if (!mFile.renameTo(mBackupFile)) &#123;
                Log.e(TAG, &quot;Couldn&#39;t rename file &quot; + mFile
                      + &quot; to backup file &quot; + mBackupFile);
                mcr.setDiskWriteResult(false);
                return;
            &#125;
        &#125; else &#123;
            mFile.delete();
        &#125;
    &#125;

    // Attempt to write the file, delete the backup and return true as atomically as
    // possible.  If any exception occurs, delete the new file; next time we will restore
    // from the backup.
    try &#123;
        FileOutputStream str = createFileOutputStream(mFile);
        if (str == null) &#123;
            mcr.setDiskWriteResult(false);
            return;
        &#125;
        XmlUtils.writeMapXml(mcr.mapToWriteToDisk, str);
        FileUtils.sync(str);
        str.close();
        ContextImpl.setFilePermissionsFromMode(mFile.getPath(), mMode, 0);
        try &#123;
            final StructStat stat = Os.stat(mFile.getPath());
            synchronized (this) &#123;
                mStatTimestamp = stat.st_mtime;
                mStatSize = stat.st_size;
            &#125;
        &#125; catch (ErrnoException e) &#123;
            // Do nothing
        &#125;
        // Writing was successful, delete the backup file if there is one.
        mBackupFile.delete();
        mcr.setDiskWriteResult(true);
        return;
    &#125; catch (XmlPullParserException e) &#123;
        Log.w(TAG, &quot;writeToFile: Got exception:&quot;, e);
    &#125; catch (IOException e) &#123;
        Log.w(TAG, &quot;writeToFile: Got exception:&quot;, e);
    &#125;
    // Clean up an unsuccessfully written file
    if (mFile.exists()) &#123;
        if (!mFile.delete()) &#123;
            Log.e(TAG, &quot;Couldn&#39;t clean up partially-written file &quot; + mFile);
        &#125;
    &#125;
    mcr.setDiskWriteResult(false);
&#125;
</code></pre>
<h3 id="5-使用apply导致的anr"><a href="#5-使用apply导致的anr" class="headerlink" title="5.使用apply导致的anr"></a>5.使用apply导致的anr</h3><p>其实无节制的使用apply方法也时会造成anr的，在主线程中无节制的使用apply其实也会造成anr，在调用apply时，会将等待写入到文件系统的任务awaitCommit放在QueuedWork的等待完成队列里。</p>
<pre><code>public void apply() &#123;
    final MemoryCommitResult mcr = commitToMemory();
    final Runnable awaitCommit = new Runnable() &#123;
            public void run() &#123;
                try &#123;
                    mcr.writtenToDiskLatch.await();
                &#125; catch (InterruptedException ignored) &#123;
                &#125;
            &#125;
        &#125;;

    QueuedWork.add(awaitCommit);

    Runnable postWriteRunnable = new Runnable() &#123;
            public void run() &#123;
                awaitCommit.run();
                QueuedWork.remove(awaitCommit);
            &#125;
        &#125;;

    SharedPreferencesImpl.this.enqueueDiskWrite(mcr, postWriteRunnable);

    // Okay to notify the listeners before it&#39;s hit disk
    // because the listeners should always get the same
    // SharedPreferences instance back, which has the
    // changes reflected in memory.
    notifyListeners(mcr);
&#125;
</code></pre>
<p>所以如果我们使用SharedPreference的apply方法,虽然该方法可以很快返回， 并在其它线程里将键值对写入到文件系统， 但是当Activity的onPause等方法被调用时，会调用等待写入到文件系统的任务完成，</p>
<pre><code>/**
 * Finishes or waits for async operations to complete.
 * (e.g. SharedPreferences$Editor#startCommit writes)
 *
 * Is called from the Activity base class&#39;s onPause(), after
 * BroadcastReceiver&#39;s onReceive, after Service command handling,
 * etc.  (so async work is never lost)
 */
public static void waitToFinish() &#123;
    Runnable toFinish;
    while ((toFinish = sPendingWorkFinishers.poll()) != null) &#123;
        toFinish.run();
    &#125;
&#125;
</code></pre>
<p>在执行任务writeToDiskRunnable时，会先等待postrunable执行完成，也就是awaitCommit执行完成，</p>
<pre><code>final Runnable awaitCommit = new Runnable() &#123;
            public void run() &#123;
                try &#123;
                    mcr.writtenToDiskLatch.await();
                &#125; catch (InterruptedException ignored) &#123;
                &#125;
            &#125;
        &#125;;
</code></pre>
<p>所以如果写入比较慢，主线程就会出现ANR问题。</p>
<p><a href="http://www.cloudchou.com/android/post-988.html">http://www.cloudchou.com/android/post-988.html</a></p>
<p>结论：<br>1.对于一个相同的SharedPreferences name，获取到的都是同一个SharedPreferences对象，它其实是SharedPreferencesImpl对象。<br>2.在UI线程中调用getXXX可能会导致ANR。<br>3.SharedPreferences只能用来存放少量数据，如果一个SharedPreferences对应的xml文件很大的话，在初始化时会把这个文件的所有数据都加载到内存中，这样就会占用大量的内存，有时我们只是想读取某个xml文件中一个key的value，结果它把整个文件都加载进来了，显然如果必要的话这里需要进行相关优化处理。<br>4.commit的写操作是在调用线程中执行的，而apply内部是用一个单线程的线程池实现的，因此写操作是在子线程中执行的。<br>5.SharedPreferences每次写入都是整个文件重新写入，不是增量写入。<br>6.apply也会造成anr。<br>参考：<br><a href="http://blog.csdn.net/u012619640/article/details/50940074">http://blog.csdn.net/u012619640/article/details/50940074</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>Framework</category>
      </categories>
  </entry>
  <entry>
    <title>JobScheduler</title>
    <url>/2021/02/24/Notes/Android/04Framework/Framework_08_JobService/</url>
    <content><![CDATA[<h1 id="Framework-08-JobService"><a href="#Framework-08-JobService" class="headerlink" title="Framework_08_JobService"></a>Framework_08_JobService</h1><span id="more"></span>

<p>Google在Android 5.0中引入<code>JobScheduler</code>来执行一些需要满足特定条件的后台任务，主要解决了某个任务需要在某种或者某几种条件满足之后触发的需求。这些条件包括网络状态，电池充电等。在JobScheduler出现之前，我们只能通过AlarmManager定时唤起应用或者监听广播的方式来做这件事，而一些系统广播是无法被静态注册的。这些做法效率很低，使应用进程不断的启动，甚至需要保活，浪费系统资源。很显然，<code>JobScheduler</code>很好的解决了这个问题。本文主要介绍下<code>JobService</code>的用法和一些常见的问题，并且分析下<code>JobSchedule#schedule</code>到<code>JobService.onStartJob</code>的执行过程。 </p>
<h2 id="一、基本用法"><a href="#一、基本用法" class="headerlink" title="一、基本用法"></a>一、基本用法</h2><ol>
<li>新建MyJobService继承JobService</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJobService</span> <span class="keyword">extends</span> <span class="title">JobService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStartJob</span><span class="params">(JobParameters params)</span> </span>&#123;</span><br><span class="line">        doSampleJob(params); </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStopJob</span><span class="params">(JobParameters params)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSampleJob</span><span class="params">(JobParameters params)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Do some heavy operation</span></span><br><span class="line">        ...... </span><br><span class="line">        <span class="comment">// At the end inform job manager the status of the job.</span></span><br><span class="line">        jobFinished(params, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注意：JobService要声明权限</span><br><span class="line">&lt;service</span><br><span class="line">    android:name=<span class="string">&quot;.MyJobService&quot;</span></span><br><span class="line">    android:permission=<span class="string">&quot;android.permission.BIND_JOB_SERVICE&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>通过JobInfo.Builder，创建JobInfo设置JobService执行的参数</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ComponentName serviceName = <span class="keyword">new</span> ComponentName(<span class="string">&quot;com.example.aven.jobdemo&quot;</span>,</span><br><span class="line">       <span class="string">&quot;com.example.aven.jobdemo.MyJobService&quot;</span>);</span><br><span class="line">JobInfo jobInfo = <span class="keyword">new</span> JobInfo.Builder(JOB_ID, serviceName)</span><br><span class="line">       <span class="comment">//.setMinimumLatency(3000)</span></span><br><span class="line">       .setPeriodic(<span class="number">15</span> * <span class="number">60</span> * <span class="number">1000</span>)</span><br><span class="line">       .build();</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用JobSchduler开启服务</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JobScheduler jobScheduler = (JobScheduler)<span class="keyword">this</span>.getSystemService(Context.JOB_SCHEDULER_SERVICE);</span><br><span class="line">jobScheduler.schedule(jobInfo);</span><br></pre></td></tr></table></figure>

<h2 id="二、API"><a href="#二、API" class="headerlink" title="二、API"></a>二、API</h2><p>使用JobService 主要会涉及到的3个类，JobScheduler，JobService，JobInfo.Builder(JobInfo)，重要的api和方法摘要如下。</p>
<h3 id="2-1、JobScheduler"><a href="#2-1、JobScheduler" class="headerlink" title="2.1、JobScheduler"></a>2.1、<code>JobScheduler</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">schedule(JobInfo job) 开启任务</span><br><span class="line"></span><br><span class="line">cancel(<span class="keyword">int</span> jobId) 取消任务</span><br></pre></td></tr></table></figure>

<h3 id="2-2、JobService"><a href="#2-2、JobService" class="headerlink" title="2.2、JobService"></a>2.2、<code>JobService</code></h3><ol>
<li>onStartjob（jobparameters params）<br>如果返回值是true，那么表示系统执行的是耗时任务，当给定的任务完成时，需要手动调用jobFinished来停止该任务。</li>
<li>onStopJob(JobParameters params)<br>系统停止服务时会调用。返回值true，表示任务会在满足setBackoffCriteria条件下重复执行。</li>
<li>jobFinished(JobParameters params, boolean needsRescheduled)<br>表示任务执行完成，两个参数值一个是JobParameters传递到JobService类，一个布尔值让系统知道是否需要根据工作的最初要求重新编排工作，类似于onStopJob的返回值。</li>
</ol>
<h3 id="2-3、JobInfo-Builder"><a href="#2-3、JobInfo-Builder" class="headerlink" title="2.3、JobInfo.Builder"></a>2.3、<code>JobInfo.Builder</code></h3><ol>
<li><p><code>setMinimumLatency</code>(long minLatencyMillis)：<br>这会使你的工作不启动直到规定的毫秒数已经过去了。这是与setPeriodic(long time)不兼容的，并且如果同时使用这两个函数将会导致抛出异常。</p>
</li>
<li><p><code>setOverrideDeadline</code>(long maxExecutionDelayMillis)：<br>这将设置你的工作期限。即使是无法满足其他要求，你的任务将约在规定的时间已经过去时开始执行。类似于setMinimumLatency(long time)，这个函数是与 setPeriodic(long time) 互相排斥的，并且如果同时使用这两个函数，将会导致抛出异常。</p>
</li>
<li><p><code>setPersisted</code>(boolean isPersisted)：这个函数告诉系统，在设备重新启动后，你的任务是否应该继续存在，只有能够监听开机广播的应用才可设置。</p>
<p><code>&lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt;</code><br><code>&lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;</code></p>
</li>
<li><p><code>setPeriodic</code>(long intervalMillis)<br>设置任务重复执行的周期。</p>
</li>
<li><p><code>setPeriodic</code>(long intervalMillis, long flexMillis)<br>同上 API 24 新增，增加限制intervalMillis &gt;= 15min 和 flexMillis &gt;= 5min.</p>
</li>
<li><p><code>setRequiredNetworkType</code>(int networkType)：<br>只有在设备处于一种特定的网络中时，它才启动。它的默认值是JobInfo.NETWORK_TYPE_NONE，这就意味着，无论是否有网络连接，该任务均可以运行。另外两个可用的类型是JobInfo.NETWORK_TYPE_ANY，这需要某种类型的网络连接可用，工作才可以运行；以及JobInfo.NETWORK_TYPE_UNMETERED，这就要求设备在非蜂窝网络中。</p>
</li>
<li><p><code>setRequiresCharging</code>(boolean requiresCharging)：使用这个函数会告诉你的应用程序，除非设备开始充电，否则工作不会启动。</p>
</li>
<li><p><code>setRequiresDeviceIdle</code>(boolean requiresDeviceIdle)：<br>这会告知你的工作不会启动，除非用户不使用他们的设备，并且他们已经有一段时间没有使用它。</p>
</li>
<li><p><code>setBackoffCriteria</code>(long initialBackoffMillis, int backoffPolicy) 第一个参数时第一次尝试重试的等待间隔，单位为毫秒。</p>
</li>
<li><p>第二个参数为 执行失败重试的策略，其实就是重试的时间间隔<br>BACKOFF_POLICY_LINEAR ：retry_time(current_time, num_failures) = current_time + initial_backoff_millis * num_failures<br>BACKOFF_POLICY_EXPONENTIAL ：retry_time(current_time, num_failures) = current_time + initial_backoff_millis * 2 ^ (num_failures - 1), num_failures &gt;= 1</p>
</li>
</ol>
<blockquote>
<p>注意：setRequiredNetworkType(int networkType)、setRequiresCharging(boolean requireCharging)和setRequiresDeviceIdle(boolean requireIdle)可能会导致你的工作永远不启动，除非setOverrideDeadline(long time)还设置允许即使不符合条件的情况下，你的工作也可以运行</p>
</blockquote>
<h3 id="2-4、Tips"><a href="#2-4、Tips" class="headerlink" title="2.4、Tips"></a>2.4、Tips</h3><ol>
<li>Android7.0 以上机器执行任务周期小于15分钟定时任务的方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JobInfo jobInfo;</span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;</span><br><span class="line">  <span class="comment">// 同时需要设置 jobFinished needsRescheduled = true</span></span><br><span class="line">  jobInfo = <span class="keyword">new</span> JobInfo.Builder(JOB_ID, serviceName)</span><br><span class="line">      .setMinimumLatency(REFRESH_INTERVAL)</span><br><span class="line">      .setExtras(bundle).build();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  jobInfo = <span class="keyword">new</span> JobInfo.Builder(JOB_ID, serviceName)</span><br><span class="line">      .setPeriodic(REFRESH_INTERVAL)</span><br><span class="line">      .setExtras(bundle).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>判断任务是否正常执行</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ret = jobScheduler.schedule(jobInfo);</span><br><span class="line"><span class="keyword">if</span> (ret == JobScheduler.RESULT_SUCCESS) &#123;</span><br><span class="line">     Log.d(TAG, <span class="string">&quot;Job scheduled successfully&quot;</span>);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     Log.d(TAG, <span class="string">&quot;Job scheduling failed&quot;</span>);</span><br><span class="line"> &#125;    </span><br></pre></td></tr></table></figure>

<ol start="3">
<li>设置Jobfinished（true）时，会一直重复无论是否设置setPeriodic</li>
</ol>
<h2 id="三、调试"><a href="#三、调试" class="headerlink" title="三、调试"></a>三、调试</h2><p>除了在代码中加log外，JobScheduler 可以通过以下命令方便的dump出JobScheduler执行的信息:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys jobscheduler</span><br></pre></td></tr></table></figure>

<p>主要包括2部分：1.Job任务的属性 2.Job的执行记录</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JOB #u0a191/<span class="number">1001</span>: 39fd118 com.example.aven.jobdemo/.MyJobService</span><br><span class="line">   u0a191 tag=*job*/com.example.aven.jobdemo/.MyJobService</span><br><span class="line">   Source: uid=u0a191 user=<span class="number">0</span> pkg=com.example.aven.jobdemo</span><br><span class="line">   JobInfo:</span><br><span class="line">     Service: com.example.aven.jobdemo/.MyJobService</span><br><span class="line">     PERIODIC: interval=+15m0s0ms flex=+15m0s0ms</span><br><span class="line">     Requires: charging=<span class="keyword">false</span> deviceIdle=<span class="keyword">false</span></span><br><span class="line">     Network type: <span class="number">2</span></span><br><span class="line">     Backoff: policy=<span class="number">0</span> initial=+5s0ms</span><br><span class="line">     Has early constraint</span><br><span class="line">     Has late constraint</span><br><span class="line">   Required constraints: TIMING_DELAY DEADLINE UNMETERED</span><br><span class="line">   Satisfied constraints: CONNECTIVITY UNMETERED NOT_ROAMING APP_NOT_IDLE DEVICE_NOT_DOZING</span><br><span class="line">   Unsatisfied constraints: TIMING_DELAY DEADLINE</span><br><span class="line">   Earliest run time: <span class="number">04</span>:<span class="number">12</span></span><br><span class="line">   Latest run time: <span class="number">19</span>:<span class="number">12</span></span><br><span class="line">   Ready: <span class="keyword">false</span> (job=<span class="keyword">false</span> pending=<span class="keyword">false</span> active=<span class="keyword">false</span> user=<span class="keyword">true</span>)</span><br></pre></td></tr></table></figure>

<p>adb shell dumpsys jobscheduler | grep com.example.aven.jobdemo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JOB #u0a191/<span class="number">1001</span>: d5ed9c8 com.example.aven.jobdemo/.MyJobService</span><br><span class="line">  u0a191 tag=*job*/com.example.aven.jobdemo/.MyJobService</span><br><span class="line">  Source: uid=u0a191 user=<span class="number">0</span> pkg=com.example.aven.jobdemo</span><br><span class="line">    Service: com.example.aven.jobdemo/.MyJobService</span><br><span class="line">#u0a191/<span class="number">1001</span> from u0a191: com.example.aven.jobdemo RUNNABLE</span><br><span class="line">#u0a191/<span class="number">1001</span> from u0a191: com.example.aven.jobdemo RUNNABLE</span><br><span class="line">u0a191 / com.example.aven.jobdemo: 3x pending <span class="number">1</span>% 3x active</span><br><span class="line">u0a191 / com.example.aven.jobdemo: 2x pending 1x active 1x active-top</span><br><span class="line">u0a191 / com.example.aven.jobdemo: 3x pending 2x active 1x active-top</span><br><span class="line">   <span class="comment">// 时间戳是距离当前的时间</span></span><br><span class="line">   -1h47m12s726ms START: u0a191 com.example.aven.jobdemo/.MyJobService</span><br><span class="line">   -1h47m09s669ms  STOP: u0a191 com.example.aven.jobdemo/.MyJobService</span><br><span class="line">   -1h32m17s690ms START: u0a191 com.example.aven.jobdemo/.MyJobService</span><br><span class="line">   -1h32m14s641ms  STOP: u0a191 com.example.aven.jobdemo/.MyJobService</span><br><span class="line">   -1h17m17s681ms START: u0a191 com.example.aven.jobdemo/.MyJobService</span><br><span class="line">   -1h17m14s648ms  STOP: u0a191 com.example.aven.jobdemo/.MyJobService</span><br><span class="line">   -1h02m17s704ms START: u0a191 com.example.aven.jobdemo/.MyJobService</span><br><span class="line">   -1h02m14s667ms  STOP: u0a191 com.example.aven.jobdemo/.MyJobService</span><br><span class="line">     -47m17s715ms START: u0a191 com.example.aven.jobdemo/.MyJobService</span><br><span class="line">     -47m14s665ms  STOP: u0a191 com.example.aven.jobdemo/.MyJobService</span><br><span class="line">     -27m33s752ms START: u0a191 com.example.aven.jobdemo/.MyJobService</span><br><span class="line">     -27m30s648ms  STOP: u0a191 com.example.aven.jobdemo/.MyJobService</span><br><span class="line">     -17m17s700ms START: u0a191 com.example.aven.jobdemo/.MyJobService</span><br><span class="line">     -17m14s652ms  STOP: u0a191 com.example.aven.jobdemo/.MyJobService</span><br><span class="line">      -2m17s721ms START: u0a191 com.example.aven.jobdemo/.MyJobService</span><br><span class="line">      -2m14s687ms  STOP: u0a191 com.example.aven.jobdemo/.MyJobService</span><br></pre></td></tr></table></figure>

<p>7.0（Android N版本）以上设置循环定时任务的方法：</p>
<ul>
<li>period&gt;=15min</li>
<li>jobfinished false</li>
<li>onStop 返回true</li>
</ul>
<p>对于非persist的job杀掉应用后，Job会被取消掉，persist的不会，可以通过dump 命令查看。</p>
<h2 id="四、原理分析"><a href="#四、原理分析" class="headerlink" title="四、原理分析"></a>四、原理分析</h2><h3 id="4-1、获取系统服务JobScheduler"><a href="#4-1、获取系统服务JobScheduler" class="headerlink" title="4.1、获取系统服务JobScheduler"></a>4.1、获取系统服务JobScheduler</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JobScheduler jobScheduler = (JobScheduler)<span class="keyword">this</span>.getSystemService(Context.JOB_SCHEDULER_SERVICE);</span><br></pre></td></tr></table></figure>

<h4 id="JobSchedulerImpl"><a href="#JobSchedulerImpl" class="headerlink" title="JobSchedulerImpl"></a><code>JobSchedulerImpl</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JobSchedulerImpl</span> <span class="keyword">extends</span> <span class="title">JobScheduler</span> </span>&#123;</span><br><span class="line">    IJobScheduler mBinder;</span><br><span class="line">        <span class="comment">/* package */</span> JobSchedulerImpl(IJobScheduler binder) &#123;</span><br><span class="line">    mBinder = binder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">schedule</span><span class="params">(JobInfo job)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mBinder.schedule(job);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> JobScheduler.RESULT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="IJobScheduler-aidl"><a href="#IJobScheduler-aidl" class="headerlink" title="IJobScheduler.aidl"></a><code>IJobScheduler.aidl</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IJobScheduler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">schedule</span><span class="params">(in JobInfo job)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">enqueue</span><span class="params">(in JobInfo job, in JobWorkItem work)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">scheduleAsPackage</span><span class="params">(in JobInfo job, String packageName, <span class="keyword">int</span> userId, String tag)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">(<span class="keyword">int</span> jobId)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cancelAll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">List&lt;JobInfo&gt; <span class="title">getAllPendingJobs</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">JobInfo <span class="title">getPendingJob</span><span class="params">(<span class="keyword">int</span> jobId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JobSchedulerService-JobSchedulerStub"><a href="#JobSchedulerService-JobSchedulerStub" class="headerlink" title="JobSchedulerService#JobSchedulerStub"></a><code>JobSchedulerService#JobSchedulerStub</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JobSchedulerService</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JobSchedulerStub</span> <span class="keyword">extends</span> <span class="title">IJobScheduler</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">schedule</span><span class="params">(JobInfo job)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> JobSchedulerService.<span class="keyword">this</span>.schedule(job, uid);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                Binder.restoreCallingIdentity(ident);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2、-执行任务"><a href="#4-2、-执行任务" class="headerlink" title="4.2、 执行任务"></a>4.2、 执行任务</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JobSchedulerService.schedule(jobInfo);</span><br></pre></td></tr></table></figure>

<h4 id="1、JobSchedulerService-schedule"><a href="#1、JobSchedulerService-schedule" class="headerlink" title="1、JobSchedulerService#schedule"></a>1、<code>JobSchedulerService#schedule</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JobSchedulerService</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Entry point from client to schedule the provided job.</span></span><br><span class="line"><span class="comment">     * This cancels the job if it&#x27;s already been scheduled, and replaces it with the one provided.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">schedule</span><span class="params">(JobInfo job, <span class="keyword">int</span> uId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scheduleAsPackage(job, uId, <span class="keyword">null</span>, -<span class="number">1</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">scheduleAsPackage</span><span class="params">(JobInfo job, <span class="keyword">int</span> uId, String packageName, <span class="keyword">int</span> userId,</span></span></span><br><span class="line"><span class="params"><span class="function">            String tag)</span> </span>&#123;</span><br><span class="line">        JobStatus jobStatus = JobStatus.createFromJobInfo(job, uId, packageName, userId, tag);</span><br><span class="line">        JobStatus toCancel;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="comment">// Jobs on behalf of others don&#x27;t apply to the per-app job cap</span></span><br><span class="line">            <span class="keyword">if</span> (ENFORCE_MAX_JOBS &amp;&amp; packageName == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mJobs.countJobsForUid(uId) &gt; MAX_JOBS_PER_APP) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">&quot;Too many jobs for uid &quot;</span> + uId);</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Apps may not schedule more than &quot;</span></span><br><span class="line">                                + MAX_JOBS_PER_APP + <span class="string">&quot; distinct jobs&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            toCancel = mJobs.getJobByUidAndJobId(uId, job.getId());</span><br><span class="line">            <span class="keyword">if</span> (toCancel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                cancelJobImpl(toCancel, jobStatus);</span><br><span class="line">            &#125;</span><br><span class="line">            startTrackingJob(jobStatus, toCancel);</span><br><span class="line">        &#125;</span><br><span class="line">        mHandler.obtainMessage(MSG_CHECK_JOB).sendToTarget();</span><br><span class="line">        <span class="keyword">return</span> JobScheduler.RESULT_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、JobSchedulerService-JobHandler-handMessage"><a href="#2、JobSchedulerService-JobHandler-handMessage" class="headerlink" title="2、JobSchedulerService#JobHandler#handMessage"></a>2、<code>JobSchedulerService#JobHandler#handMessage</code></h4><p>处理消息 <code>MSG_CHECK_JOB</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理mPendingJobs列队中所有的Job.</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">JobHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (message.what) &#123;</span><br><span class="line">        <span class="keyword">case</span> MSG_CHECK_JOB:</span><br><span class="line">            <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mReportedActive) &#123;</span><br><span class="line">                    <span class="comment">// if jobs are currently being run, queue all ready jobs for execution.</span></span><br><span class="line">                    queueReadyJobsForExecutionLockedH();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Check the list of jobs and run some of them if we feel inclined.</span></span><br><span class="line">                  	<span class="comment">// 1.满足触发条件的`JobStatus`加入到`mPendingJobs`队列  </span></span><br><span class="line">                     maybeQueueReadyJobsForExecutionLockedH();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 2.执行任务</span></span><br><span class="line">    maybeRunPendingJobsH();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maybeRunPendingJobsH</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            Slog.d(TAG, <span class="string">&quot;pending queue: &quot;</span> + mPendingJobs.size() + <span class="string">&quot; jobs.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        assignJobsToContextsLocked();</span><br><span class="line">        reportActive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">assignJobsToContextsLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAX_JOB_CONTEXTS_COUNT; i++) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> preservePreferredUid = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            				</span><br><span class="line">                    <span class="keyword">if</span> (!mActiveServices.get(i).executeRunnableJob(pendingJob)) &#123;</span><br><span class="line">                        Slog.d(TAG, <span class="string">&quot;Error executing &quot;</span> + pendingJob);</span><br><span class="line">                    &#125;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3、执行任务"><a href="#4-3、执行任务" class="headerlink" title="4.3、执行任务"></a>4.3、执行任务</h3><p>从 framework 调用到JobService的过程</p>
<h4 id="1、JobServiceContext-executeRunnableJob"><a href="#1、JobServiceContext-executeRunnableJob" class="headerlink" title="1、JobServiceContext#executeRunnableJob"></a>1、<code>JobServiceContext#executeRunnableJob</code></h4><p><code>bindService</code>的方式来拉起的进程，当服务启动后回调到<code>onServiceConnected</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">executeRunnableJob</span><span class="params">(JobStatus job)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">boolean</span> binding = mContext.bindServiceAsUser(intent, <span class="keyword">this</span>,</span><br><span class="line">                    Context.BIND_AUTO_CREATE | Context.BIND_NOT_FOREGROUND,</span><br><span class="line">                    <span class="keyword">new</span> UserHandle(job.getUserId()));   </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">this</span>.service = IJobService.Stub.asInterface(service);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    mCallbackHandler.obtainMessage(MSG_SERVICE_BOUND).sendToTarget();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、JobServiceContext-mCallbackHandler-handleMessage"><a href="#2、JobServiceContext-mCallbackHandler-handleMessage" class="headerlink" title="2、JobServiceContext#mCallbackHandler.handleMessage"></a>2、<code>JobServiceContext#mCallbackHandler.handleMessage</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleServiceBoundH</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mVerb = VERB_STARTING;</span><br><span class="line">        scheduleOpTimeOut();</span><br><span class="line">        service.startJob(mParams);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        Slog.e(TAG, <span class="string">&quot;Error sending onStart message to &#x27;&quot;</span> +</span><br><span class="line">                mRunningJob.getServiceComponent().getShortClassName() + <span class="string">&quot;&#x27; &quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、JobInterface-startJob"><a href="#3、JobInterface-startJob" class="headerlink" title="3、JobInterface.startJob"></a>3、<code>JobInterface.startJob</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JobInterface</span> <span class="keyword">extends</span> <span class="title">IJobService</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> WeakReference&lt;JobService&gt; mService;</span><br><span class="line">    JobInterface(JobService service) &#123;</span><br><span class="line">        mService = <span class="keyword">new</span> WeakReference&lt;&gt;(service);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startJob</span><span class="params">(JobParameters jobParams)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        JobService service = mService.get();</span><br><span class="line">        <span class="keyword">if</span> (service != <span class="keyword">null</span>) &#123;</span><br><span class="line">            service.ensureHandler();</span><br><span class="line">            Message m = Message.obtain(service.mHandler, MSG_EXECUTE_JOB, jobParams);</span><br><span class="line">            m.sendToTarget();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopJob</span><span class="params">(JobParameters jobParams)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        JobService service = mService.get();</span><br><span class="line">        <span class="keyword">if</span> (service != <span class="keyword">null</span>) &#123;</span><br><span class="line">            service.ensureHandler();</span><br><span class="line">            Message m = Message.obtain(service.mHandler, MSG_STOP_JOB, jobParams);</span><br><span class="line">            m.sendToTarget();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、JobService-JobHandler-handleMessage"><a href="#4、JobService-JobHandler-handleMessage" class="headerlink" title="4、JobService.JobHandler.handleMessage"></a>4、<code>JobService.JobHandler.handleMessage</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JobHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> JobParameters params = (JobParameters) msg.obj;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> MSG_EXECUTE_JOB:</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 调用到 JobService#onStartJob</span></span><br><span class="line">                    <span class="keyword">boolean</span> workOngoing = JobService.<span class="keyword">this</span>.onStartJob(params);</span><br><span class="line">                    ackStartMessage(params, workOngoing);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    Log.e(TAG, <span class="string">&quot;Error while executing job: &quot;</span> + params.getJobId());</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                ....</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4、小结"><a href="#4-4、小结" class="headerlink" title="4.4、小结"></a>4.4、小结</h3><p>整个过程涉及两次跨进程的调用, 第一次是从<code>app</code>通过<code>IJobScheduler</code>调用到<code>framework</code>的<code>JobScheduleService.schedule</code>方法。 第二次则是<code>framework</code> 采用<code>bindService</code>方式通过<code>IJobService</code>接口，然后调用<code>JobService#onStartJob</code>。<br><img src="https://leanote.com/api/file/getImage?fileId=5a573518ab64415fdc001540" alt="job_0"></p>
<h2 id="五、JobScheduler服务启动"><a href="#五、JobScheduler服务启动" class="headerlink" title="五、JobScheduler服务启动"></a>五、JobScheduler服务启动</h2><p>上面我们介绍了JobScheduler执行原理，下面我们看下<code>JobSchedulerService</code>的启动过程</p>
<h3 id="5-1、JobSchedulerService"><a href="#5-1、JobSchedulerService" class="headerlink" title="5.1、JobSchedulerService"></a>5.1、<code>JobSchedulerService</code></h3><p><code>SystemServer</code> 进程启动时进行初始化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void startOtherServices() &#123;</span><br><span class="line">  ...</span><br><span class="line">  mSystemServiceManager.startService(JobSchedulerService.class);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下 <code>JobSchedulerService</code> 的初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JobSchedulerService &#123;</span><br><span class="line">    List&lt;StateController&gt; mControllers;</span><br><span class="line">    <span class="keyword">final</span> JobHandler mHandler;</span><br><span class="line">    <span class="keyword">final</span> JobSchedulerStub mJobSchedulerStub;</span><br><span class="line">    <span class="keyword">final</span> JobStore mJobs;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JobSchedulerService</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">        mControllers = <span class="keyword">new</span> ArrayList&lt;StateController&gt;();</span><br><span class="line">        mControllers.add(ConnectivityController.get(<span class="keyword">this</span>));</span><br><span class="line">        mControllers.add(TimeController.get(<span class="keyword">this</span>));</span><br><span class="line">        mControllers.add(IdleController.get(<span class="keyword">this</span>));</span><br><span class="line">        mControllers.add(BatteryController.get(<span class="keyword">this</span>));</span><br><span class="line">        mControllers.add(AppIdleController.get(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建主线程的looper</span></span><br><span class="line">        mHandler = <span class="keyword">new</span> JobHandler(context.getMainLooper());</span><br><span class="line">        <span class="comment">//创建binder服务端</span></span><br><span class="line">        mJobSchedulerStub = <span class="keyword">new</span> JobSchedulerStub();</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        mJobs = JobStore.initAndGet(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        publishBinderService(Context.JOB_SCHEDULER_SERVICE, mJobSchedulerStub);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建了5个不同的StateController，分别添加到mControllers。</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ConnectivityController</td>
<td align="left">注册监听网络连接状态的广播</td>
</tr>
<tr>
<td align="left">TimeController</td>
<td align="left">注册监听job时间到期的广播</td>
</tr>
<tr>
<td align="left">IdleController</td>
<td align="left">注册监听屏幕亮/灭,dream进入/退出,状态改变的广播</td>
</tr>
<tr>
<td align="left">BatteryController</td>
<td align="left">注册监听电池是否充电,电量状态的广播</td>
</tr>
<tr>
<td align="left">AppIdleController</td>
<td align="left">监听app是否空闲</td>
</tr>
</tbody></table>
<p><img src="http://gityuan.com/images/jobscheduler/state_controller.jpg" alt="state_controller"></p>
<p>接下来，以<code>ConnectivityController</code>为例,说一说相应<code>Controller</code>的工作机制。</p>
<h4 id="1、注册网络监听"><a href="#1、注册网络监听" class="headerlink" title="1、注册网络监听"></a>1、注册网络监听</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ConnectivityController</span><span class="params">(StateChangedListener stateChangedListener, Context context,</span></span></span><br><span class="line"><span class="params"><span class="function">        Object lock)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">final</span> IntentFilter intentFilter = <span class="keyword">new</span> IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION);</span><br><span class="line">    <span class="comment">// 注册广播</span></span><br><span class="line">    mContext.registerReceiverAsUser(</span><br><span class="line">            mConnectivityReceiver, UserHandle.SYSTEM, intentFilter, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、网络变化"><a href="#2、网络变化" class="headerlink" title="2、网络变化"></a>2、网络变化</h4><p>更新任务的状态，回调<code>JobSchedulerService#onControllerStateChanged</code>触发任务执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> BroadcastReceiver mConnectivityReceiver = <span class="keyword">new</span> BroadcastReceiver() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        updateTrackedJobs(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateTrackedJobs</span><span class="params">(<span class="keyword">int</span> uid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mTrackedJobs.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> JobStatus js = mTrackedJobs.get(i);</span><br><span class="line">            <span class="keyword">if</span> (uid == -<span class="number">1</span> || uid == js.getSourceUid()) &#123;</span><br><span class="line">                changed |= updateConstraintsSatisfied(js);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">            <span class="comment">// 触发任务执行</span></span><br><span class="line">            mStateChangedListener.onControllerStateChanged();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、处理消息"><a href="#3、处理消息" class="headerlink" title="3、处理消息"></a>3、处理消息</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onControllerStateChanged</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		mHandler.obtainMessage(MSG_CHECK_JOB).sendToTarget();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 和上面的流程相同</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">JobHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">				<span class="comment">//...</span></span><br><span class="line">				<span class="keyword">case</span> MSG_CHECK_JOB:</span><br><span class="line">				     <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">				         Slog.d(TAG, <span class="string">&quot;MSG_CHECK_JOB&quot;</span>);</span><br><span class="line">				     &#125;</span><br><span class="line">				     removeMessages(MSG_CHECK_JOB);</span><br><span class="line">				     <span class="keyword">if</span> (mReportedActive) &#123;</span><br><span class="line">				         <span class="comment">// if jobs are currently being run, queue all ready jobs for execution.</span></span><br><span class="line">				         queueReadyJobsForExecutionLocked();</span><br><span class="line">				     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				         <span class="comment">// Check the list of jobs and run some of them if we feel inclined.</span></span><br><span class="line">				         maybeQueueReadyJobsForExecutionLocked();</span><br><span class="line">				     &#125;</span><br><span class="line">			<span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2、JobStore-initAndGet"><a href="#5-2、JobStore-initAndGet" class="headerlink" title="5.2、JobStore.initAndGet"></a>5.2、JobStore.initAndGet</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> JobStore <span class="title">initAndGet</span><span class="params">(JobSchedulerService jobManagerService)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (sSingletonLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sSingleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sSingleton = <span class="keyword">new</span> JobStore(jobManagerService.getContext(),</span><br><span class="line">                    jobManagerService.getLock(), Environment.getDataDirectory());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法会创建job目录以及jobs.xml文件, 以及从文件中读取所有的JobStatus。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">JobStore</span><span class="params">(Context context, Object lock, File dataDir)</span> </span>&#123;</span><br><span class="line">    mLock = lock;</span><br><span class="line">    mWriteScheduleLock = <span class="keyword">new</span> Object();</span><br><span class="line">    mContext = context;</span><br><span class="line"></span><br><span class="line">    File systemDir = <span class="keyword">new</span> File(dataDir, <span class="string">&quot;system&quot;</span>);</span><br><span class="line">    File jobDir = <span class="keyword">new</span> File(systemDir, <span class="string">&quot;job&quot;</span>);</span><br><span class="line">    jobDir.mkdirs();</span><br><span class="line">    mEventLogger = <span class="keyword">new</span> SystemConfigFileCommitEventLogger(<span class="string">&quot;jobs&quot;</span>);</span><br><span class="line">    mJobsFile = <span class="keyword">new</span> AtomicFile(<span class="keyword">new</span> File(jobDir, <span class="string">&quot;jobs.xml&quot;</span>), mEventLogger);</span><br><span class="line"></span><br><span class="line">    mJobSet = <span class="keyword">new</span> JobSet();</span><br><span class="line">		</span><br><span class="line">    mXmlTimestamp = mJobsFile.getLastModifiedTime();</span><br><span class="line">    mRtcGood = (sSystemClock.millis() &gt; mXmlTimestamp);</span><br><span class="line"></span><br><span class="line">    readJobMapFromDisk(mJobSet, mRtcGood);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JobInfo-amp-JobStatus-amp-JobStore"><a href="#JobInfo-amp-JobStatus-amp-JobStore" class="headerlink" title="JobInfo&amp;JobStatus&amp;JobStore"></a><code>JobInfo&amp;JobStatus&amp;JobStore</code></h4><p>在开机启动时在<code>JobSchedulerService</code>读取该文件，即使重启手机任务也可执行。<br><img src="https://leanote.com/api/file/getImage?fileId=5a585894ab64413e0d001645" alt="job_1"></p>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ul>
<li><code>JobSchedule</code> 的启动会执行两次跨进程的调用, 第一次是从app通过<code>IJobScheduler</code>调用到framework的<code>JobScheduleService.schedule</code>方法。 第二次则是framework 采用bindService方式通过IJobService接口，然后调用<code>JobService#onStartJob</code></li>
<li><code>JobService#onStartJob</code>运行在app进程的主线程, 当存在耗时操作时则必须要采用异步方式, 让耗时操作交给子线程去执行,这样就不会阻塞app的UI线程</li>
<li><code>JobStore</code> 保存<code>Job</code>信息，设置为<code>persist</code>的Job会写入到配置文件<code>/data/system/job/jobs.xml</code>中，在开机启动时读取该文件，即使重启手机任务也可执行</li>
<li><code>StateController</code> 监听网络等的变化，触发任务的执行</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://wiki.jikexueyuan.com/project/android-weekly/issue-146/using-jobscheduler.html">http://wiki.jikexueyuan.com/project/android-weekly/issue-146/using-jobscheduler.html</a><br><a href="http://www.bijishequ.com/detail/418422?p=">http://www.bijishequ.com/detail/418422?p=</a><br><a href="https://stackoverflow.com/questions/38344220/job-scheduler-not-running-on-android-n">https://stackoverflow.com/questions/38344220/job-scheduler-not-running-on-android-n</a><br><a href="http://gityuan.com/2017/03/10/job_scheduler_service/">http://gityuan.com/2017/03/10/job_scheduler_service/</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>Framework</category>
      </categories>
  </entry>
  <entry>
    <title>APK签名机制</title>
    <url>/2021/03/20/Notes/Android/04Framework/Framework_09_APK%E7%AD%BE%E5%90%8D%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="APK签名机制"><a href="#APK签名机制" class="headerlink" title="APK签名机制"></a>APK签名机制</h1><span id="more"></span>

<h1 id="1、什么是apk签名"><a href="#1、什么是apk签名" class="headerlink" title="1、什么是apk签名"></a>1、什么是apk签名</h1><p>android应用在安装过程中会对apk进行签名校验，主要用于验证apk的可靠性、安全性以及唯一性，保证apk是有可信性的发布者发布，防止发布后被篡改；另外在apk升级时除了包名一致，签名也要一致。要了解签名和验签过程需要先了解以下几个基本概念。</p>
<h2 id="1-1、基本概念"><a href="#1-1、基本概念" class="headerlink" title="1.1、基本概念"></a>1.1、基本概念</h2><h3 id="1-1-1、数字摘要"><a href="#1-1-1、数字摘要" class="headerlink" title="1.1.1、数字摘要"></a>1.1.1、数字摘要</h3><p>数字摘要就是采用单向Hash函数将需要加密的明文“摘要”成一串固定长度（128位）的密文这一串密文又称为数字指纹，它有固定的长度，而且不同的明文摘要成密文，其结果总是不同的，而同样的明文其摘要必定一致。常用的数字摘要技术（Digital Digest）也称作为安全HASH编码法（SHA：Secure Hash Algorithm）。对所要传输的数据进行运算生成信息摘要，它并不是一种加密机制，但却能产生信息的数字”指纹”，它的目的是为了确保数据没有被修改或变化，保证信息的完整性不被破坏。</p>
<h3 id="1-1-2、数字签名"><a href="#1-1-2、数字签名" class="headerlink" title="1.1.2、数字签名"></a>1.1.2、数字签名</h3><p>数字签名的作用就是保证信息传输的完整性、发送者的身份认证、防止交易中的抵赖发生。<strong>数字签名技术是将摘要信息用发送者的私钥加密</strong>，与原文一起传送给接收者。接收者只有<strong>用发送者的公钥才能解密被加密的摘要信息然后用HASH函数对收到的原文产生一个摘要信息，与解密的摘要信息对比</strong>。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。</p>
<h3 id="1-1-3、数字证书"><a href="#1-1-3、数字证书" class="headerlink" title="1.1.3、数字证书"></a>1.1.3、数字证书</h3><p>数字证书是由权威公证的第三方认证机构（即CA，Certificate Authority）负责签发和管理的、个人或企业的网络数字身份证明。A的数字签名可以类比为现实世界中的签名，用来证明一个文件或者消息是A签署的，通常是使用A的私钥对消息摘要加密而得到，其他人可以使用A的公钥对数字签名进行验证。但是怎么才能信任A的公钥呢？让A自己证明自己是一件很难的事情，因此就需要第三方来证明，这就是数字证书的意义所在。</p>
<h2 id="1-2、apk签名和验签原理"><a href="#1-2、apk签名和验签原理" class="headerlink" title="1.2、apk签名和验签原理"></a>1.2、apk签名和验签原理</h2><p><img src="/pics/image-20201216113655542.png" alt="image-20201216113655542"></p>
<h3 id="1-2-1、APK签名"><a href="#1-2-1、APK签名" class="headerlink" title="1.2.1、APK签名"></a>1.2.1、APK签名</h3><ol>
<li>计算摘要：使用数字摘要算法计算出apk的摘要；</li>
<li>签名：通过私钥对摘要进行加密，加密后的信息就是签名；</li>
<li>写入签名：将签名信息、证书以及公钥写入到文件中。</li>
</ol>
<h3 id="1-2-2、APK验签"><a href="#1-2-2、APK验签" class="headerlink" title="1.2.2、APK验签"></a>1.2.2、APK验签</h3><ol>
<li>解密签名：通过公钥解密签名信息获得摘要；</li>
<li>计算摘要：使用摘要算法从接收的数据中计算摘要；</li>
<li>比较摘要：比较解密出的摘要和通过文件计算的摘要，若一致，则校验通过。</li>
</ol>
<p>接下来介绍下现有的4种apk签名的方式。</p>
<h1 id="2、v1-签名"><a href="#2、v1-签名" class="headerlink" title="2、v1 签名"></a>2、v1 签名</h1><p>V1签名又称为JAR签名，是对jar包进行签名的一种机制，由于jar包apk本质上都是zip包，所以可以应用到对apk的签名。解压apk后，META-INF目录中存放的就是签名相关的文件。</p>
<h2 id="2-1-v1签名过程"><a href="#2-1-v1签名过程" class="headerlink" title="2.1 v1签名过程"></a>2.1 v1签名过程</h2><p><img src="/pics/image-20201221200634926.png" alt="image-20201221200634926"></p>
<p>MANIFEST.MF、CERT.SF、CERT.RSA是签名过程中生成的文件（<a href="https://android.googlesource.com/platform/build/+/7e447ed/tools/signapk/SignApk.java">apksigner源码</a>），作用如下：</p>
<h3 id="2-1-1、MANIFEST-MF"><a href="#2-1-1、MANIFEST-MF" class="headerlink" title="2.1.1、MANIFEST.MF"></a>2.1.1、MANIFEST.MF</h3><p>对APK中所有文件计算摘要保存到该文件中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Manifest-Version: <span class="number">1.0</span></span><br><span class="line">Created-By: <span class="number">1.8</span><span class="number">.0_212</span> (Oracle Corporation)</span><br><span class="line"></span><br><span class="line">Name: AndroidManifest.xml <span class="comment">//apk各个文件的摘要</span></span><br><span class="line">SHA1-Digest: GpiU1HOPO9rxpTPh43kG1XVG8iw=</span><br><span class="line"></span><br><span class="line">Name: META-INF/BdTuringSdk_cnRelease.kotlin_module</span><br><span class="line">SHA1-Digest: PVHPdoZ9+09Zq0PF+eJz0yRVf10=</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="2-1-2、CERT-SF"><a href="#2-1-2、CERT-SF" class="headerlink" title="2.1.2、CERT.SF"></a>2.1.2、CERT.SF</h3><ul>
<li>SHA1-Digest-Manifest-Main-Attributes：MANIFEST.MF主属性的数据摘要。</li>
<li>SHA1-Digest-Manifest： MANIFEST.MF 文件计算摘要。</li>
<li>SHA1-Digest：MANIFEST.MF 的各个条目摘要。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Signature-Version: <span class="number">1.0</span></span><br><span class="line">SHA1-Digest-Manifest-Main-Attributes: TN5zBsqBLAij6alOeMWe+Ejwd4g= <span class="comment">//主属性记录了MANIFEST.MF文件所有主属性的数据摘要</span></span><br><span class="line">SHA1-Digest-Manifest: PBUX5Kag9TIOJy4jZ57vwuAur1Y= <span class="comment">//整个MANIFEST.MF文件的数据摘要</span></span><br><span class="line">Created-By: <span class="number">1.8</span><span class="number">.0_45</span>-internal (Oracle Corporation)</span><br><span class="line"></span><br><span class="line">Name: res/layout/ac.xml</span><br><span class="line">SHA1-Digest: mYQig54fsd3pTRQTmTwMD2oO5CM= <span class="comment">//MANIFEST.MF 各个条目的摘要</span></span><br></pre></td></tr></table></figure>

<h3 id="2-1-3、CERT-RSA"><a href="#2-1-3、CERT-RSA" class="headerlink" title="2.1.3、CERT.RSA"></a>2.1.3、CERT.RSA</h3><p><strong>对CERT.SF 文件的摘要通过私钥加密生成校验串</strong>, 然后和<strong>数字签名、公钥、数字证书</strong>一同写入 CERT.RSA 中保存。很多文章将校验串描述成签名，这样的理解是不准确的。可以比较2个同一个公司出品的apk的RSA文件，你会发现可能除了结尾部分不太一样外，其他部分基本相同，原因其实就是同一个公司出品的apk，它的签名，证书，公钥通常都是相同的，只有通过私钥加密的CERT.SF的摘要不同。 如下图：</p>
<p><img src="/pics/image-20201217160514944.png" alt="image-20201217160514944"></p>
<h4 id="1、查看证书与公钥"><a href="#1、查看证书与公钥" class="headerlink" title="1、查看证书与公钥"></a>1、查看证书与公钥</h4><p>1、将.rsa 后缀改为.p7b文件，双击直接打开</p>
<p>2、openssl 命令查看证书信息（公钥在证书信息中）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 查看.RSA文件中证书信息</span><br><span class="line">openssl pkcs7 -inform DER -in XXX.RSA -noout -print_certs -text</span><br><span class="line"></span><br><span class="line">// 查看本地证书的公钥和私钥</span><br><span class="line">keytool -list -rfc --keystore test.jks | openssl x509 -inform pem -pubkey</span><br></pre></td></tr></table></figure>

<p>通过一个实例去理解一下这两种方式的区别和联系。</p>
<ol>
<li>使用AS或keytool生成一个.jks签名文件； <a href="https://www.jianshu.com/p/b28a5be05029">Android studio 如何生成jks签名文件</a></li>
<li>使用签名文件对apk进行签名；</li>
<li>通过相关命令查看.jks文件以及解压apk中的.rsa 文件。</li>
</ol>
<p><img src="/pics/image-20201217162850396.png" alt="image-20201217162850396"></p>
<h4 id="2、查看签名"><a href="#2、查看签名" class="headerlink" title="2、查看签名"></a>2、查看签名</h4><p>其实能看到也是签名的摘要，不是真正的签名。</p>
<ol>
<li>将.rsa 后缀改为.p7b文件，双击直接打开</li>
<li>使用keytool的命令查看.RSA文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">keytool -printcert -file xxx.RSA</span><br></pre></td></tr></table></figure>

<p><strong>证书信息：</strong></p>
<p><img src="/pics/image-20201217163225037.png" alt="image-20201217163225037"></p>
<h2 id="2-2、v1验签过程"><a href="#2-2、v1验签过程" class="headerlink" title="2.2、v1验签过程"></a>2.2、<a href="https://android.googlesource.com/platform/frameworks/base/+/android-5.1.1_r38/services/core/java/com/android/server/pm/PackageManagerService.java">v1验签过程</a></h2><ol>
<li><p><strong>首先校验cert.sf文件的签名</strong></p>
<p>计算cert.sf文件的摘要，与通过签名者公钥解密CERT.RSA文件得到的摘要进行对比，如果一致则进入下一步；</p>
</li>
<li><p><strong>校验manifest.mf文件的完整性</strong></p>
<p>计算manifest.mf文件的摘要，与cert.sf主属性中记录的摘要进行对比，如一致则逐一校验mf文件各个条目的完整性；</p>
</li>
<li><p><strong>校验apk中每个文件的完整性</strong></p>
<p>逐一计算apk中每个文件（META-INF目录除外）的摘要，与mf中的记录进行对比，如全部一致，刚校验通过；</p>
</li>
<li><p><strong>校验签名的一致性</strong></p>
<p>如果是升级安装，还需校验证书签名是否与已安装app一致。</p>
</li>
</ol>
<h2 id="2-3、v1签名的劣势"><a href="#2-3、v1签名的劣势" class="headerlink" title="2.3、v1签名的劣势"></a>2.3、v1签名的劣势</h2><ol>
<li><p>签名校验速度慢</p>
<p>校验过程中需要对apk中所有文件进行摘要计算，在apk资源很多、性能较差的机器上签名校验会花费较长时间，导致安装速度慢；</p>
</li>
<li><p>完整性保障不够</p>
<p>META-INF目录用来存放签名，自然此目录本身是不计入签名校验过程的，可以随意在这个目录中添加文件，比如一些快速批量打包方案就选择在这个目录中添加渠道文件。</p>
<p>为了解决这两个问题，Android 7.0推出了全新的签名方案V2，下面介绍下v2签名。</p>
</li>
</ol>
<h1 id="2、v2签名"><a href="#2、v2签名" class="headerlink" title="2、v2签名"></a>2、v2签名</h1><h2 id="2-1、ZIP文件结构"><a href="#2-1、ZIP文件结构" class="headerlink" title="2.1、ZIP文件结构"></a>2.1、ZIP文件结构</h2><p>我们先来了解下v1签名文件的apk结构，也就是zip文件的结构。</p>
<p><img src="/pics/image-20201217175101791.png" alt="image-20201217175101791"></p>
<p>zip文件分为3部分：</p>
<ol>
<li><p><strong>数据区</strong></p>
<p>主要存放压缩的文件数据</p>
</li>
<li><p><strong>中央目录</strong></p>
<p>存放数据区压缩文件的索引</p>
</li>
<li><p><strong>中央目录结尾记录</strong></p>
<p>存放中央目录的文件索引</p>
</li>
</ol>
<p>查找压缩文件中数据可以先中央目录起始偏移量和size即可定位到中央目录，再遍历中央目录条目，根据本地文件头的起始偏移量即可在数据区中找到相应数据。</p>
<h2 id="2-2、v2签名原理"><a href="#2-2、v2签名原理" class="headerlink" title="2.2、v2签名原理"></a>2.2、v2签名原理</h2><p>JAR签名是在apk文件中添加META-INF目录，即需要修改数据区、中央目录，此外，添加文件后会导致中央目录大小和偏移量发生变化，还需要修改中央目录结尾记录。</p>
<p>v2方案为加强数据完整性保证，不在数据区和中央目录中插入数据，选择在 数据区和中央目录之间插入一个APK签名分块，从而保证了原始数据的完整性。</p>
<img src="/pics/image-20201217174414400.png" alt="image-20201217174414400" style="zoom:150%;" />

<p>APK 签名方案 v2 负责保护第 1、3、4 部分的完整性，以及第 2 部分包含的“APK 签名方案 v2 分块”中的 <code>signed data</code> 分块的完整性。第 1、3 和 4 部分的完整性通过其内容的一个或多个摘要来保护，这些摘要存储在 <code>signed data</code> 分块中，而这些分块则通过一个或多个签名来保护。</p>
<h3 id="2-2-1、APK摘要计算"><a href="#2-2-1、APK摘要计算" class="headerlink" title="2.2.1、APK摘要计算"></a>2.2.1、APK摘要计算</h3><p><img src="/pics/image-20201217202801891.png" alt="image-20201217202801891"></p>
<p>第 1、3 和 4 部分的摘要采用以下计算方式：</p>
<ol>
<li>将APK拆分成多个大小为 1 MB大小的连续块，最后一个块可能小于1M。之所以分块，是为了可以通过并行计算摘要以加快计算速度；</li>
<li>计算块的摘要，以字节 0xa5 + 块的长度（字节数） + 块的内容 进行计算；</li>
<li>计算整体摘要，字节 0x5a + 块数 + 块的摘要的连接（按块在 APK 中的顺序）进行计算。</li>
</ol>
<h2 id="2-3、签名过程"><a href="#2-3、签名过程" class="headerlink" title="2.3、签名过程"></a>2.3、签名过程</h2><p>介绍APK签名过程前，需要先了解下使用apk签名块的结构和v2签名块的结构。</p>
<h3 id="2-3-1、APKSigning-Block"><a href="#2-3-1、APKSigning-Block" class="headerlink" title="2.3.1、APKSigning Block"></a>2.3.1、APKSigning Block</h3><p>APK签名分块包含了4部分：分块长度、ID-VALUE序列、分块长度、固定magic值。其中APK 签名方案 <strong>v2分块</strong>存放在ID为<strong>0x7109871a</strong>的ID-VALUE区中。</p>
<p><img src="/pics/image-20201217212653708.png" alt="image-20201217212653708"></p>
<h3 id="2-3-2、v2-Block"><a href="#2-3-2、v2-Block" class="headerlink" title="2.3.2、v2 Block"></a>2.3.2、v2 Block</h3><p>v2分块主要由签名数据，数字签名以及公钥组成，具体结构如下。</p>
<p><img src="/pics/image-20201219104001970.png" alt="image-20201219104001970"></p>
<h3 id="2-3-3、签名过程"><a href="#2-3-3、签名过程" class="headerlink" title="2.3.3、签名过程"></a>2.3.3、签名过程</h3><p>V2签名块的生成可参考<a href="https://android.googlesource.com/platform/build/+/dd910c5/tools/signapk/src/com/android/signapk/ApkSignerV2.java">ApkSignerV2</a>，整体结构和流程如下图所示：</p>
<p><img src="/pics/image-20201219153651713.png" alt="image-20201219153651713"></p>
<h2 id="2-4、v2验签过程"><a href="#2-4、v2验签过程" class="headerlink" title="2.4、v2验签过程"></a>2.4、v2验签过程</h2><p>在 Android 7.0 及更高版本中，可以根据 APK 签名方案 v2+ 或 JAR 签名（v1 方案）验证 APK。更低版本的平台会忽略 v2 签名，仅验证 v1 签名。</p>
<p><img src="/pics/image-20201221204054757.png" alt="image-20201221204054757"></p>
<h3 id="2-4-1、v2签名块定位"><a href="#2-4-1、v2签名块定位" class="headerlink" title="2.4.1、v2签名块定位"></a>2.4.1、v2签名块定位</h3><p>APK签名分块包含了4部分：分块长度、ID-VALUE序列、分块长度、固定magic值。其中APK 签名方案 v2分块存放在ID为0x7109871a的键值对中。</p>
<p>在进行签名校验时，先找到zip中央目录结尾记录，从该记录中找到中央目录起始偏移量，再通过magic值（APK Sig Block 42）即可确定前方可能是APK签名分块，再通过前后两个分块长度字段，即可确定APK签名分块的位置，最后通过ID（0x7109871a）定位APK 签名方案 v2分块位置。</p>
<h3 id="2-4-2、v2-验证过程"><a href="#2-4-2、v2-验证过程" class="headerlink" title="2.4.2、v2 验证过程"></a>2.4.2、v2 验证过程</h3><p><img src="/pics/image-20210319101806758.png" alt="image-20210319101806758"></p>
<h3 id="2-4-3、防回滚保护"><a href="#2-4-3、防回滚保护" class="headerlink" title="2.4.3、防回滚保护"></a>2.4.3、防回滚保护</h3><p><img src="/pics/image-20210319102400692.png" alt="image-20210319102400692"></p>
<h1 id="3、v3签名"><a href="#3、v3签名" class="headerlink" title="3、v3签名"></a>3、<a href="https://source.android.com/security/apksigning/v3.html">v3签名</a></h1><p>v3和v2一样签名块存储在中央目录区之前，v3 签名会存储的ID为<strong>0xf05368c0</strong>，新增了 ID为<strong>0x3ba06f8c</strong> 的proof-of-rotation 结构中用来支持应用替换签名证书。在 Android 9 及更高版本中，可以根据 APK 签名方案 v3、v2 或 v1 验证 APK。较旧的平台会忽略 v3 签名而尝试验证 v2 签名，然后尝试验证 v1 签名。</p>
<p><img src="/pics/image-20201222203051481.png" alt="image-20201222203051481"></p>
<h1 id="4、v4签名"><a href="#4、v4签名" class="headerlink" title="4、v4签名"></a>4、v4签名</h1><p>Android 11 通过 APK 签名方案 v4 支持与流式传输兼容的签名方案（来支持增量安装APK）。v4 签名基于根据 APK 的所有字节计算得出的 Merkle 哈希树。</p>
<p><a href="https://source.android.google.cn/security/apksigning/v4">https://</a><a href="https://source.android.google.cn/security/apksigning/v4">source.android.google.cn/security/apksigning/v4</a> </p>
<h1 id="5、多渠道打包原理"><a href="#5、多渠道打包原理" class="headerlink" title="5、多渠道打包原理"></a>5、多渠道打包原理</h1><p>同一个app，需要上线各种平台，比如：小米，华为，百度等，我们多数称之为渠道，如果发的渠道多，可能有上百个渠道。</p>
<p>针对每个渠道，我们希望可以获取各个渠道的一些独立的统计信息，比如：下载量等。</p>
<p><strong>那么，如何区分各个渠道呢？</strong></p>
<p>Gradle Plugin为我们提供了一个自动化的方案，我们可以利用占位符，然后在build.gradle中去配置多个渠道信息，这样就可以将枯燥重复的任务自动化了。</p>
<p>这样的方式最大的问题，就是效率问题，每个渠道包，都要执行一遍构建流程，打包效率太低，目前市面比较出名的方案有美团<a href="https://tech.meituan.com/2017/01/13/android-apk-v2-signature-scheme.html">Walle</a>，腾讯的<a href="https://github.com/Tencent/VasDolly">VasDolly</a>所谓万变不离其宗，下面就介绍下市面上多渠道打包方案的基本原理。</p>
<h2 id="5-1、v1方案"><a href="#5-1、v1方案" class="headerlink" title="5.1、v1方案"></a>5.1、v1方案</h2><h3 id="5-1-1、EOCD"><a href="#5-1-1、EOCD" class="headerlink" title="5.1.1、EOCD"></a>5.1.1、EOCD</h3><p>我们知道要在apk中定位某个文件的位置必须要先解析出EOCD的结果，根据EOCD的结构推断出中央目录区，再根据中央目录区定位到v2签名块或者文件的情况。下面是EOCD的结构，主要包括几部分：</p>
<ol>
<li>魔数 0x06054B50，标记EOCD</li>
<li>中央目录信息（起始位置，记录数，长度）</li>
<li>注释区长度n（前2个字节）以及注释内容（Comment）</li>
</ol>
<p><img src="/pics/image-20201219155013207.png" alt="image-20201219155013207"></p>
<h3 id="5-1-2、v1方案"><a href="#5-1-2、v1方案" class="headerlink" title="5.1.2、v1方案"></a>5.1.2、v1方案</h3><p>根据之前的V1签名和校验机制可知，v1签名只会检验第一部分的所有压缩文件，而不理会后两部分内容。因此，我们可以向注释区中写入渠道。写入过程如下：</p>
<p><img src="/pics/image-20201222201238671.png" alt="image-20201222201238671"></p>
<p>这里添加魔数的好处是方便从后向前读取数据，定位渠道信息。因此，读取渠道信息包括以下几步：</p>
<ol>
<li>定位到魔数（8字节）</li>
<li>向前读两个字节，确定渠道信息的长度LEN（2字节）</li>
<li>继续向前读LEN字节，就是渠道信息了。</li>
</ol>
<h2 id="5-2、v2方案"><a href="#5-2、v2方案" class="headerlink" title="5.2、v2方案"></a>5.2、v2方案</h2><p>对于v2签名，Android系统只会关注ID为<strong>0x7109871a</strong>的v2签名块，并且忽略其他的ID-Value，同时v2签名只会保护APK本身，不包含签名块。所以可以将渠道写入到ID-Value键值对区。写入过程如下：</p>
<ol>
<li>从apk文件结尾，通过ID <strong>0x06054B50定</strong>位到<strong>EOCD</strong></li>
<li>通过EOCD找到<strong>中央目录结尾起始偏移</strong></li>
<li>定位APKSigning Block，</li>
<li>定位v2block</li>
<li>获取已有的ID-Value Pair</li>
<li><strong>添加包含渠道信息的ID-Value</strong></li>
<li>基于所有的ID-Value生成新的签名</li>
<li>修改EOCD的中央目录的偏移量(修改EOCD的中央目录偏移量，不会导致数据摘要校验失败）</li>
</ol>
<p>读取过程和写入过程基本相同，忽略。</p>
<h2 id="5-3、v3-方案"><a href="#5-3、v3-方案" class="headerlink" title="5.3、v3 方案"></a>5.3、v3 方案</h2><p>v3和v2的方案基本相同，但是v3签名<strong>限制了签名块大小是4096的倍数</strong>（<a href="https://www.cnblogs.com/yrstudy/p/11884996.html">参考</a>）在不写入渠道时读取下APK Singing Block，其大小刚好是4096。若写入渠道后不满足该条件，如果不是的话，就会去生成一个ByteBuffer来填充签名块，其ID为0x42726577。所以写入渠道后，<strong>可以通过修改0x42726577的value的大小保证签名块长度是4096的倍数即可</strong>。源码：</p>
<p><a href="https://android.googlesource.com/platform/tools/apksig/+/master/src/main/java/com/android/apksig/internal/apk/ApkSigningBlockUtils.java">generateApkSigningBlock</a></p>
<p><img src="/pics/image-20201222211918992.png" alt="image-20201222211918992"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/286d2b372334">https://www.jianshu.com/p/286d2b372334</a></p>
<p><a href="https://juejin.cn/post/6844903473310334984">https://juejin.cn/post/6844903473310334984</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/108036144">https://zhuanlan.zhihu.com/p/108036144</a></p>
<p><a href="https://mp.weixin.qq.com/s/709mXKfEzSuLrd0WCqrmbghttps://github.com/Meituan-Dianping/walle">https://mp.weixin.qq.com/s/709mXKfEzSuLrd0WCqrmbghttps://github.com/Meituan-Dianping/walle</a>)</p>
<p><a href="https://www.cnblogs.com/yrstudy/p/11884996.html">https://www.cnblogs.com/yrstudy/p/11884996.html</a></p>
<p><a href="https://source.android.google.cn/security/apksigning/v2?hl=zh-cn">https://source.android.google.cn/security/apksigning/v2?hl=zh-cn</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>APK签名</category>
      </categories>
  </entry>
  <entry>
    <title>open_08_AOP</title>
    <url>/2021/10/10/Notes/Android/06AOP/open_08_AOP/</url>
    <content><![CDATA[<h1 id="open-08-AOP"><a href="#open-08-AOP" class="headerlink" title="open_08_AOP"></a>open_08_AOP</h1><span id="more"></span>

<p>APT：注解编译器java文件，生成java文件</p>
<p>AspectJ：java 文件编译成 class文件之前，直接修改源代码生成class</p>
<p>ASM：class 文件编译成 dex文件之前，修改的是class文件</p>
<p><a href="https://www.jianshu.com/p/89ac9a2513c4">https://www.jianshu.com/p/89ac9a2513c4</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>开源</category>
      </categories>
  </entry>
  <entry>
    <title>Java进阶04_ClassLoader</title>
    <url>/2022/06/25/Notes/Android/05%E6%8F%92%E4%BB%B6%E5%8C%96/Android%E6%8F%92%E4%BB%B6%E5%8C%9601_ClassLoader/</url>
    <content><![CDATA[<h1 id="Android插件化01-ClassLoader"><a href="#Android插件化01-ClassLoader" class="headerlink" title="Android插件化01_ClassLoader"></a>Android插件化01_ClassLoader</h1><span id="more"></span>

<p><code>Android插件化</code>作为一个进阶的技术目前也已经非常成熟了，许多头部的公司都开源了他们的插件化技术。插件化技术的核心难点有三个：</p>
<ul>
<li>如何加载并执行插件 <code>Apk</code> 中的代码（<code>ClassLoader Injection</code>）</li>
<li>让系统能调用插件 <code>Apk</code> 中的组件（<code>Runtime Container</code>）</li>
<li>正确识别插件 <code>Apk</code> 中的资源（<code>Resource Injection</code>）</li>
</ul>
<p>这节课我们先来了解下插件加载的原理 <code>classLoader</code>,我们知道Android应用本身是基于魔改的 <code>Java</code> 虚拟机的，而由于插件是未安装的 apk，系统不会处理其中的类，所以需要使用 <code>ClassLoader</code> 加载 <code>Apk</code>，然后反射里面的代码。</p>
<p><strong>Java 中的 ClassLoader</strong></p>
<ul>
<li><code>BootstrapClassLoader</code> 负责加载 JVM 运行时的核心类，比如 JAVA_HOME/lib/rt.jar 等等</li>
<li><code>ExtensionClassLoader</code> 负责加载 JVM 的扩展类，比如 JAVA_HOME/lib/ext 下面的 jar 包</li>
<li><code>AppClassLoader</code> 负责加载 classpath 里的 jar 包和目录</li>
</ul>
<p> <strong>Android 中的 ClassLoader</strong></p>
<p>在Android系统中<code>ClassLoader</code>是用来加载<code>dex</code>文件的，有包含 dex 的 apk 文件以及 jar 文件，dex 文件是一种对class文件优化的产物，在<code>Android</code>中应用打包时会把所有class文件进行合并、优化（把不同的class文件重复的东西只保留一份），然后生成一个最终的<code>class.dex</code>文件。Android中负责加载 dex 的 中的<code>ClassLoader</code> 有三个，分别是：</p>
<ul>
<li>BootClassLoader：加载Framework 类 Context Activity 这些</li>
<li>PathClassLoader : 默认的程序类加载器</li>
<li>DexClassLoader : 和PathClassLoader 差不多，PathClassLoader 和 DexClassLoader <strong>都能加载外部的 dex／apk</strong>，只不过区别是 DexClassLoader 可以<strong>指定 optimizedDirectory</strong>，也就是 dex2oat 的产物 .odex 存放的位置，而 PathClassLoader 只能使用系统默认位置。但是这个 optimizedDirectory 在 Android 8.0 以后也被舍弃了，只能使用系统默认的位置了。</li>
</ul>
<h1 id="一、Android-类加载过程"><a href="#一、Android-类加载过程" class="headerlink" title="一、Android 类加载过程"></a>一、Android 类加载过程</h1><h2 id="ClassLoader加载过程"><a href="#ClassLoader加载过程" class="headerlink" title="ClassLoader加载过程"></a><code>ClassLoader</code>加载过程</h2><p>Android中<code>ClassLoader</code>的类作用和Java 基本是一致，使用了 <code>双亲委派机制</code>加载类。</p>
<p><code>libcore/ojluni/src/main/java/java/lang/ClassLoader.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        <span class="comment">// 1.</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="comment">// 2.</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass(String name) &#123;</span><br><span class="line">     ClassLoader loader;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span> == BootClassLoader.getInstance())</span><br><span class="line">         loader = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         loader = <span class="keyword">this</span>;</span><br><span class="line">     <span class="keyword">return</span> VMClassLoader.findLoadedClass(loader, name);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, java.nio.ByteBuffer b,</span><br><span class="line">                                      ProtectionDomain protectionDomain)</span><br><span class="line">     <span class="keyword">throws</span> ClassFormatError</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;can&#x27;t load this type of class file&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要子类复写</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>JVM中<code>ClassLoader</code>通过<code>defineClass</code>方法加载jar里面的Class，而<code>Android</code>中这个方法被弃用了。</p>
<p>既然<code>Android</code>中不能用<code>defineClass</code>的方法读取一个class文件的byte，那么android如何加载class文件的？</p>
<p>答案是通过 <code>BaseDexClassLoader</code>。</p>
<h2 id="BaseDexClassLoader"><a href="#BaseDexClassLoader" class="headerlink" title="BaseDexClassLoader"></a><code>BaseDexClassLoader</code></h2><p><code>libcore/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDexClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">BaseDexClassLoader</span><span class="params">(String dexPath,</span></span></span><br><span class="line"><span class="params"><span class="function">            String librarySearchPath, ClassLoader parent, ClassLoader[] sharedLibraryLoaders,</span></span></span><br><span class="line"><span class="params"><span class="function">            ClassLoader[] sharedLibraryLoadersAfter,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">boolean</span> isTrusted)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="comment">// Setup shared libraries before creating the path list. ART relies on the class loader</span></span><br><span class="line">        <span class="comment">// hierarchy being finalized before loading dex files.</span></span><br><span class="line">        <span class="keyword">this</span>.sharedLibraryLoaders = sharedLibraryLoaders == <span class="keyword">null</span></span><br><span class="line">                ? <span class="keyword">null</span></span><br><span class="line">                : Arrays.copyOf(sharedLibraryLoaders, sharedLibraryLoaders.length);</span><br><span class="line">        <span class="keyword">this</span>.pathList = <span class="keyword">new</span> DexPathList(<span class="keyword">this</span>, dexPath, librarySearchPath, <span class="keyword">null</span>, isTrusted);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.sharedLibraryLoadersAfter = sharedLibraryLoadersAfter == <span class="keyword">null</span></span><br><span class="line">                ? <span class="keyword">null</span></span><br><span class="line">                : Arrays.copyOf(sharedLibraryLoadersAfter, sharedLibraryLoadersAfter.length);</span><br><span class="line">        <span class="comment">// Run background verification after having set &#x27;pathList&#x27;.</span></span><br><span class="line">        <span class="keyword">this</span>.pathList.maybeRunBackgroundVerification(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        reportClassLoaderChain();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">      <span class="comment">// First, check whether the class is present in our shared libraries.</span></span><br><span class="line">      <span class="keyword">if</span> (sharedLibraryLoaders != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">for</span> (ClassLoader loader : sharedLibraryLoaders) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">return</span> loader.loadClass(name);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Check whether the class in question is present in the dexPath that</span></span><br><span class="line">      <span class="comment">// this classloader operates on.</span></span><br><span class="line">      List&lt;Throwable&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;Throwable&gt;();</span><br><span class="line">      <span class="comment">// 1. 通过DexPathList 加载</span></span><br><span class="line">      Class c = pathList.findClass(name, suppressedExceptions);</span><br><span class="line">      <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> c;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Now, check whether the class is present in the &quot;after&quot; shared libraries.</span></span><br><span class="line">      <span class="keyword">if</span> (sharedLibraryLoadersAfter != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">for</span> (ClassLoader loader : sharedLibraryLoadersAfter) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">return</span> loader.loadClass(name);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">          ClassNotFoundException cnfe = <span class="keyword">new</span> ClassNotFoundException(</span><br><span class="line">                  <span class="string">&quot;Didn&#x27;t find class \&quot;&quot;</span> + name + <span class="string">&quot;\&quot; on path: &quot;</span> + pathList);</span><br><span class="line">          <span class="keyword">for</span> (Throwable t : suppressedExceptions) &#123;</span><br><span class="line">              cnfe.addSuppressed(t);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">throw</span> cnfe;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> c;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BaseDexClassLoader 构造函数有四个参数，含义如下：</p>
<ul>
<li><strong>dexPath</strong>: 需要加载的文件列表，文件可以是包含了 classes.dex 的 JAR/APK/ZIP，也可以直接使用 classes.dex 文件，多个文件用 “:” 分割</li>
<li><strong>optimizedDirectory</strong>: 存放优化后的 dex，可以为空</li>
<li><strong>libraryPath</strong>: 存放需要加载的 native 库的目录</li>
<li><strong>parent</strong>: 父 ClassLoader</li>
</ul>
<p>通过构造函数我们大概可以了解到 BaseDexClassLoader 的运行方式，传入 dex 文件，然后进行优化，保存优化后的 dex 文件到 optimizedDirectory 目录。</p>
<p><code>BaseClassLoader</code> 中 <code>findClass</code>调用的是 <code>DexPathList</code> 加载类，我们继续分析 </p>
<h2 id="DexPathList"><a href="#DexPathList" class="headerlink" title="DexPathList"></a><code>DexPathList</code></h2><p><code>DexPathList</code>中主要有2个过程</p>
<ul>
<li>加载Dex文件</li>
<li>加载Class</li>
</ul>
<p><code>libcore/dalvik/src/main/java/dalvik/system/DexPathList.java</code></p>
<h3 id="DexPathList-findClass"><a href="#DexPathList-findClass" class="headerlink" title="DexPathList#findClass"></a><code>DexPathList#findClass</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DexPathList</span> </span>&#123;</span><br><span class="line">    DexPathList(ClassLoader definingContext, String dexPath,</span><br><span class="line">            String librarySearchPath, File optimizedDirectory, <span class="keyword">boolean</span> isTrusted) &#123;</span><br><span class="line">				<span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">this</span>.definingContext = definingContext;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;IOException&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;IOException&gt;();</span><br><span class="line">        <span class="comment">// 1、加载dex 文件</span></span><br><span class="line">        <span class="keyword">this</span>.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,</span><br><span class="line">                                           suppressedExceptions, definingContext, isTrusted);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Native libraries may exist in both the system and</span></span><br><span class="line">        <span class="comment">// application library paths, and we use this search order:</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//   1. This class loader&#x27;s library path for application libraries (librarySearchPath):</span></span><br><span class="line">        <span class="comment">//   1.1. Native library directories</span></span><br><span class="line">        <span class="comment">//   1.2. Path to libraries in apk-files</span></span><br><span class="line">        <span class="comment">//   2. The VM&#x27;s library path from the system property for system libraries</span></span><br><span class="line">        <span class="comment">//      also known as java.library.path</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// This order was reversed prior to Gingerbread; see http://b/2933456.</span></span><br><span class="line">        <span class="keyword">this</span>.nativeLibraryDirectories = splitPaths(librarySearchPath, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">this</span>.systemNativeLibraryDirectories =</span><br><span class="line">                splitPaths(System.getProperty(<span class="string">&quot;java.library.path&quot;</span>), <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.nativeLibraryPathElements = makePathElements(getAllNativeLibraryDirectories());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (suppressedExceptions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.dexElementsSuppressedExceptions =</span><br><span class="line">                suppressedExceptions.toArray(<span class="keyword">new</span> IOException[suppressedExceptions.size()]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dexElementsSuppressedExceptions = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.加载Class</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; findClass(String name, List&lt;Throwable&gt; suppressed) &#123;</span><br><span class="line">        <span class="comment">// 遍历Element数组</span></span><br><span class="line">        <span class="keyword">for</span> (Element element : dexElements) &#123;</span><br><span class="line">            <span class="comment">// Element.findClass</span></span><br><span class="line">            Class&lt;?&gt; clazz = element.findClass(name, definingContext, suppressed);</span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dexElementsSuppressedExceptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">            suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、Dex文件加载"><a href="#二、Dex文件加载" class="headerlink" title="二、Dex文件加载"></a>二、Dex文件加载</h1><h2 id="DexPathList-makeDexElements"><a href="#DexPathList-makeDexElements" class="headerlink" title="DexPathList#makeDexElements"></a><code>DexPathList#makeDexElements</code></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Element[] makeDexElements(List&lt;File&gt; files, File optimizedDirectory,</span><br><span class="line">        List&lt;IOException&gt; suppressedExceptions, ClassLoader loader, <span class="keyword">boolean</span> isTrusted) &#123;</span><br><span class="line">  Element[] elements = <span class="keyword">new</span> Element[files.size()];</span><br><span class="line">  <span class="keyword">int</span> elementsPos = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Open all files and load the (direct or contained) dex files up front.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">      <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">          <span class="comment">// We support directories for looking up resources. Looking up resources in</span></span><br><span class="line">          <span class="comment">// directories is useful for running libcore tests.</span></span><br><span class="line">          elements[elementsPos++] = <span class="keyword">new</span> Element(file);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">          String name = file.getName();</span><br><span class="line"></span><br><span class="line">          DexFile dex = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">if</span> (name.endsWith(DEX_SUFFIX)) &#123;</span><br><span class="line">              <span class="comment">// Raw dex file (not inside a zip/jar).</span></span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  dex = loadDexFile(file, optimizedDirectory, loader, elements);</span><br><span class="line">                  <span class="keyword">if</span> (dex != <span class="keyword">null</span>) &#123;</span><br><span class="line">                      elements[elementsPos++] = <span class="keyword">new</span> Element(dex, <span class="keyword">null</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">catch</span> (IOException suppressed) &#123;</span><br><span class="line">                  System.logE(<span class="string">&quot;Unable to load dex file: &quot;</span> + file, suppressed);</span><br><span class="line">                  suppressedExceptions.add(suppressed);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  dex = loadDexFile(file, optimizedDirectory, loader, elements);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (IOException suppressed) &#123;</span><br><span class="line">                  <span class="comment">/*</span></span><br><span class="line"><span class="comment">                   * IOException might get thrown &quot;legitimately&quot; by the DexFile constructor if</span></span><br><span class="line"><span class="comment">                   * the zip file turns out to be resource-only (that is, no classes.dex file</span></span><br><span class="line"><span class="comment">                   * in it).</span></span><br><span class="line"><span class="comment">                   * Let dex == null and hang on to the exception to add to the tea-leaves for</span></span><br><span class="line"><span class="comment">                   * when findClass returns null.</span></span><br><span class="line"><span class="comment">                   */</span></span><br><span class="line">                  suppressedExceptions.add(suppressed);</span><br><span class="line">              &#125;</span><br><span class="line">							<span class="comment">// 3、添加到elements数组中</span></span><br><span class="line">              <span class="keyword">if</span> (dex == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  elements[elementsPos++] = <span class="keyword">new</span> Element(file);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  elements[elementsPos++] = <span class="keyword">new</span> Element(dex, file);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (dex != <span class="keyword">null</span> &amp;&amp; isTrusted) &#123;</span><br><span class="line">            dex.setTrusted();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          System.logW(<span class="string">&quot;ClassLoader referenced unknown path: &quot;</span> + file);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (elementsPos != elements.length) &#123;</span><br><span class="line">      elements = Arrays.copyOf(elements, elementsPos);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> elements;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> DexFile <span class="title">loadDexFile</span><span class="params">(File file, File optimizedDirectory, ClassLoader loader,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   Element[] elements)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (optimizedDirectory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DexFile(file, loader, elements);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String optimizedPath = optimizedPathFor(file, optimizedDirectory);</span><br><span class="line">        <span class="keyword">return</span> DexFile.loadDex(file.getPath(), optimizedPath, <span class="number">0</span>, loader, elements);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>makeDexElements</code>的主要过程就是遍历<code>dexPath</code>加载<code>Dex</code>文件，而加载Dex 文件的过程是通过<code>DexFile</code>。</p>
<h2 id="DexFile-loadDex"><a href="#DexFile-loadDex" class="headerlink" title="DexFile#loadDex"></a><code>DexFile#loadDex</code></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DexFile</span> </span>&#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="function"><span class="keyword">static</span> DexFile <span class="title">loadDex</span><span class="params">(String sourcePathName, String outputPathName,</span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="keyword">int</span> flags, ClassLoader loader, DexPathList.Element[] elements)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">           * <span class="doctag">TODO:</span> we may want to cache previously-opened DexFile objects.</span></span><br><span class="line"><span class="comment">           * The cache would be synchronized with close().  This would help</span></span><br><span class="line"><span class="comment">           * us avoid mapping the same DEX more than once when an app</span></span><br><span class="line"><span class="comment">           * decided to open it multiple times.  In practice this may not</span></span><br><span class="line"><span class="comment">           * be a real issue.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> DexFile(sourcePathName, outputPathName, flags, loader, elements);</span><br><span class="line">      &#125;</span><br><span class="line">	</span><br><span class="line">      DexFile(String fileName, ClassLoader loader, DexPathList.Element[] elements)</span><br><span class="line">              <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">          mCookie = openDexFile(fileName, <span class="keyword">null</span>, <span class="number">0</span>, loader, elements);</span><br><span class="line">          mInternalCookie = mCookie;</span><br><span class="line">          mFileName = fileName;</span><br><span class="line">          <span class="comment">//System.out.println(&quot;DEX FILE cookie is &quot; + mCookie + &quot; fileName=&quot; + fileName);</span></span><br><span class="line">      &#125;</span><br><span class="line">  		</span><br><span class="line">   		<span class="comment">// </span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">openDexFile</span><span class="params">(String sourceName, String outputName, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">            ClassLoader loader, DexPathList.Element[] elements)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// Use absolute paths to enable the use of relative paths when testing on host.</span></span><br><span class="line">        <span class="keyword">return</span> openDexFileNative(<span class="keyword">new</span> File(sourceName).getAbsolutePath(),</span><br><span class="line">                                 (outputName == <span class="keyword">null</span>)</span><br><span class="line">                                     ? <span class="keyword">null</span></span><br><span class="line">                                     : <span class="keyword">new</span> File(outputName).getAbsolutePath(),</span><br><span class="line">                                 flags,</span><br><span class="line">                                 loader,</span><br><span class="line">                                 elements);</span><br><span class="line">    &#125;</span><br><span class="line">  		</span><br><span class="line">  	<span class="comment">// native 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Object <span class="title">openDexFileNative</span><span class="params">(String sourceName, String outputName, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">            ClassLoader loader, DexPathList.Element[] elements)</span></span>;</span><br><span class="line">  	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>DexFile#loadDex</code>都会调用 <code>DexFile</code> 构造函数，最后都会通过 <code>openDexFileNative</code> 进行处理。</p>
<h1 id="三、Class文件加载"><a href="#三、Class文件加载" class="headerlink" title="三、Class文件加载"></a>三、Class文件加载</h1><h2 id="DexPathList-findClass-1"><a href="#DexPathList-findClass-1" class="headerlink" title="DexPathList#findClass"></a><code>DexPathList#findClass</code></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.加载Class</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; findClass(String name, List&lt;Throwable&gt; suppressed) &#123;</span><br><span class="line">    <span class="comment">// 遍历Element数组</span></span><br><span class="line">    <span class="keyword">for</span> (Element element : dexElements) &#123;</span><br><span class="line">        <span class="comment">// Element.findClass</span></span><br><span class="line">        Class&lt;?&gt; clazz = element.findClass(name, definingContext, suppressed);</span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dexElementsSuppressedExceptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">        suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DexPathList-Element-findClass"><a href="#DexPathList-Element-findClass" class="headerlink" title="DexPathList#Element#findClass"></a><code>DexPathList#Element#findClass</code></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; findClass(String name, ClassLoader definingContext,</span><br><span class="line">          List&lt;Throwable&gt; suppressed) &#123;</span><br><span class="line">      <span class="keyword">return</span> dexFile != <span class="keyword">null</span> ? dexFile.loadClassBinaryName(name, definingContext, suppressed)</span><br><span class="line">              : <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="DexFile-loadClassBinaryName"><a href="#DexFile-loadClassBinaryName" class="headerlink" title="DexFile#loadClassBinaryName"></a><code>DexFile#loadClassBinaryName</code></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   注意这个注释</span></span><br><span class="line"><span class="comment"> * If you are not calling this from a class loader, this is most likely not</span></span><br><span class="line"><span class="comment"> * going to do what you want. Use &#123;<span class="doctag">@link</span> Class#forName(String)&#125; instead.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">loadClass</span><span class="params">(String name, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">    String slashName = name.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> loadClassBinaryName(slashName, loader, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">loadClassBinaryName</span><span class="params">(String name, ClassLoader loader, List&lt;Throwable&gt; suppressed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> defineClass(name, loader, mCookie, <span class="keyword">this</span>, suppressed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Class <span class="title">defineClass</span><span class="params">(String name, ClassLoader loader, Object cookie,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 DexFile dexFile, List&lt;Throwable&gt; suppressed)</span> </span>&#123;</span><br><span class="line">    Class result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = defineClassNative(name, loader, cookie, dexFile);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoClassDefFoundError e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (suppressed != <span class="keyword">null</span>) &#123;</span><br><span class="line">            suppressed.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (suppressed != <span class="keyword">null</span>) &#123;</span><br><span class="line">            suppressed.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Class <span class="title">defineClassNative</span><span class="params">(String name, ClassLoader loader, Object cookie,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  DexFile dexFile)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ClassNotFoundException, NoClassDefFoundError</span>;</span><br></pre></td></tr></table></figure>

<p>class 文件的加载过程就是遍历 Element 数组，加载对应的Class，这也是插件化技术的核心，替换修改 Elements。</p>
<blockquote>
<p>既然<code>DexFile</code>完成的是最终<code>classLoader</code>需要完成的<code>loadClass</code>的操作，为啥不直接用dexFile呢？</p>
<p>re ：If you are not calling this from a class loader, this is most likely not going to do what you want. Use {@link Class#forName(String)} instead。</p>
</blockquote>
<p>这里明确说了，如果你的DexFile的loadClass操作不是在classLoader里做的，那你很大可能得不到你想要的结果。。。。</p>
<p>所以以后要记住了，<strong>DexFile相关的操作一定要在ClassLoader里完成</strong></p>
<h1 id="四、Q-amp-A"><a href="#四、Q-amp-A" class="headerlink" title="四、Q&amp;A"></a>四、Q&amp;A</h1><h2 id="4-1、loadClass-findClass-defineClass区别"><a href="#4-1、loadClass-findClass-defineClass区别" class="headerlink" title="4.1、loadClass/findClass/defineClass区别"></a>4.1、loadClass/findClass/defineClass区别</h2><p><code>loadClass</code>实现了双亲委派规则，<code>findClass</code>用于写类加载逻辑，<code>defineClass</code>可以从byte[]还原出一个Class对象。</p>
<p>1、如果不想打破双亲委派模型，那么只需要重写findClass方法即可</p>
<p>2、如果想打破双亲委派模型，那么就重写整个loadClass方法</p>
<h2 id="4-2、DexClassLoader-vs-PathClassLoader"><a href="#4-2、DexClassLoader-vs-PathClassLoader" class="headerlink" title="4.2、DexClassLoader vs PathClassLoader"></a>4.2、DexClassLoader vs PathClassLoader</h2><p><a href="https://stackoverflow.com/questions/37296192/what-are-differences-between-dexclassloader-and-pathclassloader">What are differences between DexClassLoader and PathClassLoader?</a></p>
<p>PathClassLoader 和 DexClassLoader <strong>都能加载外部的 dex／apk</strong>，只不过区别是 DexClassLoader 可以<strong>指定 optimizedDirectory</strong>，也就是 dex2oat 的产物 .odex 存放的位置，而 PathClassLoader 只能使用系统默认位置。但是这个 optimizedDirectory 在 Android 8.0 以后也被舍弃了，只能使用系统默认的位置了。</p>
<blockquote>
<p>For Android 8.1 (API 27) and up, <a href="http://androidxref.com/8.1.0_r33/xref/libcore/dalvik/src/main/java/dalvik/system/DexClassLoader.java">DexClassLoader</a> and <a href="http://androidxref.com/8.1.0_r33/xref/libcore/dalvik/src/main/java/dalvik/system/PathClassLoader.java">PathClassLoader</a> are essentially identical. They both <code>extend</code> <code>BaseDexClassLoader</code>, and immediately call <code>super()</code> when constructed. There are no implementation differences or side effects (at least in the AOSP versions I’ve referenced here).</p>
<p>In prior versions (8.0 and earlier) <code>DexClassLoader</code> accepted an argument for <code>String optimizedDirectory</code>, which allowed the caller to specify the directory to store optimized Dex code (ODEX files), for the Dex that was loaded by the class loader. This argument still exists in newer versions of Android, but it <a href="http://androidxref.com/8.1.0_r33/xref/libcore/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java#56">has no effect</a>.</p>
</blockquote>
]]></content>
      <categories>
        <category>Android</category>
        <category>插件化</category>
      </categories>
  </entry>
  <entry>
    <title>Android O 版本安装包大小获取失败分析及解决</title>
    <url>/2021/02/24/Notes/Android/other/Android%20O%20%E7%89%88%E6%9C%AC%E5%AE%89%E8%A3%85%E5%8C%85%E5%A4%A7%E5%B0%8F%E8%8E%B7%E5%8F%96%E5%A4%B1%E8%B4%A5%E5%88%86%E6%9E%90%E5%8F%8A%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<h1 id="Android-O-版本安装包大小获取失败分析及解决"><a href="#Android-O-版本安装包大小获取失败分析及解决" class="headerlink" title="Android O 版本安装包大小获取失败分析及解决"></a>Android O 版本安装包大小获取失败分析及解决</h1><span id="more"></span>

<h1 id="一、背景："><a href="#一、背景：" class="headerlink" title="一、背景："></a>一、背景：</h1><p>Android O版本上获取安装包大小报错：<br><img src="https://leanote.com/api/file/getImage?fileId=59ca517eab64417152002e2c" alt="pic0"></p>
<h1 id="二、调用过程分析："><a href="#二、调用过程分析：" class="headerlink" title="二、调用过程分析："></a>二、调用过程分析：</h1><p>(1)8.0 以下读取安装包大小通常会反射调用PackageManage.getPackageSizeInfo<br>参考<a href="http://blog.csdn.net/qinjuning/article/details/6892054">http://blog.csdn.net/qinjuning/article/details/6892054</a><br><img src="https://leanote.com/api/file/getImage?fileId=59ca4f72ab64417152002df4" alt="pic1"><br>(2)PackageManager 调用到getPackageSizeInfo -&gt; getPackageSizeInfoAsUser</p>
<p>(3)PackageManager是个抽象类，具体的实现是在ApplicationPackageManager.getPackageSizeInfoAsUser中<br>对应8.0的代码<br> <img src="https://leanote.com/api/file/getImage?fileId=59ca51a7ab64417152002e2e" alt="pic2"><br>可以看到逻辑上判断如果apk 的targetsdkversion&gt;= 8.0版本才会有这个错误，逻辑上26以下是不会走到这个case里的，这是目前待check的问题。</p>
<h1 id="三、解决方案："><a href="#三、解决方案：" class="headerlink" title="三、解决方案："></a>三、解决方案：</h1><p>所以这问题其实是由于Android8.0 新特性导致的问题，目前有2种：<br>1．    框架修改getPackageSizeInfoAsUser逻辑，不推荐<br>2．    使用StorageStatsManager，在8.0的PackageManager.getPackageSizeInfo方法中：<br><img src="https://leanote.com/api/file/getImage?fileId=59ca4f72ab64417152002df8" alt="pic3"><br> Google 推荐我们使用的是这个类StorageStatsManager，这个接口在8.0新加的，8.0以下是不存在的，需要对8.0和8.0 以下做兼容。<br>frameworks\base\core\java\android\app\usage\StorageStats.java<br>frameworks\base\core\java\android\content\pm\PackageStats.java<br>StorageStats应用数据分成了3种：1.apk大小 2.用户数据 3用户缓存数据，用户数据包含缓存数据。3种数据的路径如下：<br>codeBytes = appBytes data/app/pkgname/<br>dataBytes = data/data/pkgname/  +  sdcard/Android/data/pkgname/<br>cacheBytes = data/data/pkgname/cache/ + sdcard/Android/data/pkgname/cache/<br>相比于8.0 之前的PackageStats，将数据做了简化和整合。Android应该是将内部存储和sd分成2个StorageVolume ，根据对不同的uuid获取相关的数据。（个人理解是这样）。<br>示例代码：<br><img src="https://leanote.com/api/file/getImage?fileId=59ca4f72ab64417152002df7" alt="pic4"><br>注意：</p>
<ol>
<li>   androidstudio编译时，api的编译版本必须是26<br><img src="https://leanote.com/api/file/getImage?fileId=59ca52b9ab64417152002e55" alt="pic5">     </li>
<li>   app必须是系统app，且要声明权限<br><img src="https://leanote.com/api/file/getImage?fileId=59ca52f1ab6441737b002f42" alt="pic6"></li>
</ol>
<p>参考：<br><a href="https://stackoverflow.com/questions/43472398/how-to-use-storagestatsmanager-querystatsforpackage-on-android-o">https://stackoverflow.com/questions/43472398/how-to-use-storagestatsmanager-querystatsforpackage-on-android-o</a></p>
<p>附：7.0 , 8.0 getPackageSizeInfo逻辑对比：<br>Android 7.0<br>frameworks\base\core\java\android\content\pm\PackageManager.java<br> <img src="https://leanote.com/api/file/getImage?fileId=59ca4f72ab64417152002dfa" alt="pic6"><br> <img src="https://leanote.com/api/file/getImage?fileId=59ca4f72ab64417152002df2" alt="pic7"><br>frameworks/base/core/java/android/app/ApplicationPackageManager.java</p>
<p>Android 8.0<br>frameworks\base\core\java\android\content\pm\PackageManager.java<br> <img src="https://leanote.com/api/file/getImage?fileId=59ca4f72ab64417152002df3" alt="pic8"><br>frameworks/base/core/java/android/app/ApplicationPackageManager.java<br> <img src="https://leanote.com/api/file/getImage?fileId=59ca4f72ab64417152002df9" alt="pic9"></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>问题</category>
      </categories>
  </entry>
  <entry>
    <title>JVM_01_JVM</title>
    <url>/2021/04/09/Notes/Java/01JVM/JVM_01_JVM%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="JVM-01-JVM简介"><a href="#JVM-01-JVM简介" class="headerlink" title="JVM_01_JVM简介"></a>JVM_01_JVM简介</h1><span id="more"></span>

<h2 id="JVM-是什么"><a href="#JVM-是什么" class="headerlink" title="JVM 是什么"></a>JVM 是什么</h2><p><code>JVM</code> 是 <code>Java Virtual Machine</code>（<strong>Java虚拟机</strong>)的缩写，<code>JVM</code>是一种用于计算设备的<strong>规范</strong>，它是一个<strong>虚构</strong>的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。</p>
<p>Java 虚拟机是二进制字节码的运行环境，负责装载<strong>字节码</strong>到其内部，解释/编译为对应平台的机器指令执行。每一条 Java 指令，Java 虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>一次编译，到处运次（跨平台）</li>
<li>自动内存管理</li>
<li>自动垃圾回收功能</li>
</ul>
<h3 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h3><p>我们平时所说的 java 字节码，指的是用 java 语言编写的字节码，准确的说任何能在 jvm 平台上执行的字节码格式都是一样的，所以应该统称为 <strong>jvm字节码</strong>。</p>
<p>不同的编译器可以编译出相同的字节码文件，字节码文件也可以在不同的 jvm 上运行。</p>
<p>JVM 与 Java 语言没有必然的联系，它只与特定的二进制文件格式——Class 文件格式关联，Class 文件中包含了 Java 虚拟机指令集（或者称为字节码、Bytecodes）和符号集，还有一些其他辅助信息。</p>
<img src="/pics/image-20210411170035870.png" alt="image-20210411170035870" style="zoom:20%;" />

<h2 id="JVM-的位置"><a href="#JVM-的位置" class="headerlink" title="JVM 的位置"></a>JVM 的位置</h2><p>JVM 是运行在操作系统之上的，它与硬件没有直接的交互。</p>
<p><code>JDK</code>(Java Development Kit) 是 <code>Java</code> 语言的软件开发工具包（<code>SDK</code>）。<code>JDK</code> 物理存在，是 <code>Java Language</code>、<code>Tools</code>、<code>JRE</code> 和 <code>JVM</code> 的一个集合。</p>
<img src="/pics/image-20210411170149148.png" alt="image-20210411170149148" style="zoom:30%;" />

<h2 id="JVM-整体结构"><a href="#JVM-整体结构" class="headerlink" title="JVM 整体结构"></a>JVM 整体结构</h2><img src="/pics/image-20210409200106588.png" alt="image-20210409200106588" style="zoom:75%;" />

<h2 id="JVM-生命周期"><a href="#JVM-生命周期" class="headerlink" title="JVM 生命周期"></a>JVM 生命周期</h2><h4 id="虚拟机的启动"><a href="#虚拟机的启动" class="headerlink" title="虚拟机的启动"></a>虚拟机的启动</h4><p>Java 虚拟机的启动是通过引导类加载器（Bootstrap Class Loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</p>
<h4 id="虚拟机的执行"><a href="#虚拟机的执行" class="headerlink" title="虚拟机的执行"></a>虚拟机的执行</h4><ul>
<li>一个运行中的 Java 虚拟机有着一个清晰的任务：执行 Java 程序</li>
<li>程序开始执行时它才运行，程序结束时它就停止</li>
<li>执行一个所谓的 Java 程序的时候，真正执行的是一个叫做 Java 虚拟机的进程</li>
<li>你在同一台机器上运行三个程序，就会有三个运行中的 Java 虚拟机。 Java 虚拟机总是开始于一个**main()**方法，这个方法必须是公有、返回 void、只接受一个字符串数组。在程序执行时，你必须给 Java 虚拟机指明这个包含 main() 方法的类名。</li>
</ul>
<h4 id="虚拟机的退出"><a href="#虚拟机的退出" class="headerlink" title="虚拟机的退出"></a>虚拟机的退出</h4><p>有以下几种情况：</p>
<ul>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而异常终止</li>
<li>由于操作系统出现错误而导致 Java 虚拟机进程终止</li>
<li>某线程调用 Runtime 类或 System 类的 exit 方法，或 Runtime 类的 halt 方法，并且 Java 安全管理器也允许这次 exit 或 halt 操作</li>
<li>除此之外，JNI(Java Native Interface)规范描述了用<code>JNI Invocation API</code>来加载或卸载 Java 虚拟机时，Java 虚拟机的退出情况</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.starfish.ink/java/JVM/JVM-Java.html#%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8Ejava%E8%99%9A%E6%8B%9F%E6%9C%BA">http://www.starfish.ink/java/JVM/JVM-Java.html#%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8Ejava%E8%99%9A%E6%8B%9F%E6%9C%BA</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>JVM_02_类加载机制</title>
    <url>/2021/04/14/Notes/Java/01JVM/JVM_02%20%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="JVM-02-类加载机制"><a href="#JVM-02-类加载机制" class="headerlink" title="JVM_02_类加载机制"></a>JVM_02_类加载机制</h1><span id="more"></span>

<h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><p><strong>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</strong></p>
<p>Class 文件由类装载器装加载后，在 JVM 中将形成一份描述 Class 结构的元信息对象，通过该元信息对象可以获知 Class 的结构信息：如构造函数，属性和方法等，Java 允许用户借由这个 Class 相关的元信息对象间接调用 Class 对象的功能，这里就是我们经常能见到的 Class 类。</p>
<img src="/pics/image-20210411165909852.png" alt="image-20210411165909852" style="zoom:30%" />

<h2 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h2><ul>
<li>类加载子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识（0xCAFEBABE）</li>
<li>ClassLoader 只负责 class 文件的加载。至于它是否可以运行，则由 Execution Engine 决定</li>
<li>加载的类信息存放于一块称为**<code>方法区</code>**的内存空间。除了类的信息外，方法区中还存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</li>
<li>Class 对象是存放在堆区的</li>
</ul>
<img src="/pics/image-20210409215629775.png" alt="image-20210409215629775" style="zoom:67%;" />



<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><img src="/pics/image-20210409215512294.png" alt="image-20210409215629775" style="zoom:80%;" />

<h3 id="加载（Loading）"><a href="#加载（Loading）" class="headerlink" title="加载（Loading）"></a>加载（Loading）</h3><ul>
<li>通过一个类的全限定名获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>
</ul>
<h3 id="链接（Linking）"><a href="#链接（Linking）" class="headerlink" title="链接（Linking）"></a>链接（Linking）</h3><h4 id="验证（Verify）"><a href="#验证（Verify）" class="headerlink" title="验证（Verify）"></a>验证（Verify）</h4><p>确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。</p>
<p>主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</p>
<h4 id="准备（Prepare）"><a href="#准备（Prepare）" class="headerlink" title="准备（Prepare）"></a>准备（Prepare）</h4><ul>
<li><p>为类变量(静态变量，static修饰的变量)分配内存并且设置该类变量的默认初始值，即<strong>零值</strong></p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>零值</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
</tr>
<tr>
<td>short</td>
<td>(short)0</td>
</tr>
<tr>
<td>char</td>
<td>‘\u0000’</td>
</tr>
<tr>
<td>byte</td>
<td>(byte)0</td>
</tr>
<tr>
<td>boolean</td>
<td>false</td>
</tr>
<tr>
<td>float</td>
<td>0.0f</td>
</tr>
<tr>
<td>double</td>
<td>0.0d</td>
</tr>
<tr>
<td>reference</td>
<td>null</td>
</tr>
</tbody></table>
</li>
<li><p>这里不包含用 final 修饰的 static，因为 final 在<code>编译</code>的时候就会分配了，准备阶段会显式初始化</p>
</li>
<li><p>这里<strong>不会为实例变量分配初始化</strong>，类变量会分配在<strong>方法区</strong>中，而实例变量是会随着对象一起分配到 Java 堆中</p>
</li>
</ul>
<blockquote>
<p>byte 是字节数据类型 ，是有符号型的，占1 个字节；大小范围为-128—127 。</p>
<p>char 是字符数据类型 ，是无符号型的，占2字节(Unicode码 ）；大小范围 是0—65535 ；</p>
<p>char是一个16位二进制的Unicode字符，JAVA用char来表示一个字符 。</p>
<p>char类型：</p>
<p>char：2个字节。</p>
<p>整型：</p>
<p>byte:1个字节 8位 -128~127，1byte = 8bit</p>
<p>short ：2个字节 16位</p>
<p>int ：4个字节 32位</p>
<p>long：8个字节 64位</p>
<p>浮点型：</p>
<p>float：4个字节 32 位</p>
<p>double ：8个字节 64位</p>
<p>注：默认的是double类型，如3.14是double类型的，加后缀F（3.14F）则为float类型的。</p>
</blockquote>
<h4 id="解析（Resolve）"><a href="#解析（Resolve）" class="headerlink" title="解析（Resolve）"></a>解析（Resolve）</h4><ul>
<li><p><strong>将常量池内的<code>符号引用</code>转换为<code>直接引用</code>的过程</strong></p>
<p>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《Java虚拟机规范》的 Class文件格式中。</p>
<p>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</p>
</li>
<li><p>事实上，解析操作往往会伴随着 JVM 在执行完初始化之后再执行</p>
<p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的<code>CONSTANT_Class_info</code>、<code>CONSTANT_Fieldref_info</code>、<code>CONSTANT_Methodref_info</code>等，可用通过javap -v 命令查看class 文件的符合应用。</p>
<img src="/pics/image-20210414125116226.png" alt="image-20210414125116226" style="zoom:70%;" /></li>
</ul>
<h3 id="初始化（Initialization）"><a href="#初始化（Initialization）" class="headerlink" title="初始化（Initialization）"></a>初始化（Initialization）</h3><ul>
<li> 初始化阶段就是执行类构造器方法 <clinit>() 的过程</li>
<li>此方法不需要定义，是 javac 编译器自动收集类中的所有**<code>类变量的赋值动作和静态代码块</code>**中的语句合并而来构造器方法中指令按语句在源文件中出现的顺序执行</li>
<li><clinit>() 不同于类的构造器（构造器是虚拟机视角下的 <init>()）</li>
<li>若该类具有父类，JVM 会保证子类的 <clinit>() 执行前，父类的 <clinit>() 已经执行完毕</li>
<li>虚拟机必须保证一个类的 <clinit>() 方法在多线程下被同步加锁</li>
</ul>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><h2 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h2><p>JVM 支持两种类型的类加载器，分别为<strong>启动（引导）类加载器</strong>（Bootstrap ClassLoader）和<strong>自定义类加载器</strong>（User-Defined ClassLoader。</p>
<ul>
<li>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是 Java 虚拟机规范却没有这么定义，而是<code>将所有派生于抽象类 ClassLoader 的类加载器都划分为自定义类加载器</code>。</li>
</ul>
<ul>
<li>从功能角度，类加载器又可以分为4类，它们的<code>等级关系</code> 如下所示：</li>
</ul>
<img src="/pics/image-20210411153335541.png" alt="image-20210411153335541" style="zoom:50%;" />

<p>注意：这里系统类SytemClassLoader加载器在jvm中的实现是AppClassLoader，也叫应用程序类加载器，是一个东西。</p>
<h2 id="JVM-自带的类加载器"><a href="#JVM-自带的类加载器" class="headerlink" title="JVM 自带的类加载器"></a>JVM 自带的类加载器</h2><p>jvm虚拟机中自带的加载器有启动类加载器，扩展类加载器，应用程序类加载器。</p>
<h3 id="启动类加载器（引导类加载器，Bootstrap-ClassLoader）"><a href="#启动类加载器（引导类加载器，Bootstrap-ClassLoader）" class="headerlink" title="启动类加载器（引导类加载器，Bootstrap ClassLoader）"></a>启动类加载器（引导类加载器，Bootstrap ClassLoader）</h3><ul>
<li>这个类加载使用 C/C++ 语言实现，嵌套在 JVM 内部</li>
<li>它用来加载 Java 的核心库（<code>JAVA_HOME/jre/lib/rt.jar</code>、<code>resource.jar</code>或<code>sun.boot.class.path</code>路径下的内容），用于提供 JVM 自身需要的类</li>
<li>并不继承自 <code>java.lang.ClassLoader</code>，没有父加载器</li>
<li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器</li>
<li>出于安全考虑，Bootstrap 启动类加载器只加载名为 java、javax、sun 等开头的类</li>
</ul>
<h3 id="扩展类加载器（Extension-ClassLoader）"><a href="#扩展类加载器（Extension-ClassLoader）" class="headerlink" title="扩展类加载器（Extension ClassLoader）"></a>扩展类加载器（Extension ClassLoader）</h3><ul>
<li>Java 语言编写，由 <code>sun.misc.Launcher$ExtClassLoader</code> 实现</li>
<li>派生于 ClassLoader</li>
<li>父类加载器为启动类加载器</li>
<li>从 <code>java.ext.dirs</code> 系统属性所指定的目录中加载类库，或从 JDK 的安装目录的 <code>jre/lib/ext</code> 子目录（扩展目录）下加载类库。如果用户创建的 JAR 放在此目录下，也会自动由扩展类加载器加载</li>
</ul>
<h3 id="应用程序类加载器（也叫系统类加载器，AppClassLoader）"><a href="#应用程序类加载器（也叫系统类加载器，AppClassLoader）" class="headerlink" title="应用程序类加载器（也叫系统类加载器，AppClassLoader）"></a>应用程序类加载器（也叫系统类加载器，AppClassLoader）</h3><ul>
<li>Java 语言编写，由 <code>sun.misc.Lanucher$AppClassLoader</code> 实现</li>
<li>派生于 ClassLoader</li>
<li>父类加载器为扩展类加载器</li>
<li>它负责加载环境变量 <code>classpath</code> 或系统属性 <code>java.class.path</code> 指定路径下的类库</li>
<li>该类加载是<strong>程序中默认的类加载器</strong>，一般来说，Java 应用的类都是由它来完成加载的</li>
<li>通过 <code>ClassLoader#getSystemClassLoader()</code> 方法可以获取到该类加载器</li>
</ul>
<h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><p>在 Java 的日常应用程序开发中，类的加载几乎由以上3 种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。</p>
<h3 id="为什么要自定义类加载器？"><a href="#为什么要自定义类加载器？" class="headerlink" title="为什么要自定义类加载器？"></a>为什么要自定义类加载器？</h3><ul>
<li>隔离加载类</li>
<li>修改类加载的方式</li>
<li>拓展加载源</li>
<li>防止源码泄漏</li>
</ul>
<h3 id="用户自定义加载器实现步骤"><a href="#用户自定义加载器实现步骤" class="headerlink" title="用户自定义加载器实现步骤"></a>用户自定义加载器实现步骤</h3><ol>
<li>开发人员可以通过继承抽象类 <code>java.lang.ClassLoader</code> 类的方式，实现自己的类加载器，以满足一些特殊的需求</li>
<li>在 JDK1.2 之前，在自定义类加载器时，总会去继承 ClassLoader 类并重写 loadClass() 方法，从而实现自定义的类加载类，但是 JDK1.2 之后已经不建议用户去覆盖 <code>loadClass()</code> 方式，而是建议把自定义的类加载逻辑写在 <code>findClass()</code> 方法中</li>
<li>编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承 URLClassLoader 类，这样就可以避免自己去编写 findClass() 方法及其获取字节码流的方式，使自定义类加载器编写更加简洁</li>
</ol>
<h1 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h1><p>ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><p>系统类加载器和扩展类加载器都继承自ClassLoader，继承关系如下图</p>
<img src="/pics/image-20210411152641950.png" alt="image-20210411152641950" style="zoom:25%;" />

<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p>ClassLoader类的常用方法如下：</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>getParent（）</td>
<td>返回该类加载器的超类加载器</td>
</tr>
<tr>
<td>loadClass（String name）</td>
<td>加载名称为name的类，返回结果为java.lang.Class类的实例</td>
</tr>
<tr>
<td>findClass（String name）</td>
<td>查找名称为name的类，返回结果为java.lang.Class类的实例</td>
</tr>
<tr>
<td>findLoadedClass（String name）</td>
<td>查找名称为name的已经被加载过的类，返回结果为java.lang.Class类的实例</td>
</tr>
<tr>
<td>defineClass（String name，byte[] b,int off,int len）</td>
<td>把字节数组b中的内容转换为一个Java类 ，返回结果为java.lang.Class类的实例</td>
</tr>
<tr>
<td>resolveClass（Class&lt;?&gt; c）</td>
<td>连接指定的一个java类</td>
</tr>
</tbody></table>
<h2 id="获取ClassLoader"><a href="#获取ClassLoader" class="headerlink" title="获取ClassLoader"></a>获取ClassLoader</h2><p>Java层获取ClassLoader的方式有4种</p>
<img src="/pics/image-20210411155040511.png" alt="image-20210411155040511" style="zoom:50%;" />



<h1 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h1><p>Java虚拟机对class文件采用的是<code>按需加载</code>的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成的class对象。而且加载某个类的class文件时，java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。</p>
<h2 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h2><ul>
<li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li>
<li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li>
<li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li>
</ul>
<img src="/pics/image-20210411155736044.png" alt="image-20210411155736044" style="zoom:50%;" />

<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul>
<li><p><strong>避免类的重复加载</strong></p>
<p>JVM 中区分不同类，不仅仅是根据类名，相同的 class 文件被不同的 ClassLoader 加载就属于两个不同的类（比如，Java中的Object类，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，如果不采用双亲委派模型，由各个类加载器自己去加载的话，系统中会存在多种不同的 Object 类（后面会解释）。</p>
</li>
<li><p><strong>保护程序安全，防止核心 API 被随意篡改</strong></p>
<p>避免用户自己编写的类动态替换 Java 的一些核心类，比如我们自定义类：<code>java.lang.String</code></p>
</li>
</ul>
<h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h2><p>Java安全模型的核心就是Java沙箱（sandbox），什么是沙箱？沙箱是一个<code>限制程序运行的环境</code>。沙箱机制就是将 Java 代码限定在虚拟机(JVM)特定的运行范围中，并且严格限制代码对本地系统资源访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏。沙箱主要限制系统资源访问，那系统资源包括什么？——CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。</p>
<p>举例：</p>
<img src="/pics/image-20210411164041615.png" alt="image-20210411164041615" style="zoom:50%;" />

<p>我们自己定义一个java.lang包，在其下面定义一个String类，里面声明了静态代码块。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;我是自定义的String类的静态代码块&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在一个测试类中加载String类，看看加载的String类是JDK自带的，还是我们自己编写的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="keyword">new</span> java.lang.String();</span><br><span class="line">        System.out.println(<span class="string">&quot;hello，world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">你好，世界</span><br></pre></td></tr></table></figure>

<p>结果：程序并没有输出我们静态代码块中的内容，可见仍然加载的是 JDK 自带的 String 类</p>
<p>如果我们自己定义的 String 类中加个 main( ) 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是自定义的String类的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,String&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line">错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">否则 JavaFX 应用程序类必须扩展javafx.application.Application</span></span><br></pre></td></tr></table></figure>

<p>在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java.lang.String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</p>
<p><a href="https://www.cnblogs.com/MyStringIsNotNull/p/8268351.html">https://www.cnblogs.com/MyStringIsNotNull/p/8268351.html</a></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h3 id="如何判断两个class对象是否相同？"><a href="#如何判断两个class对象是否相同？" class="headerlink" title="如何判断两个class对象是否相同？"></a>如何判断两个class对象是否相同？</h3><p>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p>
<ul>
<li><p>类的完整类名必须一致，包括包名</p>
</li>
<li><p>加载这个类的 ClassLoader（指ClassLoader实例对象）必须相同</p>
<p>换句话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的 ClassLoader 实例对象不同，那么这两个类对象也是不相等的</p>
</li>
</ul>
<h3 id="对类加载器的引用"><a href="#对类加载器的引用" class="headerlink" title="对类加载器的引用"></a>对类加载器的引用</h3><ul>
<li>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的</li>
<li>如果一个类型是由用户类加载器加载的，那么<code>JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</code></li>
<li>当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的</li>
</ul>
<h3 id="类的主动使用和被动使用"><a href="#类的主动使用和被动使用" class="headerlink" title="类的主动使用和被动使用"></a>类的主动使用和被动使用</h3><p>Java程序对类的使用方式分为：主动使用 和 被动使用。</p>
<p>主动使用，又分为七种情况：</p>
<ol>
<li>创建类的实例</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射（ 比如：Class.forName(“cn.sxt.Test”) )</li>
<li>初始化一个类的子类</li>
<li>Java虚拟机启动时被标明为启动类的类</li>
<li>JDK7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化</li>
</ol>
<p>除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化，即不会执行初始化阶段（不会调用 clinit( ) 方法和 init( ) 方法）</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/sj15814963053/article/details/109851454">https://blog.csdn.net/sj15814963053/article/details/109851454</a></p>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p><a href="https://github.com/ingokegel/jclasslib/releases">https://github.com/ingokegel/jclasslib/releases</a></p>
<p>反编译命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javap -v xxx.class</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JAVA</category>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>JVM_03_运行时数据区和线程</title>
    <url>/2021/04/11/Notes/Java/01JVM/JVM_03_%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</url>
    <content><![CDATA[<h1 id="JVM-03-运行时数据区和线程"><a href="#JVM-03-运行时数据区和线程" class="headerlink" title="JVM_03_运行时数据区和线程"></a>JVM_03_运行时数据区和线程</h1><span id="more"></span>

<p>本节主要讲的是<code>运行时数据区</code>，也就是下图这部分，它是在类加载完成后的阶段</p>
<img src="/pics/image-20210411175545037.png" alt="image-20210411175545037" style="zoom:33%;" />

<p>当我们通过前面的：类的加载 –&gt; 验证 –&gt; 准备 –&gt; 解析 –&gt; 初始化，这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们的运行时数据区。</p>
<p>JVM 中运行时数据的结构如下：</p>
<img src="/pics/image-20210411171930165.png" alt="image-20210411171930165" style="zoom:70%;" />



<h2 id="运行时数据区与线程"><a href="#运行时数据区与线程" class="headerlink" title="运行时数据区与线程"></a>运行时数据区与线程</h2><p>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。</p>
<p>不同的JVM对于内存的划分方式和管理机制存在着部分差异。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。</p>
<p>我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁。下图是JDK8运行时数据区划分</p>
<img src="/pics/image-20210411174039107.png" alt="image-20210411174039107" style="zoom:33%;" />



<p>说明：方法区在JVM规范中是一个逻辑概念，由虚拟机自己进行具体实现，<code>jdk7和以前的版本使用的是堆上的永久代实现的方法区，而在jdk8及以后使用的是元数据区实现方法区。</code></p>
<h2 id="线程的内存空间"><a href="#线程的内存空间" class="headerlink" title="线程的内存空间"></a>线程的内存空间</h2><p>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机的退出而销毁。<code>另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</code></p>
<img src="/pics/image-20210411174801884.png" alt="image-20210411174801884" style="zoom:50%;" />

<p>灰色的为<code>单独线程私有的</code>，红色的为<code>多个线程共享的</code>。即：</p>
<ul>
<li>线程独有：独立包括<code>程序计数器</code>、<code>栈</code>、<code>本地方法栈</code></li>
<li>线程间共享：<code>堆</code>、<code>堆外内存（永久代或元空间、代码缓存）</code></li>
</ul>
<img src="/pics/image-20210411180542906.png" alt="image-20210411180542906" style="zoom:33%;" />

<p><code>每个JVM只有一个Runtime实例</code>。即为运行时环境，相当于内存结构的中间的那个框框：运行时环境。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="JVM线程"><a href="#JVM线程" class="headerlink" title="JVM线程"></a>JVM线程</h3><ul>
<li>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行<ul>
<li>在Hotspot JVM里，每个线程都与<code>操作系统的本地线程直接映射</code></li>
<li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收</li>
</ul>
</li>
<li>操作系统负责将线程安排调度到任何一个可用的CPU上。<ul>
<li>一旦本地线程初始化成功，它就会调用Java线程中的run( )方法。</li>
<li>Java中的线程有2种类型一种是守护线程，另一种是普通线程；当进程中只有守护线程时，那么进程将停止。<a href="https://blog.51cto.com/u_14820287/2507947">Java中守护线程和本地线程区别</a></li>
</ul>
</li>
</ul>
<h3 id="JVM系统线程"><a href="#JVM系统线程" class="headerlink" title="JVM系统线程"></a>JVM系统线程</h3><ul>
<li>如果你使用 jconsole 或者是任何一个调试工具，都能看到在后台有许多线程在运行。<br>这些后台线程不包括调用public static void main(String [ ])的main线程以及所有由这个main方法自己创建的线程。</li>
<li>这些主要的后台系统线程在Hotspot JVM里主要是以下几个：<ul>
<li><strong>虚拟机线程：</strong>这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销</li>
<li>周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行</li>
<li><strong>GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持（重点）</strong></li>
<li>编译线程：这种线程在运行时会将字节码编译成 本地代码</li>
<li>信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>JAVA</category>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>JVM_04_PC寄存器</title>
    <url>/2021/04/17/Notes/Java/01JVM/JVM_04_PC%E5%AF%84%E5%AD%98%E5%99%A8/</url>
    <content><![CDATA[<h1 id="JVM-04-PC寄存器"><a href="#JVM-04-PC寄存器" class="headerlink" title="JVM_04_PC寄存器"></a>JVM_04_PC寄存器</h1><span id="more"></span>

<p>PC寄存器（<strong>Program Counter Register</strong>）或称为程序计数器，<code>记录正在执行的虚拟机字节码指令地址</code>。Register 的命名源于 CPU 的寄存器，寄存器存储指令相关的线程信息，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器（CPU寄存器，不是我们程PCRegister）才能够运行</p>
<p>这里，并非是广义上所指的物理寄存器，叫程序计数器（或PC计数器或指令计数器）会更加贴切，并且也不容易引起一些不必要的误会。<strong>JVM 中的 PC 寄存器是对物理 PC 寄存器的一种抽象模拟</strong>。</p>
<blockquote>
<p>PC寄存器的作用有2种定义：</p>
<p>第一种解释：记录正在执行的虚拟机字节码指令地址（深入理解Java虚拟机）</p>
<p>第二种解释：用来存储指向下一条指令的地址，也就是即将要执行的指令代码。</p>
<p>这2种解释其实都可以，我们主要理解PC寄存器记录的是虚拟机栈执行的字节码指令就好，至于是下一条还是当前，不必细究。</p>
</blockquote>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域</li>
<li>在 JVM 规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期一致</li>
<li>任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。如果当前线程正在执行的是 Java 方法，程序计数器记录的是 JVM 字节码指令地址，如果是执行 natice 方法，则是未指定值（undefined）</li>
<li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖它来完成</li>
<li>字节码解释器工作 时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令</li>
<li>它是唯一一个在 JVM 规范中没有规定任何 <code>OutOfMemoryError</code> 情况的区域，<code>也不存在GC</code>。</li>
</ul>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><code>PC寄存器用来存储指向下一条指令的地址，也就是即将要执行的指令代码。</code>由执行引擎读取下一条指令，并执行该指令。</p>
<img src="/pics/image-20210411210734629.png" alt="image-20210411210734629" style="zoom:33%;" />

<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PCRegisterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">int</span> k = i + j;</span><br><span class="line">        System.out.println(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用反编译：javap -v PCRegisterTest.class 或通过 IDEA 插件 <code>Jclasslib</code> 查看字节码指令。</p>
<img src="/pics/image-20210411212618773.png" alt="image-20210411212618773" style="zoom:33%;" />

<p><strong>理解下方法执行的过程：</strong></p>
<blockquote>
<ol>
<li>Java代码执行时，代码会首先被编译成字节码命令</li>
<li>某个方法执行时，相应的代码的字节码指令会被压入虚拟机栈</li>
<li>方法执行的线程中的PC寄存器会记录当前字节码执行的偏移地址</li>
<li>执行引擎会读取PC寄存器当前偏移地址的字节码指令，转换成机器指令，再由cpu执行</li>
</ol>
</blockquote>
<p>以上的步骤画图理解下：</p>
<img src="/pics/image-20210411210630941.png" alt="image-20210411210630941" style="zoom:33%;" />



<h2 id="CPU时间片"><a href="#CPU时间片" class="headerlink" title="CPU时间片"></a>CPU时间片</h2><p>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</p>
<ul>
<li>在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</li>
<li>但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</li>
</ul>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ul>
<li><p><code>使用PC寄存器存储字节码指令地址有什么用呢？为什么使用PC寄存器记录当前线程的执行地址呢？</code></p>
<p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p>
</li>
<li><p><code>PC寄存器为什么会被设定为线程私有的？</code></p>
<p>多线程在一个特定的时间段内只会执行其中某一个线程方法，CPU会不停的做任务切换，这样必然会导致经常中断或恢复。为了能够准确的记录各个线程正在执行的当前字节码指令地址，所以为每个线程都分配了一个PC寄存器，每个线程都独立计算，不会互相影响。</p>
</li>
</ul>
<p><a href="https://blog.csdn.net/sj15814963053/article/details/109864077">https://blog.csdn.net/sj15814963053/article/details/109864077</a></p>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>JVM_05_虚拟机栈</title>
    <url>/2021/04/17/Notes/Java/01JVM/JVM_05_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/</url>
    <content><![CDATA[<h1 id="JVM-05-虚拟机栈"><a href="#JVM-05-虚拟机栈" class="headerlink" title="JVM_05_虚拟机栈"></a>JVM_05_虚拟机栈</h1><span id="more"></span>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。</p>
<p>Java虚拟机栈描述的是<strong>方法执行的内存模型</strong>：每个方法执行时都会创建一个<strong>栈帧</strong>，方法从调用到执行完成，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p>
<p>Java虚拟机栈的生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了。栈是线程私有的，对于栈来说不存在垃圾回收 (GC) 问题，但存在栈溢出的情况（StackOverFlowError）</p>
<p>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。</p>
<ul>
<li>JVM直接对Java栈的操作只有两个：<ul>
<li>方法时执行入栈</li>
<li>执行结束后出栈</li>
</ul>
</li>
<li>对于栈来说不存在垃圾回收 (GC) 问题，但是栈存在溢出的情况</li>
</ul>
<p>Java 虚拟机规范允许<code>Java栈的大小是动态的或者是固定不变的</code>。</p>
<ul>
<li>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。<br>如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个<code>StackoverflowError</code> 异常（栈溢出）。</li>
<li>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 <code>OutOfMemoryError</code> 异常。</li>
</ul>
<p>可以通过参数<code>-Xss</code>来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。</p>
<h1 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h1><p>每个线程都有自己的栈，栈中的数据都是以<code>栈帧（Stack Frame）</code>为基本单位存储的。</p>
<p><strong>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</strong></p>
<p>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</p>
<h2 id="栈的运行原理"><a href="#栈的运行原理" class="headerlink" title="栈的运行原理"></a>栈的运行原理</h2><ul>
<li>JVM 直接对 Java 栈的操作只有两个，对栈帧的<strong>压栈</strong>和<strong>出栈</strong>，遵循<code>FILO</code>原则</li>
<li>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为<strong>当前栈帧</strong>（Current Frame），与当前栈帧对应的方法就是<strong>当前方法</strong>（Current Method），定义这个方法的类就是<strong>当前类</strong>（Current Class）</li>
<li>执行引擎运行的字节码指令只针对当前栈帧进行操作，PC寄存器中存储也是当前栈帧的执行地址。</li>
<li><strong>不同线程中所包含的栈帧是不允许存在相互引用的，即线程间私有数据是隔离的</strong>。</li>
<li>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，称为新的当前栈帧</li>
<li>当前方法返回时，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧</li>
<li>Java 方法有两种返回函数的方式，<strong>一种是正常的函数返回，使用 return 指令，另一种是抛出异常，不管用哪种方式，都会导致栈帧被弹出</strong></li>
</ul>
<img src="/pics/image-20210411223806924.png" alt="image-20210411223806924" style="zoom:33%;" />

<h2 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h2><p>每个<strong>栈帧</strong>（Stack Frame）中存储着：</p>
<ul>
<li><code>局部变量表（Local Variables）</code></li>
<li><code>操作数栈（Operand Stack）(或称为表达式栈)</code></li>
<li>动态链接（Dynamic Linking）：指向运行时常量池中当前方法引用</li>
<li>方法返回地址（Return Address）：方法正常退出或异常退出的地址</li>
<li>一些附加信息</li>
</ul>
<img src="/pics/image-20210411223657857.png" alt="image-20210411223657857" style="zoom:33%;" />

<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>局部变量表：Local Variables，也被称之为局部变量数组或本地变量表，是一组变量值存储空间，<strong>用于存放方法参数和方法内定义的局部变量</strong>。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li><strong>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</strong>，这些数据类型包括各类基本数据类型、对象引用（reference），以及 returnAddress(返回值) 类型</li>
<li>由于局部变量表是建立在线程的栈上，是线程的私有数据，<strong>因此不存在数据安全问题</strong></li>
<li><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的Code属性的maximum local variables数据项中，方法运行期间局部变量表的大小是不会改变。</li>
<li>对于一个方法来说<ul>
<li><strong>方法嵌套调用的次数由栈的大小决定</strong>。一般来说，栈越大，方法嵌套调用次数越多</li>
<li>方法的参数和局部变量越多，<strong>局部变量表越大，它的栈帧就越大</strong>。进而方法调用就会占用更多的栈空间，导致其嵌套调用次数就会减少</li>
</ul>
</li>
<li>局部变量表中的变量只在当前方法调用中有效<ul>
<li>在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程</li>
<li>当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁</li>
</ul>
</li>
<li><strong>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</strong></li>
</ul>
<h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>通过jclasslib 查看字节码信息，java代码及其对应的字节码结构如图所示。</p>
<img src="/pics/image-20210413113124288.png" alt="image-20210413113124288" style="zoom:100%;" /> 

<h4 id="Slot"><a href="#Slot" class="headerlink" title="Slot"></a>Slot</h4><p>Slot（变量槽），局部变量表的最基本存储单元。</p>
<ul>
<li><p>局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</p>
<ul>
<li>32位以内的类型（包括 <strong>引用类型、returnAddress类型</strong>）只占用一个slot；64位的类型（long和double）占用两个slot</li>
<li>byte、short、char 在存储前被转换为int，boolean 也被转换为int（false -&gt; 0，true- &gt; 非零），long 和 double 则占据两个Slot</li>
</ul>
</li>
<li><p>方法被调用的时候，<strong>方法参数和方法体内定义的局部变量将会按照顺序被复制到局部变量表中的每一个slot上</strong></p>
<ul>
<li>局部变量表中的每一个Slot有一个访问索引，通过这个索引可访问到局部变量值</li>
<li>访问64bit（long或double类型变量）的局部变量时，只需要使用起始索引</li>
</ul>
</li>
<li><p>对于构造方法或者实例方法，那么<strong>该对象this引用将会存放在index为0的slot处</strong>，其余的参数按照参数表顺序排列</p>
</li>
<li><p><strong>栈帧中的局部变量表中的槽位是可以重用的</strong>，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而<strong>达到节省资源的目的</strong>。下图中，this、a、b、c 理论上应该有 4 个变量，<strong>c 复用了 b 的槽</strong></p>
<img src="/pics/image-20210413221825354.png" alt="image-20210413221825354" style="zoom:70%;" /></li>
</ul>
<h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。</p>
<ul>
<li><p>操作数栈就是 JVM 执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，此时这个方法的操作数栈是空的。</p>
</li>
<li><p>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在<code>编译期</code>就定义好了，保存在方法的 Code 属性的 <code>stack</code> 数据项中</p>
<img src="/pics/image-20210415005545972.png" alt="image-20210415005545972" style="zoom:50%;" /></li>
<li><p>方法执行过程中，根据字节码指令，往操作数栈中写入数据或取出数据</p>
<ul>
<li>栈中的任何一个元素都可以是任意的 Java 数据类型。32bit 的类型占用一个栈单位深度，64bit 的类型占用两个栈单位深度</li>
<li>操作数栈并非采用索引方式进行数据访问，只能通过入栈和出栈来完成数据访问</li>
</ul>
</li>
<li><p>另外，我们说<strong>Java虚拟机的解释引擎是基于栈的执行引擎</strong>，其中的栈指的就是操作数栈</p>
</li>
</ul>
<h4 id="栈顶缓存技术-Top-Of-Stack-Cashing"><a href="#栈顶缓存技术-Top-Of-Stack-Cashing" class="headerlink" title="栈顶缓存技术(Top Of Stack Cashing)"></a>栈顶缓存技术(Top Of Stack Cashing)</h4><p>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数。</p>
<p>由于<strong>操作数是存储在内存中</strong>的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，将<code>栈顶元素</code>全部缓存在<code>物理CPU的寄存器</code>中，以此降低对内存的读/写次数，提升执行引擎的执行效率。</p>
<h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a><strong>动态链接</strong></h3><p>动态链接（Dynamic Linking），指向运行时常量池的该栈帧所属<code>方法的引用</code>。每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态链接。</p>
<p>在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为<strong>符号引用</strong>（Symbolic Reference）保存在 Class 文件的常量池中。</p>
<p>字节码中的方法调用指令就是以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或第一次使用时转化为直接引用，这种转化称为静态链接（或静态解析）。另一部分将在每一次运行期间转化为直接引用，这部分称为动态链接。</p>
<p>为什么要用常量池呢？</p>
<ul>
<li>不同的方法，都可能调用相同常量或者方法，所以<code>只需要存储一份即可，然后记录其引用即可，节省空间</code></li>
<li>常量池的作用：就是为了提供一些符号和常量，便于指令的识别</li>
</ul>
<img src="/pics/image-20210414205105346.png" alt="image-20210414205105346" style="zoom:33%;" />

<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicLinkingTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodA()....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodB()....&quot;</span>);</span><br><span class="line">        methodA();</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ============反编译字节码命令 ============</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// =====常量池===========  </span></span><br><span class="line"></span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">9.</span>#<span class="number">23</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">8.</span>#<span class="number">24</span>         <span class="comment">// cn/sxt/java1/DynamicLinkingTest.num:I</span></span><br><span class="line">   #<span class="number">3</span> = Fieldref           #<span class="number">25.</span>#<span class="number">26</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   #<span class="number">4</span> = String             #<span class="number">27</span>            <span class="comment">// methodA()....</span></span><br><span class="line">   #<span class="number">5</span> = Methodref          #<span class="number">28.</span>#<span class="number">29</span>        <span class="comment">// java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">   #<span class="number">6</span> = String             #<span class="number">30</span>            <span class="comment">// methodB()....</span></span><br><span class="line">   #<span class="number">7</span> = Methodref          #<span class="number">8.</span>#<span class="number">31</span>         <span class="comment">// cn/sxt/java1/DynamicLinkingTest.methodA:()V</span></span><br><span class="line">   #<span class="number">8</span> = Class              #<span class="number">32</span>            <span class="comment">// cn/sxt/java1/DynamicLinkingTest</span></span><br><span class="line">   #<span class="number">9</span> = Class              #<span class="number">33</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">  #<span class="number">10</span> = Utf8               num</span><br><span class="line">  #<span class="number">11</span> = Utf8               I</span><br><span class="line">  #<span class="number">12</span> = Utf8               &lt;init&gt;</span><br><span class="line">  #<span class="number">13</span> = Utf8               ()V</span><br><span class="line">  #<span class="number">14</span> = Utf8               Code</span><br><span class="line">  #<span class="number">15</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">16</span> = Utf8               LocalVariableTable</span><br><span class="line">  #<span class="number">17</span> = Utf8               <span class="keyword">this</span></span><br><span class="line">  #<span class="number">18</span> = Utf8               Lcn/sxt/java1/DynamicLinkingTest;</span><br><span class="line">  #<span class="number">19</span> = Utf8               methodA</span><br><span class="line">  #<span class="number">20</span> = Utf8               methodB</span><br><span class="line">  #<span class="number">21</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">22</span> = Utf8               DynamicLinkingTest.java</span><br><span class="line">  #<span class="number">23</span> = NameAndType        #<span class="number">12</span>:#<span class="number">13</span>        <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">24</span> = NameAndType        #<span class="number">10</span>:#<span class="number">11</span>        <span class="comment">// num:I</span></span><br><span class="line">  #<span class="number">25</span> = Class              #<span class="number">34</span>            <span class="comment">// java/lang/System</span></span><br><span class="line">  #<span class="number">26</span> = NameAndType        #<span class="number">35</span>:#<span class="number">36</span>        <span class="comment">// out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">27</span> = <span class="function">Utf8               <span class="title">methodA</span><span class="params">()</span>....</span></span><br><span class="line"><span class="function">  #28 </span>= Class              #<span class="number">37</span>            <span class="comment">// java/io/PrintStream</span></span><br><span class="line">  #<span class="number">29</span> = NameAndType        #<span class="number">38</span>:#<span class="number">39</span>        <span class="comment">// println:(Ljava/lang/String;)V</span></span><br><span class="line">  #<span class="number">30</span> = <span class="function">Utf8               <span class="title">methodB</span><span class="params">()</span>....</span></span><br><span class="line"><span class="function">  #31 </span>= NameAndType        #<span class="number">19</span>:#<span class="number">13</span>        <span class="comment">// methodA:()V</span></span><br><span class="line">  #<span class="number">32</span> = Utf8               cn/sxt/java1/DynamicLinkingTest</span><br><span class="line">  #<span class="number">33</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">34</span> = Utf8               java/lang/System</span><br><span class="line">  #<span class="number">35</span> = Utf8               out</span><br><span class="line">  #<span class="number">36</span> = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #<span class="number">37</span> = Utf8               java/io/PrintStream</span><br><span class="line">  #<span class="number">38</span> = Utf8               println</span><br><span class="line">  #<span class="number">39</span> = Utf8               (Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==== 字节码命令 ====</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: getstatic     #<span class="number">3</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">3</span>: ldc           #<span class="number">6</span>                  <span class="comment">// String methodB()....</span></span><br><span class="line">         <span class="number">5</span>: invokevirtual #<span class="number">5</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">         <span class="number">8</span>: aload_0</span><br><span class="line">         <span class="number">9</span>: invokevirtual #<span class="number">7</span>                  <span class="comment">// Method methodA:()V</span></span><br><span class="line"><span class="comment">//	...  </span></span><br></pre></td></tr></table></figure>

<p>看一下methodBn调用methodA的过程</p>
<blockquote>
<p>#7 = Methodref #8.#31<br>先找 #8 ：<br>#8 = Class #32 ：去找 #32<br>#32 = Utf8 cn/sxt/java1/DynamicLinkingTest<br>结论：通过 #8 我们找到了 DynamicLinkingTest 这个类</p>
<p>再来找 #31：<br>#31 = NameAndType #19:#13 ：去找 #19 和 #13<br>#19 = Utf8 methodA ：方法名为 methodA<br>#13 = Utf8 ()V ：方法没有形参，返回值为 void<br>结论：通过 #7 我们就能找到需要调用的 methodA( ) 方法，并进行调用</p>
</blockquote>
<p>以上的过程也是符号引用转换为直接引用，就是说通过符号引用一直查找到方法名的过程。</p>
<h3 id="返回地址"><a href="#返回地址" class="headerlink" title="返回地址"></a>返回地址</h3><p>用来存放调用该方法的 <strong>PC 寄存器的值</strong>（PC寄存器存储着下一条要执行的指令）。</p>
<p><strong>方法执行完成时，调用者的 PC 寄存器的值作为返回地址，即调用该方法的指令的下一条指令的地址。</strong>而通过异常退出的，返回地址是要通过异常表来确定的，栈帧中一般不会保存这部分信息。</p>
<img src="/pics/image-20210414232209000.png" alt="image-20210414232209000" style="zoom:50%;" />



<p>一个方法的结束，有两种方式</p>
<ul>
<li>正常执行完成</li>
<li>出现未处理的异常，非正常退出</li>
</ul>
<p>这2者区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</p>
<h4 id="正常完成出口"><a href="#正常完成出口" class="headerlink" title="正常完成出口"></a>正常完成出口</h4><p>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者正常完成<br>一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。</p>
<blockquote>
<p>在字节码指令中，返回指令包含：</p>
<ul>
<li>ireturn：当返回值是boolean，byte，char，short和int类型时使用</li>
<li>lreturn：Long类型</li>
<li>freturn：Float类型</li>
<li>dreturn：Double类型</li>
<li>areturn：引用类型</li>
<li>return：返回值类型为void的方法以及类的构造器、静态代码块</li>
</ul>
</blockquote>
<h4 id="异常完成出口"><a href="#异常完成出口" class="headerlink" title="异常完成出口"></a>异常完成出口</h4><p>在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称异常完成出口。</p>
<p><img src="/pics/image-20210414230130630.png" alt="image-20210414230130630"></p>
<p>方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码 </p>
<h3 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h3><p>栈帧中还允许携带与 Java 虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息，但这些信息取决于具体的虚拟机实现。</p>
<blockquote>
<p>一般会把动态链接、方法返回地址与其他信息归为一类，称为栈帧信息。</p>
</blockquote>
<h1 id="方法调用（解析和分派）"><a href="#方法调用（解析和分派）" class="headerlink" title="方法调用（解析和分派）"></a>方法调用（解析和分派）</h1><p>方法调用并不等同于方法中的代码被执行，方法调用阶段唯一的任务就是确定被调用方法，暂时还未涉及方法内部的具体运行过程。一切方法调用在Class文件里面存储的都只是符号引用，我们知道符号引用在运行时需要转化为直接引用（方法在实际运行时内存布局中的入口地址），转换的情况有2种分别是：静态链接与动态链接。</p>
<h2 id="静态链接与动态链接"><a href="#静态链接与动态链接" class="headerlink" title="静态链接与动态链接"></a>静态链接与动态链接</h2><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p>
<ul>
<li>静态链接：<br>当一个字节码文件被装载进JVM内部时，<strong>如果被调用的目标方法在编译期确定</strong>，且运行期保持不变时，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接</li>
<li>动态链接：<br>如果被调用的方法在编译期无法被确定下来，也就是说，<strong>只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性</strong>，因此也被称之为动态链接。</li>
</ul>
<p>静态链接和动态链接对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</p>
<h4 id="方法的绑定机制"><a href="#方法的绑定机制" class="headerlink" title="方法的绑定机制"></a>方法的绑定机制</h4><ul>
<li>早期绑定<br>早期绑定就是指被调用的目标方法<strong>如果在编译期可知，且运行期保持不变时</strong>，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</li>
<li>晚期绑定<br>如果被调用的方法在编译期无法被确定下来，<strong>只能够在程序运行期根据实际的类型绑定相关的方法</strong>，这种绑定方式也就被称之为晚期绑定。</li>
</ul>
<p>随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</p>
<blockquote>
<p>解析一定是个静态的过程，在编译期间就能完全确定，而分派可能是静态的也可能是动态的。也就是说解析一定是静态链接，而分派可能是动态链接也可能是静态链接。</p>
</blockquote>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>所有方法调用的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能够成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。</p>
<p>换句话说，调用目标在程序代码写好、编译器进行编译那一刻就已经确定下来。这类方法的调用被称为<strong>解析（Resolution）</strong>。</p>
<h3 id="方法的分类"><a href="#方法的分类" class="headerlink" title="方法的分类"></a>方法的分类</h3><ul>
<li>非虚方法：如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为<code>非虚方法</code>。</li>
<li>其他方法称为虚方法。</li>
</ul>
<h3 id="方法调用指令"><a href="#方法调用指令" class="headerlink" title="方法调用指令"></a>方法调用指令</h3><ul>
<li><code>invokestatic</code>：用于调用静态方法。</li>
<li><code>invokespecial</code>：用于调用实例构造器<init>()方法、私有方法和父类中的方法。</li>
<li><code>invokevirtual</code>：用于调用所有的虚方法。</li>
<li><code>invokeinterface</code>：用于调用接口方法，会在运行时再确定一个实现该接口的对象。</li>
<li><code>invokedynamic</code>：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。</li>
</ul>
<blockquote>
<p>以上指令的区别：</p>
<ol>
<li>invokestatic指令和invokespecial指令调用的方法称为非虚方法</li>
<li>invokevirtual 除（final修饰）称为虚方法。</li>
<li>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预而invokedynamic指令则支持由用户确定方法版本</li>
</ol>
</blockquote>
<h2 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h2><p><strong>分派会解释多态性特征的一些最基本的体现，如“重载”、“重写”在Java虚拟机中是如何实现的</strong>，当然这里的实现不是语法上该怎么写，我们关心的是虚拟机如何确定正确的目标方法。</p>
<p>分派（Dispatch）它可能是静态的也可能是动态的，按照分派依据的宗量数可分为单分派和多分派。这两类分派方式两两组合就构成了静态单分派、静态多分派、动态单分派、动态多分派4种分派组合情况。</p>
<h3 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h3><p><strong>依赖静态类型来决定方法执行版本的分派动作，都称为静态分派</strong>。静态分派的最典型应用表现就是<strong>方法重载</strong>，虚拟机（或者准确地说是编译器）在重载时是通过参数的静态类型来作为判定依据的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Human guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,guy!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Man guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,gentleman!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Woman guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,lady!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        StaticDispatch sr = <span class="keyword">new</span> StaticDispatch();</span><br><span class="line">        sr.sayHello(man);</span><br><span class="line">        sr.sayHello(woman);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line">hello,guy!</span><br><span class="line">hello,guy!</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Human man = <span class="keyword">new</span> Man();</span><br></pre></td></tr></table></figure>

<p>这里的<code>Human </code>就是变量的“静态类型”（Static Type），或者叫“外观类型”（Apparent Type）；<code>Man</code>就是变量的“实际类型”（Actual Type）或者叫“运行时类型”（Runtime Type）。</p>
<h3 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h3><p><strong>在运行期根据实际类型确定方法执行版本的分派过程称为动态分派</strong>。最典型的表现就是重写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello,Man!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello,Woman!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">        woman.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果：</span></span><br><span class="line">hello,Man!</span><br><span class="line">hello,Woman!</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反编译字节码</span></span><br><span class="line">...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class com/xiaolyuh/DynamicDispatch$Man</span></span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         <span class="number">4</span>: invokespecial #<span class="number">3</span>                  <span class="comment">// Method com/xiaolyuh/DynamicDispatch$Man.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">7</span>: astore_1</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">new</span>           #<span class="number">4</span>                  <span class="comment">// class com/xiaolyuh/DynamicDispatch$Woman</span></span><br><span class="line">        <span class="number">11</span>: dup</span><br><span class="line">        <span class="number">12</span>: invokespecial #<span class="number">5</span>                  <span class="comment">// Method com/xiaolyuh/DynamicDispatch$Woman.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        <span class="number">15</span>: astore_2</span><br><span class="line">        <span class="number">16</span>: aload_1</span><br><span class="line">        <span class="number">17</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method com/xiaolyuh/DynamicDispatch$Human.sayHello:()V</span></span><br><span class="line">        <span class="number">20</span>: aload_2</span><br><span class="line">        <span class="number">21</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method com/xiaolyuh/DynamicDispatch$Human.sayHello:()V</span></span><br><span class="line">        <span class="number">24</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">27</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">28</span>: <span class="number">8</span></span><br><span class="line">        line <span class="number">29</span>: <span class="number">16</span></span><br><span class="line">        line <span class="number">30</span>: <span class="number">20</span></span><br><span class="line">        line <span class="number">31</span>: <span class="number">24</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">25</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">8</span>      <span class="number">17</span>     <span class="number">1</span>   man   Lcom/xiaolyuh/DynamicDispatch$Human;</span><br><span class="line">           <span class="number">16</span>       <span class="number">9</span>     <span class="number">2</span> woman   Lcom/xiaolyuh/DynamicDispatch$Human;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>通过字节码我们发现：在main方法中，<code>sayHello()</code>方法的调用对应的<strong>符号引用是一样的</strong>，<code>com/xiaolyuh/DynamicDispatch$Human.sayHello:()V </code>。在这里我们可以得出一个结论：<strong>在动态分派的情况下，在编译时期我们是无法确定方法的直接引用的</strong>，那么它是怎么实现重载方法的调用的呢？问题关键是在<code>invokevirtual</code>指令上，在执行<code>invokevirtual</code>指令时，<code>invokevirtual</code>指令会去确定方法的调用版本。</p>
<h4 id="invokevirtual指令的运行过程"><a href="#invokevirtual指令的运行过程" class="headerlink" title="invokevirtual指令的运行过程"></a>invokevirtual指令的运行过程</h4><ol>
<li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。</li>
<li>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError 异常</li>
<li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</li>
</ol>
<blockquote>
<p>正是因为invokevirtual指令执行的第一步就是在运行期确定接收者的实际类型，所以两次调用中的invokevirtual指令并不是把常量池中方法的符号引用解析到直接引用上就结束了，还会根据方法接收者的实际类型来选择方法版本，这个过程就是Java语言中方法重写的本质</p>
</blockquote>
<h4 id="动态分派的实现"><a href="#动态分派的实现" class="headerlink" title="动态分派的实现"></a>动态分派的实现</h4><p>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。</p>
<p>因此，为了提高性能，JVM在方法区建立一个<strong>虚方法表（virtual method table）</strong>，表中存放着各个虚方法的实际入口，非虚方法不会出现在表中。</p>
<p>虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表中的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类虚方法表中的地址也会被替换为指向子类实现版本的入口地址。</p>
<img src="/pics/image-20210415000959425.png" alt="image-20210415000959425" style="zoom:33%;" />

<blockquote>
<p><strong>虚方法表是什么时候被创建的呢？</strong></p>
<p>虚方法表会在类加载的链接阶段被创建并开始初始化，类变量初始值准备完成之后，JVM会把该类的虚方法表也初始化完毕。</p>
</blockquote>
<h3 id="单分派与多分派"><a href="#单分派与多分派" class="headerlink" title="单分派与多分派"></a>单分派与多分派</h3><p>方法的接收者与方法的参数统称为方法的宗量。分派基于多少种宗量，可以将分派划分为单分派和多分派两种。单分派是根据一个宗量对目标方法进行选择，多分派则是根据两个及以上的宗量对目标方法进行选择。</p>
<ul>
<li><p>静态分派需要根据<strong>静态类型和方法参数</strong>两个宗量来确定方法调用，所以属于多分派。</p>
</li>
<li><p>动态分派只需要根据<strong>实际类型</strong>一个宗量来确定方法的调用，所以属于单分派。</p>
<p>在动态分派的过程中，方法签名是确定的，所以方法参数就不会变，方法调用就取决于参数的实际类型。</p>
</li>
</ul>
<h2 id="动态类型语言和静态类型语言"><a href="#动态类型语言和静态类型语言" class="headerlink" title="动态类型语言和静态类型语言"></a>动态类型语言和静态类型语言</h2><p>动态类型语言和静态类型语言两者的区别就在于<strong>对类型的检查是在编译期还是在运行期</strong>，满足前者就是静态类型语言，反之是动态类型语言。</p>
<p>说的再直白一点就是，静态类型语言是判断<strong>变量自身的类型信息</strong>；动态类型语言是判断<strong>变量值的类型信息</strong>，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Java语言：String info = <span class="string">&quot;mogu blog&quot;</span>;     		(Java是静态类型语言的，会先编译再进行类型检查)</span><br><span class="line">JS语言：<span class="keyword">var</span> name = <span class="string">&quot;shkstart&quot;</span>;  <span class="keyword">var</span> name = <span class="number">10</span>;	（运行时才进行检查）</span><br><span class="line">Python语言：info = <span class="number">130.5</span>;  （动态类型语言）</span><br></pre></td></tr></table></figure>

<img src="/pics/image-20210414233954002.png" alt="image-20210414233954002" style="zoom:33%;" />

<h3 id="invokedynamic"><a href="#invokedynamic" class="headerlink" title="invokedynamic"></a>invokedynamic</h3><p>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现<code>【动态类型语言】</code>支持而做的一种改进。</p>
<p>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。<strong>直到Java8的 Lambda表达式 的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。</strong></p>
<p>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>线程执行方法时，会创建一个栈帧，用来保存方法需要的信息。其中，局部变量表中存储着方法需要的各个变量信息；操作数栈用于存储方法执行过程中的中间变量；动态连接指向的是常量池中方法的引用；返回地址存储的是调用该方法的 PC 寄存器的值，PC寄存器存储着下一条要执行的指令。</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/sj15814963053/article/details/109922984">https://blog.csdn.net/sj15814963053/article/details/109922984</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>JVM_07_本地方法栈</title>
    <url>/2021/04/12/Notes/Java/01JVM/JVM_07_%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/</url>
    <content><![CDATA[<h1 id="JVM-07-本地方法栈"><a href="#JVM-07-本地方法栈" class="headerlink" title="JVM_07_本地方法栈"></a>JVM_07_本地方法栈</h1><span id="more"></span>

<img src="/pics/image-20210412214838032.png" alt="image-20210412214838032" style="zoom:50%;" />

<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>Java 虚拟机栈用于管理 Java 方法的调用，而<code>本地方法栈(Native Method Stack)</code>用于管理本地方法的调用。</p>
<ul>
<li>本地方法栈也是线程私有的</li>
<li>允许线程固定或者可动态扩展的内存大小<ul>
<li>如果线程请求分配的栈容量<code>超过本地方法栈允许的最大容量</code>，Java 虚拟机将会抛出一个 <code>StackOverflowError</code> 异常</li>
<li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么 Java虚拟机将会抛出一个<code>OutofMemoryError</code>异常</li>
</ul>
</li>
<li>本地方法一般是使用 C 语言实现的</li>
<li>它的具体做法是 <code>Native Method Stack</code> 中登记 native 方法，在 <code>Execution Engine</code> 执行时加载本地方法库当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</li>
<li><strong>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</strong><ul>
<li>本地方法可以通过本地方法接口来访问<strong>虚拟机内部的运行时数据区</strong></li>
<li>甚至可以直接使用本地处理器中的寄存器</li>
<li>直接从本地内存的堆中分配任意数量的内存</li>
</ul>
</li>
<li>并不是所有 JVM 都支持本地方法。因为 Java 虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果 JVM 产品不打算支持 native 方法，也可以无需实现本地方法栈</li>
<li><strong>在 Hotspot JVM 中，直接将本地方栈和虚拟机栈合二为一</strong></li>
</ul>
<h2 id="本地方法接口-JNI"><a href="#本地方法接口-JNI" class="headerlink" title="本地方法接口(JNI)"></a>本地方法接口(JNI)</h2><p>JNI(Java Native Interface) 就是Java 调用本地方法库（一般是C或C++库）接口。</p>
<ul>
<li>在定义一个native method时，<strong>并不提供实现体</strong>（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。</li>
<li>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是<code>融合C/C++程序</code>。</li>
</ul>
<p>JDK 中有很多被native关键修饰的方法。比如Object#getClass( )等等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure>

<h3 id="为什么要使用本地方法（NativeMethod）？"><a href="#为什么要使用本地方法（NativeMethod）？" class="headerlink" title="为什么要使用本地方法（NativeMethod）？"></a>为什么要使用本地方法（NativeMethod）？</h3><p>Java使用起来非常方便，<code>然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时</code>，问题就来了。</p>
<ul>
<li><strong>与Java环境外交互</strong><br><code>有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因</code>。你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。<br>本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</li>
<li><strong>与操作系统的交互</strong><br>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。<br><code>通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的</code>。<br>还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</li>
<li><strong>Sun’s Java</strong><br><code>Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。</code><br>例如：类java.lang.Thread的setPriority( )方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriority0( )。这个本地方法是用C实现的，并被植入JVM内部在Windows 95的平台上，这个本地方法最终将调用Win32 setpriority( ) API。<br>这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。</li>
</ul>
<blockquote>
<p>总结：Java方法可以通过JNI调用到本地方法；本地方法是在本地方法栈中执行的。</p>
</blockquote>
]]></content>
      <categories>
        <category>JAVA</category>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>JVM_08_方法区</title>
    <url>/2021/04/17/Notes/Java/01JVM/JVM_08_%E6%96%B9%E6%B3%95%E5%8C%BA/</url>
    <content><![CDATA[<h1 id="JVM-08-方法区"><a href="#JVM-08-方法区" class="headerlink" title="JVM_08_方法区"></a>JVM_08_方法区</h1><span id="more"></span>

<p><strong>方法区主要存放的是 Class</strong>，<strong>而堆中主要存放的是实例化的对象</strong>，<strong>方法区可以看作是一块独立于Java堆的内存空间</strong>。</p>
<ul>
<li>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域</li>
<li>多个线程同时加载统一个类时，只能有一个线程能加载该类，其他线程只能等等待该线程加载完毕，然后直接使用该类，即类只能加载一次</li>
<li>方法区在JVM启动的时候被创建，并且它的实际物理内存空间和Java堆区一样都可以是不连续的。</li>
<li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展</li>
<li>方法区是接口，元空间或者永久代是方法区的实现</li>
<li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：java.lang.OutofMemoryError:PermGen space（JDK7之前）或者 java.lang.OutOfMemoryError:Metaspace（JDK8之后）</li>
<li>关闭JVM就会释放方法区内存</li>
</ul>
<h2 id="栈、堆、方法区的交互关系"><a href="#栈、堆、方法区的交互关系" class="headerlink" title="栈、堆、方法区的交互关系"></a>栈、堆、方法区的交互关系</h2><h3 id="线程共享的角度"><a href="#线程共享的角度" class="headerlink" title="线程共享的角度"></a>线程共享的角度</h3><p><img src="/pics/image-20210416100231841.png" alt="image-20210416100231841"></p>
<p>线程共享：堆 + 方法区，存在OOM 和 GC</p>
<p>线程私有：虚拟机栈 + 本地方法栈 + PC寄存器，虚拟机栈 + 本地方法栈存在栈溢出问题，PC寄存器</p>
<h3 id="相互的关系"><a href="#相互的关系" class="headerlink" title="相互的关系"></a>相互的关系</h3><img src="/pics/image-20210416100432888.png" alt="image-20210416100432888" style="zoom:67%;" />

<p>虚拟机栈中对象引用执行堆中的Persion对象实例数据，Persion对象的class信息又是保存在方法区中的，需要通过类型数据指针指向Persion.class类型信息。</p>
<h2 id="Hotspot中方法区的演进过程"><a href="#Hotspot中方法区的演进过程" class="headerlink" title="Hotspot中方法区的演进过程"></a>Hotspot中方法区的演进过程</h2><p><strong>在 JDK7 及以前，习惯上把方法区，称为永久代。JDK8开始，使用元空间取代了永久代</strong>。</p>
<ul>
<li>本质上，方法区和永久代并不等价。仅是对Hotspot而言的可以看作等价。</li>
<li>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。</li>
<li><strong>元空间不在虚拟机的内存中，而是使用本地内存</strong>。</li>
</ul>
<img src="/pics/image-20210416102338775.png" alt="image-20210416102338775" style="zoom:70%;" />

<h3 id="永久代的演进过程"><a href="#永久代的演进过程" class="headerlink" title="永久代的演进过程"></a>永久代的演进过程</h3><p><img src="/pics/image-20210416145726419.png" alt="image-20210416145726419"></p>
<ul>
<li>JDK6，方法区由永久代实现，使用 JVM 虚拟机内存</li>
</ul>
<p><img src="/pics/image-20210416150341751.png" alt="image-20210416150341751"></p>
<ul>
<li>JDK7 方法区由永久代实现，使用 JVM 虚拟机内存，静态变量和字符串常量池保存在堆中</li>
</ul>
<p><img src="/pics/image-20210416150504193.png" alt="image-20210416150504193"></p>
<p>JDK8及以后，方法区由元空间实现，<strong>使用本地内存</strong></p>
<img src="/pics/image-20210416150414929.png" alt="image-20210416150414929" style="zoom:70%;" />

<h3 id="元空间为什么要替代永久代"><a href="#元空间为什么要替代永久代" class="headerlink" title="元空间为什么要替代永久代"></a>元空间为什么要替代永久代</h3><ul>
<li><p>官方的牵强解释：JRockit是和HotSpot融合后的结果，因为JRockit没有永久代，所以他们不需要配置永久代，HotSpot也就取消了永久代</p>
</li>
<li><p>为永久代设置空间大小是很难确定的</p>
<p>如果动态加载类过多，容易产生Perm区的OOM。<strong>元空间并不在虚拟机中，而是使用本地内存，元空间的大小仅受本地内存限制</strong></p>
</li>
<li><p>对永久代进行调优是很困难的</p>
<ul>
<li>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再用的类型，方法 区的调优主要是为了降低Full GC</li>
<li>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。</li>
</ul>
</li>
</ul>
<h2 id="设置方法区大小与OOM"><a href="#设置方法区大小与OOM" class="headerlink" title="设置方法区大小与OOM"></a>设置方法区大小与OOM</h2><p>方法区的大小不必是固定的，JVM可以根据应用的需要动态调整</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试设置方法区大小参数的默认值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * jdk7及以前：</span></span><br><span class="line"><span class="comment"> * -XX:PermSize=100m -XX:MaxPermSize=100m</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * jdk8及以后：</span></span><br><span class="line"><span class="comment"> * -XX:MetaspaceSize=100m  -XX:MaxMetaspaceSize=100m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;end...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h3><p><strong>内存泄漏就是有大量的引用指向某些对象，但是这些对象以后不会使用了</strong>，但是因为它们还和GC ROOT有关联，所以导致以后这些对象也不会被回收，这就是内存泄漏的问题</p>
<p>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。<strong>于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的</strong>。掌握了泄漏对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置。</p>
<h2 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h2><p>它用于存储已被虚拟机加载的<strong>类型信息、运行时常量池、静态变量、即时编译器编译后的代码缓存</strong>等。</p>
<p><img src="/pics/image-20210416162001528.png" alt="image-20210416162001528"></p>
<h3 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h3><p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：</p>
<ul>
<li>这个类型的完整有效名称（全类名=包名.类名）</li>
<li>这个类型直接父类的完整有效名（对于interface或是java.lang.Object，都没有父类）</li>
<li>这个类型的修饰符（public，abstract，final的某个子集）</li>
<li>这个类型直接接口的一个有序列表</li>
</ul>
<h3 id="域（Field）信息"><a href="#域（Field）信息" class="headerlink" title="域（Field）信息"></a>域（Field）信息</h3><p>JVM 必须在方法区中保存类型的所有域的相关信息以及域的声明顺序</p>
<ul>
<li><p><code>域信息</code>通俗来讲是类的成员变量（static 修饰）</p>
</li>
<li><p>域的相关信息包括：域名称、域类型、域修饰符（public、private、protected、static、final、volatile、transient 的某个子集）</p>
</li>
</ul>
<h3 id="方法（Method）信息"><a href="#方法（Method）信息" class="headerlink" title="方法（Method）信息"></a>方法（Method）信息</h3><p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p>
<ul>
<li>方法名称</li>
<li>方法的返回类型</li>
<li>方法参数的数量和类型</li>
<li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract 的一个子集）</li>
<li>方法的字符码（bytecodes）、操作数栈、局部变量表及大小（abstract 和 native 方法除外）</li>
<li>异常表（abstract 和 native 方法除外），每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li>
</ul>
<blockquote>
<p>static final 修饰的常量在编译的时候就会被分配了。</p>
</blockquote>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。</p>
<ul>
<li>运行时常量池，JVM加载类和后，就会创建对应的运行时常量池。</li>
<li>JVM为每个类都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。</li>
<li>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。<strong>此时不再是常量池中的符号应用了，这里换为直接引用（真实地址）</strong>。</li>
<li>运行时常量池，相对于Class文件常量池的另一重要特征是：<strong>具备动态性</strong>。不如可以通过String.intern() 向运行时常量池中放置常量。</li>
</ul>
<blockquote>
<p>常量池和运行时常量池</p>
<p><strong>常量池表（Constant Pool Table）是Class字节码文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中</strong>。</p>
<p><strong>运行时常量池（Runtime Constant Pool）是方法区的一部分</strong>。</p>
</blockquote>
<h4 id="为什么需要常量池？"><a href="#为什么需要常量池？" class="headerlink" title="为什么需要常量池？"></a>为什么需要常量池？</h4><p>字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外，还包含一项信息就是<strong>常量池表</strong>（<strong>Constant Pool Table</strong>），包括<strong>各种字面量（属性值）和对类型、域（成员变量）和方法的符号引用</strong>。</p>
<img src="/pics/image-20210417184336117.png" alt="image-20210417184336117" style="zoom:30%;" />

<p>Java文件中的类、接口，编译后产生字节码文件，而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，所以使用<strong>符号引用</strong>的方式存到了常量池。而这些符号引用，在程序运行时被转化为<strong>直接引用</strong>（地址），这个过程称为<strong>动态链接</strong>。</p>
<h3 id="内部结构举例"><a href="#内部结构举例" class="headerlink" title="内部结构举例"></a>内部结构举例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodInnerStrucTest</span> <span class="keyword">extends</span> <span class="title">Object</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> xx = <span class="number">1001L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> yy = <span class="number">1000L</span>;</span><br><span class="line">    <span class="keyword">private</span> String nihao = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String str = <span class="string">&quot;测试方法的内部结构&quot;</span>;</span><br><span class="line">    <span class="comment">//构造器没写</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">20</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;count = &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test2</span><span class="params">(<span class="keyword">int</span> cal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> value = <span class="number">30</span>;</span><br><span class="line">            result = value / cal;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ======反编译字节码结果====</span></span><br><span class="line">Classfile /E:/work/JavaLearn/out/production/jvm/MethodInnerStrucTest.class</span><br><span class="line">  Last modified <span class="number">2021</span>-<span class="number">4</span>-<span class="number">16</span>; size <span class="number">1646</span> bytes</span><br><span class="line">  MD5 checksum ea25c6e80bbc8e5b2650095fd4359124</span><br><span class="line">  Compiled from <span class="string">&quot;MethodInnerStructTest.java&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodInnerStrucTest</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Comparable</span>&lt;<span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class">  <span class="title">minor</span> <span class="title">version</span>: 0</span></span><br><span class="line"><span class="class">  <span class="title">major</span> <span class="title">version</span>: 52</span></span><br><span class="line"><span class="class">  <span class="title">flags</span>: <span class="title">ACC_SUPER</span></span></span><br><span class="line"><span class="class"><span class="title">Constant</span> <span class="title">pool</span>: // 常量池</span></span><br><span class="line"><span class="class">   #1 </span>= Methodref          #<span class="number">20.</span>#<span class="number">55</span>        <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">19.</span>#<span class="number">56</span>        <span class="comment">// MethodInnerStrucTest.num:I</span></span><br><span class="line">   #<span class="number">3</span> = String             #<span class="number">57</span>            <span class="comment">// hello world</span></span><br><span class="line">   #<span class="number">4</span> = Fieldref           #<span class="number">19.</span>#<span class="number">58</span>        <span class="comment">// MethodInnerStrucTest.nihao:Ljava/lang/String;</span></span><br><span class="line">   #<span class="number">5</span> = Fieldref           #<span class="number">59.</span>#<span class="number">60</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   #<span class="number">6</span> = Class              #<span class="number">61</span>            <span class="comment">// java/lang/StringBuilder</span></span><br><span class="line">   #<span class="number">7</span> = Methodref          #<span class="number">6.</span>#<span class="number">55</span>         <span class="comment">// java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">8</span> = String             #<span class="number">62</span>            <span class="comment">// count =</span></span><br><span class="line">   #<span class="number">9</span> = Methodref          #<span class="number">6.</span>#<span class="number">63</span>         <span class="comment">// java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">  #<span class="number">10</span> = Methodref          #<span class="number">6.</span>#<span class="number">64</span>         <span class="comment">// java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span></span><br><span class="line">  #<span class="number">11</span> = Methodref          #<span class="number">6.</span>#<span class="number">65</span>         <span class="comment">// java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">  #<span class="number">12</span> = Methodref          #<span class="number">66.</span>#<span class="number">67</span>        <span class="comment">// java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">  #<span class="number">13</span> = Class              #<span class="number">68</span>            <span class="comment">// java/lang/Exception</span></span><br><span class="line">  #<span class="number">14</span> = Methodref          #<span class="number">13.</span>#<span class="number">69</span>        <span class="comment">// java/lang/Exception.printStackTrace:()V</span></span><br><span class="line">  #<span class="number">15</span> = Class              #<span class="number">70</span>            <span class="comment">// java/lang/String</span></span><br><span class="line">  #<span class="number">16</span> = Methodref          #<span class="number">19.</span>#<span class="number">71</span>        <span class="comment">// MethodInnerStrucTest.compareTo:(Ljava/lang/String;)I</span></span><br><span class="line">  #<span class="number">17</span> = String             #<span class="number">72</span>            <span class="comment">// 测试方法的内部结构</span></span><br><span class="line"><span class="comment">// 省略 ...</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> num; <span class="comment">// 域信息</span></span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: <span class="function">ACC_PUBLIC</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>; <span class="comment">// 方法信息</span></span><br><span class="line">    descriptor: ()V    <span class="comment">// 方法返回值</span></span><br><span class="line">    flags: ACC_PUBLIC  <span class="comment">// 方法修饰符 </span></span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span> <span class="comment">//方法字节码信息</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">20</span></span><br><span class="line">         <span class="number">2</span>: istore_1</span><br><span class="line">         <span class="number">3</span>: getstatic     #<span class="number">5</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">6</span>: <span class="keyword">new</span>           #<span class="number">6</span>                  <span class="comment">// class java/lang/StringBuilder</span></span><br><span class="line">         <span class="number">9</span>: dup</span><br><span class="line">        <span class="number">10</span>: invokespecial #<span class="number">7</span>                  <span class="comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        <span class="number">13</span>: ldc           #<span class="number">8</span>                  <span class="comment">// String count =</span></span><br><span class="line">        <span class="number">15</span>: invokevirtual #<span class="number">9</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">        <span class="number">18</span>: iload_1</span><br><span class="line">        <span class="number">19</span>: invokevirtual #<span class="number">10</span>                 <span class="comment">// Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span></span><br><span class="line">        <span class="number">22</span>: invokevirtual #<span class="number">11</span>                 <span class="comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">        <span class="number">25</span>: invokevirtual #<span class="number">12</span>                 <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">        <span class="number">28</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">13</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">14</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">15</span>: <span class="number">28</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">29</span>     <span class="number">0</span>  <span class="keyword">this</span>   LMethodInnerStrucTest;</span><br><span class="line">            <span class="number">3</span>      <span class="number">26</span>     <span class="number">1</span> count   I</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         <span class="number">0</span>: ldc           #<span class="number">17</span>                 <span class="comment">// String 测试方法的内部结构</span></span><br><span class="line">         <span class="number">2</span>: putstatic     #<span class="number">18</span>                 <span class="comment">// Field str:Ljava/lang/String;</span></span><br><span class="line">         <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">Signature: #<span class="number">52</span>                          <span class="comment">// Ljava/lang/Object;Ljava/lang/Comparable&lt;Ljava/lang/String;&gt;;Ljava/io/Serializable;</span></span><br><span class="line">SourceFile: <span class="string">&quot;MethodInnerStructTest.java&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="字符串常量池-StringTable-为什么要调整位置？"><a href="#字符串常量池-StringTable-为什么要调整位置？" class="headerlink" title="字符串常量池 StringTable 为什么要调整位置？"></a>字符串常量池 StringTable 为什么要调整位置？</h3><p>JDK7中将StringTable放到了堆空间中。<strong>因为永久代的回收效率很低</strong>，在Full GC的时候才会执行永久代的垃圾回收，而Full GC是老年代的空间不足、永久代不足时才会触发。</p>
<p>这就导致StringTable回收效率不高，而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。<strong>放到堆里，能及时回收内存</strong>。</p>
<h3 id="静态变量对象存放在哪里？"><a href="#静态变量对象存放在哪里？" class="headerlink" title="静态变量对象存放在哪里？"></a>静态变量对象存放在哪里？</h3><p>静态变量引用对应的对象实体始终都在堆空间中（符合堆的内存分配规则） ，变量引用放在了元空间。</p>
<p><img src="/pics/image-20210418203012633.png" alt="image-20210418203012633"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 结论：</span></span><br><span class="line"><span class="comment"> *  静态变量在jdk6/7存在与永久代中，在jdk8存在于堆中 //private static byte[] arr</span></span><br><span class="line"><span class="comment"> *  静态引用对应的对象实体始终都存在堆空间 //new byte[1024 * 1024 * 100];</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * jdk7：</span></span><br><span class="line"><span class="comment"> * -Xms200m -Xmx200m -XX:PermSize=300m -XX:MaxPermSize=300m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> * jdk 8：</span></span><br><span class="line"><span class="comment"> * -Xms200m -Xmx200m -XX:MetaspaceSize=300m -XX:MaxMetaspaceSize=300m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticFieldTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>]; <span class="comment">//100MB</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(StaticFieldTest.arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h3><p>方法区内常量池之中主要存放的两大类常量：<strong>字面量和符号引用</strong></p>
<ul>
<li>字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等</li>
<li>符号引用则属于编译原理方面的概念，包括下面三类常量：<ul>
<li>类和接口的全限定名</li>
<li>域（字段）的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
</li>
</ul>
<p>HotSpot虚拟机对常量池的回收策略是很明确的，<code>只要运行时常量池中的常量没有被任何地方引用，就可以被回收</code>。</p>
<p>而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了</p>
<ul>
<li><strong>该类所有的实例都已经被回收</strong>，也就是Java堆中不存在该类及其任何派生子类的实例。</li>
<li><strong>该类的类加载器已经被回收</strong>，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</li>
<li><strong>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</strong></li>
</ul>
<p>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用<code>-verbose:class 以及 -XX：+TraceClass-Loading、-XX：+TraceClassUnLoading</code>查看类加载和卸载信息。</p>
<p>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及 OSGi 这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</p>
<h3 id="大厂面试题"><a href="#大厂面试题" class="headerlink" title="大厂面试题"></a>大厂面试题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">百度</span><br><span class="line"></span><br><span class="line">三面：说一下JVM内存模型吧，有哪些区？分别干什么的？</span><br><span class="line">字节跳动</span><br><span class="line"></span><br><span class="line">二面：Java的内存分区</span><br><span class="line">二面：讲讲vm运行时数据库区</span><br><span class="line">什么时候对象会进入老年代？</span><br><span class="line">蚂蚁金服</span><br><span class="line"></span><br><span class="line">Java8的内存分代改进</span><br><span class="line">JVM内存分哪几个区，每个区的作用是什么？</span><br><span class="line">一面：JVM内存分布/内存结构？栈和堆的区别？堆的结构？为什么两个survivor区？</span><br><span class="line">二面：Eden和survior的比例分配</span><br><span class="line">小米</span><br><span class="line"></span><br><span class="line">jvm内存分区，为什么要有新生代和老年代</span><br><span class="line">京东</span><br><span class="line"></span><br><span class="line">JVM的内存结构，Eden和Survivor比例。</span><br><span class="line">JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和survivor。</span><br><span class="line">天猫</span><br><span class="line"></span><br><span class="line">一面：Jvm内存模型以及分区，需要详细到每个区放什么。</span><br><span class="line">一面：JVM的内存模型，Java8做了什么改</span><br><span class="line">拼多多</span><br><span class="line"></span><br><span class="line">JVM内存分哪几个区，每个区的作用是什么？</span><br><span class="line">美团</span><br><span class="line"></span><br><span class="line">java内存分配</span><br><span class="line">jvm的永久代中会发生垃圾回收吗？</span><br><span class="line">一面：jvm内存分区，为什么要有新生代和老年代</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JAVA</category>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>JVM_09_JVM_GC</title>
    <url>/2021/07/24/Notes/Java/01JVM/JVM_09_JVM_GC/</url>
    <content><![CDATA[<h1 id="JVM-09-JVM-GC"><a href="#JVM-09-JVM-GC" class="headerlink" title="JVM_09_JVM_GC"></a>JVM_09_JVM_GC</h1><span id="more"></span>

<h2 id="哪里的内存需要回收？"><a href="#哪里的内存需要回收？" class="headerlink" title="哪里的内存需要回收？"></a>哪里的内存需要回收？</h2><p>JVM GC只回收<code>堆和方法区内的对象</code>。而栈区的数据，在超出作用域后会被JVM自动释放掉，所以其不在JVM GC的管理范围内。</p>
<h2 id="如何判断对象可以回收？"><a href="#如何判断对象可以回收？" class="headerlink" title="如何判断对象可以回收？"></a>如何判断对象可以回收？</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>给对象中添加一个<code>引用计数器</code>，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p>
<p>它的优点是简单、高效，但是缺点也是异常明显：无法解决<code>对象循环引用</code>的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象循环引用示例</span></span><br><span class="line">Object objectA = <span class="keyword">new</span> Object();</span><br><span class="line">Object objectB = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">objectA.instance = objectB;</span><br><span class="line">objectB.instance = objectA;</span><br><span class="line"></span><br><span class="line">objectA = <span class="keyword">null</span>;</span><br><span class="line">objectB = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">System.gc();</span><br></pre></td></tr></table></figure>
<p>假设我们有上面的代码。程序启动后，objectA和objectB两个对象被创建并在堆中分配内存，它们都相互持有对方的引用，但是除了它们相互持有的引用之外，再无别的引用。</p>
<p>而实际上，引用已经被置空，这两个对象不可能再被访问了，但是因为它们相互引用着对方，导致它们的引用计数都不为0，因此引用计数算法无法通知GC回收它们，造成了内存的浪费。如下图：对象之间的引用形成一个有环图。<br><img src="/pics/image-20210417183019446.png" alt="image-20210417183019446" style="zoom:50%;" /></p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>通过一系列称为<code>GC Roots</code>的对象作为起始点，从这些节点开始向下搜索，搜索所走过的引用路径称为<code>引用链（Reference Chain）</code>，当一个对象到GC Roots 没有任何的引用链相连时，则证明此对象不可用的，是可以被回收的。</p>
<img src="/pics/image-20210417184107213.png" alt="image-20210417184107213" style="zoom:30%;" />

<h4 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h4><p>在 Java 语言中，可作为 GC Root 的对象包括以下 4 种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象（static）</li>
<li>方法区中常量引用的对象（static final）</li>
<li>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象</li>
</ul>
<h4 id="Java引用"><a href="#Java引用" class="headerlink" title="Java引用"></a>Java引用</h4><p>Java 中的引用类型总共有四种：强引用，软引用，弱引用，虚引用。</p>
<ul>
<li><p>强引用就是最普通的对象引用，每当 new 一个对象的时候，都是生成一个强引用。这种引用对垃圾回收免疫，即使发生 OOM，这种对象也不会被回收。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure></li>
<li><p>软引用的强度相对弱一些，用来描述一些还有用但非必须的对象。在发生 OOM 之前，JVM 会尝试去回收这些对象，软引用的实现类是 SoftReference。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Object();</span><br><span class="line">SoftReference srf = <span class="keyword">new</span> SoftReference(o);</span><br></pre></td></tr></table></figure></li>
<li><p>弱引用就更弱了，用来描述一些非必需对象，碰上了垃圾回收，弱引用的对象肯定会被回收，弱引用的实现类是 WeakReference。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Object();</span><br><span class="line">WeakReference wrf = <span class="keyword">new</span> WeakReference(o);</span><br></pre></td></tr></table></figure></li>
<li><p>虚引用无法引用对象，实际只是做一些垃圾清理之后的事情, 虚引用的实现类是 PhantomReference。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object o = new Object();</span><br><span class="line">ReferenceQueue rq = new ReferenceQueue();</span><br><span class="line">PhantomReference prf = new PhantomReference(o, rq);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>上面的各种引用都继承了 Reference 类，Reference 类中有一个 get 方法，如果软引用和弱引用所指向的对象没有被回收，那么使用 get 方法就可以获取原对象的引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Object();</span><br><span class="line">SoftReference srf = <span class="keyword">new</span> SoftReference(o);</span><br><span class="line">o = <span class="keyword">null</span>; <span class="comment">// 断开强引用</span></span><br><span class="line">System.out.println(srf.get()); <span class="comment">// java.lang.Object@17579e0f</span></span><br></pre></td></tr></table></figure>

<p>虚引用 PhantomReference 的 get 方法会一直返回 null，所以无法通过虚引用获取到对象。虚引用的意义在于提供了一种在对象被回收之后做某些事情的机制，在这里就需要谈到引用队列。</p>
<p>ReferenceQueue 称之为引用队列。如果我们为一个引用指定一个引用队列，那么这个引用所指向的队列在被垃圾回收后，该引用就会被加入到引用队列中。</p>
<p>我们就可以根据引用队列中的引用来判断某个对象是否被回收，或者直接清除引用队列的引用对象，具体的逻辑要看具体的业务场景。</p>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记 - 清除算法"></a>标记 - 清除算法</h3><p>“标记-清除”（Mark-Sweep）算法，如同它的名字一样，算法分为“标记”和“清除”两个阶段：</p>
<ul>
<li>首先标记出所有需要回收的对象</li>
<li>在标记完成后统一回收所有被标记的对象</li>
</ul>
<p>主要不足有两个：</p>
<ol>
<li><p>效率问题</p>
<p>标记和清除两个过程的效率都不高；</p>
</li>
<li><p>空间问题</p>
<p>标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>
</li>
</ol>
<img src="/pics/image-20210417202955925.png" alt="image-20210417202955925" style="zoom:50%;" />

<h4 id="可达性算法中的标记"><a href="#可达性算法中的标记" class="headerlink" title="可达性算法中的标记"></a>可达性算法中的标记</h4><p>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize方法。当对象没有覆盖finalize方法，或者finalize方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</p>
<p>如果这个对象被判定为有必要执行finalize方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。</p>
<p>finalize方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。</p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p>
<p>这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。</p>
<p>不足：内存缩小为了原来的一半。</p>
<img src="/pics/image-20210417204202632.png" alt="image-20210417204202632" style="zoom:50%;" />

<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记 - 整理算法"></a>标记 - 整理算法</h3><p>“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</p>
<img src="/pics/image-20210417204307864.png" alt="image-20210417204307864" style="zoom:50%;" />

<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，根据对象存活周期的不同将内存划分为几块，各再根据个年代的特点采用最适当的收集算法。</p>
<p><strong>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法</strong>，只需要付出少量存活对象的复制成本就可以完成收集。</p>
<p>老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。</p>
<h2 id="HotSpot的算法实现"><a href="#HotSpot的算法实现" class="headerlink" title="HotSpot的算法实现"></a>HotSpot的算法实现</h2><h3 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h3><p>Stop The World + OopMap(类加载完成后，特定位置记录类引用的类型数据的地址)</p>
<p>可达性分析时为<code>保证结果准确性，不可出现分析过程中对象引用关系还在不断变化的情况</code>，所以GC进行时必须停顿所有Java执行线程（称为“Stop The World”）。</p>
<p>当进入STW状态时，虚拟机需要知道哪些地方放着对象引用。在HotSpot的实现中，是使用一组称为<strong>OopMap</strong>的数据结构来达到这个目的的，在类加载完成的时候，<code>HotSpot就把对象内什么偏移量上是什么类型的数据计算出来</code>，在JIT编译过程中，也会在<strong>特定的位置</strong>记录下栈和寄存器中哪些位置是引用。这样，GC在扫描时就可以直接得知这些信息了。</p>
<h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举，但一个很现实的问题随之而来：可能导致引用关系变化（OopMap内容变化）的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本将会变得很高。</p>
<p>HotSpot也的确没有为每条指令都生成OopMap，前面已经提到，只是在“特定的位置”记录了这些信息，这些位置称为安全点（Safepoint），只有在到达安全点时才能暂停。</p>
<p>安全点的选定基本上是以程序<code>是否具有让程序长时间执行的特征</code>为标准进行选定的，“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生Safepoint。</p>
<h4 id="抢先式中断和主动式中断"><a href="#抢先式中断和主动式中断" class="headerlink" title="抢先式中断和主动式中断"></a>抢先式中断和主动式中断</h4><p>对于Sefepoint，另一个需要考虑的问题是如何在GC发生时让所有线程都“跑”到最近的安全点上再停顿下来。</p>
<ul>
<li><p>抢先式中断（Preemptive Suspension）</p>
<p>不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。</p>
</li>
<li><p>主动式中断（Voluntary Suspension）</p>
<p>当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。</p>
</li>
</ul>
<p>现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。</p>
<h3 id="安全区"><a href="#安全区" class="headerlink" title="安全区"></a>安全区</h3><p>Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”（没有分配CPU时间）的时候呢？比如线程处于Sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全的地方去中断挂起，JVM也显然不太可能等待线程重新被分配CPU时间。对于这种情况，就需要安全区域（Safe Region）来解决。</p>
<p><code>安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。</code></p>
<p>在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。</p>
<p>在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。</p>
<h2 id="HotSpot垃圾收集器"><a href="#HotSpot垃圾收集器" class="headerlink" title="HotSpot垃圾收集器"></a>HotSpot垃圾收集器</h2><img src="/pics/image-20210417210644456.png" alt="image-20210417210644456" style="zoom:33%;" />

<blockquote>
<p>说明：如果两个垃圾回收器之间存在连线说明他们之间是可以搭配使用的</p>
</blockquote>
<h3 id="Serial-和-Serial-Old-回收器"><a href="#Serial-和-Serial-Old-回收器" class="headerlink" title="Serial 和 Serial Old 回收器"></a>Serial 和 Serial Old 回收器</h3><p>Serial</p>
<ul>
<li>工作在新生代</li>
<li>复制算法</li>
<li>单线程的垃圾回收器，当垃圾回收线程开始的时候，工作（业务）线程必须暂停</li>
</ul>
<p>Serial Old</p>
<ul>
<li>工作在老年代</li>
<li>标记-整理算法<img src="/pics/image-20210417213537906.png" alt="image-20210417213537906" style="zoom:50%;" /></li>
</ul>
<h3 id="ParNew-回收器"><a href="#ParNew-回收器" class="headerlink" title="ParNew 回收器"></a>ParNew 回收器</h3><ul>
<li>ParNew可以认为是Serial的<code>多线程</code>版本</li>
<li>ParNew是<code>多线程并行</code>回收的，回收时<code>工作线程</code>必须暂停</li>
</ul>
<img src="/pics/image-20210417211623550.png" alt="image-20210417211623550" style="zoom:50%;" />

<blockquote>
<p>注意　从ParNew收集器开始，后面还会接触到几款并发和并行的收集器。并发和并行。这两个名词都是并发编程中的概念，在谈论垃圾收集器的上下文语境中，它们可以解释如下。</p>
<p>●并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于暂停（等待）状态。</p>
<p>●并发（Concurrent）：指工作（用户）线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上</p>
</blockquote>
<h3 id="Parallel-Scavenge-Parallel-Old-回收器"><a href="#Parallel-Scavenge-Parallel-Old-回收器" class="headerlink" title="Parallel Scavenge/Parallel Old 回收器"></a>Parallel Scavenge/Parallel Old 回收器</h3><p>Parallel Scavenge </p>
<ul>
<li>新生代</li>
<li>复制算法</li>
<li>使用多线程进行垃圾回收，回收时工作线程处于暂停状态</li>
</ul>
<p>Parallel Old </p>
<ul>
<li>是 Parallel Scavenge 的老年代版本，也就是说<code>Parallel Old</code>工作在<code>老年代</code></li>
<li>标记-整理</li>
<li>多线程并行</li>
</ul>
<p>JDK1.8默认采用的垃圾回收器：Parallel Scavenge、Parallel Old</p>
<img src="/pics/image-20210417212833916.png" alt="image-20210417212833916" style="zoom:50%;" />

<p>Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是<code>尽可能地缩短垃圾收集时用户线程的停顿时间</code>，而Parallel Scavenge收集器的目标则是<code>达到一个可控制的吞吐量（Throughput）</code>。</p>
<p>Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX：MaxGCPauseMillis）以及直接设置吞吐量大小的-XX：GCTimeRatio参数。</p>
<p>MaxGCPauseMillis参数允许的值是一个大于0的毫秒数，收集器将尽可能地保证内存回收花费的时间不超过设定值。不过大家不要认为如果把这个参数的值设置得稍小一点就能使得系统的垃圾收集速度变得更快，<code>GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的</code>：系统把新生代调小一些，收集300MB新生代肯定比收集500MB快吧，这也直接导致垃圾收集发生得更频繁一些，原来10秒收集一次、每次停顿100毫秒，现在变成5秒收集一次、每次停顿70毫秒。停顿时间的确在下降，但吞吐量也降下来了。</p>
<h3 id="CMS-回收器"><a href="#CMS-回收器" class="headerlink" title="CMS 回收器"></a>CMS 回收器</h3><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。</p>
<ul>
<li><p>老年代</p>
</li>
<li><p>CMS是<code>多线程并发</code>的，也就是说<code>垃圾线程</code>和<code>工作线程</code>是可以<code>一起执行</code>的</p>
</li>
<li><p>采用 <code>标记-清除</code> 算法实现</p>
</li>
<li><p>运行步骤：</p>
<ul>
<li>初始标记(CMS initial mark)：标记 GC Roots 能直接关联到的对象</li>
<li>并发标记(CMS concurrent mark)：进行 GC Roots Tracing</li>
<li>重新标记(CMS remark)：修正并发标记期间的变动部分<ul>
<li>这里要注意：重新标记就不能业务线程和垃圾线程一起执行了，也就是不能并发执行了</li>
</ul>
</li>
<li>并发清除(CMS concurrent sweep)</li>
</ul>
</li>
</ul>
<img src="/pics/image-20210417222939099.png" alt="image-20210417222939099" style="zoom:50%;" />

<h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4><ul>
<li><p>CMS收集器对CPU资源非常敏感</p>
<p>在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。</p>
</li>
<li><p>CMS收集器无法处理浮动垃圾（Floating Garbage）</p>
<p>由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”。</p>
<p>也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。</p>
</li>
<li><p>CMS是一款基于“标记—清除”算法实现的收集器。</p>
<p>收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。</p>
</li>
</ul>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><ul>
<li>Java堆，划分成一个个Region</li>
<li>标记- 整理 （整体上看）</li>
<li>运作步骤：<ul>
<li>初始标记(Initial Marking)</li>
<li>并发标记(Concurrent Marking)</li>
<li>最终标记(Final Marking)</li>
<li>筛选回收(Live Data Counting and Evacuation)</li>
</ul>
</li>
</ul>
<p><img src="/pics/image-20210417215936579.png" alt="image-20210417215936579"></p>
<p>G1优点</p>
<ol>
<li>并行与并发：多线程并行回收；工作线程和GC线程并发执行</li>
<li>分代收集：采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象</li>
<li>空间整合：G1从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的。没有CMS标记—清理的缺点。</li>
<li>可预测的停顿：这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</li>
</ol>
<h4 id="Region"><a href="#Region" class="headerlink" title="Region"></a>Region</h4><p>使用G1收集器时，Java堆的内存布局就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。</p>
<p>G1跟踪各个Region里面的垃圾堆积的价值大小<code>（回收所获得的空间大小以及回收所需时间的经验值）</code>，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</p>
<h4 id="Remembered-Set"><a href="#Remembered-Set" class="headerlink" title="Remembered Set"></a>Remembered Set</h4><p>在G1收集器中，Region之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，虚拟机都是使用Remembered Set来避免全堆扫描的。G1中每个Region都有一个与之对应的Remembered Set，虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，<code>检查Reference引用的对象是否处于不同的Region之中，如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set之中</code>。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。</p>
<h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><ol>
<li><p>对象优先在Eden分配</p>
</li>
<li><p>大对象直接进入老年代</p>
</li>
<li><p>长期存活的对象将进入老年代</p>
</li>
<li><p>动态对象年龄判定</p>
<p>为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold（默认15）才能晋升老年代。</p>
<p>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</p>
</li>
<li><p>空间分配担保</p>
<p>在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。</p>
<p>如果不成立，则虚拟机会判断是否允许<code>冒险担保失败（HandlePromotionFailure）</code>。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者不允许冒险担保，那这时也要改为进行一次Full GC。</p>
</li>
</ol>
<p>“冒险”是冒了什么风险？</p>
<blockquote>
<p>前面提到过，新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。</p>
<p>与生活中的贷款担保类似，老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象会活下来在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。</p>
</blockquote>
<p>Minor GC和Full GC有什么不一样吗？</p>
<blockquote>
<p>新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。</p>
<p>老年代GC（Major GC/Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。</p>
</blockquote>
]]></content>
      <categories>
        <category>JAVA</category>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>JVM_06_堆</title>
    <url>/2021/04/17/Notes/Java/01JVM/JVM_06_%E5%A0%86/</url>
    <content><![CDATA[<h1 id="JVM-06-堆"><a href="#JVM-06-堆" class="headerlink" title="JVM_06_堆"></a>JVM_06_堆</h1><span id="more"></span>

<p>堆（Heap）存放对象实例，几乎所有的对象实例以及数据都在这里分配内存。</p>
<p>一个进程对应一个JVM实例，一个JVM实例对应一个堆空间进程包含多个线程，所以线程之间共享同一个堆空间堆也是Java内存管理的核心区域。</p>
<ul>
<li>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了，堆是JVM管理的最大一块内存空间，它的大小是可以调节的。</li>
<li>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</li>
<li>《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。</li>
<li>《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。从实际使用角度看的：“几乎”所有的对象实例都在这里分配内存。因为还有一些对象是在栈上分配的（逃逸分析，标量替换）</li>
<li>堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集（GC）的时候才会被移除。如果堆中对象马上被回收，那么用户线程就会收到影响，因为有 stop the word。</li>
</ul>
<img src="/pics/image-20210415113030622.png" alt="image-20210415113030622" style="zoom:80%;" />

<h2 id="内存划分"><a href="#内存划分" class="headerlink" title="内存划分"></a>内存划分</h2><p>Java 8之前堆内存逻辑上分为三部分：<strong>新生代 + 老年代 + 永久代</strong>，新生代又可划分为 <strong>Eden区 和 Survivor区</strong>。</p>
<p><img src="/pics/image-20210415152003048.png" alt="image-20210415152003048"></p>
<p>Java 8及之后堆内存，<code>永久代</code> 被替换成 <code>元空间</code>，<code>永久代/元空间</code>，实际上控制不到。</p>
<img src="/pics/image-20210415115152421.png" alt="image-20210415115152421" style="zoom:70%;" />



<h3 id="新生代-Young-Generation"><a href="#新生代-Young-Generation" class="headerlink" title="新生代 (Young Generation)"></a>新生代 (Young Generation)</h3><p>年轻代是所有新对象创建的地方。当填充年轻代时，执行垃圾收集。这种垃圾收集称为 <strong>Minor GC</strong>。年轻代被分为三个部分伊甸园（<strong>Eden Memory</strong>）和两个幸存区（<strong>Survivor Memory</strong>，被称为from/to或s0/s1），默认比例是<code>8:1:1</code></p>
<h3 id="老年代-Old-Generation"><a href="#老年代-Old-Generation" class="headerlink" title="老年代(Old Generation)"></a>老年代(Old Generation)</h3><p>经过多轮MinorGC 后仍然存活的对象被移动到老年代。JVM默认<strong>新生代和老年代的比例是1：2</strong>。老年代垃圾收集MajorGC，通常需要更长的时间。</p>
<p>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象），目的是避免在Eden区和两个Survivor 区之间发生大量的内存拷贝。</p>
<h3 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h3><p>不管是 JDK8 之前的永久代，还是 JDK8 及以后的元空间，都可以看作是 Java 虚拟机规范中方法区的实现。</p>
<p>虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 <strong>Non-Heap（非堆）</strong>，目的应该是与 Java 堆区分开。所以元空间放在后边的方法区再说。</p>
<h2 id="对象分配的过程"><a href="#对象分配的过程" class="headerlink" title="对象分配的过程"></a>对象分配的过程</h2><p><img src="/pics/image-20210415162006461.png" alt="image-20210415162006461"></p>
<blockquote>
<p>注意：上图中的FullGC可以理解为老年代GC ，等价于 MajorGC，不区分majorGC和FullGC。</p>
</blockquote>
<h3 id="图解对象分配"><a href="#图解对象分配" class="headerlink" title="图解对象分配"></a>图解对象分配</h3><ol>
<li>我们创建的对象，一般都是存放在Eden区的，<strong>当我们的Eden区满了后，就会触发GC操作</strong>，一般被称为 <code>YGC / Minor GC</code>操作</li>
</ol>
<p><img src="/pics/image-20210415155215283.png" alt="image-20210415155215283"></p>
<ol start="2">
<li><p>当我们进行一次垃圾收集后，红色的对象将会被回收，而绿色的独享还被占用着，存放在S0(Survivor From)区。同时我们给每个对象设置了一个年龄计数器，经过一次回收后还存在的对象，将其年龄加 1。</p>
</li>
<li><p>同时Eden区继续存放对象，当Eden区再次存满的时候，又会触发一个MinorGC操作，此时GC将会把 Eden和S0中的对象进行一次垃圾收集，把存活的对象放到 S1区，同时让存活的对象年龄 + 1</p>
<p><img src="/pics/image-20210415155539388.png" alt="image-20210415155539388"></p>
</li>
<li><p>此时若再次经历MinorGC，又会对Eden区和S1区进行清理，剩下的对象放到S0区，也就是说S0和S1（from和to）在minorGC时<code>逻辑上</code>是不停交换的</p>
</li>
<li><p>我们继续不断的进行对象生成和垃圾回收，当Survivor中的对象的年龄达到15的时候（-XX:MaxTenuringThreshold 设置），将会触发一次 <code>Promotion 晋升</code>的操作，也就是将年轻代中的对象晋升到老年代中</p>
</li>
</ol>
<p><img src="/pics/image-20210415155419659.png" alt="image-20210415155419659"></p>
<blockquote>
<p>注意：在Eden区满了的时候，才会触发MinorGC，而Survivor区满了，不会触发MinorGC操作</p>
</blockquote>
<h3 id="对象分配的特殊情况"><a href="#对象分配的特殊情况" class="headerlink" title="对象分配的特殊情况"></a>对象分配的特殊情况</h3><ol>
<li><p><strong>Eden区存放对象</strong></p>
<ol>
<li>如果 Eden 放得下，则直接放到 Eden 区</li>
<li>如果 Eden 放不下，则触发 MinorGc，执行垃圾回收；如果还不能放下，则直接放入到老年代</li>
<li>如果 Eden 区满了，MinorGC完将对象往Survivor拷贝时，发现Survivor放不下，直接晋升至老年代</li>
</ol>
</li>
<li><p><strong>将对象存放到老年代</strong></p>
<ul>
<li>如果 Eden 执行了MinorGc 还是无法放不下该对象，说明是超大对象，只能直接放到到老年代</li>
<li>老年代都放不下，则先触发MajorGC ，再看看能不能放下，如果还是放不下，就会报 OOM</li>
</ul>
</li>
</ol>
<h3 id="对象分配原则"><a href="#对象分配原则" class="headerlink" title="对象分配原则"></a>对象分配原则</h3><ul>
<li>new 对象优先分配到Eden</li>
<li>大对象直接分配到老年代</li>
<li>长期存活的对象分配到老年代</li>
<li><strong>动态对象年龄判断</strong>：如果Survivor区中相同年龄的所有对象大小的总和 大于 Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</li>
<li><strong>空间分配担保</strong>：经过Minor GC后，所有的对象都存活，因为Survivor比较小，所以就需要将Survivor无法容纳的对象，存放到老年代中</li>
</ul>
<h3 id="相关JVM参数"><a href="#相关JVM参数" class="headerlink" title="相关JVM参数"></a>相关JVM参数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 设置堆空间大小的参数</span></span><br><span class="line"><span class="comment"> * -Xms 用来设置堆空间（年轻代+老年代）的初始内存大小</span></span><br><span class="line"><span class="comment"> *      -X 是jvm的运行参数</span></span><br><span class="line"><span class="comment"> *      ms 是memory start</span></span><br><span class="line"><span class="comment"> * -Xmx 用来设置堆空间（年轻代+老年代）的最大内存大小</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. 默认堆空间的大小</span></span><br><span class="line"><span class="comment"> *      初始内存大小：物理电脑内存大小 / 64</span></span><br><span class="line"><span class="comment"> *      最大内存大小：物理电脑内存大小 / 4</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3. 手动设置：-Xms600m -Xmx600m</span></span><br><span class="line"><span class="comment"> *     开发中建议将初始堆内存和最大的堆内存设置成相同的值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 4. 查看设置的参数：方式一： jps   /  jstat -gc 进程id</span></span><br><span class="line"><span class="comment"> *                  方式二：-XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSpaceInitial</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回Java虚拟机中的堆内存总量</span></span><br><span class="line">        <span class="keyword">long</span> initialMemory = Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">        <span class="comment">//返回Java虚拟机试图使用的最大堆内存量</span></span><br><span class="line">        <span class="keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-Xms : &quot;</span> + initialMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-Xmx : &quot;</span> + maxMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Minor-GC、Major-GC、Full-GC"><a href="#Minor-GC、Major-GC、Full-GC" class="headerlink" title="Minor GC、Major GC、Full GC"></a>Minor GC、Major GC、Full GC</h2><p>JVM在进行GC时，并非每次都对上面三个内存( 新生代、老年代；方法区 )区域一起回收的，大部分时候回收的都是指新生代。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）</p>
<p>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：</p>
<ul>
<li><strong>新生代收集（ Minor GC/Young GC ）</strong>：只是新生代( Eden、S0/S1 )的垃圾收集</li>
<li><strong>老年代收集（ Major GC/Old GC</strong> ）：只是老年代的垃圾收集<ul>
<li>目前，只有CMS GC会有单独收集老年代的行为</li>
<li><code>注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</code></li>
</ul>
</li>
<li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。目前，只有G1 GC会有这种行为</li>
<li><strong>整堆收集（Full GC）</strong>：收集整个java堆和方法区的垃圾收集</li>
</ul>
<h3 id="新生代-GC（Minor-GC）触发机制"><a href="#新生代-GC（Minor-GC）触发机制" class="headerlink" title="新生代 GC（Minor GC）触发机制"></a>新生代 GC（Minor GC）触发机制</h3><p>当新生代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden区满，Survivor区满不会触发GC。（每次Minor GC会清理年轻代的内存）</p>
<p>因为Java对象<code>大多都具备朝生夕灭</code>的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解</p>
<p>Minor GC会引发STW，暂停其它用户的线程，等待垃圾回收线程结束，用户线程才恢复运行</p>
<h3 id="老年代GC（Major-GC）-触发机制"><a href="#老年代GC（Major-GC）-触发机制" class="headerlink" title="老年代GC（Major GC） 触发机制"></a>老年代GC（Major GC） 触发机制</h3><ul>
<li>指发生在老年代的GC，对象从老年代消失时，我们说 “Major Gc” 或 “Full GC” 发生了</li>
<li>出现了MajorGc，经常会伴随至少一次的Minor GC但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程<ul>
<li>也就是在老年代空间不足时，会先尝试触发Minor GC，如果之后空间还不足，则触发Major GC</li>
</ul>
</li>
<li>Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长</li>
<li>如果Major GC后，内存还不足，就报OOM了</li>
</ul>
<h3 id="整堆收集（Full-GC）触发机制"><a href="#整堆收集（Full-GC）触发机制" class="headerlink" title="整堆收集（Full GC）触发机制"></a>整堆收集（Full GC）触发机制</h3><ol>
<li><p>调用System.gc( )时，系统建议执行Full GC，但是不必然执行</p>
</li>
<li><p>老年代空间不足</p>
</li>
<li><p>方法区空间不足</p>
</li>
<li><p>通过Minor GC后进入老年代的平均大小 大于 老年代的可用内存</p>
</li>
<li><p>由Eden和From区 向 To 区复制时，对象大小大于To 区的可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</p>
<p>说明：Full GC 是开发或调优中尽量要避免的。这样STW时间会短一些。</p>
</li>
</ol>
<h2 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h2><p>TLAB：Thread Local Allocation Buffer，Eden为每个线程单独分配了一个私有缓冲区域</p>
<ul>
<li><strong>JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内</strong>。</li>
<li>多线程同时分配内存时，<strong>使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量</strong>，因此我们可以将这种内存分配方式称之为<strong>快速分配策略</strong>。</li>
</ul>
<p><img src="/pics/image-20210415212342136.png" alt="image-20210415212342136"></p>
<h3 id="为什么有TLAB（Thread-Local-Allocation-Buffer）？"><a href="#为什么有TLAB（Thread-Local-Allocation-Buffer）？" class="headerlink" title="为什么有TLAB（Thread Local Allocation Buffer）？"></a>为什么有TLAB（Thread Local Allocation Buffer）？</h3><ul>
<li>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</li>
<li>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li>
<li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</li>
</ul>
<h3 id="TLAB-分配过程"><a href="#TLAB-分配过程" class="headerlink" title="TLAB 分配过程"></a>TLAB 分配过程</h3><ul>
<li><p>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选</p>
</li>
<li><p>在程序中，开发人员可以通过选项“-XX:UseTLAB”设置是否开启TLAB空间</p>
</li>
<li><p>默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选项“-</p>
<p>XX:TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小</p>
</li>
<li><p>一旦对象在TLAB空间分配内存失败时，<strong>JVM就会尝试着通过使用加锁机制确保数据操作的原子性</strong>，从而直接在Eden空间中分配内存</p>
</li>
</ul>
<p>也就是说，JVM分配对象时预先会尝试分配在TLAB上，如果对象较大，无法分配在 TLAB 上，则JVM会试图直接分配在Eden其他位置上。</p>
<img src="/pics/image-20210415211025999.png" alt="image-20210415211025999" style="zoom:80%;" />

<h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><p>逃逸分析，根据新对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p>
<p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p>
<p>逃逸分析的基本行为就是分析对象动态作用域：</p>
<ul>
<li><strong>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸</strong>。</li>
<li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li>
</ul>
<p>使用逃逸分析，编译器可以对代码做如下优化：</p>
<ul>
<li>栈上分配</li>
<li>同步省略</li>
<li>分离对象或标量替换</li>
</ul>
<h3 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h3><ul>
<li>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。</li>
<li>分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</li>
</ul>
<h3 id="同步省略"><a href="#同步省略" class="headerlink" title="同步省略"></a>同步省略</h3><ul>
<li><p>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</p>
</li>
<li><p>在动态编译同步块的时候，<code>JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程</code>。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫<code>锁消除</code>。</p>
</li>
</ul>
<h3 id="分离对象或标量替换"><a href="#分离对象或标量替换" class="headerlink" title="分离对象或标量替换"></a>分离对象或标量替换</h3><ul>
<li>标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</li>
<li>相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</li>
<li>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point point = <span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;point.x&quot;</span> + point.x + <span class="string">&quot;;point.y&quot;</span> + point.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上代码，经过标量替换后，就会变成</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;point.x = &quot;</span> + x + <span class="string">&quot;; point.y=&quot;</span> + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于逃逸分析的论文在1999年就已经发表了，但直到JDK 1.6才有实现，而且这项技术到如今也并不是十分成熟的。</p>
<p><strong>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</strong></p>
<p>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p>
<p>虽然这项技术并不十分成熟，但是他也是即时编译器优化技术中一个十分重要的手段。</p>
<p><strong>Oracle Hotspot JVM中并未这么做</strong>，Oracle Hotspot JVM是通过标量替换实现逃逸分析的</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>新生代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</p>
<p>当然，也有特殊情况，我们知道普通的对象可能会被分配在TLAB上。如果对象较大，无法分配在 TLAB 上，则JVM会试图直接分配在Eden其他位置上。如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代</p>
</li>
<li><p>老年代放置长生命周期的对象，通常都是从Survivor区域筛选拷贝过来的Java对象。</p>
</li>
<li><p>当GC只发生在新生代中，回收新生代对象的行为被称为Minor GC</p>
</li>
<li><p>当GC发生在老年代时则被称为Major GC或者Full GC。一般的，Minor GC的发生频率要比Major GC高很多，即老年代中垃圾回收发生的频率将大大低于新生代。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JAVA</category>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>JVM_10_String</title>
    <url>/2021/07/24/Notes/Java/01JVM/JVM_10_String/</url>
    <content><![CDATA[<h1 id="JVM-10-String"><a href="#JVM-10-String" class="headerlink" title="JVM_10_String"></a>JVM_10_String</h1><span id="more"></span>

<h2 id="String-的不可变性"><a href="#String-的不可变性" class="headerlink" title="String 的不可变性"></a>String 的不可变性</h2><p><strong>通过字面量的方式声明的字符串在字符串常量池中。</strong></p>
<ul>
<li>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</li>
<li>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li>
<li>当调用String的replace（）方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String s1 = <span class="string">&quot;abc&quot;</span>; <span class="comment">// abc 存储在字符串常量池中</span></span><br><span class="line">    String s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    System.out.println(s1 == s2); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    String s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    s2 += <span class="string">&quot;def&quot;</span>; <span class="comment">// abcdef</span></span><br><span class="line">    System.out.println(s1 == s2); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    String s2 = s1.replace(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;m&quot;</span>);</span><br><span class="line">  	System.out.println(s1 == s2); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩展：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        changeString(str);</span><br><span class="line">        System.out.println(<span class="string">&quot;str=&quot;</span>+str); <span class="comment">// ab</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeString</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        str = <span class="string">&quot;cd&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>java在方法传递参数时，是将变量复制一份，然后传入方法体去执行。</strong> </p>
<p><a href="https://www.jianshu.com/p/94cdeb969031">https://www.jianshu.com/p/94cdeb969031</a></p>
<h2 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h2><p>字符串常量池（StringPool） 是一个固定大小的Hashtable，如果放进StringPool的String非常多， 就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String. intern时性能会大幅下降。</p>
<blockquote>
<p>在jdk6中StringTable默认产地是1009</p>
<p>在jdk7中，StringTable的长度默认值是60013</p>
<p>jdk8开始，1009是StringTable长度可设置的最小值</p>
<p>使用 <code>-XX:StringTableSize</code>可设置StringTable的长度</p>
</blockquote>
<p>常量池就类似一个Java系统级别提供的缓存。</p>
<ul>
<li>直接使用双引号声明出来的String对象会直接存储在常量池中</li>
<li>如果不是用双引号声明的String对象，可以使用String提供的intern方法</li>
</ul>
<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p>字符串常量池存放方法区。</p>
<ul>
<li>Java 6及以前，方法区是永久代，字符串常量池也在永久代</li>
<li>Java 7中，方法区是永久代，但是将字符串常量池的位置调整到Java堆</li>
<li>Java8中，方法区是元空间，字符串常量池还在堆。</li>
</ul>
<p><strong>StringTable为什么要调整</strong>?</p>
<ul>
<li>永久代permSize默认比较小</li>
<li>永久代的垃圾回收频率低</li>
</ul>
<h2 id="String-拼接"><a href="#String-拼接" class="headerlink" title="String 拼接"></a>String 拼接</h2><p>字符串拼接时：</p>
<ol>
<li>只要其中有一个是变量，结果就在堆中，变量拼接的原理是StringBuilder</li>
<li>String常量池中不会存在相同内容的常量，常量与常量的拼接结果在常量池，原理是编译期优化。</li>
<li>如果拼接的结果调用intern方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String s1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    String s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    String s3 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如下的s1 + s2 的执行细节：(变量s是我临时定义的）</span></span><br><span class="line"><span class="comment">    ① StringBuilder s = new StringBuilder();</span></span><br><span class="line"><span class="comment">    ② s.append(&quot;a&quot;)</span></span><br><span class="line"><span class="comment">    ③ s.append(&quot;b&quot;)</span></span><br><span class="line"><span class="comment">    ④ s.toString()  --&gt; 约等于 new String(&quot;ab&quot;)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    补充：在jdk5.0之后使用的是StringBuilder,</span></span><br><span class="line"><span class="comment">    在jdk5.0之前使用的是StringBuffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String s4 = s1 + s2;</span><br><span class="line">    System.out.println(s3 == s4);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1. 字符串拼接操作不一定使用的是StringBuilder!</span></span><br><span class="line"><span class="comment"> *    如果拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译期优化，即非StringBuilder的方式。</span></span><br><span class="line"><span class="comment"> * 2. 针对于final修饰类、方法、基本数据类型、引用数据类型的量的结构时，能使用上final的时候建议使用上。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String s1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> String s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    String s3 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    String s4 = s1 + s2;</span><br><span class="line">    System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用intern</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String s1 = <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">    String s2 = <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">    String s3 = <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line">    String s4 = s1 + s2;</span><br><span class="line">    <span class="comment">//intern():判断字符串常量池中是否存在javaEEhadoop值，如果存在，则返回常量池中javaEEhadoop的地址；</span></span><br><span class="line">    <span class="comment">//如果字符串常量池中不存在javaEEhadoop，则在常量池中加载一份javaEEhadoop，并返回次对象的地址。</span></span><br><span class="line">    String s5 = s4.intern();</span><br><span class="line">    System.out.println(s3 == s5);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>test3 和 test4 字节码维度的理解</strong>：</p>
<ul>
<li>new 是在堆中创建新对象</li>
<li>ldc 返回常量池中的对象地址。如果常量池中没有，则先创建；如果常量池中已经有了，则直接返回。</li>
</ul>
<img src="/pics/image-20210419114052246.png" alt="image-20210419114052246" style="zoom:70%;" />

<p>综合练习：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String s1 = <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">    String s2 = <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"></span><br><span class="line">    String s3 = <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line">    String s4 = <span class="string">&quot;javaEE&quot;</span> + <span class="string">&quot;hadoop&quot;</span>;<span class="comment">//编译期优化</span></span><br><span class="line">    </span><br><span class="line">    String s5 = s1 + <span class="string">&quot;hadoop&quot;</span>; <span class="comment">// StringBuilder</span></span><br><span class="line">    String s6 = <span class="string">&quot;javaEE&quot;</span> + s2; <span class="comment">// StringBuilder</span></span><br><span class="line">    String s7 = s1 + s2; <span class="comment">// StringBuilder</span></span><br><span class="line">    <span class="comment">//如果拼接符号的前后出现了变量，则相当于在堆空间中new String()，具体的内容为拼接的结果：javaEEhadoop</span></span><br><span class="line">    System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">    System.out.println(s3 == s5);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s3 == s6);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s3 == s7);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s5 == s6);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s5 == s7);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s6 == s7);<span class="comment">//false</span></span><br><span class="line">    <span class="comment">//intern():判断字符串常量池中是否存在javaEEhadoop值，如果存在，则返回常量池中javaEEhadoop的地址；</span></span><br><span class="line">    <span class="comment">//如果字符串常量池中不存在javaEEhadoop，则在常量池中加载一份javaEEhadoop，并返回次对象的地址。</span></span><br><span class="line">    String s8 = s6.intern();</span><br><span class="line">    System.out.println(s3 == s8);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拼接-vs-append"><a href="#拼接-vs-append" class="headerlink" title="拼接 vs append"></a>拼接 vs append</h3><p>通过StringBuilder的append()的方式添加字符串的效率要远高于使用String的字符串拼接方式。</p>
<ul>
<li>StringBuilder的append()的方式：自始至终中只创建过一个StringBuilder的对象</li>
<li>使用String的字符串拼接方式：创建过多个StringBuilder和String的对象。使用String的字符串拼接方式：内存中由于创建了较多的StringBuilder和String的对象，内存占用更大；如果进行GC，需要花费额外的时间。</li>
</ul>
<p>在实际开发中，如果基本确定要前前后后添加的字符串长度不高于某个限定值highLevel的情况下，建议使用带参数构造器实例，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder s = <span class="keyword">new</span> StringBuilder(highLevel);<span class="comment">//new char[highLevel]</span></span><br></pre></td></tr></table></figure>
<p>测试拼接效率</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//method1(100000);// 4014ms</span></span><br><span class="line">    method2(<span class="number">100000</span>);<span class="comment">// 7ms</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(<span class="keyword">int</span> highLevel)</span> </span>&#123;</span><br><span class="line">    String src = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; highLevel; i++) &#123;</span><br><span class="line">        src = src + <span class="string">&quot;a&quot;</span>;<span class="comment">//每次循环都会创建一个StringBuilder、String</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// System.out.println(src);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(<span class="keyword">int</span> highLevel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//只需要创建一个StringBuilder</span></span><br><span class="line">    StringBuilder src = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; highLevel; i++) &#123;</span><br><span class="line">        src.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// System.out.println(src);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="new-String-理解"><a href="#new-String-理解" class="headerlink" title="new String()理解"></a>new String()理解</h2><p>从创建角度看，new String（）时，会创建2个对象。</p>
<ul>
<li>一个对象是：在堆空间创建的。字节码指令：new</li>
<li>另一个对象是：字符串常量池中的对象”ab”。 字节码指令：ldc</li>
</ul>
<p>从返回值维度：</p>
<ul>
<li><p>new 返回的是堆中的对象地址</p>
</li>
<li><p>如果使用了的intern，返回的是字符串常量池中的地址</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 =  <span class="keyword">new</span> String(<span class="string">&quot;I hate u&quot;</span>); <span class="comment">// 创建了2个对象，返回的是堆中的地址</span></span><br><span class="line"></span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">&quot;I love u&quot;</span>).intern(); <span class="comment">// 创建了2个对象，返回的是字符串常量池中的地址</span></span><br></pre></td></tr></table></figure>

<h3 id="new-String-和StringBuilder-toString的区别"><a href="#new-String-和StringBuilder-toString的区别" class="headerlink" title="new String()和StringBuilder.toString的区别"></a>new String()和StringBuilder.toString的区别</h3><ul>
<li>StringBuilder. toString()的调用，在字符串常量池中，没有生成”ab”</li>
</ul>
<p>以下代码创建了多少个对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String s1 = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    System.out.println(s1); <span class="comment">//false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//对象1：new StringBuilder()</span></span><br><span class="line"><span class="comment">//对象2： new String(&quot;a&quot;)</span></span><br><span class="line"><span class="comment">//对象3： 常量池中的&quot;a&quot;</span></span><br><span class="line"><span class="comment">//对象4： new String(&quot;b&quot;)</span></span><br><span class="line"><span class="comment">//对象5： 常量池中的&quot;b&quot;</span></span><br><span class="line"><span class="comment">// StringBuilder的toString():</span></span><br><span class="line"><span class="comment">// 对象6 ：new String(&quot;ab&quot;)</span></span><br></pre></td></tr></table></figure>

<p><img src="/pics/image-20210419120004352.png" alt="image-20210419120004352"></p>
<h2 id="Intern"><a href="#Intern" class="headerlink" title="Intern"></a>Intern</h2><p>intern的含义：返回该字符串正在常量池中的地址。</p>
<ul>
<li>如果字符串常量池中有，返回<code>StringPool</code>已有的对象的地址；</li>
<li>如果没有，创建新对象（这里不准确，下面解释），放入串池，并返回串池中的对象地址。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>).intern();</span><br></pre></td></tr></table></figure>

<h3 id="intern-在JDK6-7"><a href="#intern-在JDK6-7" class="headerlink" title="intern 在JDK6/7"></a>intern 在JDK6/7</h3><p>谈到intern必须要解释下JDK6 和 JDK7之上的区别，主要是在<code>StringPool</code>中没有时：</p>
<ul>
<li>JDK6时，会把<strong>对象复制一份</strong>，放入<code>StringPool</code>，并返回<code>StringPool</code>中的对象地址</li>
<li>JDK7时，会把<strong>对象的引用地址复制一份</strong>，放入<code>StringPool</code>中，<code>StringPool</code>中不需要再存储一份对象了，可以直接存储堆中的引用，并返回<code>StringPool</code>中的引用地址。</li>
</ul>
<p>如果字符串常量池中有，返回<code>StringPool</code>已有的对象的地址。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test9</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String s = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    String s2 = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    s.intern();</span><br><span class="line">    System.out.println(s == s2); <span class="comment">//JDK6: false ; JDK7:false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行完此方法后，字符串常量池中，是否存在&quot;11&quot;呢？答案：不存在！！</span></span><br><span class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="comment">// 调用此方法时，字符串常量池中创建 “11”</span></span><br><span class="line">    String s4 = <span class="string">&quot;11&quot;</span>;</span><br><span class="line">    <span class="comment">// 调用此方法之前，字符串常量池中已经存在了&quot;11&quot;</span></span><br><span class="line">    s3.intern();</span><br><span class="line">    System.out.println(s3 == s4); <span class="comment">//JDK6:false ; JDK7:false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String s = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    s.intern();</span><br><span class="line">    String s2 = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    System.out.println(s == s2); <span class="comment">// JDK6: false ; JDK7:false</span></span><br><span class="line"></span><br><span class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="comment">//  intern 在字符串常量池中生成&quot;11&quot;。</span></span><br><span class="line">    <span class="comment">//  如何理解：jdk6:创建了一个新的对象&quot;11&quot;,也就有新的地址。</span></span><br><span class="line">    <span class="comment">//  jdk7:此时常量中并没有创建&quot;11&quot;,而是创建一个指向堆空间中new String(&quot;11&quot;)的地址</span></span><br><span class="line">    s3.intern();</span><br><span class="line">    String s4 = <span class="string">&quot;11&quot;</span>;</span><br><span class="line">    System.out.println(s3 == s4); <span class="comment">//JDK6:false ; JDK7:true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>JDK6 以上2种情况的理解</strong></p>
<img src="/pics/image-20210419150519890.png" alt="image-20210419150519890" style="zoom:60%;" />

<blockquote>
<p>注：图中绿色线条代表 string 对象的内容指向。 黑色线条代表地址指向。</p>
</blockquote>
<p>先说一下 JDK6中的情况，在JDK6中上述的所有打印都是 false 的，<code>因为JDK6中的常量池是放在Perm区中的，Perm区和正常的JAVA Heap区域是完全分开的。</code></p>
<p>上面说过如果是使用引号声明的字符串都是会直接在字符串常量池中生成，而 new 出来的 String 对象是放在 JAVA Heap 区域。所以拿一个 <code>JAVA Heap 区域的对象地址和字符串常量池的对象地址进行比较肯定是不相同的</code>，即使调用<code>String.intern</code>方法也是没有任何关系的。</p>
<p><strong>JDK7 以上的理解</strong></p>
<p><img src="/pics/image-20210419171114039.png" alt="image-20210419171114039"></p>
<p><code>test9()</code></p>
<ul>
<li>再看 s 和 s2 对象。 <code>String s = new String(&quot;1&quot;);</code> 第一句代码，生成了2个对象。常量池中的“1” 和 JAVA Heap 中的字符串对象。<code>s.intern();</code> 这一句是 s 对象去常量池中寻找后发现 “1” 已经在常量池里了。</li>
<li>接下来<code>String s2 = &quot;1&quot;;</code> 这句代码是生成一个 s2的引用指向常量池中的“1”对象。 结果就是 s 和 s2 的引用地址明显不同。图中画的很清晰。</li>
</ul>
<p><code>test10()</code></p>
<ul>
<li><p>先看 s3和s4字符串。<code>String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);</code>，这句代码中现在生成了2最终个对象，是字符串常量池中的“1” 和 JAVA Heap 中的 s3引用指向的对象。中间还有2个匿名的<code>new String(&quot;1&quot;)</code>我们不去讨论它们。<code>此时s3引用对象内容是”11”，但此时常量池中是没有 “11”对象的</code>。</p>
</li>
<li><p>接下来<code>s3.intern();</code>这一句代码，是将 s3中的“11”字符串放入 String 常量池中，因为此时常量池中不存在“11”字符串，因此常规做法是跟 jdk6 图中表示的那样，在常量池中生成一个 “11” 的对象，关键点是 jdk7 中常量池不在 Perm 区域了，这块做了调整。常量池中不需要再存储一份对象了，可以直接存储堆中的引用。这份引用指向 s3 引用的对象。 也就是说引用地址是相同的。</p>
</li>
<li><p>最后<code>String s4 = &quot;11&quot;;</code> 这句代码中”11”是显示声明的，因此会直接去常量池中创建，创建的时候发现已经有这个对象了，此时也就是指向 s3 引用对象的一个引用。所以 s4 引用就指向和 s3 一样了。因此最后的比较 <code>s3 == s4</code> 是 true。</p>
</li>
</ul>
<p><strong>体会下 JDK 6/7 intern的区别</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test11</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String s1 = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    String s2 = s.intern();</span><br><span class="line">    String s3 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    System.out.println(s2 == s3); <span class="comment">// JDK6:true, JDK7:true</span></span><br><span class="line">    System.out.println(s1 == s3); <span class="comment">// JDK6:false, JDK7: true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/pics/image-20210419151958617.png" alt="image-20210419151958617"></p>
<p><strong>体会下intern 在 new String() 后使用的情况</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test12</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String s1 = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    String s2 = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>).intern(); <span class="comment">// 注意这里加了intern，StringPool中添加对象</span></span><br><span class="line">    String s3 = s1.intern(); <span class="comment">// 返回字符串常量池中对象的地址</span></span><br><span class="line">    System.out.println(s2 == s3); <span class="comment">//jdk6/7 : true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>体会下 intern 在 字面量创建后使用的情况</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test13</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String s1 = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    String s2 = <span class="string">&quot;ab&quot;</span>; <span class="comment">// StringPool中添加对象</span></span><br><span class="line">    String s3 = s1.intern(); <span class="comment">// 返回字符串常量池中对象的地址</span></span><br><span class="line">    System.out.println(s2 == s3);<span class="comment">//jdk6/7 : true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="intern优化"><a href="#intern优化" class="headerlink" title="intern优化"></a>intern优化</h3><p>需要内存中存储大量的字符串。比如社交网站，很多人都存储：北京市、海淀区等信息。<strong>如果字符串都调用 intern方法，就会明显降低内存的大小。</strong></p>
<blockquote>
<p>不使用intern的话，堆中维护的对象是1000w个，字符串常量池中只有10个；</p>
<p>使用intern的话，返回的字符串常量池中的地址，堆中的对象可被销毁。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用intern()测试执行效率：空间使用上</span></span><br><span class="line"><span class="comment"> * 结论：对于程序中大量存在存在的字符串，尤其其中存在很多重复字符串时，使用intern()可以节省内存空间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringIntern2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT = <span class="number">1000</span> * <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String[] arr = <span class="keyword">new</span> String[MAX_COUNT];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer[] data = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_COUNT; i++) &#123;</span><br><span class="line"><span class="comment">//            arr[i] = new String(String.valueOf(data[i % data.length]));</span></span><br><span class="line">            arr[i] = <span class="keyword">new</span> String(String.valueOf(data[i % data.length])).intern();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="StrtingTable的垃圾回收"><a href="#StrtingTable的垃圾回收" class="headerlink" title="StrtingTable的垃圾回收"></a>StrtingTable的垃圾回收</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * String的垃圾回收:</span></span><br><span class="line"><span class="comment"> * -Xms15m -Xmx15m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringGCTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        for (int j = 0; j &lt; 100; j++) &#123;</span></span><br><span class="line"><span class="comment">//            String.valueOf(j).intern();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//发生垃圾回收行为</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++) &#123;</span><br><span class="line">            String.valueOf(j).intern();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/pics/image-20210419162440505.png" alt="image-20210419162440505" style="zoom:80%;" />

<h2 id="G1中的String去重操作"><a href="#G1中的String去重操作" class="headerlink" title="G1中的String去重操作"></a>G1中的String去重操作</h2><p>背景：对许多Java应用做的测试得出以下结果：</p>
<ul>
<li>堆存活数据集合里面String对象占了25%，重复的String对象有13.5%</li>
<li>String对象的平均长度是45</li>
</ul>
<p>G1垃圾收集器中实现自动持续对重复的String对象进行去重，这样就能避免浪费内存。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ol>
<li>当垃圾收集器工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的String对象。</li>
<li>如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的String对象。</li>
<li>使用一个<code>Hashtable</code>来记录所有的被String对象使用的不重复的char数组。 当去重的时候，会查这个<code>Hashtable</code>，来看堆上是否已经存在一个一模一样的char数组。</li>
<li>如果存在，String对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/94cdeb969031">https://www.jianshu.com/p/94cdeb969031</a></p>
<p><a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html">https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>JUC_01_JMM</title>
    <url>/2022/12/25/Notes/Java/02JUC/JUC_01_Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="JUC-01-JMM"><a href="#JUC-01-JMM" class="headerlink" title="JUC_01_JMM"></a>JUC_01_JMM</h1><span id="more"></span>

<p>介绍 Java 内存模型之前，先温习下计算机硬件内存模型。</p>
<p>计算机在执行程序的时候，每条指令都是在 CPU 中执行的，而执行的时候，又免不了要和数据打交道。而计算机上面的数据，是存放在主存当中的，也就是计算机的物理内存。</p>
<p>计算机硬件架构简易图：</p>
<img src="/pics/image-20210318234901621.png" alt="image-20210318234901621" style="zoom:50%;" />

<p>我们以多核 CPU 为例，每个CPU 核都包含<strong>一组 「CPU 寄存器」</strong>，这些寄存器本质上是在 CPU 内存中。CPU 在这些寄存器上执行操作的速度要比在主内存(RAM)中执行的速度快得多。</p>
<p>因为<strong>CPU速率高， 内存速率慢，为了让存储体系可以跟上CPU的速度，所以中间又加上 Cache 层，就是我们说的 「CPU 高速缓存」</strong>。</p>
<h3 id="CPU多级缓存"><a href="#CPU多级缓存" class="headerlink" title="CPU多级缓存"></a>CPU多级缓存</h3><p>由于CPU的运算速度远远超越了1级缓存的数据IO能力，CPU厂商又引入了多级的缓存结构。通常L1、L2 是每个CPU 核有一个，L3 是多个核共用一个。</p>
<h3 id="Cache-Line"><a href="#Cache-Line" class="headerlink" title="Cache Line"></a>Cache Line</h3><p>Cache又是由很多个<strong>「缓存行」</strong>(Cache line) 组成的。Cache line 是 Cache 和 RAM 交换数据的最小单位。</p>
<p>Cache 存储数据是固定大小为单位的，称为一个<strong>Cache entry</strong>，这个单位称为<strong>Cache line</strong>或<strong>Cache block</strong>。给定Cache 容量大小和 Cache line size 的情况下，它能存储的条目个数(number of cache entries)就是固定的。因为Cache 是固定大小的，所以它从主内存获取数据也是固定大小。对于X86来讲，是 64Bytes。对于ARM来讲，较旧的架构的Cache line是32Bytes，但一次内存访存只访问一半的数据也不太合适，所以它经常是一次填两个 Cache line，叫做 double fill。</p>
<h3 id="缓存的工作原理"><a href="#缓存的工作原理" class="headerlink" title="缓存的工作原理"></a>缓存的工作原理</h3><p>这里的缓存的工作原理和我们项目中用 memcached、redis 做常用数据的缓存层是一个道理。</p>
<p>当 CPU 要读取一个数据时，首先从缓存中查找，如果找到就立即读取并送给CPU处理；如果没有找到，就去内存中读取并送给 CPU 处理，同时把这个数据所在的<strong>数据块</strong>（就是我们上边说的 Cache block）调入缓存中，即把临近的共 64 Byte 的数据也一同载入，因为临近的数据在将来被访问的可能性更大，可以使得以后对整块数据的读取都从缓存中进行，<strong>不必再调用内存</strong>。</p>
<p>这就增加了CPU读取缓存的<strong>命中率</strong>（Cache hit）了。</p>
<h3 id="计算机层级存储"><a href="#计算机层级存储" class="headerlink" title="计算机层级存储"></a>计算机层级存储</h3><p>计算机存储系统是有层次结构的，类似一个金字塔，顶层的寄存器读写速度较高，但是空间较小。底层的读写速度较低，但是空间较大。</p>
<img src="/pics/image-20210318235811049.png" alt="image-20210318235811049" style="zoom:50%;" />

<h3 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h3><p>既然每个核中都有单独的缓存，那我的 4 核 8 线程 CPU 处理主内存数据的时候，不就会出现数据不一致问题了吗？</p>
<p>为了解决这个问题，先后有过两种方法：<strong>总线锁机制</strong>和<strong>缓存锁机制</strong>。</p>
<p>总线锁就是使用 CPU 提供的一个<code>LOCK#</code>信号，当一个处理器在总线上输出此信号，其他处理器的请求将被阻塞，那么该处理器就可以独占共享锁。这样就保证了数据一致性。</p>
<p>但是总线锁开销太大，我们需要控制锁的粒度，所以又有了缓存锁，核心就是“<strong>缓存一致性协议</strong>”，不同的 CPU 硬件厂商实现方式稍有不同，有MSI、MESI、MOSI等。</p>
<h3 id="代码乱序执行优化"><a href="#代码乱序执行优化" class="headerlink" title="代码乱序执行优化"></a>代码乱序执行优化</h3><p>为了使得处理器内部的运算单元尽量被充分利用，提高运算效率，处理器可能会对输入的代码进行「乱序执行」**(Out-Of-Order Execution)，处理器会在计算之后将乱序执行的结果重组，**乱序优化可以保证在单线程下该执行结果与顺序执行的结果是一致的，但不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致。</p>
<p><strong>乱序执行技术是处理器为提高运算速度而做出违背代码原有顺序的优化</strong>。在单核时代，处理器保证做出的优化不会导致执行结果远离预期目标，但在多核环境下却并非如此。</p>
<p>多核环境下， 如果存在一个核的计算任务依赖另一个核的计算任务的中间结果，而且对相关数据读写没做任何防护措施，那么其顺序性并不能靠代码的先后顺序来保证，处理器最终得出的结果和我们逻辑得到的结果可能会大不相同。</p>
<h4 id="编译器指令重排"><a href="#编译器指令重排" class="headerlink" title="编译器指令重排"></a>编译器指令重排</h4><p>除了上述由处理器和缓存引起的乱序之外，现代编译器同样提供了乱序优化。之所以出现编译器乱序优化其根本原因在于处理器每次只能分析一小块指令，但编译器却能在很大范围内进行代码分析，从而做出更优的策略，充分利用处理器的乱序执行功能。</p>
<h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><p>尽管我们看到乱序执行初始目的是为了提高效率，但是它看来其好像在这多核时代不尽人意，其中的某些”自作聪明”的优化导致多线程程序产生各种各样的意外。因此有必要存在一种机制来消除乱序执行带来的坏影响，也就是说应该允许程序员显式的告诉处理器对某些地方禁止乱序执行。这种机制就是所谓内存屏障。不同架构的处理器在其指令集中提供了不同的指令来发起内存屏障，对应在编程语言当中就是提供特殊的关键字来调用处理器相关的指令，JMM里我们再探讨。</p>
<h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><p>Java 内存模型即 <code>Java Memory Model</code>，简称 <strong>JMM</strong>。</p>
<p>这里的内存模型可不是 JVM 里的运行时数据区。</p>
<p>「内存模型」可以理解为<strong>在特定操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象</strong>。</p>
<p>不同架构的物理计算机可以有不一样的内存模型，Java虚拟机也有自己的内存模型。</p>
<p>Java虚拟机规范中试图定义一种「 <strong>Java 内存模型</strong>」来<strong>屏蔽掉各种硬件和操作系统的内存访问差异</strong>，以实现<strong>让 Java 程序在各种平台下都能达到一致的内存访问效果</strong>，不必因为不同平台上的物理机的内存模型的差异，对各平台定制化开发程序。</p>
<p>Java 内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。这里的变量与我们写 Java 代码中的变量不同，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量和方法参数，因为他们是线程私有的，不会被共享。</p>
<h3 id="JMM-组成"><a href="#JMM-组成" class="headerlink" title="JMM 组成"></a>JMM 组成</h3><ul>
<li><p><strong>主内存</strong>：Java 内存模型规定了所有变量都存储在主内存(Main Memory)中（此处的主内存与物理硬件的主内存RAM 名字一样，两者可以互相类比，但此处仅是虚拟机内存的一部分）。</p>
</li>
<li><p><strong>工作内存</strong>：每条线程都有自己的工作内存(Working Memory，又称本地内存，可与CPU高速缓存类比)，线程的工作内存中保存了该线程使用到的主内存中的共享变量的副本拷贝。<strong>线程对变量的所有操作都必须在工作内存进行，而不能直接读写主内存中的变量</strong>。<strong>工作内存是 JMM 的一个抽象概念，并不真实存在</strong>。</p>
<img src="/pics/image-20210318234012867.png" alt="image-20210318234012867" style="zoom:50%;" /></li>
</ul>
<h3 id="JMM-与-JVM-内存结构"><a href="#JMM-与-JVM-内存结构" class="headerlink" title="JMM 与 JVM 内存结构"></a>JMM 与 JVM 内存结构</h3><p>JMM 与 Java 内存区域中的堆、栈、方法区等并不是同一个层次的内存划分，两者基本没有关系。如果一定要勉强对应，那从变量、主内存、工作内存的定义看，<strong>主内存主要对应 Java 堆中的对象实例数据部分，工作内存则对应虚拟机栈的部分区域</strong>（与上图对应着看哈）。</p>
<img src="/pics/image-20210319000613709.png" alt="image-20210319000613709" style="zoom:50%;" />

<h3 id="JMM-与计算机内存结构"><a href="#JMM-与计算机内存结构" class="headerlink" title="JMM 与计算机内存结构"></a>JMM 与计算机内存结构</h3><p>Java 内存模型和硬件内存体系结构也没有什么关系。硬件内存体系结构不区分栈和堆。在硬件上，线程栈和堆都位于主内存中。线程栈和堆的一部分有时可能出现在高速缓存和CPU寄存器中。如下图所示:</p>
<img src="/pics/image-20210319000711299.png" alt="image-20210319000711299" style="zoom:50%;" />

<p>当对象和变量可以存储在计算机中不同的内存区域时，这就可能会出现某些问题。两个主要问题是:</p>
<ul>
<li><strong>线程更新(写)到共享变量的可见性</strong></li>
<li><strong>读取、检查和写入共享变量时的竞争条件</strong></li>
</ul>
<h4 id="可见性问题（Visibility-of-Shared-Objects）"><a href="#可见性问题（Visibility-of-Shared-Objects）" class="headerlink" title="可见性问题（Visibility of Shared Objects）"></a>可见性问题（Visibility of Shared Objects）</h4><p>如果两个或多个线程共享一个对象，则一个线程对共享对象的更新可能对其他线程不可见（当然可以用 Java 提供的关键字 volatile）。 假设共享对象最初存储在主内存中。在 CPU 1上运行的线程将共享对象读入它的CPU缓存后修改，但是还没来得及即刷新回主内存，这时其他 CPU 上运行的线程就不会看到共享对象的更改。这样，每个线程都可能以自己的线程结束，就出现了可见性问题，如下</p>
<img src="/pics/image-20210319004455084.png" alt="image-20210319004455084" style="zoom:50%;" />

<h4 id="竞争条件（Race-Conditions）"><a href="#竞争条件（Race-Conditions）" class="headerlink" title="竞争条件（Race Conditions）"></a>竞争条件（Race Conditions）</h4><p>这个其实就是我们常说的原子问题。</p>
<p>如果两个或多个线程共享一个对象，并且多个线程更新该共享对象中的变量，则可能出现竞争条件。</p>
<p>想象一下，如果线程 A 将一个共享对象的变量读入到它的 CPU 缓存中。此时，线程 B 执行相同的操作，但是进入不同的 CPU 缓存。现在线程A执行 +1 操作，线程B也这样做。现在该变量增加了两次，在每个 CPU 缓存中一次。</p>
<p>如果这些增量是按顺序执行的，则变量结果会是 3，并将原始值 +2 写回主内存。但是，这两个增量是同时执行的，没有适当的同步。不管将哪个线程的结构写回主内存，更新后的值只比原始值高1，显然是有问题的。如下（当然可以用 Java 提供的关键字 Synchronized）</p>
<img src="/pics/image-20210319004553218.png" alt="image-20210319004553218" style="zoom:50%;" />

<h3 id="JMM-特性"><a href="#JMM-特性" class="headerlink" title="JMM 特性"></a>JMM 特性</h3><p>JMM 就是用来解决如上问题的。 <strong>JMM是围绕着并发过程中如何处理可见性、原子性和有序性这 3 个 特征建立起来的</strong></p>
<ul>
<li><p><strong>可见性</strong>：<strong>可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改</strong>。Java 中的 volatile、synchronzied、final 都可以实现可见性</p>
</li>
<li><p><strong>原子性</strong>：即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。<strong>即使在多个线程一起执行的时候</strong>，一个操作一旦开始，就不会被其他线程所干扰。</p>
</li>
<li><p><strong>有序性</strong>：计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排，一般分为以下 3 种：</p>
<p><img src="/pics/image-20210319001149455.png" alt="image-20210319001149455">单线程环境里确保程序最终执行结果和代码顺序执行的结果一致；</p>
<p>处理器在进行重排序时必须要考虑指令之间的<strong>数据依赖性</strong>；</p>
<p>多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。</p>
</li>
</ul>
<h3 id="内存之间的交互操作"><a href="#内存之间的交互操作" class="headerlink" title="内存之间的交互操作"></a>内存之间的交互操作</h3><p>关于主内存和工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java 内存模型中定义了 8 种 操作来完成，<strong>虚拟机实现必须保证每一种操作都是原子的、不可再拆分的</strong>（double和long类型例外）</p>
<ul>
<li><strong>lock</strong>（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</li>
<li><strong>unlock</strong>（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li><strong>read</strong>（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li>
<li><strong>load</strong>（载入）：作用于工作内存的变量，它把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li><strong>use</strong>（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</li>
<li><strong>assign</strong>（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li><strong>store</strong>（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的 write操作使用。</li>
<li><strong>write</strong>（写入）：作用于主内存的变量，它把 store 操作从工作内存中得到的变量的值放入主内存的变量中。</li>
</ul>
<p>如果需要把一个变量从主内存复制到工作内存，那就要顺序地执行 <strong>read 和 load 操作</strong>，如果要把变量从工作内存同步回主内存，就要顺序地执行 <strong>store 和 write 操作</strong>。注意，<strong>Java 内存模型只要求上述两个操作必须按顺序执行，而没有保证是连续执行</strong>。也就是说 read 与 load 之间、store 与write 之间是可插入其他指令的，如对主内存中的变量 a、b 进行访问时，一种可能出现顺序是 read a、read b、load b、load a。</p>
<img src="/pics/image-20210319001848007.png" alt="image-20210319001848007" style="zoom:50%;" />

<p>除此之外，Java 内存模型还规定了在执行上述 8 种基本操作时必须满足如下规则</p>
<ul>
<li>不允许 read 和 load、store 和 write 操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。</li>
<li>不允许一个线程丢弃它的最近的 assign 操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li>
<li>不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从线程的工作内存同步回主内存。</li>
<li>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load 或 assign）的变量，换句话说，就是对一个变量实施 use、store 操作之前，必须先执行过了 assign 和 load 操作。</li>
<li>一个变量在同一时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。</li>
<li>如果对一个变量执行 lock 操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值。</li>
<li>如果一个变量事先没有被 lock 操作锁定，那就不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定住的变量。</li>
<li>对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中（执行 store、write 操作）。</li>
</ul>
<h4 id="long-和-double-型变量的特殊规则"><a href="#long-和-double-型变量的特殊规则" class="headerlink" title="long 和 double 型变量的特殊规则"></a>long 和 double 型变量的特殊规则</h4><p>Java 内存模型要求 lock，unlock，read，load，assign，use，store，write 这 8 个操作都具有原子性，但对于64 位的数据类型（ long 或 double），在模型中定义了一条相对宽松的规定，允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作划分为两次 32 位的操作来进行，即允许虚拟机实现选择可以不保证 64 位数据类型的load，store，read，write 这 4 个操作的原子性，即 <strong>long 和 double 的非原子性协定</strong>。</p>
<p>如果多线程的情况下double 或 long 类型并未声明为 volatile，可能会出现“半个变量”的数值，也就是既非原值，也非修改后的值。</p>
<p>虽然 Java 规范允许上面的实现，但商用虚拟机中基本都采用了原子性的操作，因此在日常使用中几乎不会出现读取到“半个变量”的情况，so，这个了解下就行。</p>
<h3 id="先行发生原则（这8种情况不可以重排序，必须加屏障）"><a href="#先行发生原则（这8种情况不可以重排序，必须加屏障）" class="headerlink" title="先行发生原则（这8种情况不可以重排序，必须加屏障）"></a>先行发生原则（这8种情况不可以重排序，必须加屏障）</h3><p>先行发生（happens-before）是 Java 内存模型中定义的两项操作之间的偏序关系，<strong>如果操作A 先行发生于操作B，那么A的结果对B可见</strong>。happens-before关系的分析需要分为<strong>单线程和多线程</strong>的情况：</p>
<ul>
<li><strong>单线程下的 happens-before</strong> 字节码的先后顺序天然包含 happens-before 关系：因为单线程内共享一份工作内存，不存在数据一致性的问题。 在程序控制流路径中靠前的字节码 happens-before 靠后的字节码，即靠前的字节码执行完之后操作结果对靠后的字节码可见。然而，这并不意味着前者一定在后者之前执行。实际上，如果后者不依赖前者的运行结果，那么它们可能会被重排序。</li>
<li><strong>多线程下的 happens-before</strong> 多线程由于每个线程有共享变量的副本，如果没有对共享变量做同步处理，线程 1 更新执行操作 A 共享变量的值之后，线程 2 开始执行操作 B，此时操作 A 产生的结果对操作 B 不一定可见。</li>
</ul>
<p>为了方便程序开发，Java 内存模型实现了下述的先行发生关系（“天然的”先行发生关系，无需任何同步器协助就存在）：</p>
<ul>
<li><strong>程序次序规则：</strong> 一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作。</li>
<li><strong>管程锁定规则：</strong> 一个 unLock 操作先行发生于后面对同一个锁的 lock 操作。</li>
<li><strong>volatile变量规则：</strong> 对一个变量的写操作先行发生于后面对这个变量的读操作。</li>
<li><strong>传递规则：</strong> 如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出操作 A 先行发生于操作 C。</li>
<li><strong>线程启动规则：</strong> Thread对象的 <code>start()</code> 方法先行发生于此线程的每一个动作。</li>
<li><strong>线程中断规则：</strong> 对线程 <code>interrupt()</code> 方法的调用先行发生于被中断线程的代码检测到中断事件的发生。</li>
<li><strong>线程终结规则：</strong> 线程中所有的操作都先行发生于线程的终止检测，我们可以通过<code>Thread.join()</code>方法结束、<code>Thread.isAlive()</code>的返回值手段检测到线程已经终止执行。</li>
<li><strong>对象终结规则：</strong> 一个对象的初始化完成先行发生于它的 <code>finalize()</code>方法的开始</li>
</ul>
<h3 id="内存屏障-1"><a href="#内存屏障-1" class="headerlink" title="内存屏障"></a>内存屏障</h3><p>上边的一系列操作保证了数据一致性，Java 中如何保证底层操作的有序性和可见性？可以通过内存屏障。</p>
<p>内存屏障是被插入两个 CPU 指令之间的一种指令，用来禁止处理器指令发生重排序（像屏障一样），从而保障<strong>有序性</strong>的。另外，为了达到屏障的效果，它也会使处理器写入、读取值之前，将主内存的值写入高速缓存，清空无效队列，从而保障<strong>可见性</strong>。eg:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Store1; </span><br><span class="line">Store2;   </span><br><span class="line">Load1;   </span><br><span class="line">StoreLoad;  //内存屏障</span><br><span class="line">Store3;   </span><br><span class="line">Load2;   </span><br><span class="line">Load3;</span><br></pre></td></tr></table></figure>

<p>StoreLoad 屏障之前的 Store 指令无法与 StoreLoad 屏障之后的 Load 指令进行交换位置，即<strong>重排序</strong>。但是 StoreLoad 屏障之前和之后的指令是可以互换位置的，即 Store1 可以和 Store2 互换，Load2 可以和 Load3 互换。</p>
<p>常见的 4 种屏障：<strong>注意这些不是cpu的指令，而是JVM的规范要求，</strong>不同的CPU有不同的实现。 </p>
<ul>
<li><p><strong>LoadLoad</strong> 屏障： 对于这样的语句 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Load1; LoadLoad; Load2</span><br></pre></td></tr></table></figure>

<p>在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</p>
</li>
<li><p><strong>StoreStore</strong> 屏障： 对于这样的语句 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Store1; StoreStore; Store2</span><br></pre></td></tr></table></figure>

<p>在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</p>
</li>
<li><p><strong>LoadStore</strong> 屏障： 对于这样的语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Load1; LoadStore; Store2</span><br></pre></td></tr></table></figure>

<p>在Store2及后续写入操作被执行前，保证Load1要读取的数据被读取完毕。</p>
</li>
<li><p><strong>StoreLoad</strong> 屏障： 对于这样的语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Store1; StoreLoad; Load2</span><br></pre></td></tr></table></figure>

<p>在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的（冲刷写缓冲器，清空无效化队列）。在大多数处理器的实现中，这个屏障也被称为<strong>全能屏障</strong>，兼具其它三种内存屏障的功能。</p>
</li>
</ul>
<p>Java 中对内存屏障的使用在一般的代码中不太容易见到，常见的有 volatile 和 synchronized 关键字修饰的代码块，还可以通过 Unsafe 这个类来使用内存屏障。（下一章扯扯这些）</p>
<p>Java 内存模型就是通过定义的这些来解决可见性、原子性和有序性的。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="JMM-是什么？"><a href="#JMM-是什么？" class="headerlink" title="JMM 是什么？"></a>JMM 是什么？</h3><p>JMM，java内存模型，定义了内存中变量的访问规范（JVM和RAM交互规则），是一种抽象的概念。目的是为了让<strong>java程序在各种平台下都能达到一致的并发效果</strong>，屏蔽掉各种硬件和操作系统的差异。</p>
<p>JMM规定了内存主要划分为<strong>主内存</strong>和<strong>工作内存</strong>两种。</p>
<ul>
<li>主内存(Main Memory)：JMM规定<strong>所有的变量都存储在主内存</strong>中。</li>
<li>工作内存：线程私有的，每条线程都有自己的工作内存。保存了该线程使用到的主内存中的共享变量的副本。<strong>线程对变量的所有操作都必须在工作内存进行，而不能直接读写主内存中的变量</strong>。</li>
</ul>
<h3 id="JMM解决什么问题？"><a href="#JMM解决什么问题？" class="headerlink" title="JMM解决什么问题？"></a>JMM解决什么问题？</h3><p>JMM主要是为了解决并发过程中<strong>可见性问题和竞争问题</strong>，围绕着并发过程中如何处理可见性、原子性和有序性这3个特性建立起来的。</p>
<ul>
<li><p>原子性</p>
<p>一个操作是不可分割、不可中断的，<strong>一个线程在执行时不会被其他线程干扰</strong>。synchronized + lock + cas</p>
</li>
<li><p>可见性</p>
<p>当一个线程修改共享变量的值，其他线程能够立即知道。 volatile  + synchronized + lock</p>
</li>
<li><p>有序性</p>
<p>程序执行的顺序按照代码的先后顺序执行。程序执行过程中，编译器和处理器对指令进行的重排序优化，使得<strong>并发过程中代码的执行顺序和代码的先后顺序不一致</strong>，导致最终的结果无法预测。synchronized + happensbefore + lock</p>
</li>
</ul>
<h3 id="JMM中的8种内存交互操作？"><a href="#JMM中的8种内存交互操作？" class="headerlink" title="JMM中的8种内存交互操作？"></a>JMM中的8种内存交互操作？</h3><ul>
<li>lock + unlock : 作用于主内存中的变量；lock，加锁，表示线程独占；unlock ，释放锁，允许其他线程再锁定</li>
<li>read +  write ：作用于主内存变量，read把变量从主内存传输到工作线程；load把变量从工作线程写入到主内存</li>
<li>load + store  ：作用于工作内存的变量，load把read 操作从主内存中得到的变量放入工作内存的变量副本中；store 把工作内存中一个变量的值传送到主内存中，以便随后的 write操作使用</li>
<li>use + assign ：作用于工作内存的变量，use把工作内存中一个变量的值传递给执行引擎；assgin把一个从执行引擎接收到的值赋给工作内存的变量</li>
</ul>
<h3 id="内存屏障？"><a href="#内存屏障？" class="headerlink" title="内存屏障？"></a>内存屏障？</h3><p>保证底层操作的有序性和可见性</p>
<ul>
<li>就像一套栅栏分割前后的代码，阻止栅栏前后的没有数据依赖性的代码进行指令重排序，保证程序在一定程度上的<strong>有序性</strong>。</li>
<li>强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效，保证数据的<strong>可见性</strong>。</li>
</ul>
<h3 id="happens-before原则理解？"><a href="#happens-before原则理解？" class="headerlink" title="happens-before原则理解？"></a>happens-before原则理解？</h3><p>先行发生（happens-before）是 Java 内存模型中定义的两项操作之间的偏序关系，<strong>如果操作A 先行发生于操作B，那么A的结果对B可见</strong>。共定义了8种规则，单线程是天然有序的，对于多线程来说，多个并发线程间必需要符合这个规则中的任一条，否则就不能保证有序。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://yq.aliyun.com/articles/750655">https://yq.aliyun.com/articles/750655</a></p>
<p><a href="https://www.cnblogs.com/54chensongxia/p/12120117.html">https://www.cnblogs.com/54chensongxia/p/12120117.html</a></p>
<p>《深入理解 Java 虚拟机》第二版</p>
<p><a href="http://tutorials.jenkov.com/java-concurrency/java-memory-model.html">http://tutorials.jenkov.com/java-concurrency/java-memory-model.html</a> <a href="https://juejin.im/post/5bf2977751882505d840321d#heading-5">https://juejin.im/post/5bf2977751882505d840321d#heading-5</a> <a href="http://rsim.cs.uiuc.edu/Pubs/popl05.pdf">http://rsim.cs.uiuc.edu/Pubs/popl05.pdf</a> <a href="http://ifeve.com/wp-content/uploads/2014/03/JSR133%E4%B8%AD%E6%96%87%E7%89%88.pdf">http://ifeve.com/wp-content/uploads/2014/03/JSR133中文版.pdf</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
        <category>JUC</category>
      </categories>
  </entry>
  <entry>
    <title>JUC_03_volatile</title>
    <url>/2022/12/25/Notes/Java/02JUC/JUC_03_Volatile/</url>
    <content><![CDATA[<h1 id="JUC-03-volatile"><a href="#JUC-03-volatile" class="headerlink" title="JUC_03_volatile"></a>JUC_03_volatile</h1><span id="more"></span>

<p>被volatile修饰的共享变量，具有了以下特性：</p>
<ul>
<li>线程间可见性</li>
<li>禁止指令重排序 – 有序性</li>
<li>不保证原子性</li>
</ul>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>被volatile修饰的变量，如果在工作内存中发生了变化，回立刻写入到主内存中，同时使得其他工作内存中的变量无效。</p>
<p>写入过程中操作如下： <strong>lock + storge + write +  unlock</strong> 。</p>
<img src="/pics/image-20210320170110425.png" alt="image-20210320170110425" style="zoom:50%;" />



<h3 id="lock-指令"><a href="#lock-指令" class="headerlink" title="lock 指令"></a>lock 指令</h3><p>volatile的底层实现是汇编的lock指令，<strong>它会锁定这块内存区域的缓存（缓存行锁定）</strong>。lock 前缀的指令在多核处理器下会引发两件事情：</p>
<ul>
<li>将当前处理器<strong>缓存行的数据写回到系统内存</strong></li>
<li><strong>使其他 CPU 里缓存了该内存地址的数据失效（MESI）</strong></li>
</ul>
<h3 id="不保证原子性"><a href="#不保证原子性" class="headerlink" title="不保证原子性"></a>不保证原子性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPlusPlus</span><span class="params">()</span></span>&#123;</span><br><span class="line">        number ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAtomic</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  MyData myData = <span class="keyword">new</span> MyData();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">        myData.add();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;addPlusThread:&quot;</span>+ i).start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//等待上边20个线程结束后(预计5秒肯定结束了)，在main线程中获取最后的number</span></span><br><span class="line">  TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>)&#123;</span><br><span class="line">    Thread.yield();</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(<span class="string">&quot;final value：&quot;</span>+myData.number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行 <code>testAtomic</code> 发现最后的输出值 &lt;= 10000 。</p>
<p>为什么会这样呢? 假设有2个线程同时执行 i ++，执行完工作内存值都是1，执行assgin回写时。此时出现线程竞争的话，<strong>线程1先会lock写入，线程2中的值会被置为无效</strong>，需要重新去主存中读取再继续执行，相当于丢失了一次值。</p>
<img src="/pics/image-20210320162753252.png" alt="image-20210320162753252" style="zoom:50%;" />



<p>volatile的底层是使用内存屏障来保证有序性的。写volatile变量时，可以确保volatile写之前的操作不会被编译器重排序到volatile写之后。读volatile变量时，可以确保volatile读之后的操作不会被编译器重排序到volatile读之前。</p>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>禁止指令重排序 .从而避免了多线程环境下程序出现乱序执行的现象。</p>
<p>最常见的多线程环境中 <code>DCL(double-checked locking)</code> 版本的单例模式中，就是使用了 volatile 禁止指令重排的特性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123; <span class="comment">// 线程B</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">              	<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;<span class="comment">// 线程A</span></span><br><span class="line">                      instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为有指令重排序的存在，双端检索机制也不一定是线程安全的。</p>
<p><code>instance = new Singleton();</code> </p>
<p>初始化对象的过程其实并不是一个原子的操作，它会分为三部分执行：</p>
<ol>
<li>给 instance 分配内存</li>
<li>调用 instance 的构造函数来初始化对象</li>
<li>将 instance 对象指向分配的内存空间</li>
</ol>
<p>步骤 2 和 3 不存在数据依赖(as-if-serial)关系，如果虚拟机存在指令重排序优化，则步骤 2 和 3 的顺序是无法确定的。</p>
<p>如果 A 线程率先进入同步代码块并先执行了步骤3 而没有执行 2，也就是先给赋值给引用，但未进行初始化。</p>
<p>这时候线程 B 在第一次检查的时候，会发现 instance 已经是 非null 了，就将其返回使用，但是此时 instance 实际上还未初始化，自然就会出错。所以我们要限制实例对象的指令重排，用 volatile 修饰（JDK 5 之前使用了 volatile 的双检锁是有问题的）。</p>
<p>通过 hsdis 工具获取 JIT 编译器生成的汇编指令来看看对 volatile 进行写操作 CPU 会做什么事情，还是用上边的单例模式，可以看到</p>
<img src="/pics/image-20210320214507422.png" alt="image-20210320214507422" style="zoom:50%;" />

<p>有 volatile 修饰的共享变量进行写操作时会多出第二行汇编代码，该句代码的意思是<strong>对原值加零</strong>，其中相加指令addl 前有 <strong>lock</strong> 修饰。</p>
<p>lock指令除了前面所讲的2个作用外，还有一个作用是<strong>提供内存屏障的作用</strong>，即</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br></pre></td></tr></table></figure>

<p>赋值操作的3条指令不可重排序。</p>
<p><a href="https://www.cnblogs.com/54chensongxia/p/12120117.html">https://www.cnblogs.com/54chensongxia/p/12120117.html</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
        <category>JUC</category>
      </categories>
  </entry>
  <entry>
    <title>JUC_04_synchronized</title>
    <url>/2022/12/25/Notes/Java/02JUC/JUC_04_Synchronized/</url>
    <content><![CDATA[<h1 id="JUC-03-synchronized"><a href="#JUC-03-synchronized" class="headerlink" title="JUC_03_synchronized"></a>JUC_03_synchronized</h1><span id="more"></span>

<p>Synchronized 是 Java 中解决并发问题的一种最常用的方法，也是最简单的一种方法。Synchronized 的作用主要有三个：</p>
<ol>
<li>原子性： <code>synchronized</code> 修饰的代码在同一时间只能被一个线程访问，在锁未释放之前，无法被其他线程访问到。因此，在Java中可以使用 <code>synchronized</code> 来保证方法和代码块内的操作是原子性的。</li>
<li>可见性：保证共享变量的修改能够及时可见，其实是通过 Java 内存模型中的 “<strong>对一个变量unlock操作之前，必须要同步到主内存中；如果对一个变量进行lock操作，则将会清空工作内存中此变量的值，在执行引擎使用此变量前，需要重新从主内存中load操作或assign操作初始化变量值</strong>” 来保证的</li>
<li>有序性：有效解决重排序问题，因为synchronized可以保证同一时间只有线程能访问代码块，虽然代码块中还是可能发生指令重排，但是因为synchronized可以保证只有一个线程执行，所以最后的执行结果还是正确的。</li>
</ol>
<h2 id="synchronized-分类"><a href="#synchronized-分类" class="headerlink" title="synchronized 分类"></a>synchronized 分类</h2><p>在 Java 代码中使用 synchronized 可以使用在代码块和方法中，根据 synchronized 用的位置可以有这些使用场景：</p>
<img src="/pics/image-20210321203952031.png" alt="image-20210321203952031" style="zoom:50%;" />

<p>synchronized 可以用在<strong>方法</strong>上也可以使用在<strong>代码块</strong>中，其中方法是实例方法和静态方法分别锁的是该类的实例对象和该类(class)的对象。而使用在代码块中也可以分为三种，具体的可以看上面的表格。这里需要注意的是：<strong>如果锁的是类(class)对象的话，尽管 new 多个实例对象，但他们仍然是属于同一个类依然会被锁住，即线程之间保证同步关系</strong>。</p>
<p>synchronized 锁的是对象而不是代码，锁方法锁的是 this，锁 static 方法锁的是 class，class也是一个对象。</p>
<h2 id="Java对象内存布局"><a href="#Java对象内存布局" class="headerlink" title="Java对象内存布局"></a>Java对象内存布局</h2><p>在 JVM 中，Java对象保存在堆中时，由以下三部分组成：</p>
<ul>
<li><p><strong>对象头（object header）</strong>：包括了关于堆对象的布局、类型、GC状态、同步状态和标识哈希码的基本信息。</p>
</li>
<li><p><strong>实例数据（Instance Data）</strong>：主要是存放类的数据信息，父类的信息，对象字段属性信息。</p>
<p>如果对象有属性字段，则这里会有数据信息。如果对象无属性字段，则这里就不会有数据。根据字段类型的不同占不同的字节，例如boolean类型占1个字节，int类型占4个字节等等；</p>
</li>
<li><p><strong>对齐填充（Padding）</strong>：为了字节对齐，填充的数据，不是必须的。</p>
<p>默认情况下，Java虚拟机堆中对象的起始地址需要对齐至8的倍数。如果一个对象用不到8N个字节则需要对其填充，以此来补齐对象头和实例数据占用内存之后剩余的空间大小。如果对象头和实例数据已经占满了JVM所分配的内存空间，那么就不用再进行对齐填充了。</p>
<p>所有的对象分配的字节总SIZE需要是8的倍数，如果前面的对象头和实例数据占用的总SIZE不满足要求，则通过对齐数据来填满。</p>
<p><strong>为什么要对齐数据</strong>？字段内存对齐的其中一个原因，是让字段只出现在同一CPU的缓存行中。如果字段不是对齐的，那么就有可能出现跨缓存行的字段。也就是说，该字段的读取可能需要替换两个缓存行，而该字段的存储也会同时污染两个缓存行。这两种情况对程序的执行效率而言都是不利的。其实对其填充的最终目的是为了计算机高效寻址。</p>
</li>
</ul>
<img src="/pics/image-20210321211030868.png" alt="image-20210321211030868" style="zoom:50%;" />

<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>对象头中主要包含2部分数据：<strong>mark word</strong> 和 klass pointer，如果对象是数组的话，还包含纪录数组长度的数据。</p>
<h4 id="klass-pointer"><a href="#klass-pointer" class="headerlink" title="klass pointer"></a>klass pointer</h4><p>即类型指针，是对象指向它的类元数据的<strong>指针</strong>，虚拟机通过这个指针来确定这个<strong>对象是哪个类的实</strong>例。</p>
<p>该指针的位长度为<strong>JVM的一个字大小</strong>，即32位的JVM为<strong>32位（4字节）</strong>，64位的JVM为64位。4位JVM如果开启<code>+UseCompressedOops</code>选项，<strong>该区域长度也将由64位压缩至32位</strong>。</p>
<h4 id="length-fileld"><a href="#length-fileld" class="headerlink" title="length fileld"></a>length fileld</h4><p>如果对象是一个数组，那么对象头还需要有额外的空间用于存储数组的长度，长度为JVM的一个字大小。这部分数据的长度也随着JVM架构的不同而不同：32位的JVM上，长度为32位；64位JVM则为64位。64位JVM如果开启<code>+UseCompressedOops</code>选项，<strong>该区域长度也将由64位压缩至32位</strong>。</p>
<h4 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h4><p>用于存储对象自身的运行时数据，长度为JVM的一个字大小，Mark Word在32位JVM中的长度是32bit，在64位JVM中长度是64bit。存储的内容主要包含HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等。</p>
<img src="/pics/image-20210324115401693.png" alt="image-20210324115401693" style="zoom:50%;" />

<p>虽然它们在不同位数的JVM中长度不一样，但是基本组成内容是一致的。</p>
<ul>
<li><strong>锁标志位（lock）</strong>：<strong>区分锁状态，11时表示对象待GC回收状态, 只有最后2位锁标识(11)有效。</strong></li>
<li><strong>biased_lock</strong>：是否偏向锁，<strong>由于无锁和偏向锁的锁标识都是 01，没办法区分，这里引入一位的偏向锁标识位</strong>。</li>
<li><strong>分代年龄（age）</strong>：表示对象被GC的次数，当该次数到达阈值的时候，对象就会转移到老年代。</li>
<li><strong>对象的hashcode（hash）</strong>：运<strong>行期间调用System.identityHashCode()来计算</strong>，延迟计算，并把结果赋值到这里。<strong>当对象加锁后</strong>，计算的结果31位不够表示，在偏向锁，轻量锁，重量锁，<strong>hashcode会被转移到Monitor中</strong>。</li>
<li><strong>偏向锁的线程ID（JavaThread）</strong>：偏向模式的时候，当某个线程持有对象的时候，对象这里就会被置为该线程的ID。 在后面的操作中，就无需再进行尝试获取锁的动作。</li>
<li><strong>epoch</strong>：偏向锁在CAS锁操作过程中，偏向性标识，表示对象更偏向哪个锁。</li>
<li><strong>ptr_to_lock_record</strong>：轻量级锁状态下，指向栈中锁记录的指针。当锁获取是无竞争的时，JVM使用原子操作而不是OS互斥。这种技术称为轻量级锁定。在轻量级锁定的情况下，JVM通过CAS操作在对象的标题字中设置指向锁记录的指针。</li>
<li><strong>ptr_to_heavyweight_monitor</strong>：重量级锁状态下，指向对象监视器Monitor的指针。如果两个不同的线程同时在同一个对象上竞争，则必须将轻量级锁定升级到Monitor以管理等待的线程。在重量级锁定的情况下，JVM在对象的ptr_to_heavyweight_monitor设置指向Monitor的指针。</li>
</ul>
<p>可以看到对象头中的 Mark Word 记录了对象和锁的有关信息，嗯，你没猜错，我们的 <strong>synchronized 和对象头息息相关</strong>。</p>
<h4 id="JOL"><a href="#JOL" class="headerlink" title="JOL"></a>JOL</h4><p>JOL是openjdk 给我们提供了一个工具包，可以用来获取对象的信息和虚拟机的信息。需引入 jol-core 依赖，如下</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jol-core&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">0.8</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>jol-core 常用的三个方法</p>
<ul>
<li><code>ClassLayout.parseInstance(object).toPrintable()</code>：查看对象内部信息.</li>
<li><code>GraphLayout.parseInstance(object).toPrintable()</code>：查看对象外部信息，包括引用的对象.</li>
<li><code>GraphLayout.parseInstance(object).totalSize()</code>：查看对象总大小.</li>
</ul>
<p><strong>测试代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//打印对应的对象头信息</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> A a = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> A[] arrays = <span class="keyword">new</span> A[]&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印JVM的详细信息</span></span><br><span class="line">        System.out.println(VM.current().details());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.打印普通对象内存布局</span></span><br><span class="line">        System.out.println(<span class="string">&quot;=========普通对象内存布局========&quot;</span>);</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(a).toPrintable());</span><br><span class="line">        <span class="comment">//2.打印数组对象内存布局</span></span><br><span class="line">        System.out.println(<span class="string">&quot;=========数组对象内存布局========&quot;</span>);</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(arrays).toPrintable());</span><br><span class="line">        <span class="comment">//3.打印class对象内存布局</span></span><br><span class="line">        System.out.println(<span class="string">&quot;=========class对象内存布局========&quot;</span>);</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(SynchronizedTest.class).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>打印结果：</strong></p>
<img src="/pics/image-20210324094937651.png" alt="image-20210324094937651" style="zoom:70%;" />

<p>打印结果中可以看到有 OFFSET、SIZE、TYPE DESCRIPTION、VALUE 这几个名词头，它们的含义分别是：</p>
<ul>
<li>OFFSET：偏移地址，单位字节；</li>
<li>SIZE：占用的内存大小，单位为字节；</li>
<li>TYPE DESCRIPTION：类型描述，其中object header为对象头；</li>
<li>VALUE：对应内存中当前存储的值，二进制32位</li>
</ul>
<p>由于默认开启了<strong>指针压缩</strong> ，所以klass pointer 和 length filed被压缩为4字节，JDK8版本是默认开启指针压缩的，可以通过配置vm参数开启关闭指针压缩，**-XX:-UseCompressedOops**。</p>
<h2 id="锁状态"><a href="#锁状态" class="headerlink" title="锁状态"></a>锁状态</h2><p>synchronized锁主要存在四种状态，依次是：<strong>无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态</strong>，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁。</p>
<h3 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a><strong>无锁</strong></h3><p>无锁，创建对象时的状态有没有执行到synchronized代码块，偏向锁标志位为0。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">noLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    a = <span class="keyword">new</span> A();</span><br><span class="line">    beforeLock();</span><br><span class="line">    sync();</span><br><span class="line">    afterLock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">beforeLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;=========beforeLock========&quot;</span>);</span><br><span class="line">    System.out.println(ClassLayout.parseInstance(a).toPrintable());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">afterLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;=========afterLock========&quot;</span>);</span><br><span class="line">    System.out.println(ClassLayout.parseInstance(a).toPrintable());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (a) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=========locking========&quot;</span> + s);</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(a).toPrintable());</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>偏向锁未启动时，无锁状态直接升级为轻量锁。</p>
<img src="/pics/image-20210324105907436.png" alt="image-20210324105907436" style="zoom:70%;" />



<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a><strong>偏向锁</strong></h3><p>在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。</p>
<p>当对象状态为偏向锁（biasable）时，<code>mark word</code><strong>存储的是偏向的线程ID</strong>。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，<strong>因为轻量级锁的获取及释放依赖多次CAS原子指令</strong>，而偏向锁只需要<strong>在置换ThreadID的时候依赖一次CAS原子指令</strong>即可。</p>
<p>虚拟机在启动的时候对于偏向锁有延迟，可以通过2种方式关闭偏向锁的延迟：</p>
<ul>
<li>第一种是加锁之前先让线程sleep5秒</li>
<li>第二种加上JVM的运行参数，关闭偏向锁的延迟：**<code>-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0</code>**</li>
</ul>
<p>模拟偏向锁场景</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testBiasLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// sleep开启偏向锁</span></span><br><span class="line">    sleep(<span class="number">5000</span>);</span><br><span class="line">    a = <span class="keyword">new</span> A();</span><br><span class="line">    beforeLock();</span><br><span class="line">    sync();</span><br><span class="line">    afterLock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> mills)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(mills);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关闭偏向延迟，新创建一个对象的时候mark word<code>将是可偏向状态，此时</code>mark word中<code>的thread id（参见上文偏向状态下的</code>mark word`格式）为0，表示未偏向任何线程，也叫做**匿名偏向(anonymously biased)**。</p>
<p>同步代码块执行时，markword中写入threadId；偏向锁执行完成后，由于没有出现竞争，偏向锁状态没有升级到轻量锁或恢复成无锁，批量重偏向，线程不会主动释放偏向锁。</p>
<img src="/pics/image-20210324114103144.png" alt="image-20210324114103144" style="zoom:70%;" />

<h4 id="偏向锁撤销"><a href="#偏向锁撤销" class="headerlink" title="偏向锁撤销"></a>偏向锁撤销</h4><p>当其他线程执行同步代码块时，持有偏向锁的线程才会释放锁，<strong>线程不会主动释放偏向锁</strong>。偏向锁的撤销，需要等待全局安全点，它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。<strong>撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</strong></p>
<h4 id="批量重偏向（了解）"><a href="#批量重偏向（了解）" class="headerlink" title="批量重偏向（了解）"></a>批量重偏向（了解）</h4><p>一个线程创建了大量对象并执行了初始的同步操作，之后在另一个线程中将这些对象作为锁进行之后的操作。这种case下，会导致大量的偏向锁撤销操作。</p>
<p>线程A创建了100个对象的MyLock的集合myLocks，分别对每次创建的MyLock对象进行加锁，这个时候MyLock就是偏向锁，当线程A结束后。创建线程B对集合myLocks每个MyLock对象进行加锁，这个时候前20个MyLock对象就是轻量锁，当达到20的时候，这个时候JVM会对后面的80个对象进行批量重偏向，就是让后面的80个对象偏向线程B。</p>
<p>加上JVM的运行参数<code>-XX:+PrintFlagsInitial</code></p>
<p><img src="/pics/image-20210324114802246.png" alt="image-20210324114802246"></p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a><strong>轻量级锁</strong></h3><p>是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，<strong>其他线程会通过CAS操作获取锁，不会阻塞，从而提高性能。</strong></p>
<p>当状态为轻量级锁（lightweight locked）时，<code>mark word</code>存储的是指向<strong>线程栈中<code>Lock Record</code>的指针</strong>。</p>
<p>模拟线程交替执行的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lightLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sleep(<span class="number">5000</span>);</span><br><span class="line">    a = <span class="keyword">new</span> A();</span><br><span class="line">    beforeLock();</span><br><span class="line">    Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            sync(<span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            sync(<span class="string">&quot;thread2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread1.start();</span><br><span class="line">    join(thread1);</span><br><span class="line">    thread2.start();</span><br><span class="line">    join(thread2);</span><br><span class="line">    afterLock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程交替执行时，第二个线程执行同步块时，偏向锁升级为匿名轻量锁，执行完解锁后恢复成无锁。</p>
<img src="/pics/image-20210324111943588.png" alt="image-20210324111943588" style="zoom:80%;" />

<p>这里还存在一种情况，JVM匿名偏向未启动时，这个执行的结果是偏向锁，实际上是不准确的，有一种解释如下：</p>
<p><a href="https://blog.csdn.net/qq_36434742/article/details/106876862">https://blog.csdn.net/qq_36434742/article/details/106876862</a></p>
<h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a><strong>重量级锁</strong></h3><p>向重量级锁的指针，<strong>此时等待锁的线程都会进入阻塞状态</strong>。</p>
<p>当状态为重量级锁（inflated）时，为指向<strong>堆中的monitor对象的指针</strong>。</p>
<p>模拟多个线程并发</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heavyLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sleep(<span class="number">5000</span>);</span><br><span class="line">    a = <span class="keyword">new</span> A();</span><br><span class="line">    beforeLock();</span><br><span class="line">    <span class="keyword">int</span> threadSize = <span class="number">2</span>;</span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadSize);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadSize; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> id = i;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                sync(<span class="string">&quot;thread_&quot;</span> + id);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    afterLock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看懂多线程同时竞争时，升级到重量锁，执行完解锁后恢复成无锁。</p>
<img src="/pics/image-20210324113023134.png" alt="image-20210324113023134" style="zoom:70%;" />

<h4 id="阻塞vs自旋"><a href="#阻塞vs自旋" class="headerlink" title="阻塞vs自旋"></a>阻塞vs自旋</h4><p>阻塞是重量级锁的实现原理，自旋是轻量级锁的实现原理。那阻塞和自旋个是什么？</p>
<p><strong>阻塞一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间</strong>。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长，不过阻塞线程是不消耗cpu资源的。</p>
<p>自旋是让请求锁的线程“稍等一下”再请求锁，不放弃CPU的执行时间，避免了线程切换的开销。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之<strong>，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源</strong>。</p>
<h2 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h2><p>偏向锁、轻量级锁、重量级锁三种形式，分别对应了锁只被一个线程持有、不同线程交替持有锁、多线程竞争锁三种情况。状态转换图如下：</p>
<p><img src="/pics/image-20210324093532176.png" alt="image-20210324093532176"></p>
<h2 id="synchronized-的底层原理"><a href="#synchronized-的底层原理" class="headerlink" title="synchronized 的底层原理"></a>synchronized 的底层原理</h2><p>synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的<strong>Mutex Lock（互斥锁）</strong>来实现的线程同步。</p>
<h3 id="synchronized代码块"><a href="#synchronized代码块" class="headerlink" title="synchronized代码块"></a>synchronized代码块</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedTest.class) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>通过命令<strong>javac SynchronizedTest.java</strong> 生成字节码文件，再使用命令  <strong>javap -c SynchronizedTest</strong>  查看字节码文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">       <span class="number">0</span>: ldc           #<span class="number">2</span>                  <span class="comment">// class SynchronizedTest</span></span><br><span class="line">       <span class="number">2</span>: dup</span><br><span class="line">       <span class="number">3</span>: astore_1</span><br><span class="line">       <span class="number">4</span>: monitorenter</span><br><span class="line">       <span class="number">5</span>: aload_1</span><br><span class="line">       <span class="number">6</span>: monitorexit</span><br><span class="line">       <span class="number">7</span>: goto          <span class="number">15</span></span><br><span class="line">      <span class="number">10</span>: astore_2</span><br><span class="line">      <span class="number">11</span>: aload_1</span><br><span class="line">      <span class="number">12</span>: monitorexit</span><br><span class="line">      <span class="number">13</span>: aload_2</span><br><span class="line">      <span class="number">14</span>: athrow</span><br><span class="line">      <span class="number">15</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>从字节码文件中可以看出，执行同步代码块后首先要先执行 <strong>monitorenter</strong> 指令，退出的时候执行 <strong>monitorexit</strong> 指令。</p>
<ol>
<li><strong>MonitorEnter 指令：插入在同步代码块的开始位置，当代码执行到该指令时，将会尝试获取该对象Monitor 的所有权，即尝试获得该对象的锁；</strong></li>
<li><strong>MonitorExit 指令：插入在方法结束处和异常处，JVM 保证每个MonitorEnter 必须有对应的MonitorExit；</strong></li>
</ol>
<p>那什么是 Monitor？可以把它理解为 一个同步工具，也可以描述为一种同步机制，它通常被描述为一个对象。</p>
<p>与万物皆对象一样，所有的 Java 对象是天生的 Monitor，每一个 Java 对象都有成为 Monitor 的潜质，因为在 Java 的设计中 ，<strong>每一个 Java 对象</strong>每个对象都存在着一个 monitor 与之关联，它叫做内部锁或者 Monitor 锁。</p>
<img src="/pics/image-20210321224031758.png" alt="image-20210321224031758" style="zoom:40%;" />

<h4 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a><strong>monitor</strong></h4><p>在 Java虚拟机(HotSpot)中，Monitor是基于C++实现的，由 <a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/runtime/objectMonitor.cpp">ObjectMonitor (opens new window)</a>实现。</p>
<p>ObjectMonitor中有两个队列， <code>_WaitSet</code>和<code>_EntryList</code>， 用来保存ObjectWaiter对象列表(每个等待锁的线程都会被封装成ObjectWaiter对象)， <code>_owner</code>指向持有ObjectMonitor对象的线程。</p>
<p>当多个线程同时访问一段同步代码时，首先会进入<code>_EntryList</code>集合， 当线程获取到对象的monitor后，进入<code>_owner</code>区域， 并把monitor中到onwer变量设置为当前线程， 同时monitor中的计数器count+1。</p>
<p>若线程调用wait()方法，将释放当前持有的monitor（锁）， owner=null， count-1, 同时该线程进入waitSet集合中等待被唤醒。若当前线程执行完毕也将释放锁，并复位变量的值，以便其他线程进入获取锁。 如下图所示：</p>
<img src="/pics/image-20210321232934684.png" alt="image-20210321232934684" style="zoom:50%;" />

<h3 id="synchronized方法"><a href="#synchronized方法" class="headerlink" title="synchronized方法"></a>synchronized方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>字节码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">   descriptor: ()V</span><br><span class="line">   flags: ACC_PUBLIC, ACC_SYNCHRONIZED --</span><br><span class="line">   Code:</span><br><span class="line">     stack=<span class="number">0</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">        <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">     LineNumberTable:</span><br><span class="line">       line <span class="number">7</span>: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>从字节码中可以看出，synchronized修饰的方法并没有monitorenter指令和monitorexit指令，取得代之的确实是<strong>ACC_SYNCHRONIZED标识</strong>，该标识指明了该方法是一个同步方法，JVM通过该ACC_SYNCHRONIZED访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p>
<h2 id="其他锁概念"><a href="#其他锁概念" class="headerlink" title="其他锁概念"></a>其他锁概念</h2><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>为了保证数据的完整性，在进行操作时需要对这部分操作进行同步控制，但是在有些情况下，JVM 检测到不可能存在共享数据竞争，这时 JVM 就会对这些同步锁进行锁消除。</p>
<p>如果不存在竞争，为什么还需要加锁呢？所以锁消除可以节省毫无意义的请求锁的时间。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是对于程序员来说这还不清楚么？在明明知道不存在数据竞争的代码块前加上同步吗？但是有时候程序并不是我们所想的那样？虽然没有显示使用锁，但是在使用一些 JDK 的内置 API 时，如 StringBuffer、Vector、HashTable 等，这个时候会存在隐形的加锁操作。比如 StringBuffer 的 <code>append()</code> 方法，Vector的 <code>add()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">vectorTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Vector&lt;String&gt; vector = <span class="keyword">new</span> Vector&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">        vector.add(i + <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(vector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在运行这段代码时，JVM 可以明显检测到变量 vector 没有逃逸出方法 vectorTest() 之外，所以 JVM可以大胆地将vector 内部的加锁操作消除。</p>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>很多时候，我们提倡尽量减小锁的粒度，可以避免不必要的阻塞。 让同步块的作用范围尽可能小，仅在共享数据的实际作用域中才进行同步，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。</p>
<p>但是如果在一段代码中连续的用同一个监视器锁反复的加锁解锁，甚至加锁操作出现在循环体中的时候，就会导致不必要的性能损耗，这种情况就需要锁粗化。</p>
<p>锁粗话概念比较好理解，就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁</p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++)&#123;</span><br><span class="line">  <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">    <span class="keyword">do</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会被粗化成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">do</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/jajian/p/13681781.html1%C2%B7%C2%B7">https://www.cnblogs.com/jajian/p/13681781.html1··</a></p>
<p><a href="https://blog.csdn.net/qq_36434742/article/details/106876862">https://blog.csdn.net/qq_36434742/article/details/106876862</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
        <category>JUC</category>
      </categories>
  </entry>
  <entry>
    <title>JUC_06_CountDownLatch</title>
    <url>/2022/12/25/Notes/Java/02JUC/JUC_06_CountDownLatch/</url>
    <content><![CDATA[<h1 id="JUC-06-CountDownLatch"><a href="#JUC-06-CountDownLatch" class="headerlink" title="JUC_06_CountDownLatch"></a>JUC_06_CountDownLatch</h1><span id="more"></span>

<p>CountDownLatch，让一个或多个线程等待其他线程完成操作。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CountDownlatchTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// do sth</span></span><br><span class="line">                System.out.println(<span class="string">&quot;do sth&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>基本原理</strong>：</p>
<ol>
<li>CountDownLatch 初始化时，设置 state 值为count 值；</li>
<li>所有调用await方法的线程会阻塞并构造节点加入同步队列；</li>
<li>直到通过调用countDown值使state为0，再唤醒同步队列所有节点的线程继续执行。</li>
</ol>
<img src="/pics/image-20210405142433953.png" alt="image-20210405142433953" style="zoom:50%;" />

<p>CountDownLatch 也是基于AQS的，内部同步器Sync实现了AQS的tryAcquireShared等方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123; <span class="comment">// 构造方法</span></span><br><span class="line">      <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;count &lt; 0&quot;</span>); <span class="comment">// count 必须&gt;0</span></span><br><span class="line">      <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count); <span class="comment">// 初始化 Sync</span></span><br><span class="line">  	&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    		<span class="comment">//...  </span></span><br><span class="line">        Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">              setState(count); <span class="comment">// 设置state的初始值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看下await的原理。</p>
<h1 id="await"><a href="#await" class="headerlink" title="await"></a>await</h1><h2 id="CDL-await"><a href="#CDL-await" class="headerlink" title="CDL.await"></a>CDL.await</h2><p>await 调用到 sync.acquireSharedInterruptibly</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>); <span class="comment">// 参数值 1 无意义 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AQS-acquireSharedInterruptibly"><a href="#AQS-acquireSharedInterruptibly" class="headerlink" title="AQS.acquireSharedInterruptibly"></a>AQS.acquireSharedInterruptibly</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted()) <span class="comment">// 在await前线程已经被中断了，直接抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>) <span class="comment">// 返回值小于 0 表示state &gt; 0</span></span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CDL.Sync.tryAcquireShared</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来重点看下AQS.doAcquireSharedInterruptibly的实现。</p>
<h3 id="AQS-doAcquireSharedInterruptibly"><a href="#AQS-doAcquireSharedInterruptibly" class="headerlink" title="AQS.doAcquireSharedInterruptibly"></a>AQS.doAcquireSharedInterruptibly</h3><p>作用有2个：</p>
<ol>
<li>阻塞 所有调用 <code>await</code> 的线程</li>
<li>通过countDown 使state == 0时，唤醒后继节点</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED); <span class="comment">// 添加节点到同步队列中，节点的类型为SHARED</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg); <span class="comment">// 检测节点的当前状态</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r); <span class="comment">// r&gt;=0,表示锁已经释放，唤醒下个节点</span></span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; <span class="comment">// 设置节点的前驱为 Signal </span></span><br><span class="line">                parkAndCheckInterrupt()) <span class="comment">// 阻塞当前线程</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="setHeadAndPropagate"><a href="#setHeadAndPropagate" class="headerlink" title="setHeadAndPropagate"></a>setHeadAndPropagate</h3><p>唤醒同步队列中的下个节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    setHead(node); <span class="comment">// 设置当前节点为head节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared(); <span class="comment">// 唤醒下个节点，下面再讲</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="countDown"><a href="#countDown" class="headerlink" title="countDown"></a>countDown</h1><h2 id="CDL-countDown"><a href="#CDL-countDown" class="headerlink" title="CDL.countDown"></a>CDL.countDown</h2><p>countDown 调用搭配 Sync.releaseShared 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AQS-releaseShared"><a href="#AQS-releaseShared" class="headerlink" title="AQS.releaseShared"></a>AQS.releaseShared</h2><p>判断当前state值是否为0，唤醒同步队列中的所有节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123; <span class="comment">// tryReleaseShared 表示 state == 0 ，需要唤醒同步队列中的所有节点</span></span><br><span class="line">        doReleaseShared(); <span class="comment">// 唤醒后面的节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CDL-Sync-tryReleaseShared"><a href="#CDL-Sync-tryReleaseShared" class="headerlink" title="CDL.Sync.tryReleaseShared"></a>CDL.Sync.tryReleaseShared</h3><p>tryReleaseShared，判断锁是否已经完全释放。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) <span class="comment">// 表示之前已经 state 已经是 0 了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">        <span class="keyword">int</span> nextc = c-<span class="number">1</span>; <span class="comment">// state - 1</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc)) <span class="comment">// cas 设置最新的state</span></span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>; <span class="comment">// state == 0 表示锁已经完全释放了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AQS-doReleaseShared"><a href="#AQS-doReleaseShared" class="headerlink" title="AQS.doReleaseShared"></a>AQS.doReleaseShared</h3><p>唤醒阻塞线程，联系前面的方法。也就是说，</p>
<ol>
<li>通过countDown 使state == 0 后，先doReleaseShared -&gt; unparkSuccessor 唤醒同步队列中阻塞的节点线程后；</li>
<li>唤醒后的线程会执行doAcquireSharedInterruptibly获取锁，再调用setHeadAndPropagate，继续唤醒下个节点；</li>
<li>setHeadAndPropagate会再次调用到doReleaseShared中，直到同步队列中所有的等待节点都被唤醒。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123; <span class="comment">//将当前节点状态改为 0 </span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h); <span class="comment">// 唤醒阻塞线程</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>countDownLatch的特性：</p>
<ol>
<li><p> 管理一个大于零的计数器值； </p>
</li>
<li><p> 每countDown一次则state就减1一次，直到许可证数量等于0则释放队列中所有的等待线程；</p>
</li>
<li><p> 也可以通过countDown/await组合一起使用，来实现CyclicBarrier的功能，举例</p>
</li>
</ol>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CountDownlatchTest2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CountDownLatch waitLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    CountDownLatch signalLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;waitLatch await  i&quot;</span> + index);</span><br><span class="line">                    waitLatch.await();</span><br><span class="line">                    sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;signalLatch countDown &quot;</span> + index);</span><br><span class="line">                    signalLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保证子线程先执行</span></span><br><span class="line">    sleep(<span class="number">500</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;waitLatch countDown &quot;</span>);</span><br><span class="line">    waitLatch.countDown();</span><br><span class="line">    System.out.println(<span class="string">&quot;signalLatch await &quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        signalLatch.await();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JAVA</category>
        <category>JUC</category>
      </categories>
  </entry>
  <entry>
    <title>JUC_07_CyclicBarrier</title>
    <url>/2022/12/25/Notes/Java/02JUC/JUC_07_CyclicBarrier/</url>
    <content><![CDATA[<h1 id="JUC-07-CyclicBarrier"><a href="#JUC-07-CyclicBarrier" class="headerlink" title="JUC_07_CyclicBarrier"></a>JUC_07_CyclicBarrier</h1><span id="more"></span>

<p>CyclicBarrier，让一组线程到达屏障是被阻塞，只到最后一个线程到达屏障时，屏障才会继续执行。</p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CyclicBarrierTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;cyclicBarrier access1&quot;</span>);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;cyclicBarrier end&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cyclicBarrier access2&quot;</span>);</span><br><span class="line">        cyclicBarrier.await();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;cyclicBarrier end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CyclicBarrier 的实现是基于ReentrantLock 和 Condition，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrier</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  表示代的概念</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// condition对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</span><br><span class="line">		<span class="comment">// 线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</span><br><span class="line">    <span class="comment">// 线程都到达屏障后，优先执行的任务，在最后一个到达线程中执行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line">    <span class="comment">// 表示代的概念</span></span><br><span class="line">    <span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br><span class="line">		<span class="comment">// 到达的线程数，初始值为parties，没到达一个线程减1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.parties = parties;</span><br><span class="line">        <span class="keyword">this</span>.count = parties;</span><br><span class="line">        <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="await"><a href="#await" class="headerlink" title="await"></a>await</h1><p>调用到dowait</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="dowait"><a href="#dowait" class="headerlink" title="dowait"></a>dowait</h2><p>dowait主要作用：</p>
<ol>
<li>在await之前，判断线程是否可await，如果barrier已经被打破了，直接抛出异常</li>
<li>所有线程都正常到达后，执行 barrierCommand 并唤醒所有线程</li>
<li>如果有线程还为到达，在await之后，判断barrier是否已经被其他线程通过中断打破。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">           TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取barrier当前的 “代”</span></span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line">        <span class="comment">// await 之前</span></span><br><span class="line">				<span class="comment">// 在第二个线程调用await过程中， 当前代是已经被打破状态，第一个线程调用await的线程发生了中断</span></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line">				<span class="comment">// 调用await 前线程已经被中断了</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier(); <span class="comment">// 标记代被中断，并唤醒其他线程</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = --count; <span class="comment">// 正常 await 时，count --</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// 所有线程都到达阻塞点后</span></span><br><span class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                    command.run(); <span class="comment">// 在最后一个到达线程中执行barrierCommand</span></span><br><span class="line">                ranAction = <span class="keyword">true</span>; <span class="comment">// 标记为true</span></span><br><span class="line">                nextGeneration(); <span class="comment">// 开启下一代</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ranAction) <span class="comment">// 执行barrierCommand 时发生异常</span></span><br><span class="line">                    breakBarrier(); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="comment">// 如果 --count &gt; 0 </span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    trip.await(); <span class="comment">// 阻塞</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos); <span class="comment">// 阻塞一定时间</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123; </span><br><span class="line">              <span class="comment">// await 之后</span></span><br><span class="line">              <span class="comment">// 线程已经await了，阻塞过程中，在 条件队列 中发生中断</span></span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; <span class="comment">// 当前代并没有变化</span></span><br><span class="line">                    ! g.broken) &#123; <span class="comment">// 当前代如果没有被打破，那么当前线程就去打破，并且抛出异常..</span></span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g.broken) <span class="comment">// 代 被打破，抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g != generation) <span class="comment">// 正常执行结束</span></span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123; <span class="comment">// 等待超时，然后主动转移到 阻塞队列 然后获取到锁 唤醒。</span></span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">//解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="breakBarrier"><a href="#breakBarrier" class="headerlink" title="breakBarrier"></a>breakBarrier</h2><p>标记 代被中断，唤醒所有await的线程，如果有继续向下执行，后续可能会抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    generation.broken = <span class="keyword">true</span>;</span><br><span class="line">    count = parties;</span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="nextGeneration"><a href="#nextGeneration" class="headerlink" title="nextGeneration"></a>nextGeneration</h2><p>所有阻塞的线程都到达了阻塞点，正常结束或重置CyclicBarrier时会调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    trip.signalAll();</span><br><span class="line">    count = parties;</span><br><span class="line">    generation = <span class="keyword">new</span> Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h1><p>重置CyclicBarrier，可重复使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        breakBarrier();   <span class="comment">// break the current generation</span></span><br><span class="line">        nextGeneration(); <span class="comment">// start a new generation</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>让一组线程互相等待，直到都到达公共屏障点才开始各自继续做各自的工作；</li>
<li>可重复利用，每正常走完一次流程，或者异常结束流程，那么接下来一轮还是可以继续利用CyclicBarrier实现线程等待功能；</li>
<li>共存亡，只要有一个线程有异常发生中断，那么其它线程都会被唤醒继续工作，然后接着就是抛异常处理；</li>
</ul>
]]></content>
      <categories>
        <category>JAVA</category>
        <category>JUC</category>
      </categories>
  </entry>
  <entry>
    <title>JUC_05_AQS</title>
    <url>/2022/12/25/Notes/Java/02JUC/JUC_05_AQS/</url>
    <content><![CDATA[<h1 id="JUC-05-AQS"><a href="#JUC-05-AQS" class="headerlink" title="JUC_05_AQS"></a>JUC_05_AQS</h1><span id="more"></span>

<p>Java中的大部分同步类（Lock、Semaphore、ReentrantLock等）都是基于AbstractQueuedSynchronizer（简称为AQS）实现的。AQS是一种提供了原子式管理同步状态、阻塞和唤醒线程功能以及队列模型的简单框架。</p>
<h1 id="一、AQS-原理"><a href="#一、AQS-原理" class="headerlink" title="一、AQS 原理"></a>一、AQS 原理</h1><p>AQS核心思想是，如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。</p>
<p>CHL是单向链表，AQS中的队列是CLH变体的虚拟双向队列（FIFO），AQS是通过将每条请求<strong>共享资源的线程封装成一个节点来实现锁</strong>的分配。</p>
<img src="/pics/image-20210328225113130.png" alt="image-20210328225113130" style="zoom:50%;" />

<p>AQS使用一个Volatile的int类型的成员变量<strong>state来表示同步状态</strong>，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State值的修改。</p>
<h2 id="1-1、数据结构"><a href="#1-1、数据结构" class="headerlink" title="1.1、数据结构"></a>1.1、数据结构</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 共享模式</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">        <span class="comment">// 独占模式</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// waitStatus状态</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 节点在队列中的状态</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同步队列中节点的前驱</span></span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line">        <span class="comment">// 同步队列中节点的后继</span></span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line">        <span class="comment">// 当前节点的线程</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 条件队列的下一个节点</span></span><br><span class="line">        Node nextWaiter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line">	  <span class="comment">// 尾结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line">	 <span class="comment">// 锁状态 &gt;0 表示锁定</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>AQS中维护了一个名为state的字段，意为同步状态，state也就是加锁状态，下图展示了独占锁和共享锁中state的不同意义，本文分析的ReentrantLock是独占锁。</p>
<img src="/pics/image-20210328231610295.png?lastModify=1617201243" alt="image-20210328231610295" style="zoom:33%;" />

<h3 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h3><p>同步队列中存储着所有竞争锁的线程节点，在前面节点释放锁或线程被中断后，同步队列中的节点开始竞争锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头结点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line">  <span class="comment">// 尾结点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br></pre></td></tr></table></figure>
<h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>同步队列中的节点</p>
<table>
<thead>
<tr>
<th align="left">方法和属性值</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">waitStatus</td>
<td align="left">当前节点在队列中的状态</td>
</tr>
<tr>
<td align="left">thread</td>
<td align="left">表示处于该节点的线程</td>
</tr>
<tr>
<td align="left">prev</td>
<td align="left">前驱指针</td>
</tr>
<tr>
<td align="left">next</td>
<td align="left">后继指针</td>
</tr>
<tr>
<td align="left">predecessor</td>
<td align="left">返回前驱节点，没有的话抛出 NullPointerException</td>
</tr>
<tr>
<td align="left">nextWaiter</td>
<td align="left">指向下一个处于 CONDITION 状态的节点</td>
</tr>
</tbody></table>
<h3 id="等待状态"><a href="#等待状态" class="headerlink" title="等待状态"></a>等待状态</h3><p>waitStatus</p>
<table>
<thead>
<tr>
<th align="left">枚举</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">当一个 Node 被初始化的时候的默认值，同步队列中的</td>
</tr>
<tr>
<td align="left">CANCELLED</td>
<td align="left">为 1，表示线程获取锁的请求已经取消了</td>
</tr>
<tr>
<td align="left">CONDITION</td>
<td align="left">为 -2，表示节点在等待队列中，节点线程等待唤醒</td>
</tr>
<tr>
<td align="left">PROPAGATE</td>
<td align="left">为 -3，当前线程处在 SHARED 情况下，该字段才会使用</td>
</tr>
<tr>
<td align="left">SIGNAL</td>
<td align="left">为 -1，表示节点的后继需要唤醒</td>
</tr>
</tbody></table>
<h2 id="1-2、重要方法"><a href="#1-2、重要方法" class="headerlink" title="1.2、重要方法"></a>1.2、重要方法</h2><p>AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单而又高效地构造出同步器。AQS的设计采用了模板方法模式的，也就是说，如果我们要借助AQS自定义锁，只需要需要实现AQS的以下方法：</p>
<img src="/pics/image-20210330222313955.png" alt="image-20210330222313955" style="zoom:70%;" />

<p>自定义同步器要么是独占方式，要么是共享方式，它们也只需实现 <code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code> 中的一种即可。除此之外, 同步器加解锁的核心方法acquire、release，acquireShared - releaseShared 等等AQS都帮我们实现好了，在后面的讲解中再介绍。</p>
<h1 id="二、ReentrantLock"><a href="#二、ReentrantLock" class="headerlink" title="二、ReentrantLock"></a>二、ReentrantLock</h1><h2 id="2-1-ReentrantLock特性概览"><a href="#2-1-ReentrantLock特性概览" class="headerlink" title="2.1 ReentrantLock特性概览"></a>2.1 ReentrantLock特性概览</h2><p>ReentrantLock意思为可重入锁，指的是一个线程多次加锁。为了帮助大家更好地理解ReentrantLock的特性，我们先将ReentrantLock跟常用的Synchronized进行比较：</p>
<img src="/pics/image-20210330221805165.png" alt="image-20210330221805165" style="zoom:70%;" />



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// **************************Synchronized的使用方式**************************</span></span><br><span class="line"><span class="comment">// 1.用于代码块</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;&#125;</span><br><span class="line"><span class="comment">// 2.用于对象</span></span><br><span class="line"><span class="keyword">synchronized</span> (object) &#123;&#125;</span><br><span class="line"><span class="comment">// 3.用于方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span> <span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 4.可重入</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// **************************ReentrantLock的使用方式**************************</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span> <span class="params">()</span> throw Exception </span>&#123;</span><br><span class="line">	<span class="comment">// 1.初始化选择公平锁、非公平锁</span></span><br><span class="line">	ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">	<span class="comment">// 2.可用于代码块</span></span><br><span class="line">	lock.lock();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 3.支持多种加锁方式，比较灵活; 具有可重入特性</span></span><br><span class="line">			<span class="keyword">if</span>(lock.tryLock(<span class="number">100</span>, TimeUnit.MILLISECONDS))&#123; &#125;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">// 4.手动释放锁</span></span><br><span class="line">			lock.unlock()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		lock.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReentrantLock分为公平锁和非公平锁，内部的实现依赖于AQS。ReentrantLock和AQS的继承关系如下图所示：</p>
<img src="/pics/image-20210330213019476.png" alt="image-20210330213019476" style="zoom:70%;" />



<p>可以看到，ReentrantLock中的内部抽象类Sync 继承自AQS，而公平锁的同步器FairSync和非公平锁的同步器NonfairSync又继承自Sync。</p>
<p>公平锁和非公平的锁的区别是什么呢？我们来看下<code>FairSync</code> 和 <code>NonfairSync</code>。</p>
<h2 id="2-2、公平锁和非公平锁"><a href="#2-2、公平锁和非公平锁" class="headerlink" title="2.2、公平锁和非公平锁"></a>2.2、公平锁和非公平锁</h2><p>ReentLock 默认的构造方法使用的是非公平锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用ReentrantLock.lock 加锁时，lock方法最终调用到了Sync.lock</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Sync类在ReentLock 有有2种实现，FairSync 和 NonfairSync，分别对应的是 <code>公平锁</code> 和 <code>非公平锁</code>的队列同步器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 公平锁同步器</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>); <span class="comment">// 不同之处1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; <span class="comment">// 不同之处2</span></span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是非公平锁同步器</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread()); <span class="comment">// 不同之处1</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nonfairTryAcquire是Sync的方法先贴过来</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123; <span class="comment">// 不同之处2</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较之后我们知道看到共有2个不同之处：</p>
<ol>
<li>lock 方法中后<strong>，非公平锁会先调用 CAS 进行一次抢锁</strong>，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</li>
<li> tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁；<strong>但是公平锁会判断同步队列中是否有等待节点</strong>，如果有则不去抢锁，乖乖排到后面。</li>
</ol>
<p>如果非公平锁这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。</p>
<p>相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</p>
<p>对比完公平锁和非公平锁，下面我们就从锁常用的4个方法<strong>lock、unlock、await、notify</strong>来介绍下ReenLock和AQS的原理，我们以<strong>公平锁</strong>为例，公平锁相对非公平锁要更复杂一点。</p>
<h2 id="2-3、lock过程分析"><a href="#2-3、lock过程分析" class="headerlink" title="2.3、lock过程分析"></a>2.3、lock过程分析</h2><p>加锁的调用链如下：</p>
<img src="/pics/image-20210330222928614.png" alt="image-20210330213019476" style="zoom:70%;" />

<h3 id="ReentrantLock-lock"><a href="#ReentrantLock-lock" class="headerlink" title="ReentrantLock.lock"></a>ReentrantLock.lock</h3><p>加锁首先lock，公平锁lock 最终调用到acquire方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>); <span class="comment">// 不同之处1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AQS-acquire"><a href="#AQS-acquire" class="headerlink" title="AQS.acquire"></a>AQS.acquire</h3><p>acquire是AQS的核心方法，分解下：</p>
<ol>
<li>调用tryAcquire获取锁，获取成功立刻结束；获取失败调用addWaiter</li>
<li>addWaiter，将获取锁的线程封装成节点加入到等待队列中</li>
<li>acquireQueued，竞争失败后挂起当前线，待唤醒后再次竞争锁</li>
<li>selfInterrupt，节点唤醒后设置线程状态为中断，返回给业务方。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) <span class="comment">//</span></span><br><span class="line">        &amp;&amp; acquireQueued(</span><br><span class="line">            addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        <span class="comment">// 设置线程状态为中断</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FairSync-tryAcquire"><a href="#FairSync-tryAcquire" class="headerlink" title="FairSync.tryAcquire"></a>FairSync.tryAcquire</h3><p>公平锁的tryAcquire的方法获取锁，成功返回true，失败返回false。</p>
<ol>
<li>state == 0， 表示当前AQS处于无锁状态，在满足以下2个条件后，设置当前独占线程为当前线程<ul>
<li>hasQueuedPredecessors，同步队列中没有等待的节点</li>
<li>compareAndSetState ，抢占锁成功</li>
</ul>
</li>
<li>current == getExclusiveOwnerThread()，表示当前获取锁的线程再次进行了加锁，state自增</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// state == 0,表示没有被加锁</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; <span class="comment">// 同步队列中是否有待唤醒的节点，后面再说</span></span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123; <span class="comment">// cas 抢占锁成功</span></span><br><span class="line">                setExclusiveOwnerThread(current);  <span class="comment">// 设置线程为当前线程</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">//支持可重入</span></span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// 越界判断，当重入次数达到int值最大之，会变负数</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tryAcquire线程抢占锁成功时直接放回，抢占失败后，addWaiter线程加入到同步队列中。</p>
<h3 id="AQS-addWaiter"><a href="#AQS-addWaiter" class="headerlink" title="AQS.addWaiter"></a>AQS.addWaiter</h3><p>addWaiter将当前线程加入到同步队列中</p>
<ol>
<li>如果当前队尾元素不为空也就是队列不为空，使用尾插法入队</li>
<li>如果当前是空队列或者cas失败，使用enq方法 <strong>自旋 + cas</strong> 入队</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred; <span class="comment">//// 先赋值前驱 + cas tail 可以保证tail.prev 一定是有值的，释放锁的时候会用到</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123; <span class="comment">//尾插法入队</span></span><br><span class="line">            <span class="comment">// 这里有并发，联系到hasQueuedPredecessors</span></span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node); <span class="comment">//自旋入队</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AQS-enq"><a href="#AQS-enq" class="headerlink" title="AQS.enq"></a>AQS.enq</h4><p> enq，自旋入队，只有当前node入队成功后，才会跳出循环，<strong>返回当前尾节点前驱节点</strong>（这里没有使用到这个特性，后面在讲）。有2种情况：</p>
<ol>
<li>tail节点为空，空队列时，<strong>先增加一个虚节点作为头节点</strong>；第二次循环时，将当前节点入队；</li>
<li>尾插法入队，通过自旋，保证一定可以入队。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">// 自旋</span></span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node())) <span class="comment">// 添加一个虚节点</span></span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t; <span class="comment">// 先赋值前驱 + cas tail 可以保证tail.prev 一定是有值的，释放锁的时候会用到</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123; <span class="comment">// 尾插法入队</span></span><br><span class="line">                t.next = node; <span class="comment">// 这里可能存在并发，tail有值，但是tail.next不一定有值。</span></span><br><span class="line">                <span class="comment">// ！！！注意返回的是当前尾节点前驱节点 ！！！</span></span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;当enq入队成功，进入acquireQueued方法。</span><br></pre></td></tr></table></figure>

<h4 id="AQS-hasQueuedPredecessors"><a href="#AQS-hasQueuedPredecessors" class="headerlink" title="AQS.hasQueuedPredecessors"></a>AQS.hasQueuedPredecessors</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp; <span class="comment">// 条件 1</span></span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> <span class="comment">//条件 2</span></span><br><span class="line">         || s.thread != Thread.currentThread()); <span class="comment">// 条件 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里补充下hasQueuedPredecessors的判断逻辑，未方便描述这3个条件分别做了如上标记：</p>
<ol>
<li><p>条件1 h != t ，很好理解，头尾不同，说明同步队列至少有2个节点，由于同步队列的第一个节点为虚节点，其实并不存储任何信息，只是占位，所以还要继续判断。</p>
</li>
<li><p>(s = h.next) == null || s.thread != Thread.currentThread() ，别忘了此时<code>条件1</code>是成立的，再分解下：</p>
<ul>
<li><p>h != t 成立情况下，若<code>条件2</code>成立 ，说明等待队列中的第二个节点正在加入同步队列过程中（前一个节点是个虚节点）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">node.prev = t; <span class="comment">// 先赋值前驱 + cas tail 可以保证tail.prev 一定是有值的，释放锁的时候会用到</span></span><br><span class="line"><span class="keyword">if</span> (compareAndSetTail(t, node)) &#123; <span class="comment">// 尾插法入队</span></span><br><span class="line">		t.next = node; <span class="comment">// 这里可能存在并发，tail有值，但是tail.next不一定有值。</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>条件3</code>成立，<code>条件1成立</code> 且 <code>条件2不成立</code>，如果(s = h.next) != null，说明此时队列中至少有一个有效节点, 如果s.thread != Thread.currentThread()，说明<strong>等待队列的第一个有效节点线程与当前线程不同</strong>，当前线程必须加入进等待队列。</p>
</li>
</ul>
</li>
</ol>
<p>总结下：hasQueuedPredecessors的逻辑是，同步队列中至少有一个有效节点且这个节点和当前要插入的节点线程不同。</p>
<h3 id="AQS-acquireQueued"><a href="#AQS-acquireQueued" class="headerlink" title="AQS.acquireQueued"></a>AQS.acquireQueued</h3><p>acquireQueued通过自旋的方式让<code>同步队列</code>中的节点竞争锁，返回值表示<strong>线程在<code>同步队列</code>中竞争锁过程中是否被中断过</strong>。在<strong>线程获取锁</strong>或<strong>线程被唤醒的场景下</strong>：</p>
<ol>
<li><p>如果当前节点是head-&gt;next节点，尝试竞争锁（head-&gt;next节点在任何情况下都有权利去争夺锁）</p>
<ol>
<li>如果<strong>竞争成功，退出自旋并返回中断标记</strong>，将当前节点设置为头节点，回收老的头节点；</li>
<li>否则，继续挂起。</li>
</ol>
</li>
<li><p>如果节点不是head -&gt;next, 挂起当前节点的线程</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//什么时候会执行这里？</span></span><br><span class="line">            <span class="comment">//1.进入for循环时 在线程尚未park前会执行</span></span><br><span class="line">            <span class="comment">//2.线程park之后 被唤醒后，也会执行这里...</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// p 是当前节点的前驱</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">             <span class="comment">// 当前节点是head的next节点，head-&gt;next节点在任何情况下都有权利去争夺锁，进入这里的情况有2种：</span></span><br><span class="line">             <span class="comment">//   1.被唤醒</span></span><br><span class="line">             <span class="comment">//   2.走到这里时，前一个线程已经释放了锁，当前节点tryAcquire成功</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node); <span class="comment">// 将当前节点设置为头节点</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 获取到锁时退出，返回当前线程的中断标记</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//  haed-&gt;next 竞争失败或者非head-&gt;next节点</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; <span class="comment">// 2.挂起当前线程</span></span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">// ！！！中断信号唤醒时，线程状态改为true ！！！</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node); <span class="comment">//通常用于响应中断的锁，普通lock只有一种情况走到这里，tryAcquire中锁多次重入，导致state越界变成负数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续看下线程挂起相关的逻辑shouldParkAfterFailedAcquire 和 parkAndCheckInterrupt 这2个方法。</p>
<h4 id="AQS-shouldParkAfterFailedAcquire"><a href="#AQS-shouldParkAfterFailedAcquire" class="headerlink" title="AQS.shouldParkAfterFailedAcquire"></a>AQS.shouldParkAfterFailedAcquire</h4><p>主要作用是找到<strong>当前节点的有效前驱</strong>，并将<strong>前驱节点状态改为SIGNAL（-1）</strong>，表示<strong>该节点释放后要继续唤醒它的后继节点</strong>，具体有三种情况：</p>
<ol>
<li>前驱节点的状态已经是SIGNAL了，直接返回</li>
<li>前驱节点的状态是CANCELLED，从后向前，找到前驱中非CANCELLED节点并且移除 查找过程中其他的CANCELLED状态节点。</li>
<li>前驱节点的状态是 0 ，设置为SIGNAL。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注意pred是当前节点的前驱节点</span></span><br><span class="line">    <span class="comment">//  前置节点的状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">// 设置前置节点状态是SIGNAL，返回后park当前线程  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="comment">// 表示cancel</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 找到cancel节点的前status&lt;=0的节点，并移除cancel状态节点，为啥会有cancle的节点后面再说</span></span><br><span class="line">        pred.next = node;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 设置前驱节点状态为-1.表示该节点释放锁之后要唤醒它的后继节点</span></span><br><span class="line">        <span class="comment">// 第一次进入时，将空节点waitStatus设置为-1 ，</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AQS-parkAndCheckInterrupt"><a href="#AQS-parkAndCheckInterrupt" class="headerlink" title="AQS.parkAndCheckInterrupt"></a>AQS.parkAndCheckInterrupt</h4><p>挂起当前线程，并且在唤醒之后返回线程中断的状态。park方法执行后，当前线程就会被挂起，直到被前一个节点释放锁之后再唤醒或者线程被中断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 挂起当前线程</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 唤醒后走到这里，返回当前线程的中断状态，并且清除中断标记</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释下LockSupport.park, 阻塞（挂起）当前线程，不会释放锁，park后，程序在下述三种情况会继续向下执行：</p>
<ol>
<li>被 unpark </li>
<li>被中断(interrupt)</li>
<li>其他不合逻辑的返回才会继续向下执行</li>
</ol>
<p>也就是说 通常只有2种方式唤醒unpark和中断(interrupt)。</p>
<h3 id="AQS-selfInterrupt"><a href="#AQS-selfInterrupt" class="headerlink" title="AQS.selfInterrupt"></a>AQS.selfInterrupt</h3><p>让我们在回到acquire方法中，selfInterrupt是怎么回事呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg)  <span class="comment">//必定成立</span></span><br><span class="line">        &amp;&amp; acquireQueued(</span><br><span class="line">            addWaiter(Node.EXCLUSIVE), arg)) <span class="comment">// acquireQueued 成立说明是抢锁成功且被中断过</span></span><br><span class="line">        <span class="comment">// 唤醒之后执行</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;        </span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 获取锁成功后，返回中断的标记</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">         </span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt()) <span class="comment">// 线程中断的状态</span></span><br><span class="line">                <span class="comment">// ！！！只要被中断信号唤醒过一次，线程状态改为true ！！！</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">              <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 中断当前线程</span></span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下selfInterrupt的调用需要的前置条件，只有acquireQueued返回true，acquireQueued成立的条件是线程<strong>节点获取锁成功且被中断过</strong>；也就是说如果<strong>中断唤醒后节点未获取到锁会继续被挂起</strong>，这也是响应中断锁和不响应中断锁的区别，后面再介绍。</p>
<p>总结下：</p>
<ol>
<li>当中断线程被唤醒时，并不知道被唤醒的原因，可能是当前线程在等待中被中断，也可能是释放了锁以后被唤醒。因此我们在parkAndCheckInterrupt通过Thread.interrupted()方法检查中断标记（该方法返回了当前线程的中断状态，并将当前线程的中断标识设置为False），并记录下来interrupted，<strong>如果发现该线程被中断过（interrupted改为true之后，不可能再被置为false）</strong>，就再通过selfInterrupt中断一次。</li>
<li>线程在等待资源的过程中被唤醒，唤醒后还是会不断地去尝试获取锁，直到抢到锁为止。也就是说，在整个流程中，并不响应中断，只是记录中断记录。最后抢到锁返回了，那么如果被中断过的话，就需要补充一次中断。</li>
</ol>
<p>到此，lock过程就全部介绍完了，下面介绍下unlock的流程。</p>
<h2 id="2-4、unlock过程"><a href="#2-4、unlock过程" class="headerlink" title="2.4、unlock过程"></a>2.4、unlock过程</h2><p>unlock的调用链如下：</p>
<p><img src="/pics/image-20210331175233795.png" alt="image-20210331175233795"></p>
<h3 id="ReentrantLock-unlock"><a href="#ReentrantLock-unlock" class="headerlink" title="ReentrantLock.unlock"></a>ReentrantLock.unlock</h3><p>解锁时先unlock，调用到Aqs的release方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AQS-release"><a href="#AQS-release" class="headerlink" title="AQS.release"></a>AQS.release</h3><p>release的主要作用有2个：</p>
<ol>
<li>tryRelease，释放当前线程持有的锁</li>
<li>上一步成功后唤醒下一个节点</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;<span class="comment">// 1.释放当前线程持有的锁</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> <span class="comment">//</span></span><br><span class="line">            &amp;&amp; h.waitStatus != <span class="number">0</span>) <span class="comment">//waitStatus=0 说明当前head之后没有待唤醒的节点，联系入队时AQS.shouldParkAfterFailedAcquire方法理解</span></span><br><span class="line">            unparkSuccessor(h); <span class="comment">// 2.唤醒下一个节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ReentrantLock-Sync-tryRelease"><a href="#ReentrantLock-Sync-tryRelease" class="headerlink" title="ReentrantLock.Sync.tryRelease"></a>ReentrantLock.Sync.tryRelease</h3><p>tryRelease 释放当前线程的锁：</p>
<ol>
<li>独占锁，unlock 时必须是当前占用线程调用</li>
<li>考虑到锁重入的情况，每次unlock state值均减1，若减完后state值为0，说明当前线程占用的锁都释放完了，将占用线程置为空；否则将新的值赋给state。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread()) <span class="comment">// 当前线程是占用线程</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 锁完全释放完</span></span><br><span class="line">        free = <span class="keyword">true</span>; </span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>); <span class="comment">//将当前占用线程置为空</span></span><br><span class="line">    &#125;</span><br><span class="line">    setState(c); <span class="comment">// 更新state值</span></span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AQS-unparkSuccessor"><a href="#AQS-unparkSuccessor" class="headerlink" title="AQS.unparkSuccessor"></a>AQS.unparkSuccessor</h3><p>上一步释放锁成功后，unparkSuccessor中会找到<strong>距离当前node最近的状态&lt;=0的节点进行唤醒</strong>，唤醒之后再回到<code>acquireQueued</code>竞争锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>); <span class="comment">// 将释放的节点状态改为 0 </span></span><br><span class="line"></span><br><span class="line">    Node s = node.next; <span class="comment">// 找到node的下一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123; <span class="comment">// head-&gt;next 节点为空或者节点状态是取消状态</span></span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev) <span class="comment">// 从tail节点向前遍历</span></span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>) <span class="comment">// 找到距离当前node最近的状态&lt;=0的节点进行唤醒</span></span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread); <span class="comment">//唤醒下一个节点，让节点竞争，联系到acquireQueued方法中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了<code>LockSupport.unpark</code>外，线程的中断方法调用时也会唤醒被park的线程。</p>
<p><a href="https://blog.csdn.net/every__day/article/details/108956415">https://blog.csdn.net/every__day/article/details/108956415</a></p>
<h2 id="2-5、独占式响应中断的锁"><a href="#2-5、独占式响应中断的锁" class="headerlink" title="2.5、独占式响应中断的锁"></a>2.5、独占式响应中断的锁</h2><p>怎么理解响应中断?其实就是锁的线程发生中断后，锁内部抛出<code>InterruptedException</code>让调用方可以去处理。ReentrantLock里的<code>lockInterruptibly</code>就是支持响应中断的锁。</p>
<h3 id="ReentrantLock-lockInterruptibly"><a href="#ReentrantLock-lockInterruptibly" class="headerlink" title="ReentrantLock.lockInterruptibly"></a>ReentrantLock.lockInterruptibly</h3><p>调用到AQS.acquireInterruptibly</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AQS-acquireInterruptibly"><a href="#AQS-acquireInterruptibly" class="headerlink" title="AQS.acquireInterruptibly"></a>AQS.acquireInterruptibly</h3><p>主要步骤有：</p>
<ol>
<li>判断当前线程是否被中断，若被中断直接抛出异常</li>
<li>tryAcquire 加锁，和普通lock加锁逻辑基本一致，不再赘述；若加锁失败调用到<code>doAcquireInterruptibly</code>,</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted()) <span class="comment">// 若线程已经被中断</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg)) <span class="comment">// 加锁</span></span><br><span class="line">        doAcquireInterruptibly(arg); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AQS-doAcquireInterruptibly"><a href="#AQS-doAcquireInterruptibly" class="headerlink" title="AQS.doAcquireInterruptibly"></a>AQS.doAcquireInterruptibly</h3><p>doAcquireInterruptibly 响应中断方式加锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE); <span class="comment">// 构造线程节点加入到同步队列</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException(); <span class="comment">// 区别：线程中断后抛出异常，让上层处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed) <span class="comment">// 抛出异常后 failed 变为 true，走到下面逻辑里</span></span><br><span class="line">            cancelAcquire(node); <span class="comment">// 注意</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// -------对比下 acquireQueued</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>; <span class="comment">// 中断唤醒后仅设置interrupted，继续自旋竞争锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到doAcquireInterruptibly和AQS.acquireQueued基本一致，主要的区别是：</p>
<p><code>doAcquireInterruptibly</code>线程通过中断唤醒节点后，<strong>会抛出<code>InterruptedException</code>异常，走入到cancelAcquire逻辑里</strong>，cancleAcquire后面再介绍。</p>
<h2 id="2-6、独占式响应中断和超时的锁"><a href="#2-6、独占式响应中断和超时的锁" class="headerlink" title="2.6、独占式响应中断和超时的锁"></a>2.6、独占式响应中断和超时的锁</h2><h3 id="AQS-tryLock"><a href="#AQS-tryLock" class="headerlink" title="AQS.tryLock"></a>AQS.tryLock</h3><p>调用到aqs.tryAcquireNanos</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AQS-tryAcquireNanos"><a href="#AQS-tryAcquireNanos" class="headerlink" title="AQS.tryAcquireNanos"></a>AQS.tryAcquireNanos</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是和上面 <code>acquireInterruptibly</code> 方法长相很详细了，继续查看来 doAcquireNanos 方法。</p>
<h3 id="AQS-doAcquireNanos"><a href="#AQS-doAcquireNanos" class="headerlink" title="AQS.doAcquireNanos"></a>AQS.doAcquireNanos</h3><p>该方法也是 throws InterruptedException，我们在中断文章中说过，方法标记上有 <code>throws InterruptedException</code> 说明该方法也是可以响应中断的，所以你可以理解超时限制是 <code>acquireInterruptibly</code> 方法的加强版，具有超时和非阻塞控制的双保险。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  	<span class="comment">// 超时时间内，未获取到同步状态，直接返回false</span></span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  	<span class="comment">// 计算超时截止时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">  	<span class="comment">// 以独占方式加入到同步队列中</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// 自旋</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="comment">// 计算新的超时时间</span></span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">          	<span class="comment">// 如果超时，直接返回 false</span></span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">            		<span class="comment">// 判断是最新超时时间是否大于阈值 1000    </span></span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">              	<span class="comment">// 挂起线程 nanosTimeout 长时间，时间到，自动返回</span></span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的方法应该不是很难懂，但是又同学可能对这个判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">nanosTimeout &gt; spinForTimeoutThreshold</span><br></pre></td></tr></table></figure>

<p>为什么 nanosTimeout 和 自旋超时阈值1000进行比较？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of nanoseconds for which it is faster to spin</span></span><br><span class="line"><span class="comment"> * rather than to use timed park. A rough estimate suffices</span></span><br><span class="line"><span class="comment"> * to improve responsiveness with very short timeouts.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> spinForTimeoutThreshold = <span class="number">1000L</span>;</span><br></pre></td></tr></table></figure>

<p>其实 doc 说的很清楚，说白了，1000 nanoseconds 时间已经非常短暂了，没必要再执行挂起和唤醒操作了，不如直接让线程进入下一次循环。</p>
<p>在上面介绍中，响应中断的锁被中断后，都会抛出<code>InterruptedException</code>异常，走入到cancelAcquire逻辑里，下面就来看下cancelAcquire。</p>
<h2 id="2-7、AQS-cancelAcquire"><a href="#2-7、AQS-cancelAcquire" class="headerlink" title="2.7、AQS.cancelAcquire"></a>2.7、AQS.cancelAcquire</h2><p>cancelAcquire 本质上就是为了中断而设计。那cancle节点是什么时候生成的？就是在cancelAcquire中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 忽略无效节点</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">	  <span class="comment">// 将关联的线程信息清空</span></span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// pred 代表前驱有效节点</span></span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>) <span class="comment">// 从当前节点从后往前遍历，找到有效（非cancle）节点</span></span><br><span class="line">        node.prev = pred = pred.prev;<span class="comment">//遍历过程中移除取消状态的前驱节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取该有效节点的后继</span></span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line">    <span class="comment">// 将当前节点的状态置为 CANCELLED</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 第一种情况</span></span><br><span class="line">    <span class="comment">// 1.1、如果当前节点的前驱节点是头节点，或者上述其他条件不满足，就唤醒当前节点的后继节点</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        <span class="comment">// tail更新成功，将tail的后继节点设置为null</span></span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="comment">// 第二种情况</span></span><br><span class="line">        <span class="comment">// 2.1、如果前驱节点pred不是head，也就是说当前节点不是头节点的后继节点</span></span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            <span class="comment">// 2.2、有效前驱节点的状态是否为 SIGNAL</span></span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             <span class="comment">// 2.3、如果不是SIGNAL，尝试将前驱节点的状态置为 SIGNAL, </span></span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = node.next;</span><br><span class="line">            <span class="comment">//将当前节点的有效节点的前驱的后继 指向 当前节点的后继节点，删除当前节点</span></span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 3、第三种情况</span></span><br><span class="line">            <span class="comment">// 3.1、如果当前节点的前驱节点是头节点，或者上述其他条件不满足，就唤醒当前节点的后继节点</span></span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要步骤有：</p>
<ol>
<li><p> 从当前节点从后往前遍历，找到有效（非cancle）节点，遍历过程中移除取消状态的前驱节点。</p>
</li>
<li><p>移除当前节点是，要重新关联链表，有三种情况：</p>
<ul>
<li><p>第一种情况，如果当前节点的前驱pred是头节点，或者上述其他条件不满足，就唤醒当前节点的后继节点</p>
<img src="/pics/image-20210331235150892.png" alt="image-20210331235150892" style="zoom:50%;" /></li>
<li><p>第二种情况，如果前驱节点的前驱pred不是head，也就是说当前节点不是头节点的后继节点，将pred-&gt;next = node.next，就是删除当前节点</p>
<img src="/pics/image-20210331235234168.png" alt="image-20210331235234168" style="zoom:50%;" /></li>
<li><p>第三种情况，如果当前节点的前驱节点是头节点，或者上述其他条件不满足，就唤醒当前节点的后继节点。这里要补充说明下和上面情况的区别；下一个唤醒的节点是通过<code>unparkSuccessor</code>从tail向前查找到的距离当前节点最近的可唤醒的节点Node1；再进入<code>shouldParkAfterFailedAcquire</code>中将head节点唤醒。</p>
<img src="/pics/image-20210401103926746.png" alt="image-20210401103926746" style="zoom:67%;" />



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev) <span class="comment">// 从tail向前</span></span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>) <span class="comment">// 距离当前节点最近的可唤醒的节点</span></span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">	  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的流程，我们对于CANCELLED节点状态的产生和变化已经有了大致的了解，但是<strong>为什么<code>cancelAcquire</code>所有的变化都是对Next指针进行了操作，而没有对Prev指针进行操作呢？什么情况下会对Prev指针进行操作？</strong></p>
<p>执行cancelAcquire的时候，当前节点的前置节点可能已经从队列中出去了<code>shouldParkAfterFailedAcquire</code>，如果此时修改Prev指针，有可能会导致Prev指向另一个已经移除队列的Node，因此这块变化Prev指针不安全。 shouldParkAfterFailedAcquire方法中，会执行下面的代码，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> do &#123;</span><br><span class="line">	node.prev = pred = pred.prev;</span><br><span class="line">&#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">	pred.next = node;</span><br></pre></td></tr></table></figure>

<p>其实就是在处理Prev指针。shouldParkAfterFailedAcquire是获取锁失败的情况下才会执行，进入该方法后，<strong>说明共享资源已被获取，当前节点之前的节点都不会出现变化，因此这个时候变更Prev指针比较安全</strong>。   </p>
</li>
</ul>
</li>
</ol>
<p>以上ReentrantLock 的加锁和解锁基本都介绍完了。下面介绍下常用的awit和notify的原理。</p>
<h1 id="三、Condition"><a href="#三、Condition" class="headerlink" title="三、Condition"></a>三、Condition</h1><h2 id="3-1、Condition原理初探"><a href="#3-1、Condition原理初探" class="headerlink" title="3.1、Condition原理初探"></a>3.1、Condition原理初探</h2><p>ReentrantLock中锁的等待唤醒机制是通过内部的Condition组件实现的，通过一个简单的例子了解下Condition的使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 等待</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                conditionWait();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 唤醒</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                conditionSignal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">conditionWait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;conditionWait&quot;</span>);</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;await finally&quot;</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">conditionSignal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;conditionSignal&quot;</span>);</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;signal finally&quot;</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标准的锁等待唤醒的范式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// step1: 先获取锁</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// step2: 等待或唤醒, await或notify时已经获取到锁了</span></span><br><span class="line">	condition.await();</span><br><span class="line">    <span class="comment">//condition.signal();</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// step3: 解锁</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>condition从何而来呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Condition condition = lock.newCondition();</span><br></pre></td></tr></table></figure>

<h3 id="ReentrantLock-newCondition"><a href="#ReentrantLock-newCondition" class="headerlink" title="ReentrantLock.newCondition"></a>ReentrantLock.newCondition</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AQS-ConditionObject"><a href="#AQS-ConditionObject" class="headerlink" title="AQS.ConditionObject"></a>AQS.ConditionObject</h3><p> <code>ConditionObject</code> 中实现了 <code>Condition</code> 中的方法，主要对外提供 <code>awaite(Object.wait())</code> 和 <code>signal(Object.notify())</code>调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter; <span class="comment">// 头</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter; <span class="comment">// 尾</span></span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外类中还有两个成员变量，通过名字我们也可猜到，condition中维护了一个单向链表，这个队列称为<strong>条件等待队列</strong>（下称条件队列），注意这里的Node和之前介绍的锁原理时候的Node是一样的。那条件等待队列和AQS中的同步队列是什么关系呢？我们通过下面这张图来理解下。</p>
<img src="/pics/image-20210401114927577.png" alt="image-20210401114927577" style="zoom:75%;" />



<p>为什么会有多个条件等待队列？</p>
<p>因为在 Lock 中可以定义多个条件，每个条件都会对应一 条件等待队列。其实await和notify的原理就是基于锁同步队列和条件等待队列的，我们先给出基本原理。</p>
<p><strong>首先记住，await或notify时线程已经获取到锁了</strong>。</p>
<ul>
<li><p>await：释放Node节点的锁，挂起节点线程（当前线程），创建<strong>新节点</strong>加入到条件队列中</p>
</li>
<li><p>notify：将条件队列中的节点移动到同步队列中，唤醒节点线程竞争锁</p>
</li>
</ul>
<h2 id="3-2、ConditionObject-await"><a href="#3-2、ConditionObject-await" class="headerlink" title="3.2、ConditionObject.await"></a>3.2、ConditionObject.await</h2><p>await的需要分成2部分讲，因为await中不仅有await的逻辑，还包含了唤醒之后的逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.节点加入到条件队列</span></span><br><span class="line">    Node node = addConditionWaiter(); </span><br><span class="line">    <span class="comment">// 2.释放锁</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.判断节点是否加入到同步队列</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>); <span class="comment">// 若节点未加入到阻塞队列，则挂起，等待signal唤醒</span></span><br><span class="line">        <span class="comment">// interruptMode == THROW_IE 成立，说明node在条件队列内发生过中断</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4.signal后开始再次竞争，且node在条件队列内发生过中断</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        <span class="comment">//说明当前node在条件队列内 未发生过中断,设置interruptMode = REINTERRUPT</span></span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="comment">// 5.移除条件队列中的cancle节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="comment">// 6.线程挂起期间，发生过中断，这里进行处理中断</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>await主要步骤是：</p>
<ol>
<li>addConditionWaiter，将节点加入到条件队列</li>
<li>fullyRelease，释放锁，返回释放前的state值</li>
<li>判断节点是否在同步队列中，否则挂起当前线程。</li>
</ol>
<p>后面的逻辑是被signal唤醒后才执行的逻辑</p>
<ol start="4">
<li>唤醒后再次开始竞争</li>
<li>移除条件队列中的cancle节点</li>
<li>线程挂起期间，发生过中断，这里进行处理中断，唤醒后识别过发生的中断情况：<ol>
<li>interruptMode == THROW_IE 成立，说明node在条件队列内发生过中断</li>
<li>interruptMode == REINTERRUPT 成立，说明node在条件队列外发生过中断</li>
</ol>
</li>
</ol>
<h2 id="3-3、await的上半场"><a href="#3-3、await的上半场" class="headerlink" title="3.3、await的上半场"></a>3.3、await的上半场</h2><p>将节点加入到条件队列并挂起当前线程，主要步骤有：</p>
<ol>
<li>addConditionWaiter，<strong>将当前线程构造成一个新节点</strong>加入到 <code>条件队列</code>？</li>
<li>fullyRelease，释放锁，返回释放前的state值</li>
<li>判断节点是否在同步队列中，否则挂起当前线程。</li>
</ol>
<h3 id="AQS-addConditionWaiter"><a href="#AQS-addConditionWaiter" class="headerlink" title="AQS.addConditionWaiter"></a>AQS.addConditionWaiter</h3><p>主要步骤有：</p>
<ol>
<li>队尾元素状态不是等待时，清理队列中的无效节点</li>
<li>创建新节点，加入到条件队列，尾插法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    <span class="comment">// 1.队尾元素状态不是等待时，清理队列中的无效节点</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        <span class="comment">// 清理队列中的非 CONDITION 状态的节点，后面讲</span></span><br><span class="line">        unlinkCancelledWaiters(); </span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.创建新节点，加入到条件队列，尾插法</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AQS-fullyRelease"><a href="#AQS-fullyRelease" class="headerlink" title="AQS.fullyRelease"></a>AQS.fullyRelease</h3><p>释放当前节点的锁，唤醒后继节点，并返回线程释放前的state值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> savedState = getState();</span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123; <span class="comment">// 1.释放锁</span></span><br><span class="line">            failed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> savedState; <span class="comment">// 返回当前线程释放的state值</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();<span class="comment">// 2. 当failed失败时，说明当前线程是未lock后就调用await方法的线程..</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            node.waitStatus = Node.CANCELLED; <span class="comment">//释放失败，节点标记为cancel</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为何要返回线程释放前的state值呢？因为在节点被唤醒后，需要再次通过<code>acquireQueued</code>获取到锁，同时考虑到锁重入，所以需要将state设置为savedState。</p>
<h3 id="挂起"><a href="#挂起" class="headerlink" title="挂起"></a>挂起</h3><p>若当前节点不在同步队列中则挂起线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>); <span class="comment">//若节点未加入到阻塞队列，则挂起，等待signal唤醒</span></span><br><span class="line">	<span class="comment">// 其他后面讲</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-4、ConditionObject-signal"><a href="#3-4、ConditionObject-signal" class="headerlink" title="3.4、ConditionObject.signal"></a>3.4、ConditionObject.signal</h2><p>signal会调用到doSignal唤醒条件队列中的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.判断调用signal方法的线程是否是独占锁持有线程</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignal(first);<span class="comment">//条件队列的不为空尝试唤醒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ConditionObject-doSignal"><a href="#ConditionObject-doSignal" class="headerlink" title="ConditionObject.doSignal"></a>ConditionObject.doSignal</h3><p>doSignal，通过循环判断，从条件队列中找到第一个可以出队的节点进行唤醒。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>) <span class="comment">// 只有一个节点</span></span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>; <span class="comment">// /当前first节点 出 条件队列，断开和下一个节点的关系</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp; </span><br><span class="line">             <span class="comment">// 当前first迁移失败，则将first更新为 first.next 继续尝试迁移</span></span><br><span class="line">             <span class="comment">// 直至迁移某个节点成功，或者 条件队列为null为止。</span></span><br><span class="line">             (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AQS-transferForSignal"><a href="#AQS-transferForSignal" class="headerlink" title="AQS.transferForSignal"></a>AQS.transferForSignal</h3><p>transferForSignal主要步骤是：</p>
<ol>
<li>cas修改当前节点状态为 0</li>
<li>将节点加入的同步队列中，注意 <strong>enq 返回的是当前节点的前驱节点</strong></li>
<li>有2情况可唤醒当前节点：<ul>
<li>前驱状态是CANCELED</li>
<li>设置前驱节点状态为SIGNAl失败，什么情况下会失败呢?<br>前驱对应的线程是<code>lockInterrupt</code>加锁时，是会响应中断的；执行完ws &gt; 0 之后，在这段时间，前驱的线程发生了中断，节点状态修改为 CANCELED，并且执行出队逻辑。</li>
</ul>
</li>
<li> LockSupport.unpark，唤醒await。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.cas修改当前节点状态为0，</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="comment">// 2.将节点加入的同步队列中，！！！返回当前节点的前驱节点！！！</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 判断的是前驱的状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="comment">// 3.是否要唤醒当前节点</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> ||  <span class="comment">// 3.1、若前驱是取消状态 </span></span><br><span class="line">        !compareAndSetWaitStatus(p, ws, Node.SIGNAL)) <span class="comment">//3.2、设置前驱节点状态为SIGNAl状态失败</span></span><br><span class="line">        LockSupport.unpark(node.thread); <span class="comment">//4.唤醒await</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止signal就结束了，signal后会唤醒线程，继续走await中剩下的逻辑。</p>
<h2 id="3-5、await的下半场"><a href="#3-5、await的下半场" class="headerlink" title="3.5、await的下半场"></a>3.5、await的下半场</h2><p>线程被唤醒后await的主要逻辑是 让节点开始竞争锁；如果线程再等待队列中发生过中断后再执行中断的一些处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.判断节点是否加入到同步队列</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>); <span class="comment">// 若节点未加入到阻塞队列，则挂起，等待signal唤醒</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// interruptMode == THROW_IE 成立，说明node在条件队列内发生过中断，跳出</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4.signal后开始再次竞争，且node在条件队列内未发生过中断</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) </span><br><span class="line">        &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        <span class="comment">// acquireQueued false 时 不会走到这里，说明节点竞争锁成功了</span></span><br><span class="line">        <span class="comment">// 说明当前node在条件队列内 未发生过中断,设置interruptMode = REINTERRUPT</span></span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="comment">// 5.移除条件队列中的cancle节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="comment">// 6.线程挂起期间，发生过中断，这里进行处理中断</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AQS-isOnSyncQueue"><a href="#AQS-isOnSyncQueue" class="headerlink" title="AQS.isOnSyncQueue"></a>AQS.isOnSyncQueue</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 唤醒后执行</span></span><br><span class="line">    <span class="comment">// interruptMode == THROW_IE 成立，说明node在条件队列内发生过中断，跳出</span></span><br><span class="line">    <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>isOnSyncQueue</code> 是否在同步队列中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// node.waitStatus == Node.CONDITION 条件成立，说明当前node一定是在条件队列，因为signal方法迁移节点到同步队列前，会将node的状态设置为 0</span></span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || </span><br><span class="line">        <span class="comment">// 即使同步队列是刚初始化的，至少会有个虚头节点存在，所以节点的前驱如果为null，那么节点也肯定不在同步队列中</span></span><br><span class="line">        node.prev == <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 条件队列的下一个节点属性是nextWaiter </span></span><br><span class="line">    <span class="comment">// 同步队列下一个节点属性是 next，next！=null 说明是在同步队列中</span></span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从队尾始向前遍历，如果查找到，返回true,查找不到返回false, 线程挂起</span></span><br><span class="line">	<span class="keyword">return</span> findNodeFromTail(node); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">findNodeFromTail</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    Node t = tail;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t == node)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        t = t.prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ConditionObject-checkInterruptWhileWaiting"><a href="#ConditionObject-checkInterruptWhileWaiting" class="headerlink" title="ConditionObject.checkInterruptWhileWaiting"></a>ConditionObject.checkInterruptWhileWaiting</h3><p>判断在await时，线程是不是被中断唤醒的：</p>
<ol>
<li><p>如果是，再判断下是否是在 条件队列 中发生了中断</p>
</li>
<li><p>否则返回0，继续判断是否在同步队列中</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted() <span class="comment">// 说明是线程是被中断唤醒，返回当前线程中断标记位，并且重置当前标记位 为 false 。</span></span><br><span class="line">        ? (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) <span class="comment">// 中断唤醒时走到这里</span></span><br><span class="line">        : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AQS-transferAfterCancelledWait"><a href="#AQS-transferAfterCancelledWait" class="headerlink" title="AQS.transferAfterCancelledWait"></a>AQS.transferAfterCancelledWait</h4><p>线程被中断唤醒时，将条件队列中的节点 迁移到 <code>同步队列</code>中，并且返回节点是是否是在 <code>条件队列</code> 中被中断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferAfterCancelledWait</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先将节点状态改为0</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// 再将节点从 条件队列 迁移到 同步队列 中</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 走到这里说明节点正在 向同步队列 迁移中</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node))</span><br><span class="line">        <span class="comment">// yield 缓一下再check，等同步队列迁移完后再判断</span></span><br><span class="line">        Thread.yield();</span><br><span class="line">    <span class="comment">// false:表示当前节点被中断唤醒时 不在 条件队列了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="加入竞争"><a href="#加入竞争" class="headerlink" title="加入竞争"></a>加入竞争</h3><p>acquireQueued 让被唤醒的线程开始竞争锁。</p>
<p>注意此时 acquireQueued 正常是获取不到锁的，会再次挂起；acquireQueued的主要功能是让线程重新竞争锁，<strong>需要等前一个线程执行完成unlock，才能在acquireQueued中重新获取到了锁，再往下执行</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4.signal后开始再次竞争，且node在条件队列内未发生过中断</span></span><br><span class="line"><span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; </span><br><span class="line">    <span class="comment">// acquireQueued false 时 不会走到这里，说明节点竞争锁成功了</span></span><br><span class="line">    interruptMode != THROW_IE) </span><br><span class="line">    <span class="comment">// acquireQueued 返回true，说明在同步队列中竞争锁时又发生了中断，需要再最后设置线程状态为 中断</span></span><br><span class="line">    <span class="comment">// interruptMode 设置为 REINTERRUPT</span></span><br><span class="line">    interruptMode = REINTERRUPT;</span><br></pre></td></tr></table></figure>

<h3 id="ConditionObject-unlinkCancelledWaiters"><a href="#ConditionObject-unlinkCancelledWaiters" class="headerlink" title="ConditionObject.unlinkCancelledWaiters"></a>ConditionObject.unlinkCancelledWaiters</h3><p>移除条件队列中非CONDITION状态的节点，非CONDITION有2种情况：</p>
<ol>
<li>一种是cancel ，线程发生了中断</li>
<li>状态是 0 ，说明节点已经被迁移到 同步队列中了，注意 Signal唤醒迁移时，并没有把节点从<code>条件队列</code>中移除，<strong>移除是在这里执行的</strong>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = firstWaiter;<span class="comment">// 从头开始循环</span></span><br><span class="line">    Node trail = <span class="keyword">null</span>; <span class="comment">// 上一个正常节点</span></span><br><span class="line">    <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node next = t.nextWaiter; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123; <span class="comment">// 当前节点状态为CANCELED</span></span><br><span class="line">            t.nextWaiter = <span class="keyword">null</span>; <span class="comment">// 节点出队</span></span><br><span class="line">            <span class="keyword">if</span> (trail == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">// 更新firstWaiter指针为下个节点就可以</span></span><br><span class="line">                firstWaiter = next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                trail.nextWaiter = next;<span class="comment">// 上一个 CONDITION 指向 非Condition的 下一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>) <span class="comment">// 当前节点为队尾节点了，更新lastWaiter 指向最后一个正常节点</span></span><br><span class="line">                lastWaiter = trail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            trail = t; <span class="comment">// 指向队列中的上一个 CONDITION 节点</span></span><br><span class="line">        </span><br><span class="line">        t = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ConditionObject-reportInterruptAfterWait"><a href="#ConditionObject-reportInterruptAfterWait" class="headerlink" title="ConditionObject.reportInterruptAfterWait"></a>ConditionObject.reportInterruptAfterWait</h3><p>有2种情况：</p>
<ol>
<li>在条件队列内发生过中断，此时await方法抛出中断异常，这也是await响应中断的原理。</li>
<li>在条件队列外发生的中断，此时设置当前线程的中断标记位 为true</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportInterruptAfterWait</span><span class="params">(<span class="keyword">int</span> interruptMode)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (interruptMode == THROW_IE) <span class="comment">// 在条件队列内发生过中断，此时await方法抛出中断异常；</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (interruptMode == REINTERRUPT) <span class="comment">// 在条件队列外发生的中断，此时设置当前线程的中断标记位 为true</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此， await和signal都介绍完了。我们再回顾下await和signal时，节点在同步队列中的条件队列中的变化情况。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过一张图来理解下await和signal过程。</p>
<p><img src="/pics/image-20210402161954926.png" alt="image-20210402161954926"></p>
<ol>
<li><p>await时，会使用当前节点的线程构造一个CONDITION 状态的<strong>新节点加入到条件队列</strong>中，<strong>并且挂起当前线程。</strong></p>
<p>那么原来同步队列中的节点什么时候出队的呢？这里有2种情况</p>
<ol>
<li>await时，锁没有竞争，那么在await时，<code>同步队列</code>中不存在任何节点，自然就不用出队</li>
<li>await时，存在竞争，那么此时的head虚节点节点就是当前线程对应的节点；执行完fullyRelease后，第二个线程在唤醒后再acquireQueued中获取到锁时会将前一次的head出队。</li>
</ol>
<p>await的线程挂起后要需要等signal唤醒之后再执行，先走到signal的流程中。</p>
</li>
<li><p>signal时，将条件队列中的节点状态从 CONDITION 改为 0， 并加入<code>同步队列</code>中，此时该节点也没有从<code>条件队列</code>中移除。什么时候移除呢？</p>
<p>在<code>unlinkCancelledWaiters</code>中会将非 CONDITION 状态节点移出条件队列。</p>
<p>执行完signal后，await的线程被唤醒继续执行，首先判断下是不是被中断唤醒的，如果是，再判断下：</p>
<ol>
<li>在<code>条件队列</code>被中断唤醒，后续会抛出中断异常</li>
<li>在signal <strong>转移迁移节点到<code>同步队列</code>过程中</strong> 被中断的，后续会设置线程为中断</li>
</ol>
</li>
</ol>
<p>最后 acquireQueued 让节点开始竞争锁，移除条件队列中的非 CONDITION 节点，识别并设置线程的中断状态。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们从AQS开始介绍到ReentrantLock的lock和unlock，Condition的await和notify的原理。理解AQS 中的 同步队列 和 条件等待 队列的作用。剩余的知识，trylock 和 lock区别，共享锁（ReentrantReadWriteLock），后面的文章再介绍。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.starfish.ink/java/JUC/AQS.html#%E6%98%AF%E4%BB%80%E4%B9%88">http://www.starfish.ink/java/JUC/AQS.html#%E6%98%AF%E4%BB%80%E4%B9%88</a></p>
<p><a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html">https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
        <category>JUC</category>
      </categories>
  </entry>
  <entry>
    <title>JUC_08_Semaphore</title>
    <url>/2022/12/25/Notes/Java/02JUC/JUC_08_Semaphore/</url>
    <content><![CDATA[<h1 id="JUC-08-Semaphore"><a href="#JUC-08-Semaphore" class="headerlink" title="JUC_08_Semaphore"></a>JUC_08_Semaphore</h1><span id="more"></span>

<p>Semaphore 用来控制同时访问共享资源的线程数量。举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SemaphoreTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">2</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">       <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(<span class="string">&quot;acquire &quot;</span> + index);</span><br><span class="line">                    Thread.sleep((size - <span class="number">1</span>) * <span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;release &quot;</span> + index);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果,aquire，release 交错输出</span></span><br><span class="line">acquire <span class="number">0</span></span><br><span class="line">acquire <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">release <span class="number">1</span></span><br><span class="line">release <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">acquire <span class="number">2</span></span><br><span class="line">acquire <span class="number">3</span></span><br><span class="line">    </span><br><span class="line">release <span class="number">2</span></span><br><span class="line">acquire <span class="number">4</span></span><br><span class="line">    </span><br><span class="line">release <span class="number">3</span></span><br><span class="line">acquire <span class="number">5</span></span><br><span class="line">    </span><br><span class="line">release <span class="number">4</span></span><br><span class="line">release <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>Semaphore 类似于ReentrantLock 也分为公平和非公平同步器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    	Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">    			setState(permits);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">  		<span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">  		<span class="comment">// ...  </span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>我们主要分析公平锁FairSync的同步器相关的实现。</p>
<h2 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h2><p>竞争获取锁，获取到直接返回，获取不到，加入到AQS的同步队列中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>); <span class="comment">// 调用到AQS.acquireSharedInterruptibly</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS.acquireSharedInterruptibly</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>) <span class="comment">// 主要看下tryAcquireShared 的实现</span></span><br><span class="line">        doAcquireSharedInterruptibly(arg); <span class="comment">// 竞争失败加入到同步队列中并阻塞</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS.doAcquireSharedInterruptibly</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);<span class="comment">//添加到同步队列中</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())<span class="comment">// 挂起</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Semaphore-FairSync-tryAcquireShared"><a href="#Semaphore-FairSync-tryAcquireShared" class="headerlink" title="Semaphore.FairSync.tryAcquireShared"></a>Semaphore.FairSync.tryAcquireShared</h3><p>我们分析的是公平的tryAcquireShared 是Semaphore.FairSync 复写的AQS的方法，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasQueuedPredecessors()) <span class="comment">// 公平锁方式，判断同步队列中是否还有节点</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires; <span class="comment">// 获取到的同步资源后，state - acquires</span></span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining)) <span class="comment">// 返回remianing</span></span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="release"><a href="#release" class="headerlink" title="release"></a>release</h2><p>释放信号量，唤醒获取信号量的线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS.releaseShared</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS.doReleaseShared</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h); <span class="comment">// 唤醒同步队列中的下一个节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Semaphore-FairSync-tryReleaseShared"><a href="#Semaphore-FairSync-tryReleaseShared" class="headerlink" title="Semaphore.FairSync.tryReleaseShared"></a>Semaphore.FairSync.tryReleaseShared</h3><p>tryReleaseShared 释放后信号量增加。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = getState();</span><br><span class="line">        <span class="keyword">int</span> next = current + releases; <span class="comment">// release 后信号量增加</span></span><br><span class="line">        <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum permit count exceeded&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Semaphore的特性： </p>
<ol>
<li>管理一系列许可证，即state共享资源值</li>
<li>每acquire一次则state就减1一次，直到许可证数量小于0则阻塞等待</li>
<li>释放许可的时候要保证唤醒后继结点，以此来保证线程释放他们所持有的信号量</li>
</ol>
]]></content>
      <categories>
        <category>JAVA</category>
        <category>JUC</category>
      </categories>
  </entry>
  <entry>
    <title>JUC_09_ReentrantReadWriteLock</title>
    <url>/2022/12/25/Notes/Java/02JUC/JUC_09_ReentrantReadWriteLock/</url>
    <content><![CDATA[<h1 id="JUC-09-ReentrantReadWriteLock"><a href="#JUC-09-ReentrantReadWriteLock" class="headerlink" title="JUC_09_ReentrantReadWriteLock"></a>JUC_09_ReentrantReadWriteLock</h1><span id="more"></span>

<p>ReentrantReadWriteLock，读写锁，允许同一时刻多个读线程访问；但是在写线程访问时，其他线程均被阻塞。在介绍ReentrantReadWriteLock前我们先介绍下独享锁 和共享锁。</p>
<p><strong>独享锁 VS 共享锁</strong></p>
<p>**<code>独享锁</code>**也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。例如ReentrantLock。</p>
<p>**<code>共享锁</code>**是指该锁可被多个线程所持有。可以同时共享的数据。比如 CountDownLatch，Se</p>
<p>读锁是共享锁，写锁是独享锁。</p>
<p>读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以ReentrantReadWriteLock的并发性相比一般的互斥锁有了很大提升。</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>ReentrantReadWriteLock 将state（int 值，32位）划分为高16位和低16位，分别表示读锁和写锁。</p>
<p><img src="/pics/image-20210406210551217.png" alt="image-20210406210551217"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLock</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ReadWriteLock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 读锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line">    <span class="comment">//  写锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line">    <span class="comment">// 第一个读线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Thread firstReader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 第一个读线程重入的次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> firstReaderHoldCount;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 支持公平和非公平方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">        readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);</span><br><span class="line">        writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">WriteLock <span class="title">writeLock</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> writerLock; &#125;</span><br><span class="line">    <span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">ReadLock  <span class="title">readLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> readerLock; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读写锁的同步器</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6317671515068378041L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>; <span class="comment">//分界线偏移值，用来向左或向右偏移尾数，以此来获取读写锁计数值</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT); <span class="comment">// 读锁需要加1时递增的增量</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;<span class="comment">// 读锁、写锁的最大计数值数量</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;<span class="comment">// 写锁掩码，用于写锁计数值的低16位有效值</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 保存当前线程重入读锁次数的容器，当读锁重入次数为0时则会被移除掉</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">transient</span> ThreadLocalHoldCounter readHolds;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 最近一个成功获取读锁的线程的计数对象</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> HoldCounter cachedHoldCounter;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 读锁值</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line">        <span class="comment">// 写锁值</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 公平锁</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">     &#125;</span><br><span class="line">   </span><br><span class="line">     <span class="comment">// 非公平锁</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h1><p>ReentrantReadWriteLock 分别公平和非公平方式获取锁，我们来看下它们的区别。</p>
<ol>
<li>公平策略下，获取读 写锁时都需要判断同步队列中是否有待唤醒的节点</li>
<li>非公平策略下，<ul>
<li>获取读锁时需要判断当前同步队列的首个节点是不是独占式的（是不是有写锁）</li>
<li>获取写锁时不需要判断同步队列中是否有待唤醒的节点</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2274990926593161451L</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 公平锁策略的写锁是否需要阻塞，阻塞的判断依据就是：</span></span><br><span class="line">    <span class="comment">// 当有阻塞队列时则返回true需要阻塞，无阻塞队列时返回false不需要阻塞；</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =========非公平 ======</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">8159625535654395037L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 写锁不需要阻塞 </span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// writers can always barge</span></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 非公平模式下读锁获取时要判断阻塞队列中的第一个结点是不是独占式结点，</span></span><br><span class="line">    <span class="comment">// 如果是独占式的节点则返回true表明读锁需要阻塞，否则返回false不需要阻塞</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">apparentlyFirstQueuedIsExclusive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node h, s;</span><br><span class="line">        <span class="keyword">return</span> (h = head) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (s = h.next)  != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            !s.isShared()         &amp;&amp; <span class="comment">// 非独占式结点</span></span><br><span class="line">            s.thread != <span class="keyword">null</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h1><p>lock 有2中方式，分别是ReadLock 和 WriteLock 的lock，下面比较这2种方式。主要分析读锁的 <code>tryAcquireShared </code>和写锁的 <code>tryAcquire </code>这2个方法。</p>
<p>涉及到的AQS内部的基类方法不再赘述。</p>
<h2 id="ReadLock-lock"><a href="#ReadLock-lock" class="headerlink" title="ReadLock.lock"></a>ReadLock.lock</h2><p>共享式的获取锁，获取不到时，节点会以SHARED的方式加入到同步队列中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AQS.acquireShared</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>) <span class="comment">// 加锁</span></span><br><span class="line">        doAcquireShared(arg); <span class="comment">// 加锁失败进入等待队列 AQS 方法, 节点状态是</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS.doAcquireShared</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);<span class="comment">//加锁失败，节点以SHARED 方式加入到同步队列中</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123; <span class="comment">// 唤醒后执行</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123; </span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt()) <span class="comment">// 挂起，等待唤醒</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="RWLock-Sync-tryAcquireShared"><a href="#RWLock-Sync-tryAcquireShared" class="headerlink" title="RWLock.Sync.tryAcquireShared"></a>RWLock.Sync.tryAcquireShared</h3><p>读锁的获取过程：</p>
<ol>
<li>如果有线程持有写锁，并且持有写锁的线程不是当前线程。也就是说，<strong>当前线程持有写锁的情况下，是可以获取到读锁的。</strong></li>
<li>判断读锁是否要阻塞以及读锁是否越界</li>
<li>第二步失败后尝试自旋获取锁，直到成功或失败</li>
</ol>
<p>读锁的特性：</p>
<ul>
<li><p><strong>写锁被持有的情况下，其他线程是不能持有读锁的；已持有写锁的线程可以再持有读锁，也称为<code>锁降级</code></strong></p>
</li>
<li><p><strong>读锁被持有的情况下，可以再持有读锁，也就是可重入；其他线程也可以持有读锁的，读锁可共享。</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState(); <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp; <span class="comment">// // 如果有线程持有写锁 </span></span><br><span class="line">        getExclusiveOwnerThread() != current)  <span class="comment">// 并且持有写锁的线程不是当前线程</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c); <span class="comment">// 读锁值</span></span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp; <span class="comment">// 联系上节，公平锁阻塞，非公平锁不阻塞</span></span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp; <span class="comment">// 读锁值 未越界</span></span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) <span class="comment">// cas 读锁值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123; <span class="comment">// 首次获取读锁</span></span><br><span class="line">            firstReader = current; <span class="comment">// 赋值第一个</span></span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123; <span class="comment">// 第一个读线程发生了重入</span></span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            HoldCounter rh = cachedHoldCounter; <span class="comment">// 获取最近的一个成功获取读锁的线程的计数对象</span></span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) <span class="comment">// 如果rh为空或者rh的线程id不是当前线程的话        // 将readHolds的计数对象取出来赋值给cachedHoldCounter</span></span><br><span class="line">		        <span class="comment">// readHolds里面有最近一次获取读锁的线程的一些简单的计数信息</span></span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>) <span class="comment">//最近一个的计数对象count=0，则说明HoldCounter还刚刚被创立出来</span></span><br><span class="line">                readHolds.set(rh);<span class="comment">// 那么将rh这个对象直接赋值到readHolds中去</span></span><br><span class="line">            rh.count++; <span class="comment">// 并且次数累加一次</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">// 返回1说明当前已经成功的获取到了读锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current); <span class="comment">// 通过自旋的方式再次获取锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RWLock-Sync-fullTryAcquireShared"><a href="#RWLock-Sync-fullTryAcquireShared" class="headerlink" title="RWLock.Sync.fullTryAcquireShared"></a>RWLock.Sync.fullTryAcquireShared</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">    HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">            <span class="comment">// Make sure we&#x27;re not acquiring read lock reentrantly</span></span><br><span class="line">            <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                        rh = readHolds.get();</span><br><span class="line">                        <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            readHolds.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123; <span class="comment">// cas获取锁成功改变state</span></span><br><span class="line">            <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                firstReader = current;</span><br><span class="line">                firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                firstReaderHoldCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line">                rh.count++;</span><br><span class="line">                cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="WriteLock-lock"><a href="#WriteLock-lock" class="headerlink" title="WriteLock.lock"></a>WriteLock.lock</h2><p>获取写锁，如果获取失败，节点以独占（EXCLUSIVE）模式加入到同步队列中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) <span class="comment">//获取写锁失败时，节点以独占模式加入到队列中。</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RWLock-Sync-tryAcquire"><a href="#RWLock-Sync-tryAcquire" class="headerlink" title="RWLock.Sync.tryAcquire"></a>RWLock.Sync.tryAcquire</h3><p> 获取写锁，有几个判断：</p>
<ol>
<li>锁是否被读锁占用，如果被读锁占用则不可获取写锁</li>
<li>判断是否是写锁重入</li>
<li>判断是state是否越界</li>
</ol>
<p>写锁的特性：</p>
<ol>
<li><p><strong>写锁被持有的情况下，持有写锁的线程可重入；但其他线程是不能持有写锁的；</strong></p>
</li>
<li><p><strong>读锁被持有的情况下，任何线程是不能再持有写锁的。</strong></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c); <span class="comment">// 获取写锁</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123; <span class="comment">// c不为零，说明有线程占有锁，可能是读可能是写</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || <span class="comment">// 说明已经持有的是读锁</span></span><br><span class="line">            <span class="comment">// 在w ！= 0的前提下，走到这case 说明写锁已经被获取，需要判断是不是重入 </span></span><br><span class="line">            current != getExclusiveOwnerThread()) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT) <span class="comment">// 重入时判断写锁越界</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(c + acquires);<span class="comment">//获取到写锁</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行到此，c=0，也就是说目前还没有线程占用读锁和写锁</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() || <span class="comment">//根据公平或者非公平策略获取写锁</span></span><br><span class="line">        !compareAndSetState(c, c + acquires)) </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    setExclusiveOwnerThread(current); <span class="comment">// 设置独占线程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="unlock"><a href="#unlock" class="headerlink" title="unlock"></a>unlock</h1><p>介绍下读锁和写锁的解锁，主要分析读锁的 <code>tryReleaseShared</code>和写锁的 <code>tryRelease</code>这2个方法。</p>
<h2 id="ReadLock-unlock"><a href="#ReadLock-unlock" class="headerlink" title="ReadLock.unlock"></a>ReadLock.unlock</h2><p>读锁解锁，<code>releaseShared</code>返回true表示锁完全释放，false 表示未完全释放。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS.releaseShared</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123; <span class="comment">// 解锁</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS.doReleaseShared</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);<span class="comment">// 唤醒同步队列后继节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RWLock-Sync-tryReleaseShared"><a href="#RWLock-Sync-tryReleaseShared" class="headerlink" title="RWLock.Sync.tryReleaseShared"></a>RWLock.Sync.tryReleaseShared</h3><p>如果释放失败的话，则会通过自旋的方式继续尝试释放资源，直到成功为止</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">if</span> (firstReader == current) &#123; <span class="comment">// firstReader是当前线程</span></span><br><span class="line">        <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">            firstReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            firstReaderHoldCount--; <span class="comment">//多次重入则减1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 执行到此，说明当前要释放读锁的线程不是那个首次获取到读锁的线程</span></span><br><span class="line">        HoldCounter rh = cachedHoldCounter;<span class="comment">// 获取最近的那个线程对象，如果不是当前线程的话</span></span><br><span class="line">        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">            rh = readHolds.get(); <span class="comment">// 那么则通过readHolds获取最近的那个计数对象</span></span><br><span class="line">        <span class="keyword">int</span> count = rh.count;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;<span class="comment">// 若小于等于1，那么自减1就没了，所以减都没减了，直接移除掉，简单干脆</span></span><br><span class="line">            readHolds.remove();</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">        &#125;</span><br><span class="line">        --rh.count;<span class="comment">// 如果大于1的话，则还有的减，那么就自减1操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// state 的维护</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">int</span> nextc = c - SHARED_UNIT; <span class="comment">// 读锁 “减1”</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>; <span class="comment">// = 0表示 锁完全释放</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="WriteLock-unlock"><a href="#WriteLock-unlock" class="headerlink" title="WriteLock.unlock"></a>WriteLock.unlock</h2><p>写锁释放锁的过程，<code>release</code> 返回true表示写锁完全释放。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123; <span class="comment">// 重点分析</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);<span class="comment">// 唤醒同步队列中的后继</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RWLock-Sync-tryRelease"><a href="#RWLock-Sync-tryRelease" class="headerlink" title="RWLock.Sync.tryRelease"></a>RWLock.Sync.tryRelease</h3><p>每次释放，state低位减一；完全释放后独占线程置空。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively()) <span class="comment">// 写锁是独占式锁，也就是说当前线程没有持有写锁的话，那么就直接抛异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">int</span> nextc = getState() - releases; <span class="comment">// state--</span></span><br><span class="line">    <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>; <span class="comment">// 写锁是否都释放完毕</span></span><br><span class="line">    <span class="keyword">if</span> (free)</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>); <span class="comment">// 独占线程置空</span></span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ReentrantReadWriteLock的特性：</p>
<ul>
<li>已持有写锁的线程<ul>
<li>可以再持有写锁，这和ReentrantLock的重入锁概念是一致的；</li>
<li><strong>其他线程是不能持有读锁、写锁的；</strong></li>
<li><strong>持有写锁的线程可以再持有读锁，这里我们称之为锁降级；</strong></li>
</ul>
</li>
<li>已持有读锁的线程<ul>
<li>可以再持有读锁，这和ReentrantLock的重入锁概念是一致的；</li>
<li> 其他线程也可以持有读锁的；    </li>
<li>其他线程(同时也包括已持有读锁的线程)是不能持有写锁的；</li>
</ul>
</li>
</ul>
<p>提炼总结</p>
<ul>
<li><strong>写锁会排斥读锁、写锁，但是读锁会阻塞写锁；</strong></li>
<li><strong>写锁可以降级为读锁，但读锁不能升级为写锁；</strong>    </li>
</ul>
<p><a href="https://my.oschina.net/hmilyylimh/blog/1634883">https://my.oschina.net/hmilyylimh/blog/1634883</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
        <category>JUC</category>
      </categories>
  </entry>
  <entry>
    <title>JUC_10_BlockingQueue</title>
    <url>/2022/12/25/Notes/Java/02JUC/JUC_10_BlockingQueue/</url>
    <content><![CDATA[<h1 id="JUC-10-BlockingQueue"><a href="#JUC-10-BlockingQueue" class="headerlink" title="JUC_10_BlockingQueue"></a>JUC_10_BlockingQueue</h1><span id="more"></span>

<p>BlockingQueue，阻塞队列，先了解几个概念。</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p><code>Queue</code> 实际上是实现了一个先进先出（FIFO：First In First Out）的有序表。和 <code>List</code> 的区别在于，<code>List</code>可以在任意位置添加和删除元素，而<code>Queue</code> 只有两个操作：</p>
<ul>
<li>把元素添加到队列末尾；</li>
<li>从队列头部取出元素。</li>
</ul>
<h2 id="线程安全的队列"><a href="#线程安全的队列" class="headerlink" title="线程安全的队列"></a>线程安全的队列</h2><p>在并发编程中，经常需要使用到线程安全的队列。要实现一个线程安全的队列有2种方式，一种是使用阻塞算法，另一种是使用非阻塞算法。非阻塞算法的典型代表是ConcurrentLinkedQueue，而阻塞算法的典型代表是BlockingQueue，也就是我们常说的阻塞队列。</p>
<h3 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h3><p>ConcurrentLinkedQueue 是由单向链表实现的，每个元素都是一个Node节点，每个节点中都有指向下一个节点的指针。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentLinkedQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; head;</span><br><span class="line">	</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; tail;</span><br><span class="line">  </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ConcurrentLinkedQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    head = tail = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">      <span class="keyword">volatile</span> E item;</span><br><span class="line">      <span class="keyword">volatile</span> Node&lt;E&gt; next;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然没有加锁，那么它的线程安全是怎么实现的？其实ConcurrentLinkedQueue是循环CAS。</p>
<p><a href="https://blog.csdn.net/qq_38293564/article/details/80798310">https://blog.csdn.net/qq_38293564/article/details/80798310</a></p>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>阻塞队列，顾名思义，首先它是一个队列，而一个阻塞队列在数据结构中所起的作用大致如下。</p>
<img src="/pics/image-20210406203534870.png" alt="image-20210406203534870" style="zoom:60%;" />

<p>线程 1 往阻塞队列中添加元素，而线程 2 从阻塞队列中移除元素</p>
<ul>
<li>当阻塞队列是空时，从队列中获取元素的操作将会被阻塞。</li>
<li>当阻塞队列是满时，从队列中添加元素的操作将会被阻塞。</li>
</ul>
<h1 id="阻塞队列-1"><a href="#阻塞队列-1" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><h2 id="公平模式和非公平模式"><a href="#公平模式和非公平模式" class="headerlink" title="公平模式和非公平模式"></a>公平模式和非公平模式</h2><p>公平模式：指阻塞的线程可以按照阻塞的先后顺序访问队列，即先阻塞的线程先访问。</p>
<p>非公平模式：当队列可用时，阻塞的线程都可以争夺队列的访问资格。</p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>相比 Queue 接口，BlockingQueue 有四种形式的 API。</p>
<table>
<thead>
<tr>
<th>方法类型</th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>一直阻塞</th>
<th>超时退出</th>
</tr>
</thead>
<tbody><tr>
<td>插入</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e,time,unit)</td>
</tr>
<tr>
<td>移除（取出）</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time,unit)</td>
</tr>
<tr>
<td>检查</td>
<td>element()</td>
<td>peek()</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody></table>
<p>抛出异常：</p>
<ul>
<li>当阻塞队列满时，再往队列里 add 插入元素会抛出 <code>java.lang.IllegalStateException: Queue full</code> 异常；</li>
<li>当队列为空时，从队列里 remove 移除元素时会抛出 <code>NoSuchElementException</code> 异常 。</li>
<li>element()，返回队列头部的元素，如果队列为空，则抛出一个 <code>NoSuchElementException</code> 异常</li>
</ul>
<p>返回特殊值：</p>
<ul>
<li>offer()，插入方法，成功返回 true，失败返回 false；</li>
<li>poll()，移除方法，成功返回出队列的元素，队列里没有则返回 null</li>
<li>peek() ，返回队列头部的元素，如果队列为空，则返回 null</li>
</ul>
<p><strong>一直阻塞：</strong></p>
<ul>
<li>当阻塞队列满时，如果生产线程继续往队列里 put 元素，队列会一直阻塞生产线程，直到拿到数据，或者响应中断退出；</li>
<li>当阻塞队列空时，消费线程试图从队列里 take 元素，队列也会一直阻塞消费线程，直到队列可用。</li>
</ul>
<p><strong>超时退出：</strong></p>
<ul>
<li>当阻塞队列满时，队列会阻塞生产线程一定时间，如果超过一定的时间，生产线程就会退出，返回 false</li>
<li>当阻塞队列空时，队列会阻塞消费线程一定时间，如果超过一定的时间，消费线程会退出，返回 null</li>
</ul>
<p><strong>JDK中的阻塞队列</strong></p>
<p>JDK 提供了 7 个阻塞队列。分别是</p>
<ul>
<li>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列</li>
<li>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列</li>
<li>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列</li>
<li>DelayQueue：一个使用优先级队列实现的无界阻塞队列</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列</li>
<li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列（实现了继承于 BlockingQueue 的 TransferQueue）</li>
<li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列</li>
</ul>
<p>前面说过阻塞队列的特性有2个：</p>
<ul>
<li>当阻塞队列满时，如果生产线程继续往队列里 put 元素，队列会一直阻塞生产线程，直到拿到数据，或者响应中断退出；</li>
<li>当阻塞队列空时，消费线程试图从队列里 take 元素，队列也会一直阻塞消费线程，直到队列可用。</li>
</ul>
<p>这是一个典型的生产者消费者模型，下面分析下典型的3个阻塞队列的源码ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue，看下BlockingQueue put 和 take的原理。</p>
<h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><p>我们先来看下ArrayBlockingQueue 数据结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过数组来实现的队列</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items;</span><br><span class="line">    <span class="comment">//记录队首元素的下标</span></span><br><span class="line">    <span class="keyword">int</span> takeIndex;</span><br><span class="line">    <span class="comment">//记录队尾元素的下标</span></span><br><span class="line">    <span class="keyword">int</span> putIndex;</span><br><span class="line">    <span class="comment">//队列中的元素个数</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">//通过ReentrantLock来实现同步</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line">    <span class="comment">//有2个条件对象，分别表示队列不为空和队列不满的情况</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line">    <span class="comment">//迭代器</span></span><br><span class="line">    <span class="keyword">transient</span> Itrs itrs;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">        <span class="comment">// 是否是公平模式，</span></span><br><span class="line">        lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">        notEmpty = lock.newCondition();</span><br><span class="line">        notFull =  lock.newCondition();</span><br><span class="line">    &#125;  </span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ArrayBlokingQueue 使用的数据结构是数组，构造函数初始化时构建了Reentrantlock和2 个 Condition对象，构造函数中的参数fair就是控制是否是公平模式，底层的原理其实依赖的是Reentrantlock。到这里我们也应该能猜到，ArrayBlokingQueue 阻塞的原理就是锁 和<code>等待-通知</code>机制。</p>
<h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p>put 的步骤：</p>
<ol>
<li>使用 lock.lockInterruptibly() 进行加锁</li>
<li>如果队列满的话就阻塞等待，</li>
<li>如果队列不满，使用enqueue方法将元素加入到队列中</li>
<li>notEmpty.signal()唤醒take</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">   <span class="comment">//因为后面调用了条件变量的await()方法，而await()方法会在中断标志设置后抛出InterruptedException异常后退出，</span></span><br><span class="line">  <span class="comment">// 所以在加锁时候先看中断标志是不是被设置了，如果设置了直接抛出InterruptedException异常，就不用再去获取锁了</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            <span class="comment">//如果队列满的话就阻塞等待，直到notFull的signal方法被调用，也就是队列里有空间了</span></span><br><span class="line">            notFull.await();</span><br><span class="line">       <span class="comment">//队列里有空间了执行添加操作</span></span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数据添加到队列中的具体方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">   <span class="comment">//通过循环数组实现的队列，当数组满了时下标就变成0了</span></span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">   <span class="comment">//唤醒因为notEmpty条件而阻塞的线程，比如调用take方法的线程</span></span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="take"><a href="#take" class="headerlink" title="take"></a>take</h3><p>take的步骤：</p>
<ol>
<li>使用 lock.lockInterruptibly() 进行加锁</li>
<li>如果队列空的话就阻塞等待，</li>
<li>如果队列不空，使用dequeue方法将元素加入到队列中</li>
<li>唤醒 put 操作</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//take方法也是用于取队列中的数据，和poll方法不同的是它有可能会阻塞当前的线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//当队列为空时，就会阻塞当前线程</span></span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="comment">//直到队列中有数据了，调用dequeue方法将数据返回</span></span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将数据从队列中取出的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line">    <span class="comment">//将对应的数组下标位置设置为null释放资源</span></span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">   <span class="comment">//唤醒因为notFull条件而阻塞的线程，比如调用put方法的线程</span></span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><p>LinkedBlockingQueue 是一个用单向链表实现的有界阻塞队列。此队列的默认和最大长度为 <code>Integer.MAX_VALUE</code>。此队列按照先进先出的原则对元素进行排序。</p>
<p>如果不是特殊业务，LinkedBlockingQueue 使用时，切记要定义容量 <code>new LinkedBlockingQueue(capacity)</code></p>
<p>，防止过度膨胀。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6903933977591709194L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于链表实现，肯定要有结点类，典型的单链表结构</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node(E x) &#123; item = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="comment">//当前队列元素数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="comment">// 头节点，不存数据</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line"> 		<span class="comment">// 尾节点，便于入队</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// take锁，出队锁，只有take，poll方法会持有</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// 出队等待条件</span></span><br><span class="line">    <span class="comment">// 当队列无元素时，take锁会阻塞在notEmpty条件上，等待其它线程唤醒</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入队锁，只有put，offer会持有</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// 入队等待条件</span></span><br><span class="line">    <span class="comment">// 当队列满了时，put锁会会阻塞在notFull上，等待其它线程唤醒</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同样提供三个构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">       <span class="comment">// 初始化head和last指针为空值节点</span></span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        last = head = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果没传容量，就使用最大int值初始化其容量</span></span><br><span class="line">        <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LinkedBlockingQueue 中有2把锁</p>
<ol>
<li> 出队锁，只有take，poll方法会持有</li>
<li>入队锁，只有put，offer会持有</li>
</ol>
<p>和ArrayBlockingQueue相比起来</p>
<ul>
<li>ArrayBlockingQueue 入队出队采用一把锁，导致入队出队相互阻塞，效率低下；</li>
<li>LinkedBlockingQueue 入队出队采用两把锁，入队出队互不干扰，效率较高；</li>
<li>LinkedBlockingQueue  默认是非公平模式访问，不支持公平</li>
</ul>
<h3 id="put-1"><a href="#put-1" class="headerlink" title="put"></a>put</h3><p>put的步骤</p>
<ol>
<li>如果队列满了，就阻塞在notFull条件上</li>
<li>队列未满，put完后，先一次唤醒notFull上的线程的操作，唤醒其他阻塞在put上的操作；最后再唤醒阻塞在notEmpty上的take操作</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      <span class="comment">// 不允许null元素</span></span><br><span class="line">      <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">      <span class="comment">//规定给当前put方法预留一个本地变量</span></span><br><span class="line">      <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 新建一个节点</span></span><br><span class="line">      Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">      <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">      <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">      <span class="comment">// 使用put锁加锁</span></span><br><span class="line">      putLock.lockInterruptibly();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// 如果队列满了，就阻塞在notFull条件上</span></span><br><span class="line">      	<span class="comment">// 等待被其它线程唤醒</span></span><br><span class="line">          <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">              notFull.await();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 队列不满了，就入队</span></span><br><span class="line">          enqueue(node);</span><br><span class="line">          <span class="comment">// 队列长度加1</span></span><br><span class="line">          c = count.getAndIncrement();</span><br><span class="line">          <span class="comment">// 如果现队列长度小于容量</span></span><br><span class="line">      		<span class="comment">// 就再唤醒一个阻塞在notFull条件上的线程</span></span><br><span class="line">          <span class="comment">// 这里为啥要唤醒一下呢？</span></span><br><span class="line">          <span class="comment">// 因为可能有很多线程阻塞在notFull这个条件上的</span></span><br><span class="line">          <span class="comment">// 而取元素时只有取之前队列是满的才会唤醒notFull</span></span><br><span class="line">          <span class="comment">// 为什么队列满的才唤醒notFull呢？</span></span><br><span class="line">          <span class="comment">// 因为唤醒是需要加putLock的，这是为了减少锁的次数</span></span><br><span class="line">          <span class="comment">// 所以，这里索性在放完元素就检测一下，未满就唤醒其它notFull上的线程</span></span><br><span class="line">          <span class="comment">// 说白了，这也是锁分离带来的代价</span></span><br><span class="line">          <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">              notFull.signal();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="comment">// 释放锁</span></span><br><span class="line">          putLock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果原队列长度为0，现在加了一个元素后立即唤醒notEmpty条件</span></span><br><span class="line">      <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">          signalNotEmpty();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">      <span class="comment">// 加take锁</span></span><br><span class="line">      takeLock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 唤醒notEmpty条件</span></span><br><span class="line">          notEmpty.signal();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          takeLock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">      putLock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          notFull.signal();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          putLock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 直接加到last后面</span></span><br><span class="line">      last = last.next = node;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="take-1"><a href="#take-1" class="headerlink" title="take"></a>take</h3><p>take的步骤：</p>
<ol>
<li>如果队列为空，就阻塞在notEmpty条件上</li>
<li>队列未满，put完后，唤醒notEmpty，执行其他阻塞在take上的操作；最后再唤醒阻塞在notFull上的put操作</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果队列无元素，则阻塞在notEmpty条件上</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则，出队</span></span><br><span class="line">        x = dequeue();</span><br><span class="line">        <span class="comment">// 获取出队前队列的长度</span></span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        <span class="comment">// 如果取之前队列长度大于1，则唤醒notEmpty</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果取之前队列长度等于容量</span></span><br><span class="line">	 <span class="comment">// 则唤醒notFull</span></span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; h = head;</span><br><span class="line">    Node&lt;E&gt; first = h.next;</span><br><span class="line">    h.next = h; <span class="comment">// help GC</span></span><br><span class="line">    head = first;</span><br><span class="line">    E x = first.item;</span><br><span class="line">    first.item = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><p>是一个不存储元素的阻塞队列，也称为同步队列。每一个 put 操作必须等待一个 take 操作，否则不能继续添加元素。和ArrayBlockingQueue 以及LinkedBlockingQueue不同的是 ，SynchronousQueue 是基于循环CAS，SynchronousQueue是基于循环CAS的。</p>
<p>SynchronousQueue 可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。<code>队列本身并不存储任何元素</code>，非常适合于传递性场景, 比如在一个线程中使用的数据，传递给另外一个线程使用，SynchronousQueue 的吞吐量高于 LinkedBlockingQueue 和 ArrayBlockingQueue。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronousQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// cpu 数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPUS = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定超时时间后，当前线程的最大自旋次数；cpu数&lt;2时直接挂起</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> maxTimedSpins = (NCPUS &lt; <span class="number">2</span>) ? <span class="number">0</span> : <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 未指定超时限制，线程等待匹配时的自旋次数是maxTimedSpins的16倍</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> maxUntimedSpins = maxTimedSpins * <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定超时限制后，自旋的最小时间间隔，大于这个值才有必要挂起</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> spinForTimeoutThreshold = <span class="number">1000L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Transferer</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// e != null ,表示是data类型请求，即put操作; e== null,表示是request类型请求，即take操作</span></span><br><span class="line">        <span class="comment">// 返回值不为null 表示操作成功</span></span><br><span class="line">        <span class="comment">// timed,nanos 表示超时时间，在指定时间内操作必须要返回</span></span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span>;</span><br><span class="line">	&#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    	transferer = fair ? <span class="keyword">new</span> TransferQueue&lt;E&gt;() : <span class="keyword">new</span> TransferStack&lt;E&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>SynchronousQueue 提供了两个构造器（公平与否），内部是通过 Transferer 来实现的，具体分为两个Transferer，分别是 TransferStack 和 TransferStack 。</p>
<p>TransferStack 和 TransferStack 都实现Transferer接口，SynchronousQueue中的所有接口put take offer poll 等等的实现都是调用 tranfer方法。下面我们看下TransferQueue 和 TransferStack的原理</p>
<h3 id="TransferStack"><a href="#TransferStack" class="headerlink" title="TransferStack"></a>TransferStack</h3><p>非公平竞争模式使用的数据结构是后进先出栈(LIFO Stack)，先了解下TransferStack的数据结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferStack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Transferer</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Node 类型为请求类型</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REQUEST    = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Node 类型为数据类型</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DATA       = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// NODE 类型为匹配类型</span></span><br><span class="line">    <span class="comment">// 当栈顶元素类型为 REQUEST，新入栈类型为DATA 类型时，入栈类型被修改为FULFILLING|MODE；反之亦然</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FULFILLING = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns true if m has fulfilling bit set. */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isFulfilling</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123; <span class="keyword">return</span> (m &amp; FULFILLING) != <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Node class for TransferStacks. */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SNode</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 下个栈帧</span></span><br><span class="line">        <span class="keyword">volatile</span> SNode next;        <span class="comment">// next node in stack</span></span><br><span class="line">        <span class="comment">// 匹配的节点</span></span><br><span class="line">        <span class="keyword">volatile</span> SNode match;       <span class="comment">// the node matched to this</span></span><br><span class="line">        <span class="comment">// 待匹配节点的线程</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread waiter;     <span class="comment">// to control park/unpark</span></span><br><span class="line">        <span class="comment">// 数据域</span></span><br><span class="line">        Object item;                <span class="comment">// data; or null for REQUESTs</span></span><br><span class="line">        <span class="comment">// NODE 模式</span></span><br><span class="line">        <span class="keyword">int</span> mode;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TransferStack 的主要原理是：</p>
<p>1、执行相同操作时，假设先执行了2次put操作时，入栈2个mode 为 DATA的 节点 </p>
<p>2、当执行take操作时，发现和栈顶元素可以匹配（DATA 和 REQUEST），入栈节点会被修改为FULFILLING | mode 状态</p>
<p>3、执行出栈逻辑，将match的2个节点同时出栈，同时修改栈顶指针</p>
<img src="/pics/image-20210411225525733.png" alt="image-20210411225525733" style="zoom:50%;" />

<h3 id="TransferQueue"><a href="#TransferQueue" class="headerlink" title="TransferQueue"></a>TransferQueue</h3><p>公平竞争模式则使用先进先出队列（FIFO Queue）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Transferer</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">QNode</span> </span>&#123;</span><br><span class="line">    		<span class="comment">//指向当前节点的下一个节点，组装链表使用的。</span></span><br><span class="line">        <span class="keyword">volatile</span> QNode next;          <span class="comment">// next node in queue</span></span><br><span class="line">        <span class="comment">//数据域  Node代表的是DATA类型，item表示数据   否则 Node代表的REQUEST类型，item == null</span></span><br><span class="line">        <span class="keyword">volatile</span> Object item;         <span class="comment">// CAS&#x27;ed to or from null</span></span><br><span class="line">        <span class="comment">//当Node对应的线程 未匹配到节点时，对应的线程 最终会挂起，挂起之前会保留 线程引用到waiter ，</span></span><br><span class="line">        <span class="comment">//方法 其它Node匹配当前节点时 唤醒 当前线程..</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread waiter;       <span class="comment">// to control park/unpark</span></span><br><span class="line">        <span class="comment">//true 当前Node是一个DATA类型   false表示当前Node是一个REQUEST类型。</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isData;</span><br><span class="line"></span><br><span class="line">        QNode(Object item, <span class="keyword">boolean</span> isData) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.isData = isData;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>TransferStack 的工作原理是：</p>
<ol>
<li>执行相同操作时，假设先执行了2次put操作时，入栈2个 isData为true的节点</li>
<li>当执行take操作时，发现和<code>队尾</code>元素可以匹配（true 和 false）时，会将<code>队头</code>元素移除队列，这也是公平模式，先入先出。</li>
</ol>
<img src="/pics/image-20210409002509050.png" alt="image-20210409002509050" style="zoom:50%;" />



<p><strong>不存储任何元素的理解：</strong></p>
<p>一般的阻塞队列如果发现队列中没有满put方法就直接把数据放到队列中，然后线程继续执行，同样发现队列中有数据take方法也会直接从队列中拿到数据然后继续执行。</p>
<p>之前的队列都是把要交换的数据当作资源去put或take,而SynchronousQueue就好像是把线程当作资源，这样就不需要多出来资源来存储交换的数据了。</p>
<p>在之前的队列中没有数据是如果take方法进来<code>线程就会阻塞</code>，或者当队列满了的时候put方法进来纤<code>线程也会阻塞</code>。</p>
<p>而SynchronousQueue把put和take分成两类资源，阻塞队列中只有不同的类型就去匹配，否则就阻塞，同时SynchronousQueue通过实现先进先出表示公平，先进后出表示不公平。 </p>
<p><a href="https://my.oschina.net/u/4585596/blog/4616562">https://my.oschina.net/u/4585596/blog/4616562</a></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>除此之外还有几种同步队列，简单总结下。</p>
<img src="/pics/image-20210409121605513.png" alt="image-20210409121605513" style="zoom:50%;" />

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/a/1190000023769855">https://segmentfault.com/a/1190000023769855</a></p>
<p><a href="https://www.cnblogs.com/duanxz/p/3252267.html">https://www.cnblogs.com/duanxz/p/3252267.html</a></p>
<p><a href="https://blog.csdn.net/u010853261/article/details/78520960">https://blog.csdn.net/u010853261/article/details/78520960</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
        <category>JUC</category>
      </categories>
  </entry>
  <entry>
    <title>JUC_13_生产者和消费者模式</title>
    <url>/2022/03/27/Notes/Java/02JUC/JUC_13_%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="JUC-13-生产者和消费者模式"><a href="#JUC-13-生产者和消费者模式" class="headerlink" title="JUC_13_生产者和消费者模式"></a>JUC_13_生产者和消费者模式</h1><span id="more"></span>

<p>生产者 - 消费者模型 <code>Producer-consumer problem</code> 是一个非常经典的多线程并发协作的模型，也是JUC 面试中高频的问题。</p>
<p>简单来说，这个模型是由3个角色：</p>
<ul>
<li><p>缓冲区：生产者和消费者的公共存储空间。</p>
</li>
<li><p>生产者：“生产”产品，并把产品放到一个缓冲区，当缓冲区满是阻塞</p>
</li>
<li><p>消费者：“消费”产品，从缓冲区取走产品，当缓冲区为空时阻塞</p>
</li>
</ul>
<img src="/pics/image-20220327201653323.png" alt="image-20220327201653323" style="zoom:50%;" />

<p>该模型实现了生产者和消费者之间的<strong>解耦和异步</strong>。</p>
<p>生产者就只需要关注生产，而不用管消费者的消费行为，更不用等待消费者线程执行完；</p>
<p>消费者也只管消费，不用管生产者是怎么生产的，更不用等着生产者生产。</p>
<p>通常有四种方式可以实现：</p>
<ul>
<li><strong>Object</strong>的wait() / notify()方法</li>
<li><strong>Lock和Condition</strong>的await() / signal()方法</li>
<li><strong>BlockingQueue</strong>阻塞队列方法</li>
<li><strong>Semaphore</strong>的acquire()/release()方法</li>
</ul>
<p>下面来一一介绍下。</p>
<h2 id="一、Object的wait-notify"><a href="#一、Object的wait-notify" class="headerlink" title="一、Object的wait/notify"></a>一、Object的wait/notify</h2><p>在使用线程的等待通知机制时，一般都要在 while 循环中调用 wait() 方法。 因为唤醒的瞬间有可能其他的生产者线程先拿到了锁进行了生产，所以队列又经历了一个从不满到满的过程。</p>
<p>另外我们基于的是多生产者和消费者的情况，所以采用的是<code>notifyAll</code>而不是<code>notify</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjProAndConContainer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ObjProAndConContainer().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Buffer buffer = <span class="keyword">new</span> Buffer();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer(buffer), <span class="string">&quot;produce &quot;</span>).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(buffer), <span class="string">&quot;consume&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、生产者</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        Buffer buffer;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Buffer buffer)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.buffer = buffer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 死循环，不停从向队列中放元素</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">300</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 元素是随机数</span></span><br><span class="line">                buffer.put(<span class="keyword">new</span> Random().nextInt());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、消费者</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        Buffer buffer;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Buffer buffer)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.buffer = buffer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 死循环，不停从队列中取元素</span></span><br><span class="line">                buffer.get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓冲区</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// 双向队列实现，锁对象也是缓冲队列</span></span><br><span class="line">        <span class="keyword">final</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">                <span class="comment">// 在使用线程的等待通知机制时，一般都要在 while 循环中调用 wait() 方法。</span></span><br><span class="line">                <span class="comment">// 因为唤醒的瞬间有可能其他的生产者线程先拿到了锁进行了生产，</span></span><br><span class="line">                <span class="comment">// 所以队列又经历了一个从不满到满的过程。</span></span><br><span class="line">                <span class="keyword">while</span> (queue.size() == size) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        queue.wait(); <span class="comment">// 阻塞</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; put = &quot;</span> + i);</span><br><span class="line">                queue.offer(i);</span><br><span class="line">                queue.notifyAll(); <span class="comment">// 唤醒所有的，包括生产者和消费者</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">                <span class="keyword">while</span> (queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        queue.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> val = queue.poll();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; get = &quot;</span> + val);</span><br><span class="line">                queue.notifyAll(); <span class="comment">// 唤醒所有的，包括生产者和消费者</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、Lock和Condition的await-signal"><a href="#二、Lock和Condition的await-signal" class="headerlink" title="二、Lock和Condition的await / signal"></a>二、Lock和Condition的await / signal</h2><p>需要2个<code>Condition</code>，分别用来唤醒生产者和消费者。另外唤醒是采用的是 <code>signalAll</code>, 不要使用成了<code>notify</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockProConContainer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// 从唤醒的角度理解这2个名字含义</span></span><br><span class="line">    <span class="comment">// 表示&quot;不满了&quot;，可以生产了，唤醒生产者</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = lock.newCondition();</span><br><span class="line">    <span class="comment">// 表示生产者 &quot;不空了&quot;，唤醒消费者</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> LockProConContainer().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(producer, <span class="string">&quot;producer01&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(consumer, <span class="string">&quot;cousumer01&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(), <span class="string">&quot;cousumer02&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// while 判断</span></span><br><span class="line">                    <span class="keyword">while</span> (queue.size() == size) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 阻塞</span></span><br><span class="line">                            notFull.await();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> Random().nextInt());</span><br><span class="line">                    System.out.println(<span class="string">&quot;producer-- &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;--put:&quot;</span> + queue.peekFirst());</span><br><span class="line">                    <span class="comment">// 表示生产者 &quot;不空了&quot;，唤醒消费者</span></span><br><span class="line">                    <span class="comment">// 这里注意要用signal</span></span><br><span class="line">                    notEmpty.signalAll();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            notEmpty.await();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">int</span> out = queue.poll();</span><br><span class="line">                    System.out.println(<span class="string">&quot;consumer -- &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;--put:&quot;</span> + out);</span><br><span class="line">                    <span class="comment">// 表示&quot;不满了&quot;，唤醒生产者</span></span><br><span class="line">                    <span class="comment">// 不可使用notify 唤醒</span></span><br><span class="line">                    notFull.signalAll();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 控制频率</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、阻塞队列"><a href="#三、阻塞队列" class="headerlink" title="三、阻塞队列"></a>三、阻塞队列</h2><p>阻塞队列的内部实现就是 <code>Lock + Condition</code>，所以不需要再另外加锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueProAndConContainer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(size);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> QueueProAndConContainer().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer(), <span class="string">&quot;produce01&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(), <span class="string">&quot;consume01&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(), <span class="string">&quot;consume02&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">//                    if (queue.size() == size) &#123;</span></span><br><span class="line"><span class="comment">//                        System.out.println(&quot;Producer wait&quot;);</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line">                    queue.put(<span class="keyword">new</span> Random().nextInt());</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;生产者生产 = &quot;</span> + queue.peek());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 死循环</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"><span class="comment">//                    if (queue.isEmpty()) &#123;</span></span><br><span class="line"><span class="comment">//                        System.out.println(&quot;Consumer wait&quot;);</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line">                    <span class="keyword">int</span> x = queue.take();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 消费者消费 = &quot;</span> + x);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、Semaphore的acquire-release"><a href="#四、Semaphore的acquire-release" class="headerlink" title="四、Semaphore的acquire/release"></a>四、Semaphore的acquire/release</h2><p>Semaphore 的实现作为了解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemContainer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Semaphore fullCount = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    Semaphore emptyCount = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line">    Semaphore isUse = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    List queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        SemContainer container = <span class="keyword">new</span> SemContainer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer(container)).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(container)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(container)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Integer val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1、资源量 empty &gt; 0才put</span></span><br><span class="line">            emptyCount.acquire();</span><br><span class="line">            <span class="comment">// 2、锁的作用</span></span><br><span class="line">            isUse.acquire();</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;生产者生产 = &quot;</span> + val);</span><br><span class="line">            queue.add(val);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 1、</span></span><br><span class="line">            isUse.release();</span><br><span class="line">            <span class="comment">// 2、</span></span><br><span class="line">            fullCount.release();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Integer val1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1、资源量 &gt;0 才能获取</span></span><br><span class="line">            fullCount.acquire();</span><br><span class="line">            isUse.acquire();</span><br><span class="line"></span><br><span class="line">            val1 = (Integer) queue.remove(<span class="number">0</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 消费者消费 = &quot;</span> + val1);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            isUse.release();</span><br><span class="line">            emptyCount.release();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SemContainer container;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(SemContainer container)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.container = container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Integer val = container.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SemContainer container;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(SemContainer container)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.container = container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            container.put(<span class="keyword">new</span> Random().nextInt(<span class="number">100</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、死锁"><a href="#五、死锁" class="headerlink" title="五、死锁"></a>五、死锁</h2><p>死锁也是最常见的面试题之一，最简单的实现如下，2个线程竞争共享资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object obj1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object obj2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj1) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;get obj1&quot;</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (obj2) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;get obj2&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;release obj2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;release obj1&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// lambda 表达式</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj2) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;get obj2222&quot;</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (obj1) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;get obj11111&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;release obj11111&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;release obj2222&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/73442055">https://zhuanlan.zhihu.com/p/73442055</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
        <category>JUC</category>
      </categories>
  </entry>
  <entry>
    <title>JUC_12_ThreadPoolExecutor</title>
    <url>/2021/04/09/Notes/Java/02JUC/JUC_12_%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="JUC-12-ThreadPoolExecutor"><a href="#JUC-12-ThreadPoolExecutor" class="headerlink" title="JUC_12_ThreadPoolExecutor"></a>JUC_12_ThreadPoolExecutor</h1><span id="more"></span>

<h1 id="一、为什么要使用线程池？"><a href="#一、为什么要使用线程池？" class="headerlink" title="一、为什么要使用线程池？"></a>一、为什么要使用线程池？</h1><p>平时讨论多线程处理，大佬们必定会说使用线程池，那为什么要使用线程池？其实，这个问题可以反过来思考一下，不使用线程池会怎么样？</p>
<ul>
<li>当需要多线程并发执行任务时，只能不断的通过new Thread创建线程，每创建一个线程都需要在堆上分配内存空间，同时需要分配虚拟机栈、本地方法栈、程序计数器等线程私有的内存空间。</li>
<li>当这个线程对象被可达性分析算法标记为不可用时被GC回收，这样频繁的创建和回收需要大量的额外开销。</li>
<li>再者说，JVM的内存资源是有限的，如果系统中大量的创建线程对象，JVM很可能直接抛出OutOfMemoryError异常，还有大量的线程去竞争CPU会产生其他的性能开销，更多的线程反而会降低性能，所以必须要限制线程数。</li>
</ul>
<p><strong>使用线程池有哪些好处：</strong></p>
<ul>
<li><strong>降低资源消耗</strong>：线程池可以复用池中的线程，不需要每次都创建新线程，减少创建和销毁线程的开销。</li>
<li><strong>提高响应速度</strong>：任务到达时，无需等待线程创建即可立即执行。</li>
<li><strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。</li>
<li><strong>线程池可实现线程环境的隔离</strong>，例如分别定义支付功能相关线程池和优惠券功能相关线程池，当其中一个运行有问题时不会影响另一个。</li>
<li><strong>提供更多更强大的功能</strong>：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。</li>
</ul>
<p>Java中的线程池核心实现类是ThreadPoolExecutor，下面来分析下它的基本原理。</p>
<h1 id="二、如何构造线程池？"><a href="#二、如何构造线程池？" class="headerlink" title="二、如何构造线程池？"></a>二、如何构造线程池？</h1><h2 id="2-1、线程池类的设计"><a href="#2-1、线程池类的设计" class="headerlink" title="2.1、线程池类的设计"></a>2.1、线程池类的设计</h2><p>我们首先来看一下ThreadPoolExecutor的UML类图，了解下ThreadPoolExecutor的继承关系。</p>
<p><img src="/pics/image-20210304160811991.png" alt="image-20210304172819822"></p>
<ol>
<li>Executor：ThreadPoolExecutor的顶层接口，Executor只定义了一个接口execute</li>
<li>ExecutorService：继承自Executor，扩展了Executor的接口，增加了有返回值的接口submit以及主动退出线程池shutDown的方法。</li>
<li>AbstractExecutorService：实现了ExecutorService中的部分方法，比如submit。</li>
<li>ThreadPoolExecutor：线程池最核心的类，一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。</li>
</ol>
<h2 id="2-2、7大核心参数"><a href="#2-2、7大核心参数" class="headerlink" title="2.2、7大核心参数"></a>2.2、7大核心参数</h2><p>ThreadPoolExecutor构造方法中定义了7个参数，下面具体看下各个参数的含义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>coreSize</strong></p>
<p>默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到任务队列当中。线程池将长期保证这些线程处于存活状态，即使线程已经处于闲置状态。除非配置了allowCoreThreadTimeOut=true，核心线程数的线程也会在空闲时间超过keepAliveTime后被销毁。</p>
</li>
<li><p><strong>maximumPoolSize</strong></p>
<p>线程池内的最大线程数量，线程池内维护的线程不得超过该数量，大于核心线程数量的线程将在空闲时间超过keepAliveTime后被销毁。当阻塞队列存满后，将会创建新线程执行任务，线程的数量不会大于maximumPoolSize。maximumPoolSize的上限是</p>
</li>
</ol>
<p>$$<br>2^n -1 (n = 29)<br>$$</p>
<ol start="3">
<li><p><strong>keepAliveTime</strong> </p>
<p>存活时间，若线程数超过了corePoolSize，线程闲置时间超过了存活时间，该线程将被销毁。除非配置了allowCoreThreadTimeOut=true，核心线程数的线程也将不再保证长期存活于线程池内，在空闲时间超过keepAliveTime后被销毁。</p>
</li>
<li><p><strong>unit</strong></p>
<p>线程存活时间的单位，例如TimeUnit.SECONDS表示秒。</p>
</li>
<li><p><strong>workQueue</strong></p>
<p>线程池中保存等待执行的任务的阻塞队列。通过execute方法提交的Runable对象都会“存储”在该队列中，能够通过实现BlockingQueue接口来自定义我们所需要的阻塞队列。使用不同的队列可以实现不一样的任务存取策略，常见的阻塞队列有：</p>
<p><img src="/pics/image-20210304161843818.png" alt="image-20210304161843818"></p>
</li>
<li><p><strong>threadFactory</strong></p>
<p>创建线程的工厂，默认是DefaultThreadFactory，可以定义线程名称，分组，优先级等。</p>
</li>
<li><p><strong>RejectedExecutionHandler</strong></p>
<p>拒绝策略（饱和策略），当任务队列存满并且线程池个数达到maximunPoolSize后采取的策略。ThreadPoolExecutor中提供了四种拒绝策略如下：</p>
<table>
<thead>
<tr>
<th>可选值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>AbortPolicy</td>
<td>直接抛出RejectedExecutionException异常，默认拒绝策略。</td>
</tr>
<tr>
<td>DiscardPolicy</td>
<td>不进行处理也不抛出异常。</td>
</tr>
<tr>
<td>DiscardOldestPolicy</td>
<td>丢弃队列里最前的任务，执行当前任务。</td>
</tr>
<tr>
<td>CallerRunsPolicy</td>
<td>由调用线程执行该任务。</td>
</tr>
</tbody></table>
</li>
</ol>
<h1 id="三、线程池的工作原理？"><a href="#三、线程池的工作原理？" class="headerlink" title="三、线程池的工作原理？"></a>三、线程池的工作原理？</h1><p>ThreadPoolExecutor运行机制如下图所示：</p>
<p><img src="/pics/image-20210304172819822.png" alt="image-20210304172819822"></p>
<p>线程池在内部实际上构建了一个生产者消费者模型，将线程和任务两者解耦，并不直接关联，从而良好的缓冲任务，复用线程。线程池的运行主要分成两部分：任务管理、线程管理。</p>
<ul>
<li><p>任务管理部分充当生产者的角色，当任务提交后，线程池会判断该任务后续的流转：（1）直接申请线程执行该任务；（2）缓冲到队列中等待线程执行；（3）拒绝该任务。</p>
</li>
<li><p>线程管理部分是消费者，它们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收。</p>
</li>
</ul>
<p>我们会按照以下四个部分去详细讲解线程池运行机制：</p>
<ol>
<li>线程池的状态管理。</li>
<li>任务提交。</li>
<li>任务执行。</li>
<li>Worker和线程回收</li>
</ol>
<h2 id="3-1、线程池状态管理"><a href="#3-1、线程池状态管理" class="headerlink" title="3.1、线程池状态管理"></a>3.1、线程池状态管理</h2><p>线程池内部使用一个变量<strong>ctl</strong>维护运行状态(runState)和线程数量 (workerCount)，是一个32位二进制数，其中前3位表示线程池状态，后29位表示线程数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure>

<p>线程池状态：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>前3位值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>RUNNING</td>
<td>111</td>
<td>能接受新提交的任务，也能处理阻塞队列中的任务。</td>
</tr>
<tr>
<td>SHUTDOWN</td>
<td>000</td>
<td>关闭状态，不再接受新提交的任务，但可以继续执行已添加到阻塞队列中的任务。</td>
</tr>
<tr>
<td>STOP</td>
<td>001</td>
<td>不能接受新任务，也不能处理队列中的任务，会中断正在执行的任务的线程。</td>
</tr>
<tr>
<td>TIDYING</td>
<td>010</td>
<td>所有的任务都已经终止，workerCount（有效线程数）为0</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>011</td>
<td>在terminated()方法执行完后进入该状态</td>
</tr>
</tbody></table>
<p>状态转换如下图：</p>
<p><img src="/pics/image-20210304172419652.png" alt="image-20210304172419652"></p>
<p>线程池运行的状态，并不是用户显式设置的，而是伴随着线程池的运行，主要由内部来维护。</p>
<h2 id="3-2、任务提交"><a href="#3-2、任务提交" class="headerlink" title="3.2、任务提交"></a>3.2、任务提交</h2><h3 id="3-2-1、提交任务"><a href="#3-2-1、提交任务" class="headerlink" title="3.2.1、提交任务"></a>3.2.1、提交任务</h3><p>向线程池中提交一个任务后，线程池的处理流程如下：</p>
<p><img src="/pics/image-20210304164400691.png" alt="image-20210304164400691"></p>
<ol>
<li><p>如果线程池中的数量未达到核心线程的数量，则直接会启动一个核心线程来执行任务。</p>
</li>
<li><p>如果线程池中的数量已经达到或超过核心线程的数量，则任务会被插入到任务队列中等待执行。</p>
</li>
<li><p>如果任务队列已满，且线程数未达到最大线程数，则会启动一个非核心线程来执行任务。</p>
</li>
<li><p>如果线程数已达到最大值，按照饱和策略执行该任务。</p>
</li>
</ol>
<p>具体代码实现在execute方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">// 1、如果线程池中的数量未达到核心线程的数量，则直接会启动一个核心线程来执行任务</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2、如果线程池中的数量已经达到或超过核心线程的数量，则任务会被插入到任务队列中等待执行</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="comment">// 再次检查线程池的状态</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 2.1、线程池已经终止运行且任务可以从线程池中移除掉，执行拒绝策略</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 2.2、线程池中无线程，创建线程执行</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3、如果任务队列已满，且线程数未达到最大线程数，则会启动一个非核心线程来执行任务。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        <span class="comment">// 4、如果线程数已达到最大值，按照饱和策略执行该任务。</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>execute中定义了任务的执行规则，而线程的创建和任务执行都是在addWorker中，后面再讲。</p>
<h3 id="3-2-2、创建Worker"><a href="#3-2-2、创建Worker" class="headerlink" title="3.2.2、创建Worker"></a>3.2.2、创建Worker</h3><p>addWorker创建Worker并执行Worker的任务。Worker对象中封装了thread和firstTask，addWorker方法有两个参数：firstTask、core。</p>
<ul>
<li>firstTask：用于指定新增的线程执行的第一个任务，该参数可以为空；</li>
<li>core：用于判断新增线程时的阈值是corePoolSize还是maximumPoolSize；</li>
</ul>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">// 1、检查线程池是否不可创建任务</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            <span class="comment">// 下面的每个条件都要满足才return false</span></span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">// 2、检查线程数是否超过阈值</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 3、增加线程数是否成功</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">// 4、重新检查线程池状态，防止添加任务过程中，线程池状态被SHUTDOWN</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 5、创建Worker</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">                <span class="comment">// 6、检查线程状态，线程池在running或是正在退出时，若线程已经运行中则抛出异常。</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    <span class="comment">// 7、添加Worker到hashSet中</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                <span class="comment">// 8、启动工作线程</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其执行流程如下图所示：</p>
<p><img src="/pics/image-20210307210048523.png" alt="image-20210307210048523"></p>
<p>经过上面的分析，我们知道线程池将线程和任务封装到Worker中，下面看下Worker的实现。</p>
<h2 id="3-3、任务执行"><a href="#3-3、任务执行" class="headerlink" title="3.3、任务执行"></a>3.3、任务执行</h2><h3 id="3-3-1、Worker"><a href="#3-3-1、Worker" class="headerlink" title="3.3.1、Worker"></a>3.3.1、Worker</h3><p>Worker的创建2种情况：</p>
<ol>
<li><p>firstTask != null，创建线程并执行firstTask，firstTask执行完成后，从队列中获取任务执行。</p>
</li>
<li><p>firstTask == null，创建线程后从队列中取任务执行。</p>
</li>
</ol>
<p>Worker执行任务的模型如下图所示：</p>
<p><img src="/pics/image-20210307221006057.png" alt="image-20210307221006057"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Thread this worker is running in.  Null if factory fails. */</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">/** Initial task to run.  Possibly null. */</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">/** Per-thread task counter */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates with given first task and thread from ThreadFactory.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstTask the first task (null if none)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="comment">// worker 实现了Runnable接口，thread.start的时候执行run方法</span></span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Delegates main run loop to outer runWorker. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>worker 实现了Runnable接口，Worker.thread.start的时候执行run方法，再调用到runWorker。</p>
<h3 id="3-3-2、runWorker"><a href="#3-3-2、runWorker" class="headerlink" title="3.3.2、runWorker"></a>3.3.2、runWorker</h3><p>runWorker方法中，使用循环，通过getTask方法，不断从阻塞队列中获取任务执行，如果任务不为空则执行任务，这里实现了<strong>线程的复用，不断的获取任务执行，不用重新创建线程</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.若firstTask!=null，执行firstTask；firstTask!=null,从队列中取第一个任务执行</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="comment">// 2.线程池若处于STOP状态时，则中断当前线程。 </span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 3.任务执行</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 4.如果getTask结果为null则跳出循环，执行processWorkerExit()方法，移除worker。</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>43行：如果getTask结果为null则跳出循环，执行processWorkerExit()方法，移除任务。那getTask何时返回null？接着看getTask源码。</p>
<h3 id="3-3-3、getTask"><a href="#3-3-3、getTask" class="headerlink" title="3.3.3、getTask"></a>3.3.3、getTask</h3><p>getTask主要的职责是不断从workQueue中取任务出来，同时会判断当前线程池的状态和线程数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">// 1.（线程状态 == STOP或TIDYING或TERMINATED） || （线程状态为SHUTDOWN &amp;&amp; 任务队列为空）返回空，线程池关闭的原理</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="comment">// 2.是否要回收线程，若allowCoreThreadTimeOut = true，则一直为true</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">        <span class="comment">// 3.(线程数 &gt; max || 需要回收线程) &amp;&amp; (线程数 &gt; 1 || 队列为空)</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 4.获取队列中的任务，若time == true，若在keepAliveTime时间没有获取到任务，则执行到35行，再执行到24，</span></span><br><span class="line">            <span class="comment">// 使得getTask == null，Worker被回收。</span></span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>10行：线程池关闭的原理，当满足条件（线程状态 == STOP或TIDYING或TERMINATED） || （线程状态为SHUTDOWN &amp;&amp; 任务队列为空）是返回空任务。</p>
<p>19行 - 39行：allowCoreThreadTimeOut的原理，当timed=true时，若time == true，若在keepAliveTime时间没有获取到任务，timedOut = true，则执行到下一次循环时，使得getTask 返回null，Worker会被回收。</p>
<p>getTask的流程图如下：</p>
<p><img src="/pics/image-20210307225155723.png" alt="image-20210307225155723"></p>
<h2 id="3-4、线程回收"><a href="#3-4、线程回收" class="headerlink" title="3.4、线程回收"></a>3.4、线程回收</h2><p>Worker是通过继承AQS，使用AQS来实现独占锁这个功能。没有使用可重入锁ReentrantLock，而是使用AQS，为的就是实现不可重入的特性去反应线程现在的执行状态。</p>
<ol>
<li>lock方法一旦获取了独占锁，表示当前线程正在执行任务中；</li>
<li>如果正在执行任务，则不应该中断线程，<strong>shutdownNow除外</strong>。</li>
<li> 如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断；</li>
<li> 线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判 断线程池中的线程是否是空闲状态；如果线程是空闲状态则可以安全回收。</li>
</ol>
<p>在线程回收过程中就使用到了这种特性，回收过程如下图所示：</p>
<p><img src="/pics/image-20210308115543008.png" alt="image-20210308115543008"></p>
<p>线程的回收有2种：第一种是执行任务过程中，当getTask==null时尝试回收；第二种就是关闭线程池。下面具体来看下。</p>
<h3 id="3-4-1、processWorkerExit"><a href="#3-4-1、processWorkerExit" class="headerlink" title="3.4.1、processWorkerExit"></a>3.4.1、processWorkerExit</h3><p>当getTask==null时，回收空闲线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        <span class="comment">// 1.移除worker</span></span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">	  <span class="comment">// 2.尝试回收空闲线程，停止线程池，正常运行的线程池调用该方法不会有任何动作</span></span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>15行，tryTerminate：尝试回收空闲线程，停止线程池，正常运行的线程池调用该方法不会有任何动作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">            runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate</span></span><br><span class="line">            <span class="comment">// 中断空闲线程，尝试回收</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.尝试结束线程池</span></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1.线程池状态改为TIDYING</span></span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 2.调用terminated方法</span></span><br><span class="line">                    terminated();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else retry on failed CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-2、shutdown"><a href="#3-4-2、shutdown" class="headerlink" title="3.4.2、shutdown"></a>3.4.2、shutdown</h3><p>线程池退出有2个入口，shutdown 和shutdownNow。这2者的区别：</p>
<ol>
<li><p>shutdown的设置状态是SHUTDOWN，<strong>仅中断空闲线程，不会影响正在执行的任务</strong>；</p>
</li>
<li><p>shutdownNow的状态设置为STOP，<strong>会中断所有线程</strong>。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.对线程检查一下，是否有权限中断线程</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 2.改变线程池状态为SHUTDOWN</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        <span class="comment">// 3.中断空闲线程</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// 4.设置TIDYING状态，调用terminated方法</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 1.改变线程池状态为STOP</span></span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        <span class="comment">// 2.中断所有线程</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续分析shutdown。</p>
<p>8行：advanceRunState，改变线程池状态为SHUTDOWN。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">advanceRunState</span><span class="params">(<span class="keyword">int</span> targetState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert targetState == SHUTDOWN || targetState == STOP;</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (runStateAtLeast(c, targetState) ||</span><br><span class="line">            ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>10行：shutdown.interruptIdleWorkers，<strong>中断空闲线程，会使用tryLock方法来判断线程池中的线程是否是空闲状态；如果线程是空闲状态则可以安全回收。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	interruptIdleWorkers(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            Thread t = w.thread;</span><br><span class="line">            <span class="comment">// 1.尝试获取worker的锁，判断是否空闲</span></span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 2.线程状态设置为中断</span></span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>29行：shutdownNow.interruptWorkers，中断所有线程，<strong>包括正在运行的线程</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">            w.interruptIfStarted();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t;</span><br><span class="line">    <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t.interrupt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面看出，<strong>shutdown方法改变状态为SHUTDOWN,并在尝试给每个线程设置中断标志，接着结合runWorker以及getTask()，当getTask()返回null来移除线程，最后尝试终止线程池。</strong></p>
<h1 id="四、Executors创建线程池"><a href="#四、Executors创建线程池" class="headerlink" title="四、Executors创建线程池"></a>四、Executors创建线程池</h1><p>除了自定义线程池外，JDK的Executors类中还定义了几种线程池如下：</p>
<table>
<thead>
<tr>
<th>线程</th>
<th>描述</th>
<th>阻塞队列</th>
</tr>
</thead>
<tbody><tr>
<td>newFixedThreadPool</td>
<td>只有核心线程，核心线程数 == 最大线程数，</td>
<td>LinkedBlockingQueue</td>
</tr>
<tr>
<td>newCachedThreadPool</td>
<td>只有非核心线程，最大线程数为Integer.MAX_VALUE</td>
<td>SynchronousQueue</td>
</tr>
<tr>
<td>newSingleThreadExecutor</td>
<td>线程池内部只有一个核心线程，所有的任务都在一个线程中执行，用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行</td>
<td>LinkedBlockingQueue</td>
</tr>
<tr>
<td>newScheduledThreadPool</td>
<td>最大线程数为Integer.MAX_VALUE，执行定时任务和固定周期的任务</td>
<td>DelayedWorkQueue</td>
</tr>
<tr>
<td>newScheduledThreadPool</td>
<td>和上面区别是该线程池大小为1。</td>
<td>DelayedWorkQueue</td>
</tr>
</tbody></table>
<p>一般情况下不推荐使用Executors创建，建议通过ThreadPoolExecutor的方式创建，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。Executors返回的线程池对象的弊端如下：</p>
<ol>
<li><p>FixedThreadPool和SingleThreadPool：允许的请求队列长度为Integet.MAX_VALUE,可能会堆积大量的请求从而导致OOM;</p>
</li>
<li><p>CachedThreadPool：允许创建线程数量为Integet.MAX_VALUE,可能会创建大量的线程，从而导致OOM。</p>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html</a></p>
<p><a href="https://www.cnblogs.com/franson-2016/p/13291591.html">https://www.cnblogs.com/franson-2016/p/13291591.html</a></p>
<p><a href="https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html">https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
        <category>JUC</category>
      </categories>
  </entry>
  <entry>
    <title>Java集合_01_Collection体系</title>
    <url>/2021/04/21/Notes/Java/03Collections/Java%E9%9B%86%E5%90%88_01_Collection%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<h1 id="Java集合-01-Collection体系"><a href="#Java集合-01-Collection体系" class="headerlink" title="Java集合_01_Collection体系"></a>Java集合_01_Collection体系</h1><span id="more"></span>

<p><img src="/pics/image-20210420233635797.png" alt="image-20210420233635797"></p>
<p><a href="https://pierrchen.blogspot.com/2014/03/java-collections-framework-cheat-sheet.html">java集合体系</a></p>
<p>在语言架构上，集合类分为了 Map 和 Collection 两个大的类别。List、Set、Queue 都继承于 Collection。</p>
<ul>
<li><p>左上角的那一块灰色里面的四个类（Dictionary、HashTable、Vector、Stack）都是 JDK 遗留下的类，太老了，已经没人使用，而且都有了对应的取代类</p>
</li>
<li><p>图片分上下两部分，最上边粉红色部分是集合类所有接口关系图，绿色部分是他们的主要实现类，也就是我们真正使用的常用集合类</p>
</li>
<li><p>下半部分中都是<code>java.util.concurrent</code> 包下内容，也就是我们常用的并发集合包。同样粉色部分是接口，绿色是其实现类。</p>
</li>
<li><p><strong>同步容器可以简单地理解为通过synchronized来实现同步的容器</strong>，比如 Vector、Hashtable 以及SynchronizedList、SynchronizedMap 等容器。</p>
</li>
</ul>
<p>对象的容器，实现了对对象常用的操作</p>
<p><strong>集合和数组的区别</strong></p>
<ol>
<li>数组长度固定，集合长度不固定</li>
<li>数组可以存储基本类型和引用类型，集合只能存储引用类型</li>
</ol>
<h3 id="Java集合系列之一：集合概述"><a href="#Java集合系列之一：集合概述" class="headerlink" title="Java集合系列之一：集合概述"></a><a href="https://segmentfault.com/a/1190000021661589">Java集合系列之一：集合概述</a></h3><h3 id="HashSet底层原理"><a href="#HashSet底层原理" class="headerlink" title="HashSet底层原理"></a><a href="https://segmentfault.com/a/1190000021434077">HashSet底层原理</a></h3><h3 id="Java集合系列之七：TreeMap底层原理"><a href="#Java集合系列之七：TreeMap底层原理" class="headerlink" title="[Java集合系列之七：TreeMap底层原理]("></a>[Java集合系列之七：TreeMap底层原理](</h3>]]></content>
      <categories>
        <category>JAVA</category>
        <category>Collection</category>
      </categories>
  </entry>
  <entry>
    <title>Java集合_02_ArrayList</title>
    <url>/2021/04/20/Notes/Java/03Collections/Java%E9%9B%86%E5%90%88_02_ArrayList/</url>
    <content><![CDATA[<h1 id="Java集合-02-ArrayList"><a href="#Java集合-02-ArrayList" class="headerlink" title="Java集合_02_ArrayList"></a>Java集合_02_ArrayList</h1><span id="more"></span>

<p>ArrayList使用的是数据结构是数组，默认的初始容量是10，触发扩容时每次扩容为原来的1.5倍。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>ArrayList使用的是数据结构是数组，默认的初始容量是10，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 默认大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 2. 空数组，初始化容量大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 3. 默认数组，空构造函数使用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 4. 元素数组</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line">    <span class="comment">// 5. size大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 1. 初始化大小</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 默认构造使用的是空数组</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><p>添加元素的主要步骤有2个：</p>
<ol>
<li>保证容量能够满足</li>
<li>添加元素到数组中</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.保证容量能够满足</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// 2.添加元素</span></span><br><span class="line">    elementData[size++] = e; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; </span><br><span class="line">        <span class="comment">// 若是空构造函数初始化的，添加元素时，容量大小默认是10</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加的元素超过当前数组大小时，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="grow"><a href="#grow" class="headerlink" title="grow"></a>grow</h3><p>扩容规则：</p>
<ol>
<li>容量扩容为原来的1.5倍</li>
<li>将元素copy到新数组</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.minCapacity 需要的空间大小</span></span><br><span class="line">    <span class="comment">// 2.oldCapacity 当前数组大小</span></span><br><span class="line">    <span class="comment">// 3.newCapacity 扩容为原来的1.5倍</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>); <span class="comment">// 扩容规则扩容为原来的1.5倍</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.扩容后newCapacity 小于 minCapacity 有一种情况：</span></span><br><span class="line">    <span class="comment">// 初始数组大小为0时，第一次put元素时</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.如果扩容后大于 MAX_ARRAY_SIZE，取一个适当的最大值</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.将元素copy到新数组</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.minCapacity &lt; 0，表示超过int的最大值，溢出了</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="comment">// 2.minCapacity 超过MAX_ARRAY_SIZE的最大值，取Integer.MAX_VALUE，否则取 MAX_ARRAY_SIZE</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h2><p>集合的使用过程中，遍历是最常做的操作之一。</p>
<p> 使用迭代器遍历元素时（包括增强for循环，内部使用的是迭代器），若要删除元素必须使用 iterator remove，不能使用集合去删除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testNormal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    arrayList.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    arrayList.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    arrayList.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrayList.size(); i++) &#123;</span><br><span class="line">        arrayList.remove(<span class="string">&quot;b&quot;</span>); <span class="comment">//</span></span><br><span class="line">        System.out.println(arrayList.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：a c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testForEach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    arrayList.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    arrayList.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    arrayList.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String s : arrayList) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        arrayList.remove(<span class="string">&quot;b&quot;</span>); <span class="comment">// 异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出： </span></span><br><span class="line"><span class="comment">//  Exception in thread &quot;main&quot; java.util.ConcurrentModificationException</span></span><br><span class="line"><span class="comment">//	at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:909)</span></span><br><span class="line"><span class="comment">//	at java.util.ArrayList$Itr.next(ArrayList.java:859)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    arrayList.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    arrayList.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    arrayList.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    Iterator&lt;String&gt; iterator = arrayList.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">        String str = iterator.next();</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;b&quot;</span>.equals(str)) &#123;</span><br><span class="line">             <span class="comment">// iterator.remove();  // 正常</span></span><br><span class="line">            arrayList.remove(<span class="string">&quot;b&quot;</span>);  <span class="comment">// 异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  输出：</span></span><br><span class="line"><span class="comment">//  Exception in thread &quot;main&quot; java.util.ConcurrentModificationException</span></span><br><span class="line"><span class="comment">//	at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:909)</span></span><br><span class="line"><span class="comment">//	at java.util.ArrayList$Itr.next(ArrayList.java:859)</span></span><br></pre></td></tr></table></figure>

<p>解释下原因：</p>
<p><code>ArrayList</code> 中有个 modCount，用来记录数组被修改的次数（增/删时 ++）；</p>
<p>当我们构造Iterator 时，<code>Itr</code> 会使用<code>ArrayList#modCount</code>对<code>Itr#expectedModCount</code> 参数进行初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录数组被修改的次数，其实是在AbstractList </span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">        <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">        <span class="comment">// ！！！ 关键 ！！！，初始化时会将当时的modCount赋值给 expectedModCount</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ArrayList-remove"><a href="#ArrayList-remove" class="headerlink" title="ArrayList.remove"></a>ArrayList.remove</h3><p> 每次使用remove，modCount 都会自增1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ArrayList.remove </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. !!! 重点 modCount ++</span></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>) </span><br><span class="line">        <span class="comment">// 2.删除完之后，将index之后元素要往前移动一位</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h3 id="Itr-next"><a href="#Itr-next" class="headerlink" title="Itr.next"></a>Itr.next</h3><p>使用迭代器遍历过程中使用的next方法取下一个元素，每调用 next 都会check modCount 和 expectedModCount 的值；当我们在迭代过程中调用了<code>ArrayList.remove</code>方法时就会导致，这2个值不同，进而抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果使用 ArrayList.remove 会导致modCount != expectedModCount，进而会抛出异常</span></span><br><span class="line">        checkForComodification(); </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) <span class="comment">// 抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Iterator-remove"><a href="#Iterator-remove" class="headerlink" title="Iterator.remove"></a>Iterator.remove</h3><p>而使用迭代器的remove不会抛出异常为何呢？迭代器remove时中有2步：</p>
<ol>
<li>先调用 ArrayList .remove移除当前元素</li>
<li><strong>将最新的 modCount 赋值给 expectedModCount</strong>，关键就是这一步，会更新expectedModCount的值，保持和modCount 一致。 </li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Iterator.remove </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    checkForComodification();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.先调用 ArrayList 移除当前元素</span></span><br><span class="line">        ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">        cursor = lastRet;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 2.更新下expectedModCount</span></span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JAVA</category>
        <category>Collection</category>
      </categories>
  </entry>
  <entry>
    <title>Java集合_03_LinkedList</title>
    <url>/2022/12/25/Notes/Java/03Collections/Java%E9%9B%86%E5%90%88_03_LinkedList/</url>
    <content><![CDATA[<h1 id="Java集合-03-LinkedList"><a href="#Java集合-03-LinkedList" class="headerlink" title="Java集合_03_LinkedList"></a>Java集合_03_LinkedList</h1><span id="more"></span>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>使用的数据结构是双向链表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pointer to first node.</span></span><br><span class="line"><span class="comment">     * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">     *            (first.prev == null &amp;&amp; first.item != null)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pointer to last node.</span></span><br><span class="line"><span class="comment">     * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">     *            (last.next == null &amp;&amp; last.item != null)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点</span></span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = element;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">            <span class="keyword">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><p>尾插法插入到链表中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 新插入的元素是尾节点</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>) <span class="comment">// 首个节点</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode; <span class="comment">// 关联双向链表</span></span><br><span class="line">    </span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><p>remove 支持移除null元素，核心方法是unlink</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h3><p>unlink 中的核心原理其实就是双向链表出队的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123; <span class="comment">// 若当前节点前驱为空，说明是头节点</span></span><br><span class="line">        first = next; <span class="comment">// 将first指向它的下一个节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next; <span class="comment">// 不是头节点时，前驱不为空时，将后继赋值给前驱的后继</span></span><br><span class="line">        x.prev = <span class="keyword">null</span>; <span class="comment">// 置空它的前驱</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;<span class="comment">//若当前节点后继为空，说明它是尾结点</span></span><br><span class="line">        last = prev; <span class="comment">// 更新尾节点为他的前驱</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;<span class="comment">// 不是尾结点时，后继不为空时，将前驱赋值给后继的前驱</span></span><br><span class="line">        x.next = <span class="keyword">null</span>; <span class="comment">// 置空后继</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="keyword">null</span>; <span class="comment">// 元素置空</span></span><br><span class="line">    size--; </span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JAVA</category>
        <category>Collection</category>
      </categories>
  </entry>
  <entry>
    <title>Java集合_05_LinkedHashMap</title>
    <url>/2022/12/25/Notes/Java/03Collections/Java%E9%9B%86%E5%90%88_05_LinkedHashMap/</url>
    <content><![CDATA[<h1 id="Java集合-05-LinkedHashMap"><a href="#Java集合-05-LinkedHashMap" class="headerlink" title="Java集合_05_LinkedHashMap"></a>Java集合_05_LinkedHashMap</h1><span id="more"></span>

<p>LinkedHashMap的是继承自HashMap，数据结构和HashMap基本一致，区别是：</p>
<p><code>LinkedHashMap的节点Entry中增加了前驱和后继指针，将各个桶位中的元素按照添加的顺序管理起来，形成一个双向链表。</code>最终的结构类似下图。也就是说LinkedHashMap中维护了2个数据结构，桶数组和双向链表。</p>
<p><img src="/pics/image-20210421113017742.png" alt="image-20210421113017742"></p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 前驱 + 后继</span></span><br><span class="line">        Entry&lt;K,V&gt; before, after;</span><br><span class="line">        Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 头节点</span></span><br><span class="line">    <span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line">    <span class="comment">// 尾结点</span></span><br><span class="line">    <span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line">    <span class="comment">// false： 基于插入顺序  true：  基于访问顺序 </span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br><span class="line">&#125;       </span><br></pre></td></tr></table></figure>

<h2 id="相比hashMap新增函数"><a href="#相比hashMap新增函数" class="headerlink" title="相比hashMap新增函数"></a>相比hashMap新增函数</h2><p>在HashMap中提到了下面的定义,这3个函数在HashMap中并没有实现，LinkedHashMap中实现了这3个函数，顾名思义这三个函数的作用分别是：get、put、remove后做一些事情。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 访问后</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入后</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove 时</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="put-gt-afterNodeInsertion"><a href="#put-gt-afterNodeInsertion" class="headerlink" title="put-&gt;afterNodeInsertion"></a>put-&gt;afterNodeInsertion</h3><p>LinkedHashMap并没有重写任何put方法。但是其重写了构建新节点的newNode()方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>采用尾插法，建立节点间的关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时put之后如果需要移除最老的节点，LinkedHashMap重写了<code>afterNodeInsertion</code>方法，但是可以看到<code>removeEldestEntry</code>这个方法直接返回的false，因此如果要生效需要重写<code>removeEldestEntry</code>该方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123; <span class="comment">// 头元素出队</span></span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="get-gt-afterNodeAccess"><a href="#get-gt-afterNodeAccess" class="headerlink" title="get -&gt; afterNodeAccess"></a>get -&gt; afterNodeAccess</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder) <span class="comment">// accessOrder == true 时，需要将当前元素移动到链表尾部</span></span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果定义了accessOrder，那么就保证最近访问节点放到最后，主要操作有2步：</p>
<ol>
<li>将节点从链表中移除掉</li>
<li>将节点加入到队列尾部</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用来判断之前的列表是不是空列表</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123; <span class="comment">//</span></span><br><span class="line">        <span class="comment">// p 是当前节点</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, </span><br><span class="line">        <span class="comment">// b 是p的前驱</span></span><br><span class="line">        b = p.before, </span><br><span class="line">        <span class="comment">// a 是p的后继</span></span><br><span class="line">        a = p.after;</span><br><span class="line">        <span class="comment">// 要将p作为尾结点，所以p.after一定是null</span></span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ==========将节点从链表中移除 ==========</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)   <span class="comment">// p 是头节点</span></span><br><span class="line">            head = a;  <span class="comment">// head 指向 next</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a; <span class="comment">// b的后继指向 a，跳过了p节点 </span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>) <span class="comment">// a 不等于空，说明</span></span><br><span class="line">            a.before = b; <span class="comment">// a的前驱后继指向 b， 跳过p节点</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b; <span class="comment">// a == null，说明p是尾结点 ，last记录下</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ==========将节点加入到链表中 ==============</span></span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>) <span class="comment">// 空链表，head 指向p</span></span><br><span class="line">            head = p;<span class="comment">// </span></span><br><span class="line">        <span class="keyword">else</span> &#123;               </span><br><span class="line">            p.before = last; <span class="comment">// 非空链表插入到节点中</span></span><br><span class="line">            last.after = p; <span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">        tail = p; <span class="comment">// p 是尾结点</span></span><br><span class="line">        </span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：如果设置了accessOrder = true，那么在遍历的过程中，不可以去get元素，否则会报出异常，原因是设置了accessOrder = true，我们在get操作时，modCount发生了变化，导致 modCount != expectedModCount。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testLinkedHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LinkedHashMap&lt;String, String&gt; linkedHashMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(<span class="number">10</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    linkedHashMap.put(<span class="string">&quot;a&quot;</span>, <span class="string">&quot; 1&quot;</span>);</span><br><span class="line">    linkedHashMap.put(<span class="string">&quot;b&quot;</span>, <span class="string">&quot; 2&quot;</span>);</span><br><span class="line">    linkedHashMap.put(<span class="string">&quot;c&quot;</span>, <span class="string">&quot; 3&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : linkedHashMap.entrySet()) &#123;</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">&quot;:&quot;</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (String key : linkedHashMap.keySet()) &#123;</span><br><span class="line">        System.out.println(linkedHashMap.get(key)); <span class="comment">// 异常，Exception in thread &quot;main&quot; java.util.ConcurrentModificationException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://stackoverflow.com/questions/16180568/concurrentmodificationexception-with-linkedhashmap/16180833">https://stackoverflow.com/questions/16180568/concurrentmodificationexception-with-linkedhashmap/16180833</a></p>
<h3 id="remove-gt-afterNodeRemoval"><a href="#remove-gt-afterNodeRemoval" class="headerlink" title="remove -&gt; afterNodeRemoval"></a>remove -&gt; afterNodeRemoval</h3><p>remove 先是从HashMap的桶数组中remove掉这个值，然后再将这个节点从双向链表中删除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 省略</span></span><br><span class="line"> 	afterNodeRemoval(node);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// unlink</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e,</span><br><span class="line">    <span class="comment">// b 是p的前驱</span></span><br><span class="line">    b = p.before, </span><br><span class="line">    <span class="comment">// a 是p的后继</span></span><br><span class="line">    a = p.after;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 前驱和后继置空</span></span><br><span class="line">    p.before = p.after = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 前驱为空</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">        head = a; <span class="comment">// 头节点 指向a</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.after = a; <span class="comment">// b的后继指向a ，跳过p</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后继为空，说明是尾结点</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        tail = b; <span class="comment">// 尾结点指向b</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = b; <span class="comment">// a的前驱指向b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="LRUCache"><a href="#LRUCache" class="headerlink" title="LRUCache"></a>LRUCache</h3><p>LinkedHashMap的一个重要应用是在LruCache中，设置缓存固定大小，并且按照访问顺序排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LruCache</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;maxSize &lt;= 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">    <span class="keyword">this</span>.map = <span class="keyword">new</span> LinkedHashMap&lt;K, V&gt;(<span class="number">0</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JAVA</category>
        <category>Collection</category>
      </categories>
  </entry>
  <entry>
    <title>Java集合_04_HashMap</title>
    <url>/2022/12/25/Notes/Java/03Collections/Java%E9%9B%86%E5%90%88_04_HashMap/</url>
    <content><![CDATA[<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><span id="more"></span>

<p>HashMap是Java程序员使用频率最高的用于映射(键值对)处理的数据类型。现在我们就来学习一下HashMap数据结构和功能原理，基于JDK8。</p>
<h2 id="一、数据结构"><a href="#一、数据结构" class="headerlink" title="一、数据结构"></a>一、数据结构</h2><p>HashMap使用的数据结构是<strong>数组 （这个数组通常被称为称为哈希桶或table）+ 链表</strong>，链表长度大于8时，链表升级为红黑树（JDK8新增）。</p>
<img src="/pics/image-20210310212941190.png" alt="image-20210310212941190" style="zoom:50%;" />

<p>元素存储使用的数据结构是Node，Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;	</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 默认的数组大小</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line">  <span class="comment">// 数组最大容量</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">  <span class="comment">// 负载因子</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">  <span class="comment">// 树化阈值，链表长度</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line">  <span class="comment">// 树降级为链表阈值</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line">  <span class="comment">// 树化的另一个约束阈值，数组长度超过64，2个参数要同时满足，</span></span><br><span class="line">  <span class="comment">// 这个MIN_TREEIFY_CAPACITY的值至少是TREEIFY_THRESHOLD的4倍。</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// hash表</span></span><br><span class="line">  <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line">  <span class="comment">// hash表中Node个数</span></span><br><span class="line">  <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line">  <span class="comment">// 结构修改次数（插入或删除元素时+1，替换不变）</span></span><br><span class="line">  <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line">  <span class="comment">// 扩容阈值    </span></span><br><span class="line">  <span class="keyword">int</span> threshold;</span><br><span class="line">  <span class="comment">// 用于计算扩容阈值，threshold = capacity * loadFactor</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashMap 基本工作原理:</p>
<ol>
<li>插入数据时，计算key的hash，再经过位与运算计算出索引，插入到数组中；</li>
<li>当新插入的key的index和已有的冲突时，将新节点插入到已有节点的后面，构成链表；</li>
<li>当某个链表长度大于8且数组长度大于64时，将链表转化为红黑树。</li>
</ol>
<h3 id="1-2、单链表节点"><a href="#1-2、单链表节点" class="headerlink" title="1.2、单链表节点"></a>1.2、单链表节点</h3><p>Node 的数据结构如下，比较简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;<span class="comment">//key 的hash值</span></span><br><span class="line">    <span class="keyword">final</span> K key;<span class="comment">//键</span></span><br><span class="line">    V value;<span class="comment">//值</span></span><br><span class="line">    Node&lt;K,V&gt; next;<span class="comment">//链表的下一个节点</span></span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3、二叉树节点"><a href="#1-3、二叉树节点" class="headerlink" title="1.3、二叉树节点"></a>1.3、二叉树节点</h3><p>TreeNode 既是二叉树的数据结构又是双向链表，TreeNode继承自 LinkedHashMap.Entry&lt;K,V&gt;，  LinkedHashMap.Entry又继承自Node，所以TreeNode 中包含了Node的所用属性，key、value 、hash、next 。ThreeNode具有双向链表的特性主要是为了树化和二叉树转换方便，后面在介绍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 双向链表</span></span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、Hash规则"><a href="#二、Hash规则" class="headerlink" title="二、Hash规则"></a>二、Hash规则</h2><p>HashMap的增删改查，定位到哈希桶数组的位置都是很关键的第一步。如果 HashMap 里面的元素位置分布均匀，每个位置上的元素数量只有一个或少个，就能大大优化查找key的效率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法1</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// 1.h = key.hashCode()，取hashCode</span></span><br><span class="line">    <span class="comment">// 2.h ^ (h &gt;&gt;&gt; 16)，异或运算，高位参与</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123; <span class="comment">//jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></span><br><span class="line">		<span class="keyword">return</span> h &amp; (length-<span class="number">1</span>); <span class="comment">// 3.位与运算，h是上一步计算完的结果，使索引落到[0,length - 1]之间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过一张图来分析下。</p>
<img src="/pics/image-20210310230422639.png" alt="image-20210310230422639" style="zoom:50%;" />

<p>Java中，Object类是所有类的父类，所有的对象，包括数组，都实现了在<code>Object</code>类中定义的方法。Object类hashCode方法返回值是int类型，int为4个字节，1个字节是8位，4个字节就是32位。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>)</span><br></pre></td></tr></table></figure>

<p>右位移 16 位，正好是 32位的一半，高半区和低半区做异或，就是为了混合原始hashCode的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。</p>
<p><strong>总结下：key的hash值是key的hashCode经过位移和异或得到的新值，hash算法增加了更多的因子，能够更好的均匀散列，减少碰撞，进一步降低hash冲突的几率</strong>。</p>
<h2 id="三、put"><a href="#三、put" class="headerlink" title="三、put"></a>三、put</h2><p>HashMap中核心方法是增加元素的put和扩容resize，我们先来看下put。</p>
<h3 id="3-1、put的过程"><a href="#3-1、put的过程" class="headerlink" title="3.1、put的过程"></a>3.1、put的过程</h3><img src="/pics/image-20210310232925256.png" alt="image-20210310232925256" style="zoom:50%;" />

<ol>
<li>hashMap使用的是懒加载，只有在执行put操作时才会创建数组。若table=null或size=0则创建table（通过扩容逻辑）。</li>
<li>对key的hashCode()高低16位异或，位与(table.length - 1)计算出要插入到table的index（第二节介绍过了）;</li>
<li>如果index没碰撞直接插到table里；</li>
<li>如果碰撞了，有三种情况：<ul>
<li>若头元素的key和插入key相同则替换；</li>
<li>若头元素是个TreeNode，则将Node插入到红黑树中，先遍历，再插入，再平衡；若相同则替换。</li>
<li>以上2种情况都不满足，说明是个链表且头元素的key和插入的不相同，遍历链表，若链表中存在相同key的Node，替换该节点值；否则，插入到链表尾，并且判断链表是否需要转换成红黑树（树化下一小节讲）。</li>
</ul>
</li>
<li>容量 ++ ，若容量达到扩容阈值，进行扩容。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 1.table未初始化时或者初始化大小=0，reSize操作</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">   <span class="comment">// 2.table的hash不存在时，头元素不存在，创建新Node</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 3.头元素相同,进行替换</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 4.相同hash的节点不存在，且当前桶位是链表情况</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//5.相同hash的table是链表结构</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//5.1 遍历到最后也没有相同节点则插入</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 插入节点到链表中</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 循环从0开始，满足这个条件时，已经循环了TREEIFY_THRESHOLD次</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                         <span class="comment">// 链表长度大于TREEIFY_THRESHOLD时，进行树化</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 5.3 找到相同值</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">// 赋值替换</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改的次数，替换不算</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 插入元素个数+1 &gt; threshold 进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2、树化"><a href="#3-2、树化" class="headerlink" title="3.2、树化"></a>3.2、树化</h3><p>树化的条件有2个，<strong>当前链表的长度&gt;8且table的长度&gt;64</strong>，<strong>如果table长度小于64，则进行一次扩容</strong>。树化步骤如下：</p>
<ol>
<li>将单链表先转化为一个双向链表，数据结构变为TreeNode</li>
<li>将双向链表转换为红黑树</li>
</ol>
<p><strong>也就是说树化后的哈希桶既是一个红黑树，也是一个双向链表</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) <span class="comment">//1. table== null 或长度小于64，进行或扩容</span></span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>,<span class="comment">//hd 是头节点</span></span><br><span class="line">        tl = <span class="keyword">null</span>;<span class="comment">// tl指向上一个节点</span></span><br><span class="line">        <span class="keyword">do</span> &#123;<span class="comment">// 2.do while 将单链表先转化为一个双向链表</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>); <span class="comment">// p 是当前TreeNode节点,将Node转化为TreeNode</span></span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>); </span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab); <span class="comment">// 3.真正的树化是TreeNode的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真正的树化 TreeNode.treeify，主要步骤有：</p>
<ol>
<li>遍历链表，若红黑树的root节点还未创建，将链表第一个节点作为root</li>
<li>遍历剩余节点，根据这些节点的hash值和key计算出dir，若dir&lt;=0 遍历红黑树的左子树，否则遍历红黑树的右子树，插入到叶子节点的位置</li>
<li>插入节点后，平衡红黑树，注意是在for循环中，每插入一次都会平衡一下</li>
<li>调整双向链表顺序，将红黑树的root节点作为当前hash桶的头节点，将当前头节点的元素作为root的下一个节点。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123; <span class="comment">// for循环，遍历双向链表</span></span><br><span class="line">        <span class="comment">// x 表示当前要插入的节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// next是x的下一个节点</span></span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">        x.left = x.right = <span class="keyword">null</span>;<span class="comment">// 将x的左右子树节点置空</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="comment">// 将第一个节点作为头节点</span></span><br><span class="line">            x.parent = <span class="keyword">null</span>;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            root = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//遍历其他节点</span></span><br><span class="line">            K k = x.key; <span class="comment">// x节点的key</span></span><br><span class="line">            <span class="keyword">int</span> h = x.hash; <span class="comment">// x节点的hash</span></span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123; <span class="comment">// 遍历这颗红黑树，p指向当前节点</span></span><br><span class="line">                <span class="keyword">int</span> dir <span class="comment">// dir &lt; 0,插入左子树;&gt; 0 插入右子树</span></span><br><span class="line">                    , ph; <span class="comment">// p节点的hash</span></span><br><span class="line">                K pk = p.key; <span class="comment">// p节点的key</span></span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h) <span class="comment">// 比较节点的hash，同一个hash桶位的节点index相同，hash值不一定相同，index取tablelength长度的低位。</span></span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp; <span class="comment">// hash值相同的情况，key也相等</span></span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    dir = tieBreakOrder(k, pk);<span class="comment">// 比较keyclass 和 key 的identityHashCode，不用太细究</span></span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p; <span class="comment">// 下面的遍历过程中 xp指的是p的父节点</span></span><br><span class="line">                <span class="comment">// 拆分成2个逻辑看:</span></span><br><span class="line">           		<span class="comment">// p = dir &lt; 0 ? p.left ：p.right,第一步根据dir遍历节点左子树或右子树</span></span><br><span class="line">                <span class="comment">// p == null //只到找到叶子节点 </span></span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123; </span><br><span class="line">                    x.parent = xp; <span class="comment">// 将x节点插入到xp后</span></span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x; <span class="comment">// &lt; 0是左节点 </span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x; <span class="comment">// &gt;0 是右节点</span></span><br><span class="line">                    root = balanceInsertion(root, x);<span class="comment">// ！！！插入后,再平衡！！！</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    moveRootToFront(tab, root); <span class="comment">//将 root节点放到table[i],作为当前hash桶的第一个元素，同时调整双向链表。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、resize"><a href="#四、resize" class="headerlink" title="四、resize"></a>四、resize</h2><p>resize主要是put元素过程中，处理扩容，触发扩容的条件是size(节点数) &gt; threshold。 </p>
<p>扩容原理主要步骤有2步：</p>
<ol>
<li>容量和扩容阈值调整</li>
<li>数据迁移</li>
</ol>
<p>先来看下容量和扩容阈值调整</p>
<h3 id="4-1、容量和扩容阈值调整"><a href="#4-1、容量和扩容阈值调整" class="headerlink" title="4.1、容量和扩容阈值调整"></a>4.1、容量和扩容阈值调整</h3><p><img src="/pics/image-20210311112923942.png" alt="image-20210311112923942"></p>
<p>步骤如下：</p>
<ol>
<li><p>oldCap &gt; 0 说明table已经初始化过，扩容时有2种情况</p>
<ul>
<li>oldCap &gt;= MAXIMUM_CAPACITY，table数组容量达到最大，不可再扩容</li>
<li>oldCap &lt; MAXIMUM_CAPACITY，新容量newCap扩大oldCap的2倍。接着再判断（newCap &lt; MAXIMUM_CAPACITY） &amp;&amp; oldCap&gt;= 16，则将扩容阈值调整为原来的2倍。一般情况下newCap &lt; MAXIMUM_CAPACITY都是成立的，主要看第二个条件，oldCap是否大于16。也就是说除非我们的oldCap容量 &lt;16, 正常扩容时容量和扩容阈值都会翻倍。&lt;16时，最终threshold = cap * factor（0.75）。</li>
</ul>
</li>
<li><p>oldCap == 0，说明table还未初始化或者未添加元素情况，也有2种：</p>
<ul>
<li><p>oldThr &gt; 0 说明使用的是非无参的构造方法（有3个入口）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上3个构造方法，都会使得threshold被tableSizeFor赋值，结果为大于且最接近cap的2的n次方；最终这个值又会被赋值到 newCap = oldThr；<strong>也就是说table的容量永远都是2的n次方。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>oldThr == 0，说明使用的hashMap的无参构造方法，也就是我们最常用的构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>​                   仅初始化负载因子为0.75；如果是这种情况，那么newCap = 16，newThr = 12。</p>
<ol start="3">
<li><p>经过以上2步，新table的容量newCap的值就被确定了，接下来就是调整扩容阈值。满足newThr == 0，有2种情况：</p>
<ul>
<li><p>扩容的oldCap &lt;16；</p>
</li>
<li><p>使用<strong>非无参构造函数初始化</strong>的hashMap。这2种情况是有联系的，只有使用非无参构造函数初始化的cap才可能小于16，当它再次扩容时出现第一种情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">    newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">              (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line">threshold = newThr;</span><br></pre></td></tr></table></figure>

<p>跟进loadFactor和newCap计算扩容阈值，如果newCap &lt; MAXIMUM_CAPACITY 且ft &lt; (float)MAXIMUM_CAPACITY,那么说明扩容阈值有效，否则说明table容量达到最大，为Integer.MAX_VALUE。最后再将计算完的扩容阈值赋值给threshold。<strong>代码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// 当前容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">// 当前扩容阈值</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 容量达到最大，不再扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 容量先翻倍，若oldCap &gt;=16 &amp;&amp; newCap &lt; max 扩容阈值也翻倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// oldCap == 0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">// oldCap == 0  </span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY; <span class="comment">// 16 </span></span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); <span class="comment">// 12</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// oldCap &lt;16 或者 使用非无参构造函数初始化后，再计算下扩容阈值</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="4-2、数据迁移"><a href="#4-2、数据迁移" class="headerlink" title="4.2、数据迁移"></a>4.2、数据迁移</h3><img src="/pics/image-20210312231650233.png" alt="image-20210312231650233" style="zoom:50%;" />

<p>步骤如下：</p>
<ol>
<li><p>创建数组newTab，大小为newCab,newCap的大小逻辑，我们刚才已经介绍过了。</p>
</li>
<li><p>遍历oldTab，开始数据迁移，假设当前位置索引为 i ，当前Node 为 e：</p>
<ul>
<li><p>e.next == null，说明哈希桶只有一个元素，复制到newTab[i]；</p>
</li>
<li><p>e 是一个treeNode，尝试将当前索引位置的红黑树进行拆分，下一节分析；</p>
</li>
<li><p>以上2种情况都不满足，说明是一个链表，将链表中的所有Node插入到新列表中。介绍下扩容插入的原理。</p>
<p>我们知道table形成链表，说明index = h &amp; (length-1)得到了相同的值。假设length = 16 ，length - 1相应的二进制是  0b1111，index若相同说明h的低4位是相同；扩容后length = 32，length - 1的表示为二进制为 0b11111，也就是说取 h 的低5位。假设我们要迁移节点的 index = 0b 0101，迁移时要取的 h 的低五位，此时 h 的第五位有2种情况 0x10101 或 0x00101（这2种情况，若取低4位index相同即扩容前），经过计算后新的index 就有2种情况，转换为10 进制 newIndex = index 或 newIndex = index + oldCap。</p>
</li>
</ul>
<p><img src="/pics/image-20210311220343714.png" alt="image-20210311220343714"></p>
<p>​         这也是为什么要扩容的原因，扩容后相同hash的链表长度会变短，分布的更加均匀，查找效率更高。 </p>
<ul>
<li>还是上面的例子，oldCap表示为二进制0b 10000，e.hash &amp; oldCap == 0说明是高位为0，扩容完的索引与原数组相同；e.hash &amp; oldCap == 1说明是高位为1，计算出的newTab的 nexIndex = [index + newCap]；</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">   <span class="comment">// ... 以上是newSize大小确定</span></span><br><span class="line">    <span class="comment">// 创建newCap大小容量</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;<span class="comment">//  当前node节点</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 回收</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 当前桶位只有单个元素，计算新的元素</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 尝试将红黑树拆分为2个链表</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">//还是链表，需要将链表拆分    </span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//低位链表，扩容前后，下标不变</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, </span><br><span class="line">                    loTail = <span class="keyword">null</span>; <span class="comment">//低位链表表尾指针</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 高位链表，扩容后，下标变为当前数组位置 + 扩容前数组长度</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, </span><br><span class="line">                    hiTail = <span class="keyword">null</span>;<span class="comment">//高位链表的表头指针</span></span><br><span class="line">                    </span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123; <span class="comment">// 说明是低位链表，放入低位链表中</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)<span class="comment">// 首个元素赋值到表头</span></span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e; <span class="comment">//指向链尾元素 </span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e; </span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 将新链表放到对应的数组里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>; <span class="comment">// 必要操作，尾节点后继置空</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3、红黑树的拆分"><a href="#4-3、红黑树的拆分" class="headerlink" title="4.3、红黑树的拆分"></a>4.3、红黑树的拆分</h3><p>我们知道，扩容时oldTab相同index的可能放到newTab数组下标是index或index + oldCap的位置，如果oldTab[index]存放的是红黑树，那么扩容完的2个位置哈希桶的元素个数可能就不足8个，此时就需要对红黑树进行拆分。拆分步骤如下：</p>
<ol>
<li>类似拆分链表，先将当前红黑树拆分为2个双向链表，高位链表hi 和 低位链表li</li>
<li> 如果低位单链表不为空，此时有2种情况，假设低位链表长度为lc</li>
</ol>
<ul>
<li>若lc &lt;= 6 则将低位红黑树转为单链表；</li>
<li>若 lc &gt; 6 时，如果hiHead == null，高位链表为空，说明原链表的所有元素都在低位链表中，不需要再进行树化；否则要对链表进行树化。</li>
</ul>
<ol start="3">
<li>如果高位链表不为空，类似低位链表的处理，&lt;=6 转换为单链表，大于6 且 低位链表为空，不需要做任何操作；否则要对链表进行树化。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">    TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> lc = <span class="number">0</span>, <span class="comment">// 低位链表长度</span></span><br><span class="line">    hc = <span class="number">0</span>; <span class="comment">// 高位链表长度</span></span><br><span class="line">    <span class="comment">// 1. 当前红黑树拆分为2个双向链表</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">        e.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">            loTail = e;</span><br><span class="line">            ++lc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">            ++hc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD) <span class="comment">// 若lc &lt;= 6 则将低位红黑树转为单链表</span></span><br><span class="line">            tab[index] = loHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若 lc &gt; 6 时，如果hiHead == null，高位链表为空，说明原链表的所有元素都在低位链表中，不需要再进行树化；否则要对链表进行树化。</span></span><br><span class="line">            tab[index] = loHead; </span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">                loHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index + bit] = hiHead;</span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                hiHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  树转成链表</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; q = <span class="keyword">this</span>; q != <span class="keyword">null</span>; q = q.next) &#123;</span><br><span class="line">        Node&lt;K,V&gt; p = map.replacementNode(q, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">            hd = p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tl.next = p;</span><br><span class="line">        tl = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、其他方法"><a href="#五、其他方法" class="headerlink" title="五、其他方法"></a>五、其他方法</h2><h3 id="5-1、get"><a href="#5-1、get" class="headerlink" title="5.1、get"></a>5.1、get</h3><p>步骤如下：</p>
<ol>
<li>计算key的hash，再根据hash得出哈希桶的index</li>
<li>取头结点不为空，判断头节点的key和需要的key是否相同，相同直接返回</li>
<li>是否是ThreeNode，遍历红黑树获取</li>
<li>以上都不满足说明是链表，遍历链表获取节点</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-2、remove"><a href="#5-2、remove" class="headerlink" title="5.2、remove"></a>5.2、remove</h2><p>remove 比较简单，就是单链表的删除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="comment">//p是头节点</span></span><br><span class="line">    <span class="keyword">int</span> n, index;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, <span class="comment">// Node是待删除的节点</span></span><br><span class="line">        e; K k; V v;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p; <span class="comment">//p是头节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">// p是ThreeNode</span></span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 链表的处理</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;<span class="comment">// 查找要删除的节点</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;<span class="comment">// p 更新为要删除节点的上一个节点</span></span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p) <span class="comment">// node是头结点</span></span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//删除node节点</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount; <span class="comment">// 修改次数 ++ </span></span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、JDK1-7"><a href="#六、JDK1-7" class="headerlink" title="六、JDK1.7"></a>六、JDK1.7</h2><h3 id="6-1、数据结构"><a href="#6-1、数据结构" class="headerlink" title="6.1、数据结构"></a>6.1、数据结构</h3><p> 与1.8的 HashMap的区别为数据结构为数组加链表，没有二叉树。</p>
<h3 id="6-2、Hash规则"><a href="#6-2、Hash规则" class="headerlink" title="6.2、Hash规则"></a>6.2、Hash规则</h3><p>hash规则与1.8 基本一致，通过高低位异或使得数据hash值更均匀。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode(); <span class="comment">// 先异或</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>); </span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>节点的table索引计算规则不变</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</span></span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-3、put"><a href="#6-3、put" class="headerlink" title="6.3、put"></a>6.3、put</h3><p>put方法采用的是头插法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 头插法插入</span></span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    <span class="comment">// 这里很关键，插入时新节点的的next -&gt; 头节点</span></span><br><span class="line">    <span class="comment">// 将新节点放到原头节点的位置</span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.2、resize 扩容</p>
<p>resize 扩容的核心算法是transfer，采用的是头插法，扩容后的链表顺序会翻转，多线程时候可能会形成循环链表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Transfers all entries from current table to newTable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123; <span class="comment">//遍历并转移</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            <span class="comment">// 扩容时采用头插法，列表被逆转</span></span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>采用的是数组 + 列表的数据结构</p>
</li>
<li><p>采用懒加载方式，数组默认的大小是16，扩容因子为0.75，扩容阈值为数组大小 size * 0.75；</p>
</li>
<li><p>触发扩容的条件是数组容量大于扩容阈值，每次扩容是原来的2倍，扩容时，将当前桶位数组的元素重新计算桶位hash，将当前桶拆出一个新桶索引是 index + oldCap</p>
</li>
<li><p>树化</p>
<p>当桶数组中链表长度达到8之后且桶数组长度大于64时，进行树化，将Node节点转换成TreeNode，TreeNode既有双向链表的特性又有树的特性；然后将当前单链表转化成双向链表；再将双向链表转化成树。</p>
</li>
<li><p>树降级</p>
<p>扩容过程中，某个桶位的元素在扩容后拆分为2个链表放到到2个桶位，导致新桶位的元素长度可能小于8，就需要将当前树降级为链表。</p>
</li>
</ol>
<p><a href="https://www.bilibili.com/video/BV1LJ411W7dP?p=3">https://www.bilibili.com/video/BV1LJ411W7dP?p=3</a></p>
<p><a href="https://www.bilibili.com/video/BV1uy4y1k7Uf">https://www.bilibili.com/video/BV1uy4y1k7Uf</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
        <category>Collection</category>
      </categories>
  </entry>
  <entry>
    <title>Java集合_06_CopyOnWriteArrayList</title>
    <url>/2022/12/25/Notes/Java/03Collections/Java%E9%9B%86%E5%90%88_06_CopyOnWriteArrayList/</url>
    <content><![CDATA[<h1 id="Java集合-06-CopyOnWriteArrayList"><a href="#Java集合-06-CopyOnWriteArrayList" class="headerlink" title="Java集合_06_CopyOnWriteArrayList"></a>Java集合_06_CopyOnWriteArrayList</h1><span id="more"></span>

<p><a href="https://www.cnblogs.com/chengxiao/p/6881974.html">https://www.cnblogs.com/chengxiao/p/6881974.html</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
        <category>Collection</category>
      </categories>
  </entry>
  <entry>
    <title>Java集合_07_ConcurrentHashMap_JDK7</title>
    <url>/2022/12/25/Notes/Java/03Collections/Java%E9%9B%86%E5%90%88_07_ConcurrentHashMap_JDK7/</url>
    <content><![CDATA[<h1 id="Java集合-07-ConcurrentHashMap-JDK7"><a href="#Java集合-07-ConcurrentHashMap-JDK7" class="headerlink" title="Java集合_07_ConcurrentHashMap_JDK7"></a>Java集合_07_ConcurrentHashMap_JDK7</h1><span id="more"></span>

<p>我们知道HashMap不是线程安全的，并发操作时会出现问题，而ConcurrentHashMap则可以支持并发的读写，我们先来了解下JDK7版本ConcurrentHashMap的原理，非常经典的一个设计。</p>
<h1 id="一、数据结构"><a href="#一、数据结构" class="headerlink" title="一、数据结构"></a>一、数据结构</h1><p>在 JDK1.7中，本质上还是采用链表+数组的形式存储键值对的。但是，为了提高并发，把原来的整个 table 划分为 n 个 Segment 。所以，从整体来看，它是一个由 Segment 组成的数组。然后，每个 Segment 里边是由 HashEntry 组成的数组，每个 HashEntry之间又可以形成链表。我们可以把每个 Segment 看成是一个小的 HashMap，其内部结构和 HashMap 是一模一样的。</p>
<img src="/pics/image-20210315231940864.png" alt="image-20210315231940864" style="zoom:50%;" />

<p>当对某个 Segment 加锁时，如图中 Segment2，并不会影响到其他 Segment 的读写。每个 Segment 内部自己操作自己的数据。这样一来，我们要做的就是尽可能的让元素均匀的分布在不同的 Segment中。最理想的状态是，所有执行的线程操作的元素都是不同的 Segment，这样就可以降低锁的竞争。</p>
<h2 id="1-1、重要常量"><a href="#1-1、重要常量" class="headerlink" title="1.1、重要常量"></a>1.1、重要常量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认初始化容量，这个和 HashMap中的容量是一个概念，表示的是整个 Map的容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="comment">//默认加载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">//默认的并发级别，这个参数决定了 Segment数组的长度，Segment数组初始化后不再改变</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"><span class="comment">//最大的容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">//每个Segment中table数组的最小长度为2，且必须是2的n次幂。</span></span><br><span class="line"><span class="comment">//由于每个Segment是懒加载的，用的时候才会初始化，因此为了避免使用时立即调整大小，设定了最小容量2</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_SEGMENT_TABLE_CAPACITY = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//用于限制Segment数量的最大值，必须是2的n次幂</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SEGMENTS = <span class="number">1</span> &lt;&lt; <span class="number">16</span>; <span class="comment">// slightly conservative</span></span><br><span class="line"><span class="comment">//用于根据元素的hash值定位所在的 Segment 下标</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> segmentMask;</span><br><span class="line"><span class="comment">//和 segmentMask 配合使用来定位 Segment 的数组下标</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> segmentShift;</span><br><span class="line"><span class="comment">//Segment 组成的数组，每一个 Segment 都可以看做是一个特殊的 HashMap</span></span><br><span class="line"><span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br></pre></td></tr></table></figure>

<h2 id="1-2、Segment"><a href="#1-2、Segment" class="headerlink" title="1.2、Segment"></a>1.2、Segment</h2><p>Segment 对象，继承自 ReentrantLock 可重入锁。每个Segment都是单独处理扩容的，互相之间不会产生影响</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用于表示每个Segment中的 table，是一个用HashEntry组成的数组。</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line">    <span class="comment">//Segment中的元素个数，每个Segment单独计数</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">//每次 table 结构修改时，如put，remove等，此变量都会自增</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当前Segment扩容的阈值，同HashMap计算方法一样也是容量乘以加载因子</span></span><br><span class="line">    <span class="comment">//需要知道的是，每个Segment都是单独处理扩容的，互相之间不会产生影响</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> threshold;</span><br><span class="line">    <span class="comment">//加载因子</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line">    Segment(<span class="keyword">float</span> lf, <span class="keyword">int</span> threshold, HashEntry&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = lf;</span><br><span class="line">        <span class="keyword">this</span>.threshold = threshold;</span><br><span class="line">        <span class="keyword">this</span>.table = tab;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3、HashEntry"><a href="#1-3、HashEntry" class="headerlink" title="1.3、HashEntry"></a>1.3、HashEntry</h2><p>存储数据的节点，每个Segment中，它就类似于HashMap中的Node，用于存储键值对的具体数据和维护单向链表的关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V value;</span><br><span class="line">    <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    HashEntry(<span class="keyword">int</span> hash, K key, V value, HashEntry&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4、初始化"><a href="#1-4、初始化" class="headerlink" title="1.4、初始化"></a>1.4、初始化</h2><p>ConcurrentHashMap 有五种构造函数，但是最终都会调用同一个构造函数，所以只需要搞明白这一个核心的构造函数就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">    <span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">    <span class="comment">// 偏移量，是为了对hash值做位移操作，计算元素所在的Segment下标</span></span><br><span class="line">    <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 用于设定最终Segment数组的长度，必须是2的n次幂</span></span><br><span class="line">    <span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//这里就是计算 sshift 和 ssize 值的过程</span></span><br><span class="line">    <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">        ++sshift;</span><br><span class="line">        ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// hash值右移动的位数</span></span><br><span class="line">    <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">    <span class="comment">// segmentMask = 2的n次方 - 1，用于和hash值运算取高位sshift位，定位segment</span></span><br><span class="line">    <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">// HashEntry数组的容量大小</span></span><br><span class="line">    <span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line">    <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">        ++c;</span><br><span class="line">    <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">    <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">        cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// create segments and segments[0]</span></span><br><span class="line">    Segment&lt;K,V&gt; s0 =</span><br><span class="line">        <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</span><br><span class="line">                         (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line">    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</span><br><span class="line"> <span class="comment">//把S0存到Segment数组中去。在这里，我们就可以发现，此时只是创建了一个Segment数组，</span></span><br><span class="line"> <span class="comment">//但是并没有把数组中的每个Segment对象创建出来，仅仅创建了一个Segment用来作为原型对象。</span></span><br><span class="line">    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">    <span class="keyword">this</span>.segments = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结下：</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th>描述</th>
<th>使用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">sshift</td>
<td>偏移量，为计算segmentShift</td>
<td></td>
</tr>
<tr>
<td align="left">segmentShift</td>
<td>segmentShift = 32 - sshift;</td>
<td></td>
</tr>
<tr>
<td align="left">ssize</td>
<td>segement数组长度， 必须是一个大于等于 concurrencyLevel 的一个2的n次幂值 concurrencyLevel 的值 16。</td>
<td>Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize];</td>
</tr>
<tr>
<td align="left">segmentMask</td>
<td>ssize - 1，定位segment在Segment[ssize]位置</td>
<td>(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</td>
</tr>
<tr>
<td align="left">cap</td>
<td>Segment中HashEntry[]长度，必须是一个大于等于2的一个2的n次幂值</td>
<td></td>
</tr>
</tbody></table>
<p><strong>sshift 和 ssize 值的计算过程为，每次循环，都会把 sshift 自增1，并且 ssize 左移一位，即乘以2，直到 ssize 的值大于等于16。</strong></p>
<p><strong>cap计算过程类似，必须是大于等于2的一个2的n次幂值。</strong></p>
<h1 id="二、Hash规则"><a href="#二、Hash规则" class="headerlink" title="二、Hash规则"></a>二、Hash规则</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="number">0</span> != h) &amp;&amp; (k <span class="keyword">instanceof</span> String)) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spread bits to regularize both segment and index locations,</span></span><br><span class="line">    <span class="comment">// using variant of single-word Wang/Jenkins hash.</span></span><br><span class="line">    h += (h &lt;&lt;  <span class="number">15</span>) ^ <span class="number">0xffffcd7d</span>;</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">10</span>);</span><br><span class="line">    h += (h &lt;&lt;   <span class="number">3</span>);</span><br><span class="line">    h ^= (h &gt;&gt;&gt;  <span class="number">6</span>);</span><br><span class="line">    h += (h &lt;&lt;   <span class="number">2</span>) + (h &lt;&lt; <span class="number">14</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先来说明下Segment和HashEntry位置计算：</p>
<ol>
<li><p>节点所属的 segments位置，<strong>取hash值的高位</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br></pre></td></tr></table></figure></li>
<li><p>节点所属segments.HashEntry[] 的位置，<strong>取hash值的低位</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>思考一下，为什么它们的算法不一样呢？ 计算 Segment 数组下标是用的 hash值高位，而计算 HashEntry 数组下标是直接用的 hash 值的低位？举个例子分析下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//我们以并发级别16，HashEntry数组容量 4 为例，则它们参与运算的掩码分别为 15 和 3</span><br><span class="line"></span><br><span class="line">//hash值</span><br><span class="line">0110 1101 0110 1111 0110 1110 0010 0010</span><br><span class="line">//segmentMask = 15   ，标记为 (1)</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 1111</span><br><span class="line">//tab.length - 1 = 3     ，标记为 (2)</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0011</span><br><span class="line"></span><br><span class="line">//用 hash 分别和 15 ，3 做与运算，会发现得到的结果是一样，都是十进制 2.</span><br><span class="line">//这表明，当前 hash值被分配到下标为 2 的 Segment 中，同时，被分配到下标为 2 的 HashEntry 数组中</span><br><span class="line"></span><br><span class="line">//现在若有另外一个 hash 值 h2，和第一个hash值，高位不同，但是低4位相同</span><br><span class="line">1010 1101 0110 1111 0110 1110 0010 0010</span><br><span class="line">//我们会发现，最后它也会被分配到下标为 2 的 Segment 和 HashEntry 数组，就会和第一个元素形成链表。</span><br><span class="line"></span><br><span class="line">//所以，为了避免这种扎堆现象，让元素尽量均匀分配，就让 hash 的高 4 位和 (1)处做与 运算，而用低位和 (2)处做与运算</span><br><span class="line">//这样计算后，它们所在的Segment下标分别为 6(0110), 10(1010)，即使它们在HashEntry数组中的下标都为 2(0010)，也无所谓</span><br><span class="line">//因为它们并不在一个 Segment 中，也就不会在同一个 HashEntry 数组中，更不会形成链表。</span><br><span class="line">//更重要的是，它们不会有并发，因为在各自不同的 Segment 自己操作自己的加锁解锁，互不影响</span><br></pre></td></tr></table></figure>

<p>总结下，就是为了避免分配到同一个 Segment 中的元素扎堆现象，即避免它们都被分配到同一条链表上，导致链表过长。同时，也是为了减少并发。</p>
<h1 id="三、PUT"><a href="#三、PUT" class="headerlink" title="三、PUT"></a>三、PUT</h1><p>put  操作的的流程：</p>
<ol>
<li>通过哈希算法计算出当前 key 的 hash 值</li>
<li>通过这个 hash 值找到它所对应的 Segment 数组的下标</li>
<li>再通过 hash 值计算出它在对应 Segment 的 HashEntry数组 的下标</li>
<li>找到合适的位置插入元素</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask; <span class="comment">// 要插入的segment位置</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">        s = ensureSegment(j); <span class="comment">// 1.创建segment</span></span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>); <span class="comment">// 2.创建hashEntry对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-1、创建segment"><a href="#3-1、创建segment" class="headerlink" title="3.1、创建segment"></a>3.1、创建segment</h2><p>写入过程：</p>
<ol>
<li><p>为了提升效率做了3次判空，最终使用CAS进行创建。</p>
<p>在多线程环境下，因为不确定是什么时候会有其它线程 CAS 成功，有可能发生在以上的任意时刻。所以，只要发现一旦内存中的对象已经存在了，则说明已经有其它线程把Segment对象创建好，并CAS成功同步到主内存了。此时，就可以直接返回，而不需要往下执行了。这样做，是为了代码执行效率考虑。</p>
</li>
<li><p>创建Segment时，利用Segment[0] 属性快速初始化</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Segment&lt;K,V&gt; <span class="title">ensureSegment</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">long</span> u = (k &lt;&lt; SSHIFT) + SBASE; <span class="comment">// raw offset</span></span><br><span class="line">    Segment&lt;K,V&gt; seg;</span><br><span class="line">    <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) &#123;<span class="comment">//1.check当前segment是否是空</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用 Segment[0] 属性快速初始化</span></span><br><span class="line">        Segment&lt;K,V&gt; proto = ss[<span class="number">0</span>]; <span class="comment">// use segment 0 as prototype</span></span><br><span class="line">        <span class="keyword">int</span> cap = proto.table.length;</span><br><span class="line">        <span class="keyword">float</span> lf = proto.loadFactor;</span><br><span class="line">        <span class="keyword">int</span> threshold = (<span class="keyword">int</span>)(cap * lf);</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap];</span><br><span class="line">        <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">            == <span class="keyword">null</span>) &#123; <span class="comment">// recheck， //2、再次check segment是否是空</span></span><br><span class="line">            Segment&lt;K,V&gt; s = <span class="keyword">new</span> Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// cas 写入，//3、第三次次check segment是否是空</span></span><br><span class="line">            <span class="keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">                   == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 拆分成2个操作，1、赋值 seg = s,用于最后的返回</span></span><br><span class="line">                <span class="comment">// 2、写入, ss[u] = seg</span></span><br><span class="line">                <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="keyword">null</span>, seg = s))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> seg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2、Segment-put"><a href="#3-2、Segment-put" class="headerlink" title="3.2、Segment.put"></a>3.2、Segment.put</h2><p>Segment负责创建节点并插入，主要步骤有:</p>
<ol>
<li>对当前Segment加锁，避免并发插入</li>
<li>确定index数组，遍历节点，若key相同则替换；当key不同时，创建新节点并插入；插入过程中进行扩容的判断</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//这里通过tryLock尝试加锁，如果加锁成功，返回null，否则执行 scanAndLockForPut方法</span></span><br><span class="line">   <span class="comment">//这里说明一下，tryLock 和 lock 是 ReentrantLock 中的方法，</span></span><br><span class="line">   <span class="comment">//区别是 tryLock 不会阻塞，抢锁成功就返回true，失败就立马返回false，</span></span><br><span class="line">   <span class="comment">//而 lock 方法是，抢锁成功则返回，失败则会进入同步队列，阻塞等待获取锁。</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :</span><br><span class="line">        scanAndLockForPut(key, hash, value);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加锁成功</span></span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="comment">// 链表节点在数组中的索引</span></span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        <span class="comment">// 链表头节点</span></span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="comment">// key 相同的情况下替换</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123; </span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                e = e.next; <span class="comment">// 节点指向下一个节点</span></span><br><span class="line">            &#125; </span><br><span class="line">            </span><br><span class="line">            <span class="comment">// e == null</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 头插法插入</span></span><br><span class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>) <span class="comment">// scanAndLockForPut 中可能会创建node</span></span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span>.</span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    <span class="comment">// 扩容</span></span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 放到数组中</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                </span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();<span class="comment">//scanAndLockForPut 中有加锁操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3、scanAndLockForPut"><a href="#3-3、scanAndLockForPut" class="headerlink" title="3.3、scanAndLockForPut"></a>3.3、scanAndLockForPut</h2><p>加锁且预先创建对象。这里只是预测性的创建一个新节点，也有可能在这之前，就已经获取锁成功了，返回时空对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line">    <span class="keyword">while</span> (!tryLock()) &#123; <span class="comment">// 等待获取锁的过程中，做其他的事情 </span></span><br><span class="line">        HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></span><br><span class="line">        <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="comment">// speculatively create node</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>); <span class="comment">// 预测性的创建一个新节点</span></span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</span><br><span class="line">                retries = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                e = e.next;<span class="comment">//找到当前hash的最后一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">            lock();<span class="comment">// 获取锁</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                 (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123;</span><br><span class="line">            e = first = f; <span class="comment">// re-traverse if entry changed</span></span><br><span class="line">            retries = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4、rehash"><a href="#3-4、rehash" class="headerlink" title="3.4、rehash"></a>3.4、rehash</h2><p>当 put 方法时，发现当前Segment个数超过了segment的threshold，则扩容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">		rehash(node);</span><br></pre></td></tr></table></figure>

<p>需要注意的是，<strong>每个Segment只管它自己的扩容</strong>，互相之间并不影响。换句话说，可以出现这个 Segment的长度为2，另一个Segment的长度为4的情况（只要是2的n次幂）。迁移过程的主要步骤：</p>
<ol>
<li>调整newTable的容量和扩容阈值；</li>
<li>迁移数据：<ol>
<li>若当前数组只有一个节点，直接复制到table[newIndex]；</li>
<li>若是链表，从头节点开始找到newIndex相同且连续的链表最后的几个节点，整体移动到table[newIndex]；接着，采用头插法将剩余节点全部复制到新节点。</li>
</ol>
</li>
<li>使用头插法插入新节点。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 旧表</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="comment">// newTable 容量为原来2倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 扩容阈值 </span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    <span class="comment">// 创建newTable</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable =</span><br><span class="line">        (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> HashEntry[newCapacity];</span><br><span class="line">    <span class="comment">// 计算索引需要</span></span><br><span class="line">    <span class="keyword">int</span> sizeMask = newCapacity - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="comment">// 计算newTable的索引</span></span><br><span class="line">            <span class="keyword">int</span> idx = e.hash &amp; sizeMask;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)   <span class="comment">//  Single node on list</span></span><br><span class="line">                newTable[idx] = e;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// Reuse consecutive sequence at same slot</span></span><br><span class="line">                <span class="comment">// 从头结点开始向后遍历，找到当前链表的最后几个下标相同的连续的节点。</span></span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                <span class="keyword">int</span> lastIdx = idx;</span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line">                     last != <span class="keyword">null</span>;</span><br><span class="line">                     last = last.next) &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">int</span> k = last.hash &amp; sizeMask;</span><br><span class="line">                    <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 1.先迁移lastRun节点到尾结点的这部分就可以整体迁移到新数组的对应下标位置了</span></span><br><span class="line">                newTable[lastIdx] = lastRun;</span><br><span class="line">                <span class="comment">// Clone remaining nodes</span></span><br><span class="line">                <span class="comment">// 2.再复制 e 到 lastRun的所有节点</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    V v = p.value;</span><br><span class="line">                    <span class="keyword">int</span> h = p.hash;</span><br><span class="line">                    <span class="keyword">int</span> k = h &amp; sizeMask;</span><br><span class="line">                    <span class="comment">// 头插法</span></span><br><span class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                    newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 头插法插入</span></span><br><span class="line">    <span class="keyword">int</span> nodeIndex = node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    newTable[nodeIndex] = node;</span><br><span class="line">    table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从头结点开始向后遍历，找到当前链表的最后几个下标相同的连续的节点。如上图，虽然开头出现了有两个节点的下标都是 k2, 但是中间出现一个不同的下标 k1，打断了下标连续相同，因此从下一个k2，又重新开始算。好在后边三个连续的节点下标都是相同的，因此倒数第三个节点被标记为 lastRun，且变量无变化。</p>
<p>从lastRun节点到尾结点的这部分就可以整体迁移到新数组的对应下标位置了，因为它们的下标都是相同的，可以这样统一处理。</p>
<p><img src="/pics/image-20210316102451162.png" alt="image-20210316102451162"></p>
<p>另外从头结点到 lastRun 之前的节点，无法统一处理，只能一个一个去复制了。且注意，这里不是直接迁移，而是复制节点到新的数组，旧的节点会在不久的将来，因为没有引用指向，被 JVM 垃圾回收处理掉。</p>
<h1 id="四、其他方法"><a href="#四、其他方法" class="headerlink" title="四、其他方法"></a>四、其他方法</h1><h2 id="4-1、get"><a href="#4-1、get" class="headerlink" title="4.1、get"></a>4.1、get</h2><p>先定位到 Segment，然后再定位到 HashEntry 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="keyword">int</span> h = hash(key);</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    <span class="comment">// 1.定位到segment</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (tab = s.table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile            </span><br><span class="line">                 (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">             e != <span class="keyword">null</span>; e = e.next) &#123; <span class="comment">// 2.定位到tab</span></span><br><span class="line">            K k;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2、remove"><a href="#4-2、remove" class="headerlink" title="4.2、remove"></a>4.2、remove</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public V remove(Object key) &#123;</span><br><span class="line">    int hash = hash(key);</span><br><span class="line">    Segment&lt;K,V&gt; s = segmentForHash(hash);</span><br><span class="line">    return s == null ? null : s.remove(key, hash, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public boolean remove(Object key, Object value) &#123;</span><br><span class="line">    int hash = hash(key);</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    return value != null &amp;&amp; (s = segmentForHash(hash)) != null &amp;&amp;</span><br><span class="line">        s.remove(key, hash, value) != null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Segment.remove</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">remove</span><span class="params">(Object key, <span class="keyword">int</span> hash, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//尝试加锁，若失败，则执行 scanAndLock ，此方法和 scanAndLockForPut 方法类似</span></span><br><span class="line">    <span class="keyword">if</span> (!tryLock())</span><br><span class="line">        scanAndLock(key, hash);</span><br><span class="line">    V oldValue = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        HashEntry&lt;K,V&gt; e = entryAt(tab, index);</span><br><span class="line">        HashEntry&lt;K,V&gt; pred = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                (e.hash == hash &amp;&amp; key.equals(k))) &#123; <span class="comment">//匹配到 key</span></span><br><span class="line">                V v = e.value;</span><br><span class="line">                <span class="keyword">if</span> (value == <span class="keyword">null</span> || value == v || value.equals(v)) &#123; <span class="comment">// value 为空，或者 value 也匹配成功</span></span><br><span class="line">                    <span class="keyword">if</span> (pred == <span class="keyword">null</span>) <span class="comment">// 移除头节点</span></span><br><span class="line">                        setEntryAt(tab, index, next);</span><br><span class="line">                    <span class="keyword">else</span> <span class="comment">// 头插法移除中间节点</span></span><br><span class="line">                        pred.setNext(next);</span><br><span class="line">                    ++modCount;</span><br><span class="line">                    --count;</span><br><span class="line">                    oldValue = v;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pred = e; <span class="comment">//记录上一个节点</span></span><br><span class="line">            e = next; <span class="comment">//迭代</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3、size"><a href="#4-3、size" class="headerlink" title="4.3、size"></a>4.3、size</h2><p>size方法统计是所有节点的个数,发情况下，有可能在统计期间，数组元素个数不停的变化，而且，整个表还被分成了 N个 Segment，怎样统计才能保证结果的准确性呢？ 我们一起来看下吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Try a few times to get accurate count. On failure due to</span></span><br><span class="line">    <span class="comment">// continuous async changes in table, resort to locking.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// segment数组</span></span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;.</span><br><span class="line">    <span class="comment">// 统计所有Segment中元素的总个数</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">    <span class="keyword">long</span> sum;         <span class="comment">// sum of modCounts</span></span><br><span class="line">    <span class="keyword">long</span> last = <span class="number">0L</span>;   <span class="comment">// previous sum</span></span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn&#x27;t retry</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//如果超过重试次数，则不再重试，而是把所有Segment都加锁，再统计 size</span></span><br><span class="line">            <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">            &#125;</span><br><span class="line">            sum = <span class="number">0L</span>;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            overflow = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                <span class="comment">//若当前遍历到的Segment不为空，则统计它的 modCount 和 count 元素个数</span></span><br><span class="line">                <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//累加当前Segment的结构修改次数，如put，remove等操作都会影响modCount</span></span><br><span class="line">                    sum += seg.modCount;</span><br><span class="line">                    <span class="keyword">int</span> c = seg.count;</span><br><span class="line">                    <span class="comment">//若当前Segment的元素个数 c 小于0 或者 size 加上 c 的结果小于0，则认为溢出</span></span><br><span class="line">                    <span class="comment">//因为若超过了 int 最大值，就会返回负数</span></span><br><span class="line">                    <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">                        overflow = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当此次尝试，统计的 sum 值和上次统计的值相同，则说明这段时间内，</span></span><br><span class="line">            <span class="comment">//并没有任何一个 Segment 的结构发生改变，就可以返回最后的统计结果</span></span><br><span class="line">            <span class="keyword">if</span> (sum == last)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//不相等，则说明有 Segment 结构发生了改变，则记录最新的结构变化次数之和 sum，</span></span><br><span class="line">            <span class="comment">//并赋值给 last，用于下次重试的比较。</span></span><br><span class="line">            last = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果超过了指定重试次数，则说明表中的所有Segment都被加锁了，因此需要把它们都解锁</span></span><br><span class="line">        <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                segmentAt(segments, j).unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若结果溢出，则返回 int 最大值，否则正常返回 size 值 </span></span><br><span class="line">    <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先采用乐观的方式，认为在统计 size 的过程中，并没有发生 put， remove 等会改变 Segment 结构的操作。第一次遍历后，将sum赋值给last；接着统计一次，若当次统计的 sum 值和上次统计的last相同，则说明这段时间内，并没有任何一个 Segment 的结构发生改变，就可以返回最后的统计结果。</p>
<p>但是，如果结果发生了变化（last != sum），就需要把所有 Segment 都加锁之后，再统计了，以此来得到准确的结果。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/133923068">https://zhuanlan.zhihu.com/p/133923068</a></p>
<p><a href="https://www.bilibili.com/video/BV1x741117jq?p=3">https://www.bilibili.com/video/BV1x741117jq?p=3</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
        <category>Collection</category>
      </categories>
  </entry>
  <entry>
    <title>Java集合_08_ConcurrentHashMap_JDK8</title>
    <url>/2022/12/25/Notes/Java/03Collections/Java%E9%9B%86%E5%90%88_08_ConcurrentHashMap_JDK8/</url>
    <content><![CDATA[<h1 id="Java集合-08-ConcurrentHashMap-JDK8"><a href="#Java集合-08-ConcurrentHashMap-JDK8" class="headerlink" title="Java集合_08_ConcurrentHashMap_JDK8"></a>Java集合_08_ConcurrentHashMap_JDK8</h1><span id="more"></span>

<p>JDK8版本ConcurrentHashMap的数据结构相较于jdk7发生了较大的变化，已经抛弃了Segment的概念，虽然源码里面还保留了，也只是为了兼容性的考虑。JDK8的ConcurrentHashMap数据结构和和扩容原理和JDK8的HashMap是一致的，不同之处在于，增加了并发的处理。</p>
<h2 id="一、数据结构"><a href="#一、数据结构" class="headerlink" title="一、数据结构"></a>一、数据结构</h2><h3 id="1-1、重要属性"><a href="#1-1、重要属性" class="headerlink" title="1.1、重要属性"></a>1.1、重要属性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// 表示正在转移,当前节点状态时FWD</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// 表示已经转换成树</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>; <span class="comment">// hash for transient reservations</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;<span class="comment">//默认没初始化的数组，用来保存元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;<span class="comment">//转移的时候用的数组</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来控制表初始化和扩容的，默认值为0，当在初始化的时候指定了大小，这会将这个大小保存在sizeCtl中，      * 大小为数组的0.75</span></span><br><span class="line"><span class="comment">     * 当为负的时候，说明表正在初始化或扩张，-1表示初始化</span></span><br><span class="line"><span class="comment">     *     -(1+n) n:表示活动的扩张线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br></pre></td></tr></table></figure>

<h3 id="1-2、Node"><a href="#1-2、Node" class="headerlink" title="1.2、Node"></a>1.2、Node</h3><p>Node&lt;K,V&gt;,这是构成每个元素的基本类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3、TreeNode"><a href="#1-3、TreeNode" class="headerlink" title="1.3、TreeNode"></a>1.3、TreeNode</h3><p>构造树的节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next,</span><br><span class="line">             TreeNode&lt;K,V&gt; parent) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4、ForwardingNode"><a href="#1-4、ForwardingNode" class="headerlink" title="1.4、ForwardingNode"></a>1.4、ForwardingNode</h3><p>ForwardingNode在转移的时候放在头部的节点，是一个空节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">        <span class="keyword">super</span>(MOVED, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.nextTable = tab;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5、TreeBin"><a href="#1-5、TreeBin" class="headerlink" title="1.5、TreeBin"></a>1.5、TreeBin</h3><p>TreeBin 用作树的头结点，只存储root和first节点，不存储节点的key、value值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeBin</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; root;</span><br><span class="line">    <span class="keyword">volatile</span> TreeNode&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">volatile</span> Thread waiter;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> lockState;</span><br><span class="line">    <span class="comment">// values for lockState</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRITER = <span class="number">1</span>; <span class="comment">// set while holding write lock</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITER = <span class="number">2</span>; <span class="comment">// set when waiting for write lock</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READER = <span class="number">4</span>; <span class="comment">// increment value for setting read lock</span></span><br></pre></td></tr></table></figure>

<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 离c最近且大于它值的 2的幂次方的值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = c - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">        initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>)size);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="initTable"><a href="#initTable" class="headerlink" title="initTable"></a>initTable</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *      sizeCtl &lt; 0</span></span><br><span class="line"><span class="comment"> *      1. -1 表示当前table正在初始化（有线程在创建table数组），当前线程需要自旋等待..</span></span><br><span class="line"><span class="comment"> *      2.表示当前table数组正在进行扩容 ,高16位表示：扩容的标识戳   低16位表示：（1 + nThread） 当前参与并发扩容的线程数量</span></span><br><span class="line"><span class="comment"> *      </span></span><br><span class="line"><span class="comment"> *      sizeCtl = 0，表示创建table数组时 使用DEFAULT_CAPACITY为大小</span></span><br><span class="line"><span class="comment"> *      </span></span><br><span class="line"><span class="comment"> *      sizeCtl &gt; 0</span></span><br><span class="line"><span class="comment"> *      </span></span><br><span class="line"><span class="comment"> *      1. 如果table未初始化，表示初始化大小</span></span><br><span class="line"><span class="comment"> *      2. 如果table已经初始化，表示下次扩容时的 触发条件（阈值）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    <span class="comment">//tab 引用map.table</span></span><br><span class="line">    <span class="comment">//sc sizeCtl的临时值</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="comment">//自旋 条件：map.table 尚未初始化</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//大概率就是-1，表示其它线程正在进行创建table的过程，当前线程没有竞争到初始化table的锁。</span></span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.sizeCtl = 0，表示创建table数组时 使用DEFAULT_CAPACITY为大小</span></span><br><span class="line">        <span class="comment">//2.如果table未初始化，表示初始化大小</span></span><br><span class="line">        <span class="comment">//3.如果table已经初始化，表示下次扩容时的 触发条件（阈值）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//这里为什么又要判断呢？ 防止其它线程已经初始化完毕了，然后当前线程再次初始化..导致丢失数据。</span></span><br><span class="line">                <span class="comment">//条件成立，说明其它线程都没有进入过这个if块，当前线程就是具备初始化table权利了。</span></span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//sc大于0 创建table时 使用 sc为指定大小，否则使用 16 默认值.</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    <span class="comment">//最终赋值给 map.table</span></span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">//n &gt;&gt;&gt; 2  =&gt; 等于 1/4 n     n - (1/4)n = 3/4 n =&gt; 0.75 * n</span></span><br><span class="line">                    <span class="comment">//sc 0.75 n 表示下一次扩容时的触发条件。</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//1.如果当前线程是第一次创建map.table的线程话，sc表示的是 下一次扩容的阈值</span></span><br><span class="line">                <span class="comment">//2.表示当前线程 并不是第一次创建map.table的线程，当前线程进入到else if 块 时，将</span></span><br><span class="line">                <span class="comment">//sizeCtl 设置为了-1 ，那么这时需要将其修改为 进入时的值。</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="二、put"><a href="#二、put" class="headerlink" title="二、put"></a>二、put</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//控制k 和 v 不能为null</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();    <span class="comment">//通过spread方法，可以让高位也能参与进寻址运算。</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">//binCount表示当前k-v 封装成node后插入到指定桶位后，在桶位中的所属链表的下标位置</span></span><br><span class="line">    <span class="comment">//0 表示当前桶位为null，node可以直接放着</span></span><br><span class="line">    <span class="comment">//2 表示当前桶位已经可能是红黑树</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//tab 引用map对象的table</span></span><br><span class="line">    <span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        <span class="comment">//f 表示桶位 的头结点</span></span><br><span class="line">        <span class="comment">//n 表示散列表数组的长度</span></span><br><span class="line">        <span class="comment">//i 表示key通过寻址计算后，得到的桶位下标</span></span><br><span class="line">        <span class="comment">//fh 表示桶位头结点的hash值</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE1：成立，表示当前map中的table尚未初始化..</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//最终当前线程都会获取到最新的map.table引用。</span></span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">//CASE2：i 表示key使用路由寻址算法得到 key对应 table数组的下标位置，tabAt 获取指定桶位的头结点 f</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//进入到CASE2代码块 前置条件 当前table数组i桶位是Null时。</span></span><br><span class="line">            <span class="comment">//使用CAS方式 设置 指定数组i桶位 为 new Node&lt;K,V&gt;(hash, key, value, null),并且期望值是null</span></span><br><span class="line">            <span class="comment">//cas操作成功 表示ok，直接break for循环即可</span></span><br><span class="line">            <span class="comment">//cas操作失败，表示在当前线程之前，有其它线程先你一步向指定i桶位设置值了。</span></span><br><span class="line">            <span class="comment">//当前线程只能再次自旋，去走其它逻辑。</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE3：前置条件，桶位的头结点一定不是null。</span></span><br><span class="line">        <span class="comment">//条件成立表示当前桶位的头结点 为 FWD结点，表示目前map正处于扩容过程中..</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">//看到fwd节点后，当前节点有义务帮助当前map对象完成迁移数据的工作</span></span><br><span class="line">            <span class="comment">//学完扩容后再来看。</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE4：当前桶位 可能是 链表 也可能是 红黑树代理结点TreeBin</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.统计当前table一共有多少数据</span></span><br><span class="line">    <span class="comment">//2.判断是否达到扩容阈值标准，触发扩容。</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123; </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">   <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">   <span class="comment">//  </span></span><br><span class="line">   <span class="comment">//CASE4：当前桶位 可能是 链表 也可能是 红黑树代理结点TreeBin</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当插入key存在时，会将旧值赋值给oldVal，返回给put方法调用处..</span></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用sync 加锁“头节点”，理论上是“头结点”</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">//为什么又要对比一下，看看当前桶位的头节点 是否为 之前获取的头结点？</span></span><br><span class="line">                <span class="comment">//为了避免其它线程将该桶位的头结点修改掉，导致当前线程从sync 加锁 就有问题了。之后所有操作都不用在做了。</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;<span class="comment">//条件成立，说明咱们 加锁 的对象没有问题，可以进来造了！</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//条件成立，说明当前桶位就是普通链表桶位。</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//1.当前插入key与链表当中所有元素的key都不一致时，当前的插入操作是追加到链表的末尾，binCount表示链表长度</span></span><br><span class="line">                        <span class="comment">//2.当前插入key与链表当中的某个元素的key一致时，当前插入操作可能就是替换了。binCount表示冲突位置（binCount - 1）</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//迭代循环当前桶位的链表，e是每次循环处理节点。</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            <span class="comment">//当前循环节点 key</span></span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//条件一：e.hash == hash 成立 表示循环的当前元素的hash值与插入节点的hash值一致，需要进一步判断</span></span><br><span class="line">                            <span class="comment">//条件二：((ek = e.key) == key ||(ek != null &amp;&amp; key.equals(ek)))</span></span><br><span class="line">                            <span class="comment">//       成立：说明循环的当前节点与插入节点的key一致，发生冲突了</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                <span class="comment">//将当前循环的元素的 值 赋值给oldVal</span></span><br><span class="line">                                oldVal = e.val;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//当前元素 与 插入元素的key不一致 时，会走下面程序。</span></span><br><span class="line">                            <span class="comment">//1.更新循环处理节点为 当前节点的下一个节点</span></span><br><span class="line">                            <span class="comment">//2.判断下一个节点是否为null，如果是null，说明当前节点已经是队尾了，插入数据需要追加到队尾节点的后面。</span></span><br><span class="line"></span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//前置条件，该桶位一定不是链表</span></span><br><span class="line">                    <span class="comment">//条件成立，表示当前桶位是 红黑树代理结点TreeBin</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        <span class="comment">//p 表示红黑树中如果与你插入节点的key 有冲突节点的话 ，则putTreeVal 方法 会返回冲突节点的引用。</span></span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        <span class="comment">//强制设置binCount为2，因为binCount &lt;= 1 时有其它含义，所以这里设置为了2 回头讲 addCount。</span></span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//条件一：成立，说明当前插入节点的key与红黑树中的某个节点的key一致，冲突了</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">//将冲突节点的值 赋值给 oldVal</span></span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//说明当前桶位不为null，可能是红黑树 也可能是链表</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果binCount&gt;=8 表示处理的桶位一定是链表</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    <span class="comment">//调用转化链表为红黑树的方法</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="comment">//说明当前线程插入的数据key，与原有k-v发生冲突，需要将原数据v返回给调用者。</span></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>




<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//控制k 和 v 不能为null</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过spread方法，可以让高位也能参与进寻址运算。</span></span><br><span class="line">        <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">        <span class="comment">//binCount表示当前k-v 封装成node后插入到指定桶位后，在桶位中的所属链表的下标位置</span></span><br><span class="line">        <span class="comment">//0 表示当前桶位为null，node可以直接放着</span></span><br><span class="line">        <span class="comment">//2 表示当前桶位已经可能是红黑树</span></span><br><span class="line">        <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//tab 引用map对象的table</span></span><br><span class="line">        <span class="comment">//自旋</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">            <span class="comment">//f 表示桶位 的头结点</span></span><br><span class="line">            <span class="comment">//n 表示散列表数组的长度</span></span><br><span class="line">            <span class="comment">//i 表示key通过寻址计算后，得到的桶位下标</span></span><br><span class="line">            <span class="comment">//fh 表示桶位头结点的hash值</span></span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//CASE1：成立，表示当前map中的table尚未初始化..</span></span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//最终当前线程都会获取到最新的map.table引用。</span></span><br><span class="line">                tab = initTable();</span><br><span class="line">            <span class="comment">//CASE2：i 表示key使用路由寻址算法得到 key对应 table数组的下标位置，tabAt 获取指定桶位的头结点 f</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//进入到CASE2代码块 前置条件 当前table数组i桶位是Null时。</span></span><br><span class="line">                <span class="comment">//使用CAS方式 设置 指定数组i桶位 为 new Node&lt;K,V&gt;(hash, key, value, null),并且期望值是null</span></span><br><span class="line">                <span class="comment">//cas操作成功 表示ok，直接break for循环即可</span></span><br><span class="line">                <span class="comment">//cas操作失败，表示在当前线程之前，有其它线程先你一步向指定i桶位设置值了。</span></span><br><span class="line">                <span class="comment">//当前线程只能再次自旋，去走其它逻辑。</span></span><br><span class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                             <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                    <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//CASE3：前置条件，桶位的头结点一定不是null。</span></span><br><span class="line">            <span class="comment">//条件成立表示当前桶位的头结点 为 FWD结点，表示目前map正处于扩容过程中..</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                <span class="comment">//看到fwd节点后，当前节点有义务帮助当前map对象完成迁移数据的工作</span></span><br><span class="line">                <span class="comment">//学完扩容后再来看。</span></span><br><span class="line">                tab = helpTransfer(tab, f);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//CASE4：当前桶位 可能是 链表 也可能是 红黑树代理结点TreeBin</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//当插入key存在时，会将旧值赋值给oldVal，返回给put方法调用处..</span></span><br><span class="line">                V oldVal = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//使用sync 加锁“头节点”，理论上是“头结点”</span></span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="comment">//为什么又要对比一下，看看当前桶位的头节点 是否为 之前获取的头结点？</span></span><br><span class="line">                    <span class="comment">//为了避免其它线程将该桶位的头结点修改掉，导致当前线程从sync 加锁 就有问题了。之后所有操作都不用在做了。</span></span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;<span class="comment">//条件成立，说明咱们 加锁 的对象没有问题，可以进来造了！</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">//条件成立，说明当前桶位就是普通链表桶位。</span></span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">//1.当前插入key与链表当中所有元素的key都不一致时，当前的插入操作是追加到链表的末尾，binCount表示链表长度</span></span><br><span class="line">                            <span class="comment">//2.当前插入key与链表当中的某个元素的key一致时，当前插入操作可能就是替换了。binCount表示冲突位置（binCount - 1）</span></span><br><span class="line">                            binCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//迭代循环当前桶位的链表，e是每次循环处理节点。</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                                <span class="comment">//当前循环节点 key</span></span><br><span class="line">                                K ek;</span><br><span class="line">                                <span class="comment">//条件一：e.hash == hash 成立 表示循环的当前元素的hash值与插入节点的hash值一致，需要进一步判断</span></span><br><span class="line">                                <span class="comment">//条件二：((ek = e.key) == key ||(ek != null &amp;&amp; key.equals(ek)))</span></span><br><span class="line">                                <span class="comment">//       成立：说明循环的当前节点与插入节点的key一致，发生冲突了</span></span><br><span class="line">                                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                    ((ek = e.key) == key ||</span><br><span class="line">                                     (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                    <span class="comment">//将当前循环的元素的 值 赋值给oldVal</span></span><br><span class="line">                                    oldVal = e.val;</span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">//当前元素 与 插入元素的key不一致 时，会走下面程序。</span></span><br><span class="line">                                <span class="comment">//1.更新循环处理节点为 当前节点的下一个节点</span></span><br><span class="line">                                <span class="comment">//2.判断下一个节点是否为null，如果是null，说明当前节点已经是队尾了，插入数据需要追加到队尾节点的后面。</span></span><br><span class="line"></span><br><span class="line">                                Node&lt;K,V&gt; pred = e;</span><br><span class="line">                                <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                              value, <span class="keyword">null</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//前置条件，该桶位一定不是链表</span></span><br><span class="line">                        <span class="comment">//条件成立，表示当前桶位是 红黑树代理结点TreeBin</span></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                            <span class="comment">//p 表示红黑树中如果与你插入节点的key 有冲突节点的话 ，则putTreeVal 方法 会返回冲突节点的引用。</span></span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            <span class="comment">//强制设置binCount为2，因为binCount &lt;= 1 时有其它含义，所以这里设置为了2 回头讲 addCount。</span></span><br><span class="line">                            binCount = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//条件一：成立，说明当前插入节点的key与红黑树中的某个节点的key一致，冲突了</span></span><br><span class="line">                            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                           value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">//将冲突节点的值 赋值给 oldVal</span></span><br><span class="line">                                oldVal = p.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//说明当前桶位不为null，可能是红黑树 也可能是链表</span></span><br><span class="line">                <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果binCount&gt;=8 表示处理的桶位一定是链表</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                        <span class="comment">//调用转化链表为红黑树的方法</span></span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line">                    <span class="comment">//说明当前线程插入的数据key，与原有k-v发生冲突，需要将原数据v返回给调用者。</span></span><br><span class="line">                    <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">return</span> oldVal;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.统计当前table一共有多少数据</span></span><br><span class="line">        <span class="comment">//2.判断是否达到扩容阈值标准，触发扩容。</span></span><br><span class="line">        addCount(<span class="number">1L</span>, binCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="三、tryPresize"><a href="#三、tryPresize" class="headerlink" title="三、tryPresize"></a>三、tryPresize</h1><p><a href="https://www.cnblogs.com/zerotomax/p/8687425.html">https://www.cnblogs.com/zerotomax/p/8687425.html</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/133923068">https://zhuanlan.zhihu.com/p/133923068</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
        <category>Collection</category>
      </categories>
  </entry>
  <entry>
    <title>Java进阶01_注解与反射</title>
    <url>/2022/12/25/Notes/Java/04Advanced/Java%E8%BF%9B%E9%98%B601_%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h1 id="Java进阶01-注解与反射"><a href="#Java进阶01-注解与反射" class="headerlink" title="Java进阶01_注解与反射"></a>Java进阶01_注解与反射</h1><span id="more"></span>

<h1 id="一、注解"><a href="#一、注解" class="headerlink" title="一、注解"></a>一、注解</h1><p>注解 <code>Annotation</code>是JDK5 引入的新技术。注解的作用为程序打上标记，可以被编译器读取，在运行时可以通过<code>反射</code>读取。注解可以加在包、类，属性、方法，方法的参数以及局部变量上，相当于给他们添加了额外的辅助信息。</p>
<h2 id="1-1、内置注解"><a href="#1-1、内置注解" class="headerlink" title="1.1、内置注解"></a>1.1、内置注解</h2><p>JDK1.5内部提供的三个注解：</p>
<ul>
<li><code>@Override</code> - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</li>
<li><code>@Deprecated</code> - 标记过时方法。如果使用该方法，会报编译警告。</li>
<li><code>@SuppressWarnings</code> - 指示编译器去忽略注解中声明的警告。需要添加参数使用，比如<code>@SuppressWarnings(&quot;all&quot;)</code>、<code>@SuppressWarnings(&quot;unchecked&quot;)</code></li>
</ul>
<p>从 Java 7 开始，额外添加了 3 个注解:</p>
<ul>
<li><code>@SafeVarargs</code> - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</li>
<li><code>@FunctionalInterface</code> - Java 8 开始支持，标识一个匿名函数或函数式接口。</li>
<li><code>@Repeatable</code> - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。</li>
</ul>
<h2 id="1-2、元注解"><a href="#1-2、元注解" class="headerlink" title="1.2、元注解"></a>1.2、元注解</h2><p>元注解就是用来注解其他注解，java提供了4个标准的meta-annotation类型，他们被用来提供对其他annotation类型作说明。</p>
<ul>
<li><p><strong><code>@Target</code></strong>:用于描述注解的使用范围（即被描述的注解可以用在什么地方），具体有如下几种：</p>
<table>
<thead>
<tr>
<th align="left">ElementType</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">TYPE</td>
<td>Class, interface (including annotation type), or enum declaration</td>
</tr>
<tr>
<td align="left">FIELD</td>
<td>Field declaration (includes enum constants)</td>
</tr>
<tr>
<td align="left">METHOD</td>
<td>Method declaration</td>
</tr>
<tr>
<td align="left">PARAMETER</td>
<td>Formal parameter declaration</td>
</tr>
<tr>
<td align="left">CONSTRUCTOR</td>
<td>Constructor declaration</td>
</tr>
<tr>
<td align="left">LOCAL_VARIABLE</td>
<td>Local variable declaration</td>
</tr>
<tr>
<td align="left">ANNOTATION_TYPE</td>
<td>Annotation type declaration</td>
</tr>
<tr>
<td align="left">PACKAGE</td>
<td>Package declaration</td>
</tr>
<tr>
<td align="left">TYPE_PARAMETER</td>
<td>Type parameter declaration， @since 1.8</td>
</tr>
<tr>
<td align="left">TYPE_USE</td>
<td>Use of a type，@since 1.8</td>
</tr>
</tbody></table>
</li>
<li><p>**<code>@Retention</code>**：表示注解保留的有效期，可识别该注解阶段</p>
<table>
<thead>
<tr>
<th>有效期</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>SOURCE</td>
<td>源码</td>
</tr>
<tr>
<td>CLASS</td>
<td>编译器</td>
</tr>
<tr>
<td>RUNTIME</td>
<td>运行期</td>
</tr>
</tbody></table>
</li>
<li><p><code>@Documented</code>：说明该注解被包含在javadoc中</p>
</li>
<li><p><code>@Inherited</code>：说明子类可以继承父类中的注解</p>
</li>
</ul>
<h2 id="1-3、自定义注解"><a href="#1-3、自定义注解" class="headerlink" title="1.3、自定义注解"></a>1.3、自定义注解</h2><p>当使用<code>@interface</code>自定义注解时，自动继承了<code>java.lang.annotation.Annotation</code>接口。</p>
<ul>
<li><code>@interface</code>用来声明一个注解，格式: <code>@ inteface 注解名&#123;定义内容&#125;</code></li>
<li>其中的每一个方法实际上是声明了一个<code>配置参数</code></li>
<li>方法名称就是参数的名称</li>
<li>返回值类型就是参数的类型(返回值只能是 <code>基本类型 + Class + String + enum</code>)</li>
<li>可以通过<code>default</code>来声明参数的默认值</li>
<li>如果只有一个参数成员，一般参数名为<code>value</code></li>
<li>注解元素必须有值，我们定义注解元素时，经常使用空字符串，0作为默认值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(value = RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(value = &#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、反射"><a href="#二、反射" class="headerlink" title="二、反射"></a>二、反射</h1><p><code>反射</code>机制指的是在程序运行期，可以访问、检测和修改它本身状态或行为的一种能力。</p>
<h2 id="2-1、动态语言-amp-静态语言"><a href="#2-1、动态语言-amp-静态语言" class="headerlink" title="2.1、动态语言 &amp; 静态语言"></a>2.1、动态语言 &amp; 静态语言</h2><p>动态语言：在运行时可以改变器结构的语言。例如：新的函数，对象可以被引入，或者删除已有的函数或者其他结构上的变化。通俗点说就是在运行是可以根据某些条件改变自身结构。</p>
<p>常见的动态类型语言有：Object-C，JavaScrpit 等等。</p>
<p>静态语言：运行时结构不可改变的静态语言。比如Java、C++。Java 虽然不是动态类型语言，但是通过反射机制可以获得类似动态语言的特性。</p>
<h2 id="2-2、JAVA-反射"><a href="#2-2、JAVA-反射" class="headerlink" title="2.2、JAVA 反射"></a>2.2、JAVA 反射</h2><p>反射<code>Reflection</code>是Java被视为动态语言的关键，反射机制允许程序在运行期借助于 <code>Reflection API</code>获取类信息，并能操作任意对象的内部属性和方法。</p>
<p>JVM 加载完类之后，在方法区就产生了一个<code>Class类型的对象</code>（一个类只有一个Class 对象），这个对象包含了类的完整信息，我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子，可以看到类的结构，所以我们形象的称之为 反射。</p>
<p><strong>Java反射机制主要提供了以下功能：</strong> </p>
<ul>
<li>在运行时判断任意一个对象所属的类；</li>
<li>在运行时构造任意一个类的对象；</li>
<li>在运行时判断任意一个类所具有的成员变量和方法；</li>
<li>在运行时调用任意一个对象的方法；</li>
<li>在运行时处理注解；</li>
<li>在运行时获取泛型信息；</li>
<li>生成动态代理 …</li>
</ul>
<p><strong>反射的优缺点：</strong></p>
<ul>
<li>优点：可以动态的创建对象和编译，体现出很大的灵活性</li>
<li>缺点：对性能有影响。使用反射基本上是一种解释操作，运行时告诉JVM，我们希望做什么并且它满足我们的要求。JVM 无法对这些动态代码进行优化，因此通过反射来操作的方式要比正常操作效率更低。</li>
</ul>
<h2 id="2-3、元数据"><a href="#2-3、元数据" class="headerlink" title="2.3、元数据"></a>2.3、元数据</h2><p>元数据（metadata）：<strong>元数据是指用来描述类的数据，就是class的代码数据</strong>。所有的class文件加载到虚拟机之后都会被构建成class对象，class对象描述了一个类都有哪些东西，大家都知道的实现的接口，继承的抽象类，成员变量，类变量，成员方法，类方法，静态方法等，这个class对象就是元数据。</p>
<ul>
<li>Class类：代表一个类。</li>
<li>Field类：代表类的成员变量（成员变量也称为类的属性）。</li>
<li>Method类：代表类的方法。</li>
<li>Constructor类：代表类的构造方法。</li>
</ul>
<img src="./pics/image-20220223214439779.png" alt="image-20220223214439779" style="zoom:40%;" />

<h2 id="2-4、理解Class"><a href="#2-4、理解Class" class="headerlink" title="2.4、理解Class"></a>2.4、理解Class</h2><p>Class 是一个Java中一个类，能够表示所有类或对象通过getClass 等方式获取到是class对象的类型。在JVM中所有类的.class 对象是全局唯一的。</p>
<ul>
<li>Class 本身也是一个类</li>
<li>Class 对象只能由系统创建</li>
<li>一个加载的类在JVM中只会有一个Class实例（对象）</li>
<li>Class 对象对应的是一个加载到JVM中的.class 文件</li>
<li>每个类的实例都会记得自己是由哪个Class 实例所生成的</li>
<li>通过Class可以完整的得到一个类被加载的结构</li>
<li>Class 是<code>Reflection</code>的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class 对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// class 的对象</span></span><br><span class="line">    System.out.println(Class.class.hashCode());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.类名.class 获取class对象</span></span><br><span class="line">    System.out.println(Person.class.hashCode());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.对象.getClass 获取class对象</span></span><br><span class="line">    Person p = <span class="keyword">new</span> Person();</span><br><span class="line">    System.out.println(p.getClass().hashCode());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.Class.forName 获取class对象</span></span><br><span class="line">    Class&lt;?&gt; c = Class.forName(<span class="string">&quot;bean.Person&quot;</span>);</span><br><span class="line">    System.out.println(c.hashCode());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//=== 输出 ===</span></span><br><span class="line"><span class="number">1610427175</span></span><br><span class="line"><span class="number">1554874502</span></span><br><span class="line"><span class="number">1554874502</span></span><br><span class="line"><span class="number">1554874502</span></span><br></pre></td></tr></table></figure>

<p>从上面的输出可以验证，同一个类的class 对象是唯一的。</p>
<h1 id="三、Class使用"><a href="#三、Class使用" class="headerlink" title="三、Class使用"></a>三、Class使用</h1><p>下面介绍下Class对象及其操作内部方法和变量的api。</p>
<h2 id="3-1、创建对象"><a href="#3-1、创建对象" class="headerlink" title="3.1、创建对象"></a>3.1、创建对象</h2><p>Class 创建对象有2种方式：</p>
<ul>
<li><p>Class 对象调用<code>newInstance()</code>方法</p>
<p>使用 Class 对象的 <code>newInstance()</code>方法来创建该 Class 对象对应类的实例，但是这种方法要求该Class对象对应的类有默认的空构造器。</p>
</li>
<li><p>Constructor 构造器调用<code>newInstance()</code>方法</p>
<p>先使用 Class 对象获取指定的 Constructor 对象，再调用 Constructor 对象的 <code>newInstance()</code>方法来创建 Class 对象对应类的实例，通过这种方法可以选定构造方法创建实例。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;default&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 省略get和set ...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.Class.newInstance 方式</span></span><br><span class="line">Class&lt;?&gt; c2 = Class.forName(<span class="string">&quot;bean.Person&quot;</span>);</span><br><span class="line">Person p2 = (Person) c2.newInstance();</span><br><span class="line">System.out.println(p2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.构造函数Constructor 方式，注意基本类型参数的类型 int -&gt; Integer.TYPE</span></span><br><span class="line">Constructor&lt;?&gt; constructor = c2.getDeclaredConstructor(String.class, Integer.TYPE);</span><br><span class="line">Person p3 = (Person) constructor.newInstance( <span class="string">&quot;user&quot;</span>, <span class="number">10</span>);</span><br><span class="line">System.out.println(p3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//Person&#123;name=&#x27;default&#x27;, age=-1&#125;</span></span><br><span class="line"><span class="comment">//Person&#123;name=&#x27;user&#x27;, age=10&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-2、操作方法"><a href="#3-2、操作方法" class="headerlink" title="3.2、操作方法"></a>3.2、操作方法</h2><p>操作方法主要是通过Method类完成：</p>
<ul>
<li>通过Class类的<code>getMethod(String name,Class...parameterTypes)</code>方法取得Method对象，并设置此方法操作时所需要的参数类型。</li>
<li>使用<code>Object invoke Object obj,Object[] args)</code>进行调用，并向方法中传递要设置的obj对象的参数信息。</li>
</ul>
<img src="/pics/image-20220223213945355.png" alt="image-20220223213945355" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.获取class对象</span></span><br><span class="line">Class&lt;?&gt; c2 = Class.forName(<span class="string">&quot;bean.Person&quot;</span>);</span><br><span class="line"><span class="comment">// 2.创建实例</span></span><br><span class="line">Person p = (Person) c2.newInstance();</span><br><span class="line"><span class="comment">// 3.获取方法</span></span><br><span class="line">Method m1 = c2.getDeclaredMethod(<span class="string">&quot;setAge&quot;</span>, Integer.TYPE);</span><br><span class="line"><span class="comment">// 4.调用</span></span><br><span class="line">m1.invoke(p, <span class="number">100</span>);</span><br><span class="line">System.out.println(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//Person&#123;name=&#x27;default&#x27;, age=100&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;say = &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; c5 = Class.forName(<span class="string">&quot;bean.Person&quot;</span>);</span><br><span class="line">Method method = c5.getDeclaredMethod(<span class="string">&quot;say&quot;</span>, String.class);</span><br><span class="line">method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// object 可以传空</span></span><br><span class="line">method.invoke(<span class="keyword">null</span>, <span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<ul>
<li>Object对应原方法的返回值，若原方法无返回值，此时返回null</li>
<li>若原方法若为静态方法，此时形参Object obj可为null</li>
<li>若原方法形参列表为空，则Object[] args为null</li>
<li>若原方法声明为private，则需要在调用此invoke()方法前，显式调用方法对象的<code>setAccessible(true）</code>方法，将可访问private的方法。</li>
</ul>
<h2 id="3-3、操作属性"><a href="#3-3、操作属性" class="headerlink" title="3.3、操作属性"></a>3.3、操作属性</h2><p>操作方法主要是通过<code>Field</code>类：</p>
<ul>
<li>通过Class类的<code>getFiled(String name)</code>方法取得Field对象</li>
<li>使用<code>set(Object obj, Object value)</code>修改属性。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 操作属性</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">Class&lt;?&gt; c3 = Class.forName(<span class="string">&quot;bean.Person&quot;</span>);</span><br><span class="line"><span class="comment">// 2.创建实例</span></span><br><span class="line">Person p2 = (Person) c3.newInstance();</span><br><span class="line"><span class="comment">// 3.获取filed 对象</span></span><br><span class="line">Field f =  c3.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">// 4.关闭访问安全检查</span></span><br><span class="line">f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;set前 = &quot;</span> + f.get(p2));</span><br><span class="line"><span class="comment">// 5.操作属性</span></span><br><span class="line">f.set(p2, <span class="string">&quot;usernew&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;set后= &quot;</span> + f.get(p2));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// set前 = default</span></span><br><span class="line"><span class="comment">// set后= usernew</span></span><br></pre></td></tr></table></figure>

<h2 id="3-4、setAccessible"><a href="#3-4、setAccessible" class="headerlink" title="3.4、setAccessible"></a>3.4、setAccessible</h2><p><code>Method</code>和<code>Field</code>、<code>Constructor</code>对象都有<code>setAccessible</code>方法。<code>setAccessible</code>是访问安全检查的开关。<br>主要作用有2个：</p>
<ul>
<li>参数值为true，反射对象在使用时取消Java语言访问检查，可以访问私有成员</li>
<li>提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true。</li>
</ul>
<h2 id="3-5、DeclaredMethod-和-Method"><a href="#3-5、DeclaredMethod-和-Method" class="headerlink" title="3.5、DeclaredMethod 和 Method"></a>3.5、DeclaredMethod 和 Method</h2><p><code>Method</code>返回<code>本类及其父类所有 public 的方法</code></p>
<p><code>DeclaredMethod</code>返回本类所有的方法，包括私有和公有。</p>
<p>同样的规则可应用于<code>Field</code>及<code>Constructor</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; c4 = Class.forName(<span class="string">&quot;bean.Person&quot;</span>);</span><br><span class="line">Method[] methods1 = c4.getDeclaredMethods();</span><br><span class="line">Method[] methods2 = c4.getMethods();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Method m : methods1) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;method = &quot;</span> + m);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;========&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Method m : methods2) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;DeclaredMethod = &quot;</span> + m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">method = <span class="keyword">public</span> <span class="keyword">int</span> bean.Person.getAge()</span><br><span class="line">method = <span class="keyword">public</span> <span class="keyword">void</span> bean.Person.setAge(<span class="keyword">int</span>)</span><br><span class="line">method = <span class="keyword">private</span> <span class="keyword">void</span> bean.Person.toast()</span><br><span class="line">method = <span class="keyword">public</span> java.lang.String bean.Person.toString()</span><br><span class="line">method = <span class="keyword">public</span> java.lang.String bean.Person.getName()</span><br><span class="line">method = <span class="keyword">public</span> <span class="keyword">void</span> bean.Person.setName(java.lang.String)</span><br><span class="line">========</span><br><span class="line">DeclaredMethod = <span class="keyword">public</span> <span class="keyword">int</span> bean.Person.getAge()</span><br><span class="line">DeclaredMethod = <span class="keyword">public</span> <span class="keyword">void</span> bean.Person.setAge(<span class="keyword">int</span>)</span><br><span class="line">DeclaredMethod = <span class="keyword">public</span> java.lang.String bean.Person.toString()</span><br><span class="line">DeclaredMethod = <span class="keyword">public</span> java.lang.String bean.Person.getName()</span><br><span class="line">DeclaredMethod = <span class="keyword">public</span> <span class="keyword">void</span> bean.Person.setName(java.lang.String)</span><br><span class="line">DeclaredMethod = <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> java.lang.Object.wait(<span class="keyword">long</span>,<span class="keyword">int</span>) <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line">DeclaredMethod = <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.wait(<span class="keyword">long</span>) <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line">DeclaredMethod = <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> java.lang.Object.wait() <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line">DeclaredMethod = <span class="keyword">public</span> <span class="keyword">boolean</span> java.lang.Object.equals(java.lang.Object)</span><br><span class="line">DeclaredMethod = <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> java.lang.Object.hashCode()</span><br><span class="line">DeclaredMethod = <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> java.lang.Class java.lang.Object.getClass()</span><br><span class="line">DeclaredMethod = <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.notify()</span><br><span class="line">DeclaredMethod = <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.notifyAll()</span><br></pre></td></tr></table></figure>

<h1 id="四、反射与泛型"><a href="#四、反射与泛型" class="headerlink" title="四、反射与泛型"></a>四、反射与泛型</h1><p>Java采用泛型擦除的机制来引入泛型，Java中的泛型仅仅是给编译器javac使用的.确保数据的安全性和免去强制类型转换问题，但是，一旦编译完成，所有和泛型有关的类型全部擦除。</p>
<p>为了通过反射操作这些类型，Java新增了<code>ParameterizedType</code>, <code>GenericArrayType</code>，<code>TypeVariable</code>和<code>WildcardType</code>几种类型来代表不能被归一到Class类中的类型.</p>
<ul>
<li>ParameterizedType:表示一种参数化类型，比如Collection<String></li>
<li>GenericArrayType：表示一种元素类型是参数化类型或者类型变量的数组类型</li>
<li>TypeVariable：是各种类型变量的公共父接口</li>
<li>WildcardType：代表一种通配符类型表达式</li>
</ul>
<img src="/pics/image-20220223222902328.png" alt="image-20220223222902328" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; c6 = Class.forName(<span class="string">&quot;bean.Person&quot;</span>);</span><br><span class="line">Method method = c6.getDeclaredMethod(<span class="string">&quot;getMap&quot;</span>, List.class, String.class);</span><br><span class="line">Type[] pType = method.getGenericParameterTypes();</span><br><span class="line"><span class="keyword">for</span> (Type type : pType) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;参数类型是 ：type1 = &quot;</span> + type);</span><br><span class="line">    <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">        Type[] p = ((ParameterizedType) type).getActualTypeArguments();</span><br><span class="line">        <span class="keyword">for</span> (Type t : p) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;参数类型是 ：type2 = &quot;</span> + t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;======分割线======&quot;</span>);</span><br><span class="line"></span><br><span class="line">Type rType = method.getGenericReturnType();</span><br><span class="line">System.out.println(<span class="string">&quot;返回类型是 ：type1 = &quot;</span> + rType);</span><br><span class="line"><span class="keyword">if</span> (rType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">    Type[] p = ((ParameterizedType) rType).getActualTypeArguments();</span><br><span class="line">    <span class="keyword">for</span> (Type t : p) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;返回类型是 ：type2 = &quot;</span> + t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">参数类型是 ：type1 = java.util.List&lt;bean.Person&gt;</span><br><span class="line">参数类型是 ：type2 = <span class="class"><span class="keyword">class</span> <span class="title">bean</span>.<span class="title">Person</span></span></span><br><span class="line"><span class="class">参数类型是 ：<span class="title">type1</span> </span>= <span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span></span></span><br><span class="line"><span class="class"></span>======分割线======</span><br><span class="line">返回类型是 ：type1 = java.util.Map&lt;java.lang.String, bean.Person&gt;</span><br><span class="line">返回类型是 ：type2 = <span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span></span></span><br><span class="line"><span class="class">返回类型是 ：<span class="title">type2</span> </span>= <span class="class"><span class="keyword">class</span> <span class="title">bean</span>.<span class="title">Person</span></span></span><br></pre></td></tr></table></figure>

<h1 id="五、反射与注解"><a href="#五、反射与注解" class="headerlink" title="五、反射与注解"></a>五、反射与注解</h1><p>通过反射获取注解主要使用是<code>getAnnotation</code>方法，这个方法可以作用于 <code>Class</code>，<code>Method</code>，<code>Field</code>, <code>Constructor</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(value = RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(value = &#123;ElementType.FIELD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">address</span><span class="params">()</span> <span class="keyword">default</span> &quot;cn&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@MyAnnotation(address = &quot;ru&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; c6 = Class.forName(<span class="string">&quot;bean.Person&quot;</span>);</span><br><span class="line">Field f = c6.getDeclaredField(<span class="string">&quot;address&quot;</span>);</span><br><span class="line">MyAnnotation annotation = f.getAnnotation(MyAnnotation.class);</span><br><span class="line">System.out.println(annotation.address());</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>注解和反射技术广泛应用于各种大型框架，这里介绍api都是比较基础的，如果要深入了解的话还是要多看官方文档，多实践。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.bilibili.com/video/BV1p4411P7V3?p=16">https://www.bilibili.com/video/BV1p4411P7V3?p=16</a></p>
<p><a href="https://www.cnblogs.com/baiqiantao/category/2098862.html?page=5">https://www.cnblogs.com/baiqiantao/category/2098862.html?page=5</a></p>
<p><a href="https://juejin.cn/post/6979844000312213541">https://juejin.cn/post/6979844000312213541</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
  <entry>
    <title>Java进阶02_泛型</title>
    <url>/2022/12/25/Notes/Java/04Advanced/Java%E8%BF%9B%E9%98%B602_%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="Java进阶02-泛型"><a href="#Java进阶02-泛型" class="headerlink" title="Java进阶02_泛型"></a>Java进阶02_泛型</h1><span id="more"></span>

<h1 id="一、什么是泛型"><a href="#一、什么是泛型" class="headerlink" title="一、什么是泛型"></a>一、什么是泛型</h1><p>Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了<code>编译时类型安全检测机制</code>，该机制允许程序员在<code>编译时检测到非法的类型</code>。</p>
<p>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。那么参数化类型怎么理解呢？顾名思义，在不创建新的类型的情况下，通过泛型指定的不同类型来控制具体限制的类型。</p>
<p>这种参数类型可以用在类、接口和方法中，分别被称为<a href="https://so.csdn.net/so/search?q=%E6%B3%9B%E5%9E%8B%E7%B1%BB&spm=1001.2101.3001.7020">泛型类</a>、泛型接口、泛型方法。</p>
<h2 id="1-1、为什么使用泛型"><a href="#1-1、为什么使用泛型" class="headerlink" title="1.1、为什么使用泛型"></a>1.1、为什么使用泛型</h2><p>先看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">arrayList.add(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">arrayList.add(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrayList.size(); i++) &#123;</span><br><span class="line">	String item = (String) arrayList.get(i);</span><br><span class="line"> 	System.out.println(<span class="string">&quot;泛型测试 item = &quot;</span> + item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 	输出，程序产生崩溃</span></span><br><span class="line">泛型测试 item = aaaa</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span><br><span class="line">	at Demo.main(Demo.java:<span class="number">15</span>)</span><br></pre></td></tr></table></figure>

<p><code>ArrayList</code>可以存放任意类型，例子中添加了一个String类型，添加了一个Integer类型，再使用时都以String的方式使用，因此程序崩溃了。为了解决类似这样的问题（在编译阶段就可以解决），泛型应运而生。</p>
<p>我们将第一行声明初始化list的代码更改一下，编译器会在编译阶段就能够帮我们发现类似这样的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">...</span><br><span class="line"><span class="comment">//arrayList.add(100); 在编译阶段，编译器就会报错</span></span><br></pre></td></tr></table></figure>

<p>也就是说泛型的目的：在编译期就发现并解决类型转换异常。</p>
<h2 id="1-2、泛型只在编译阶段有效"><a href="#1-2、泛型只在编译阶段有效" class="headerlink" title="1.2、泛型只在编译阶段有效"></a>1.2、泛型只在编译阶段有效</h2><p>看第二个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; stringArrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;Integer&gt; integerArrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">Class classStringArrayList = stringArrayList.getClass();</span><br><span class="line">Class classIntegerArrayList = integerArrayList.getClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(classStringArrayList.equals(classIntegerArrayList))&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;类型相同&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">类型相同</span><br></pre></td></tr></table></figure>



<h1 id="二、泛型使用"><a href="#二、泛型使用" class="headerlink" title="二、泛型使用"></a>二、泛型使用</h1><h2 id="2-1、泛型类和接口"><a href="#2-1、泛型类和接口" class="headerlink" title="2.1、泛型类和接口"></a>2.1、泛型类和接口</h2><p>泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。</p>
<h3 id="2-1-1、泛型类"><a href="#2-1-1、泛型类" class="headerlink" title="2.1.1、泛型类"></a>2.1.1、泛型类</h3><p>泛型类的最基本写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名称 &lt;泛型标识, 泛型标识...&gt;</span>&#123; <span class="comment">//常用的泛型标识 T、E、K、V</span></span><br><span class="line">  <span class="keyword">private</span> 泛型标识 成员变量类型 变量名; </span><br><span class="line">  		<span class="comment">//.....</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型类注意事项：</p>
<ul>
<li>泛型的类型参数只能是类类型，不能是基本类型</li>
<li>泛型类，如果操作时没有指定具体的数据类型，操作类型是<code>Object</code></li>
<li>泛型类型在逻辑上可以看成是多个不同类型，但实际上都是相同类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123; </span><br><span class="line">    <span class="comment">//key这个成员变量的类型为T,T的类型由外部指定  </span></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123; <span class="comment">//泛型构造方法形参key的类型也为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123; <span class="comment">//泛型方法getKey的返回值类型为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.泛型的类型参数只能是类类型（包括自定义类），不能是基本类型</span></span><br><span class="line">Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> Generic&lt;Integer&gt;(<span class="number">123456</span>);</span><br><span class="line">Generic&lt;String&gt; genericString = <span class="keyword">new</span> Generic&lt;String&gt;(<span class="string">&quot;key_value&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;泛型测试 key is &quot;</span> + genericInteger.getKey());</span><br><span class="line">System.out.println(<span class="string">&quot;泛型测试 key is &quot;</span> + genericString.getKey());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.如果操作时没有指定具体的数据类型，操作类型是`Object`</span></span><br><span class="line">Generic generic = <span class="keyword">new</span> Generic(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">Object object = generic.getKey();</span><br><span class="line">System.out.println(object);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.泛型类型在逻辑上可以看成是多个不同类型，但实际上都是相同类型</span></span><br><span class="line">System.out.println(genericInteger.getClass());</span><br><span class="line">System.out.println(genericString.getClass());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.不能对确切的泛型类型使用instanceof操作。如下面的操作是非法的，编译时会出错。</span></span><br><span class="line"><span class="keyword">if</span> (genericInteger <span class="keyword">instanceof</span> Generic&lt;Integer&gt;) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">泛型测试 key is <span class="number">123456</span></span><br><span class="line">泛型测试 key is key_value</span><br><span class="line">key</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generic</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Generic</span></span></span><br></pre></td></tr></table></figure>

<h3 id="2-1-2、泛型接口"><a href="#2-1-2、泛型接口" class="headerlink" title="2.1.2、泛型接口"></a>2.1.2、泛型接口</h3><p>泛型接口定义方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> 接口名称 &lt;泛型标识, 泛型标识...&gt;</span>&#123; <span class="comment">//常用的泛型标识 T、E、K、V</span></span><br><span class="line">	泛型标识 方法名; </span><br><span class="line">  		<span class="comment">//.....</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-3、泛型继承"><a href="#2-1-3、泛型继承" class="headerlink" title="2.1.3、泛型继承"></a>2.1.3、泛型继承</h3><p>泛型类继承的规则如下：</p>
<ul>
<li><p>子类也是泛型类，则子类要和父类的泛型一致</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildGeneric1</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChildGeneric1</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>子类不是泛型类，则父类要明确泛型的数据类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildGeneric2</span> <span class="keyword">extends</span> <span class="title">Generic</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChildGeneric2</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>泛型接口实现的规则，和泛型类继承差不多，也是2条：</p>
<ul>
<li>实现类不是泛型类，泛型接口要明确数据类型</li>
<li>实现类也是泛型类，实现类和接口的泛型要一致</li>
</ul>
<p>除了这2条规则外，子类是泛型类时还可以或保留父类部分泛型，增加自己的泛型。</p>
<p>总结一下：父类有泛型，子类可以选择<strong>保留，指定，扩展</strong>泛型：</p>
<ul>
<li>子类不保留父类的泛型，普通类<ul>
<li>没有类型（擦除）</li>
<li>指定具体类型</li>
</ul>
</li>
<li>子类保留父类的泛型，泛型子类<ul>
<li>全部保留</li>
<li>部分保留</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>&lt;<span class="title">T</span>, <span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> T t;</span><br><span class="line">     <span class="keyword">private</span> E e;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> t;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> E <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> e;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 1.全部擦除（子类不是泛型类）</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Child1</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 2.全部擦除 + 扩展</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Child2</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt; <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 3.全部保留</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Child3</span>&lt;<span class="title">T</span>, <span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Parent</span>&lt;<span class="title">T</span>, <span class="title">E</span>&gt; </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 4.全部保留 + 扩展</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Child4</span>&lt;<span class="title">T</span>, <span class="title">E</span>, <span class="title">K</span>&gt; <span class="keyword">extends</span> <span class="title">Parent</span>&lt;<span class="title">T</span>, <span class="title">E</span>&gt; </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 5.全部指定（子类不是泛型类）</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Child5</span> <span class="keyword">extends</span> <span class="title">Parent</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>&gt; </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 6.指定 + 部分保留</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Child6</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Parent</span>&lt;<span class="title">String</span>, <span class="title">E</span>&gt; </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 7.指定 + 保留 + 扩展</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Child7</span>&lt;<span class="title">T</span>, <span class="title">K</span>&gt; <span class="keyword">extends</span> <span class="title">Parent</span>&lt;<span class="title">T</span>, <span class="title">String</span>&gt; </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2、泛型方法"><a href="#2-2、泛型方法" class="headerlink" title="2.2、泛型方法"></a>2.2、泛型方法</h2><p>泛型方法的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 &lt;泛型标识, 泛型标识...&gt; 返回值类型 方法名（形参列表）&#123; <span class="comment">//常用的泛型标识 T、E、K、V</span></span><br><span class="line">	泛型标识 方法名; </span><br><span class="line">  		<span class="comment">//.....</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型方法的特征：</p>
<ul>
<li> 只有在返回值类型前申明 <T> 的方法才是泛型方法</li>
<li>泛型类中使用了泛型的成员方法并不是泛型方法</li>
<li>泛型方法能独立于泛型类产生变化，泛型方法所在的类是不是泛型类都没关系</li>
<li>静态方法中不能使用类的泛型</li>
<li> 泛型方法支持可变参数</li>
</ul>
<p>举例 ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//key这个成员变量的类型为T,T的类型由外部指定</span></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123; <span class="comment">//泛型构造方法形参key的类型也为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.不是一个泛型方法。</span></span><br><span class="line"><span class="comment">     *   这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。</span></span><br><span class="line"><span class="comment">     *   所以在这个方法中才可以继续使用 T 这个泛型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2.真正的泛型方法。</span></span><br><span class="line"><span class="comment">     * 首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T</span></span><br><span class="line"><span class="comment">     * 这个T可以出现在这个泛型方法的任意位置.</span></span><br><span class="line"><span class="comment">     * 泛型的数量也可以为任意多个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">showKeyName</span><span class="params">(T name)</span> </span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 3. 泛型类的泛型 和 泛型方法的泛型虽然申明都是 T，但是没有任何关系</span></span><br><span class="line">	<span class="comment">// Generic&lt;Integer&gt; integerGeneric = new Generic&lt;&gt;(1);</span></span><br><span class="line">	<span class="comment">// integerGeneric.showKeyName(&quot;myname&quot;);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 4.这个方法是有问题的，编译器会为我们提示错误信息：&quot;UnKnown class &#x27;E&#x27; &quot;</span></span><br><span class="line"><span class="comment">     * 虽然我们声明了&lt;T&gt;,也表明了这是一个可以处理泛型的类型的泛型方法。</span></span><br><span class="line"><span class="comment">     * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line"><span class="comment">//    public &lt;T&gt; T showKeyName(E name)&#123;</span></span><br><span class="line"><span class="comment">//     ...</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5.静态方法中不能使用类的泛型</span></span><br><span class="line">    <span class="comment">// 会报错：无法从静态上下文中引用非静态 类型变量 T</span></span><br><span class="line"><span class="comment">//    public static void showType(T t) &#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;T = &quot; + t.getClass());</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 6.静态的泛型方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, E&gt; <span class="function"><span class="keyword">void</span> <span class="title">showType</span><span class="params">(T t, E e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;T = &quot;</span> + t.getClass() + <span class="string">&quot;, E = &quot;</span> + e.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 7.泛型方法支持可变参数</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">printMsg</span><span class="params">( T... args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(T t : args)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;泛型测试 t is &quot;</span> + t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3、类型通配符"><a href="#2-3、类型通配符" class="headerlink" title="2.3、类型通配符"></a>2.3、类型通配符</h2><p>先来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue1</span><span class="params">(Generic&lt;Number&gt; obj)</span></span>&#123;</span><br><span class="line">   println(<span class="string">&quot;泛型测试 key value is &quot;</span> + obj.getKey());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Generic&lt;Number&gt; generic = <span class="keyword">new</span> Generic&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">Generic&lt;Integer&gt; integerGeneric = <span class="keyword">new</span> Generic&lt;&gt;(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">showKeyValue1(generic);</span><br><span class="line"><span class="comment">// 编译不过</span></span><br><span class="line"><span class="comment">// 报错：不兼容的类型: Generic&lt;java.lang.Integer&gt;无法转换为Generic&lt;java.lang.Number&gt;</span></span><br><span class="line"> showKeyValue1(integerGeneric);</span><br></pre></td></tr></table></figure>

<p>通过提示信息我们可以看到<code>Generic&lt;Integer&gt;</code>不能被看作为``Generic<Number><code>的子类。那该怎么解决这个问题，其中一种方法就是使用泛型通配符</code>?`。我们可以将上面的方法改一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showKeyValue2</span><span class="params">(Generic&lt;?&gt; obj)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 获取到的类型时Object</span></span><br><span class="line">    Object key = obj.getKey();</span><br><span class="line">    System.out.println(<span class="string">&quot;泛型测试 key value is &quot;</span> + key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意了，<strong>此处<code>?</code>是类型实参，而不是类型形参</strong> 。<code>?</code>和Number、String、Integer一样都是一种实际的类型，可以把<code>?</code>看成所有类型的父类(Object)，通过<code>getKey</code>获取到就是一个<code>Object</code>对象。</p>
<h3 id="2-3-1、类型通配符的上限"><a href="#2-3-1、类型通配符的上限" class="headerlink" title="2.3.1、类型通配符的上限"></a>2.3.1、类型通配符的上限</h3><p><code>&lt;? extends 实参类型&gt;</code>：也称作<code>子类限定通配符</code>要求该泛型的类型，只能是实参类型 或 实参类型的子类类型。</p>
<p>上面的问题，我们使用类型通配符也能解决。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showKeyValue3</span><span class="params">(Generic&lt;? extends Number&gt; obj)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 注意此时我们获取到的类型是父类型 Number</span></span><br><span class="line">    Number key = obj.getKey();</span><br><span class="line">    System.out.println(<span class="string">&quot;泛型测试 key value is &quot;</span> + key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>上限类型统配符不能添加元素</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(List&lt;? extends Number&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可以获取</span></span><br><span class="line">    Number number = list.get(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 添加报错,原因：</span></span><br><span class="line">    <span class="comment">// 申明时这里的范围是, [-∞, Number], 假设传入的是List&lt;Integer&gt;,</span></span><br><span class="line">    <span class="comment">// 如果允许添加元素, 那么当我们添加的是Double或者其他 非Integer的子类 就会产生异常</span></span><br><span class="line">    <span class="comment">// list.add(1.0)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-2、类型通配符下限"><a href="#2-3-2、类型通配符下限" class="headerlink" title="2.3.2、类型通配符下限"></a>2.3.2、类型通配符下限</h3><p><code>&lt;? super 实参类型&gt;</code>:也称为<code>父类限定通配符</code>，要求该类的类型，只能是 实参类型 或者 实参类型的父类类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BigCat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">BigCat</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MiniCat</span> <span class="keyword">extends</span> <span class="title">Cat</span> </span>&#123; &#125;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">superAdd</span><span class="params">(List&lt;? <span class="keyword">super</span> Cat&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.[Number, +∞], 上限是 无穷大,所get的得到的对象是 Object 类型</span></span><br><span class="line">    Object cat = list.get(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 2.添加注意，不能添加 Cat 的父类</span></span><br><span class="line">    <span class="comment">// 假设我们的集合传入的是 List&lt;Cat&gt;, 如果我们允许添加 父类的话，</span></span><br><span class="line">    <span class="comment">// 我们不能确定 ？ 代表的是到底是 Animal 还是 BigCat，如果是BigCat就会产生错误</span></span><br><span class="line">    <span class="comment">// list.add(new Animal()); // 报错</span></span><br><span class="line">    list.add(<span class="keyword">new</span> Cat());</span><br><span class="line">    list.add(<span class="keyword">new</span> MiniCat());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Cat&gt; cats = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;MiniCat&gt; miniCats = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">superAdd(cats);</span><br><span class="line"><span class="comment">// 报错：</span></span><br><span class="line"><span class="comment">// 不兼容的类型: java.util.List&lt;Demo.MiniCat&gt;无法转换为java.util.List&lt;? super Demo.Cat&gt;</span></span><br><span class="line">superAdd(miniCats);</span><br></pre></td></tr></table></figure>

<h3 id="2-3-3、PECS原则"><a href="#2-3-3、PECS原则" class="headerlink" title="2.3.3、PECS原则"></a>2.3.3、PECS原则</h3><p>了解了上下界通配符后，那么问题来了，究竟什么时候调用extends 什么时候用 super?</p>
<p>答案是PECP原则：全称为 <code>Producer-Extends-Consumer-Super</code>。</p>
<ul>
<li><code>&lt;? extends 实参类型&gt;</code>：从泛型类读取类型 T 的数据，并且不能写入，用于生产者环境（Producer）；</li>
<li><code>&lt;? super 实参类型&gt;</code>： 从集合中写入类型 T 的数据，并且不需要读取，用于消费者场景（Consumer）；</li>
</ul>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(List&lt;? <span class="keyword">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; src.size(); i++)</span><br><span class="line">        dest.set(i, src.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://stackoverflow.com/questions/4343202/difference-between-super-t-and-extends-t-in-java#">https://stackoverflow.com/questions/4343202/difference-between-super-t-and-extends-t-in-java#</a></p>
<h3 id="2-3-4、类、方法与上下边界"><a href="#2-3-4、类、方法与上下边界" class="headerlink" title="2.3.4、类、方法与上下边界"></a>2.3.4、类、方法与上下边界</h3><p>在使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在泛型方法中添加上下边界限制的时候，必须在<code>访问权限</code>与<code>返回值</code>之间的<T>上添加上下边界。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译器会报错：&quot;Unexpected bound&quot;</span></span><br><span class="line"><span class="comment">//public &lt;T&gt; T showKeyName(Generic&lt;T extends Number&gt; container)&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T extends Number&gt; <span class="function">T <span class="title">showKeyName</span><span class="params">(Generic&lt;T&gt; container)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;container key :&quot;</span> + container.getKey());</span><br><span class="line">    T test = container.getKey();</span><br><span class="line">    <span class="keyword">return</span> test;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、类型擦除"><a href="#三、类型擦除" class="headerlink" title="三、类型擦除"></a>三、类型擦除</h1><h2 id="3-1、类型擦除"><a href="#3-1、类型擦除" class="headerlink" title="3.1、类型擦除"></a>3.1、类型擦除</h2><p>Java的泛型是伪泛型，这是因为Java在编译期间，所有的泛型信息都会被擦掉。Java的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程成为<strong>类型擦除</strong>。</p>
<img src="/pics/image-20220616003748215.png" alt="image-20220616003748215" style="zoom:50%;" />

<p>先看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; stringArrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;Integer&gt; integerArrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">Class classStringArrayList = stringArrayList.getClass();</span><br><span class="line">Class classIntegerArrayList = integerArrayList.getClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (classStringArrayList.equals(classIntegerArrayList)) &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;类型相同 = &quot;</span> + stringArrayList.getClass().getSimpleName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">类型相同 = ArrayList</span><br></pre></td></tr></table></figure>

<p>通过上面的例子可以证明，Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦除，只保留了<code>原始类型</code>。</p>
<h2 id="3-2、原始类型"><a href="#3-2、原始类型" class="headerlink" title="3.2、原始类型"></a>3.2、原始类型</h2><p>什么是原始类型？</p>
<p><strong>原始类型</strong> 就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型，无论何时定义一个泛型，相应的原始类型都会被自动提供，类型变量擦除，并使用其<strong>限定类型</strong>（无限定的变量用Object）替换。</p>
<p>第二个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Erasure</span> &lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Erasure2</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Erasure&lt;Integer&gt; integerErasure = <span class="keyword">new</span> Erasure&lt;&gt;();</span><br><span class="line">Class&lt;?&gt; cls = integerErasure.getClass();</span><br><span class="line">Field[] fields = cls.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;无限制类型擦除：&quot;</span> + field.getType().getSimpleName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Erasure2&lt;Number&gt; numberErasure = <span class="keyword">new</span> Erasure2&lt;&gt;();</span><br><span class="line">Class&lt;?&gt; cls2 = numberErasure.getClass();</span><br><span class="line">Field[] fields2 = cls2.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span> (Field field : fields2) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;有限制类型擦除：&quot;</span> + field.getType().getSimpleName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line">无限制类型擦除：Object</span><br><span class="line">有限制类型擦除：Number</span><br></pre></td></tr></table></figure>

<p>总结下：</p>
<ul>
<li>泛型无限制的类型擦除时，类型是：<code>Object</code></li>
<li><code>&lt;? extend 实参类型&gt;</code>有限制类型时，类型是：限制类型</li>
</ul>
<h2 id="3-3、桥接方法"><a href="#3-3、桥接方法" class="headerlink" title="3.3、桥接方法"></a>3.3、桥接方法</h2><p>现在有这样一个泛型类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child8</span> <span class="keyword">extends</span> <span class="title">Generic</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Child8</span><span class="params">(Integer key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在子类中，我们覆盖了父类的两个方法，我们的原意是这样的：将父类的泛型类型限定为<code>Integer</code>，那么父类里面方法的参数都为<code>Date</code>类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">super</span>.getKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，我们在子类中重写这两个方法一点问题也没有，实际上，从他们的<code>@Override</code>标签中也可以看到，一点问题也没有，实际上是这样的吗？</p>
<p>在编译完成，类型擦除后，父类的泛型类型变为了原始类型<code>Object</code>，所以父类编译之后会变成下面的样子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generic</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Object value;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>再看子类重写的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getValue</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getValue();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个是参数<code>Object</code>类型，一个是<code>Date</code>类型，可是我们发现，根本就没有这样的一个子类继承自父类的返回值是Object类型参数的方法。为什么会这样呢？</p>
<p>其实是这样的，我们传入父类的泛型类型<code>Integer</code>，我们的本意是将泛型父类类变为如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(Integer key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再子类中重写参数类型为Date的那两个方法，实现继承中的多态。可是在编译阶段，JVM会将类型擦除掉，变为原始类型<code>Object</code>。这样就导致，我们的本意是重写，实现多态。可是类型擦除后，只能变为了重载。类型擦除就和多态有了冲突。</p>
<p>那JVM是如何解决这问题的呢？其实就是采用桥接方法的方法。最终JVM编译生成的子类转换成Java代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child8</span> <span class="keyword">extends</span> <span class="title">Generic</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 桥接方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">volatile</span> Object <span class="title">getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、Java-自限定类型"><a href="#四、Java-自限定类型" class="headerlink" title="四、Java 自限定类型"></a>四、Java 自限定类型</h1><p>java中有一种泛型称之<code>自限定泛型</code>，定义是<strong>父类作为一个泛型类或泛型接口，用子类的名字作为其类型参数</strong>。</p>
<p>主要作用是：限定类型实例就只能和同类型的实例进行交互</p>
<h2 id="4-1、普通泛型类"><a href="#4-1、普通泛型类" class="headerlink" title="4.1、普通泛型类"></a>4.1、普通泛型类</h2><p>我们先看下不使用自限定时，普通类如何构成构成自限定：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicHolder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T element;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">        element = arg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(element.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subtype</span> <span class="keyword">extends</span> <span class="title">BasicHolder</span>&lt;<span class="title">Subtype</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Subtype st1 = <span class="keyword">new</span> Subtype(), st2 = <span class="keyword">new</span> Subtype(), st3 = <span class="keyword">new</span> Subtype();</span><br><span class="line">    st1.set(st2);</span><br><span class="line">    st2.set(st3);</span><br><span class="line">    Subtype st4 = st1.get().get();</span><br><span class="line">    st1.f();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：SubType</span></span><br></pre></td></tr></table></figure>

<p>分析下以上的代码：</p>
<ul>
<li><code>BasicHolder&lt;T&gt;</code>泛型类的类型参数并没有什么边界，在继承它的时候，可以<code>class A extends BasicHolder&lt;B&gt; &#123;&#125;</code>这样普通用。</li>
<li>但是<code>class Subtype extends BasicHolder&lt;Subtype&gt; &#123;&#125;</code>这样，就构成了自限定。从定义上来说，<code>Sbutype</code>继承的父类的类型参数是自己。从使用上来说，Subtype对象本身的类型是Subtype，且Subtype对象继承而来的成员(element)、方法的形参(set方法)、方法的返回值(get方法)也是Subtype。这样Subtype对象就只允许和Subtype对象交互，而不能是别的类型对象。</li>
</ul>
<p>正因为<code>class Subtype extends BasicHolder&lt;Subtype&gt;</code>这样用可以让<code>Subtype</code>对象只允许和<code>Subtype</code>对象交互，这里再把<code>Subtype</code>抽象成类型参数T，不就刚好变成了<code>T extends SelfBounded&lt;T&gt;</code>这样的写法。</p>
<h2 id="4-2、自限定类型的泛型类"><a href="#4-2、自限定类型的泛型类" class="headerlink" title="4.2、自限定类型的泛型类"></a>4.2、自限定类型的泛型类</h2><p>第二个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自限定类型的标准用法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//所有</span></span><br><span class="line">    T element;</span><br><span class="line"></span><br><span class="line">    <span class="function">SelfBounded&lt;T&gt; <span class="title">set</span><span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">        element = arg;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.一般用法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">A</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.编译ok，B继承SelfBounded时，给定的具体类型A确实满足了边界。不过B对象没有自限定的效果了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">A</span>&gt; </span>&#123;</span><br><span class="line">&#125; <span class="comment">// It&#x27;s OK.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.在自己新增的成员方法里，去调用继承来的成员方法。注意，继承来的方法被限定类型为C即自身了，这就是自限定的效果</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">C</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">C <span class="title">setAndGet</span><span class="params">(C arg)</span> </span>&#123;</span><br><span class="line">        set(arg);</span><br><span class="line">        <span class="keyword">return</span> get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. D 没有 extend SelfBounded&lt;D&gt;,导致E会报错</span></span><br><span class="line"><span class="comment">// [Compile error]: Type parameter D is not within its bound</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// class E extends SelfBounded&lt;D&gt; &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.编译 ok，但是失去了限定的作用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    A a = <span class="keyword">new</span> A();</span><br><span class="line">    a.set(<span class="keyword">new</span> A());</span><br><span class="line">    System.out.println(a.get().getClass().getSimpleName());</span><br><span class="line">    C c = <span class="keyword">new</span> C();</span><br><span class="line">    c = c.setAndGet(<span class="keyword">new</span> C());</span><br><span class="line">    System.out.println(c.getClass().getSimpleName());</span><br><span class="line"></span><br><span class="line">    F f = <span class="keyword">new</span> F();</span><br><span class="line">    f.set(<span class="keyword">new</span> F());</span><br><span class="line">    System.out.println(f.get().getClass().getSimpleName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以将自限定用于泛型方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态方法要求T自限定，且边界是SelfBounded。那么之前定义的A类型就符合要求了</span></span><br><span class="line"><span class="keyword">static</span> &lt;T extends SelfBounded&lt;T&gt;&gt; <span class="function">T <span class="title">f</span><span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> arg.set(arg).get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A a2 = <span class="keyword">new</span> A();</span><br><span class="line">System.out.println(f(a2).getClass().getSimpleName());</span><br></pre></td></tr></table></figure>

<h2 id="4-3、自限定泛型与协变"><a href="#4-3、自限定泛型与协变" class="headerlink" title="4.3、自限定泛型与协变"></a>4.3、自限定泛型与协变</h2><p><a href="https://www.cnblogs.com/storml/p/8124224.html">https://www.cnblogs.com/storml/p/8124224.html</a></p>
<h1 id="五、泛型与数组"><a href="#五、泛型与数组" class="headerlink" title="五、泛型与数组"></a>五、泛型与数组</h1><h2 id="5-1、泛型类型数组对象"><a href="#5-1、泛型类型数组对象" class="headerlink" title="5.1、泛型类型数组对象"></a>5.1、泛型类型数组对象</h2><p>可以声明带泛型的数组引用，但是不能直接创建一个带泛型类型的数组对象</p>
<p>也就是说下面的这个例子是不可以的：</p>
<p><code>List&lt;String&gt;[] ls = new ArrayList&lt;String&gt;[10];  </code></p>
<p>而使用通配符创建泛型数组是可以的：</p>
<p><code>List&lt;?&gt;[] ls = new ArrayList&lt;?&gt;[10];</code> </p>
<p>这样也是可以的：</p>
<p><code>List&lt;String&gt;[] ls = new ArrayList[10];</code></p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt;[] lsa = <span class="keyword">new</span> List&lt;String&gt;[<span class="number">10</span>]; <span class="comment">// Not really allowed.    </span></span><br><span class="line">Object o = lsa;    </span><br><span class="line">Object[] oa = (Object[]) o;    </span><br><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();    </span><br><span class="line">li.add(<span class="keyword">new</span> Integer(<span class="number">3</span>));    </span><br><span class="line">oa[<span class="number">1</span>] = li; <span class="comment">// Unsound, but passes run time store check    </span></span><br><span class="line">String s = lsa[<span class="number">1</span>].get(<span class="number">0</span>); <span class="comment">// Run-time error: ClassCastException.</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种情况下，由于JVM泛型的擦除机制，在运行时JVM是不知道泛型信息的，所以可以给oa[1]赋上一个ArrayList而不会出现异常，但是在取出数据的时候却要做一次类型转换，所以就会出现ClassCastException，如果可以进行泛型数组的声明，上面说的这种情况在编译期将不会出现任何的警告和错误，只有在运行时才会出错。</p>
<p>而对泛型数组的声明进行限制，对于这样的情况，可以在编译期提示代码有类型安全问题，比没有任何提示要强很多。</p>
</blockquote>
<p>以上问题，采用通配符的方式是被允许的：<code>数组的类型不可以是类型变量，除非是采用通配符的方式</code>，因为对于通配符的方式，最后取出数据是要做显式的类型转换的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;?&gt;[] lsa = <span class="keyword">new</span> List&lt;?&gt;[<span class="number">10</span>]; <span class="comment">// OK, array of unbounded wildcard type.    </span></span><br><span class="line">Object o = lsa;    </span><br><span class="line">Object[] oa = (Object[]) o;    </span><br><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();    </span><br><span class="line">li.add(<span class="keyword">new</span> Integer(<span class="number">3</span>));    </span><br><span class="line">oa[<span class="number">1</span>] = li; <span class="comment">// Correct.    </span></span><br><span class="line">Integer i = (Integer) lsa[<span class="number">1</span>].get(<span class="number">0</span>); <span class="comment">// OK </span></span><br></pre></td></tr></table></figure>

<p>第二种方式如下：举例二</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList[] ls = <span class="keyword">new</span> ArrayList[<span class="number">10</span>];</span><br><span class="line"><span class="comment">// 引用指向String</span></span><br><span class="line">ArrayList&lt;String&gt;[] listArray = ls;</span><br><span class="line">ArrayList&lt;Integer&gt; listInt = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">listInt.add(<span class="number">100</span>);</span><br><span class="line"><span class="comment">// 操作 ls 0</span></span><br><span class="line">ls[<span class="number">0</span>] = listInt;</span><br><span class="line"><span class="comment">// 运行报错，java.lang.ClassCastException: </span></span><br><span class="line"><span class="comment">// java.lang.Integer cannot be cast to java.lang.String</span></span><br><span class="line">String s= listArray[<span class="number">0</span>].get(<span class="number">0</span>);</span><br><span class="line">System.out.println(s);</span><br><span class="line"></span><br><span class="line">=====</span><br><span class="line"><span class="comment">// 声明类型</span></span><br><span class="line">ArrayList&lt;String&gt;[] listArray = <span class="keyword">new</span> ArrayList[<span class="number">10</span>];</span><br><span class="line">ArrayList&lt;Integer&gt; listInt = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">listInt.add(<span class="number">100</span>);</span><br><span class="line"><span class="comment">// 编译报错</span></span><br><span class="line"><span class="comment">// 不兼容的类型: java.util.ArrayList&lt;java.lang.Integer&gt;无法转换为java.util.ArrayList&lt;java.lang.String&gt;</span></span><br><span class="line"><span class="comment">//listArray[0] = listInt;</span></span><br><span class="line">String s= listArray[<span class="number">0</span>].get(<span class="number">0</span>);</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>

<h2 id="5-2、反射方式创建T"><a href="#5-2、反射方式创建T" class="headerlink" title="5.2、反射方式创建T[]"></a>5.2、反射方式创建T[]</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"> <span class="comment">// 不能直接创建数组，会报错</span></span><br><span class="line"> <span class="comment">// private T[] array = new T[3];</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T[] array;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fruit</span><span class="params">(Class&lt;T&gt; clz, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        array = (T[]) Array.newInstance(clz, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T t, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        array[index] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fruit&lt;String&gt; fruit = <span class="keyword">new</span> Fruit&lt;&gt;(String.class, <span class="number">5</span>);</span><br><span class="line">fruit.put(<span class="string">&quot;apple&quot;</span>, <span class="number">0</span>);</span><br><span class="line">fruit.put(<span class="string">&quot;banana&quot;</span>, <span class="number">1</span>);</span><br><span class="line">System.out.println(fruit.get(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">banana </span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/s10461/article/details/53941091">https://blog.csdn.net/s10461/article/details/53941091</a></p>
<p><a href="https://www.cnblogs.com/storml/p/8124224.html">https://www.cnblogs.com/storml/p/8124224.html</a></p>
<p><a href="https://blog.csdn.net/anlian523/article/details/102511783">https://blog.csdn.net/anlian523/article/details/102511783</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
        <category>Java进阶</category>
      </categories>
  </entry>
  <entry>
    <title>Java进阶03_动态代理</title>
    <url>/2022/12/25/Notes/Java/04Advanced/Java%E8%BF%9B%E9%98%B603_%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h1 id="Java进阶03-动态代理原理"><a href="#Java进阶03-动态代理原理" class="headerlink" title="Java进阶03_动态代理原理"></a>Java进阶03_动态代理原理</h1><span id="more"></span>

<p>代理模式（Proxy Pattern）是开发中广泛应用的一种结构型设计模式，适合于AOP的业务场景 比如日志框架、全局性异常处理等。代理模式的实现有2种，静态代理和动态代理，这篇文章，我们主要讨论最基本的 JDK 动态代理。</p>
<p>JDK 动态代理（Dymanic Proxy API）是 JDK1.3 中引入的特性，核心 API 是 Proxy 类和 InvocationHandler 接口。它的原理是利用反射机制在运行时生成代理类的字节码。</p>
<h1 id="一、基本使用"><a href="#一、基本使用" class="headerlink" title="一、基本使用"></a>一、基本使用</h1><p>Step1、定义接口和实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">select</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;查询 selectById&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;更新 update&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Step2: 定义<code>InvocationHandler</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 被代理的对象，实际的方法执行者</span></span><br><span class="line">    Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxyHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        Object result = method.invoke(target, args);  <span class="comment">// 调用 target 的 method 方法</span></span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>step3、定义DynamicProxy 工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">createProxy</span><span class="params">(Object proxyObject)</span> </span>&#123;</span><br><span class="line">        DynamicProxyHandler handler = <span class="keyword">new</span> DynamicProxyHandler(proxyObject);</span><br><span class="line">        <span class="comment">// 根据指定的类装载器、一组接口 &amp; 调用处理器 生成动态代理类实例，并最终返回</span></span><br><span class="line">        <span class="comment">// 参数说明：</span></span><br><span class="line">        <span class="comment">// 参数1：指定产生代理对象的类加载器，需要将其指定为和目标对象同一个类加载器</span></span><br><span class="line">        <span class="comment">// 参数2：指定目标对象的实现接口</span></span><br><span class="line">        <span class="comment">// 即要给目标对象提供一组什么接口。若提供了一组接口给它，那么该代理对象就默认实现了该接口，这样就能调用这组接口中的方法</span></span><br><span class="line">        <span class="comment">// 参数3：指定InvocationHandler对象。即动态代理对象在调用方法时，会关联到哪个InvocationHandler对象</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(proxyObject.getClass().getClassLoader(), proxyObject.getClass().getInterfaces(), handler);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserService proxy = (UserService) createProxy(<span class="keyword">new</span> UserServiceImpl());</span><br><span class="line">        proxy.select();</span><br><span class="line">        proxy.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">before ...</span><br><span class="line">查询 selectById</span><br><span class="line">after ...</span><br><span class="line">before ...</span><br><span class="line">更新 update</span><br><span class="line">after ...</span><br></pre></td></tr></table></figure>

<p>可以看到，经过如上的步骤，我们就可以实现一个动态代理的效果，在<code>UserService</code>执行的前后打印日志</p>
<h1 id="二、源码分析"><a href="#二、源码分析" class="headerlink" title="二、源码分析"></a>二、源码分析</h1><p>这一节，我们来分析 JDK 动态代理的源码，核心类是 Proxy，主要分析 Proxy 如何生成代理类，以及如何将方法调用统一分发到 InvocationHandler 接口。</p>
<h2 id="2-1、代理对象的获取过程"><a href="#2-1、代理对象的获取过程" class="headerlink" title="2.1、代理对象的获取过程"></a>2.1、代理对象的获取过程</h2><h3 id="Proxy-newProxyInstance"><a href="#Proxy-newProxyInstance" class="headerlink" title="Proxy#newProxyInstance"></a><code>Proxy#newProxyInstance</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      InvocationHandler h)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line">		<span class="comment">// 1、接口 clone</span></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 2.安全检查</span></span><br><span class="line">    <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Look up or generate the designated proxy class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 3. 获得代理类的class 对象</span></span><br><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Invoke its constructor with the designated invocation handler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">        <span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4. 反射 返回代理类的实例</span></span><br><span class="line">        <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">    		<span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Proxy#newProxyInstance</code>主要步骤有3步：</p>
<p>1、获取代理类的 Class </p>
<p>2、反射创建代理类对象</p>
<h3 id="Proxy-getProxyClass0"><a href="#Proxy-getProxyClass0" class="headerlink" title="Proxy#getProxyClass0"></a><code>Proxy#getProxyClass0</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                       Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;interface limit exceeded&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the proxy class defined by the given loader implementing</span></span><br><span class="line">    <span class="comment">// the given interfaces exists, this will simply return the cached copy;</span></span><br><span class="line">    <span class="comment">// otherwise, it will create the proxy class via the ProxyClassFactory</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="proxyClassCache-get"><a href="#proxyClassCache-get" class="headerlink" title="proxyClassCache#get"></a><code>proxyClassCache#get</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">    proxyClassCache = <span class="keyword">new</span> WeakCache&lt;&gt;(<span class="keyword">new</span> KeyFactory(), <span class="keyword">new</span> ProxyClassFactory());</span><br></pre></td></tr></table></figure>

<p>从缓存中获取代理类，如果缓存未命中，则通过ProxyClassFactory生成代理类</p>
<h3 id="ProxyClassFactory-apply"><a href="#ProxyClassFactory-apply" class="headerlink" title="ProxyClassFactory#apply"></a><code>ProxyClassFactory#apply</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyClassFactory</span> <span class="keyword">implements</span> <span class="title">BiFunction</span>&lt;<span class="title">ClassLoader</span>, <span class="title">Class</span>&lt;?&gt;[], <span class="title">Class</span>&lt;?&gt;&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 代理类命名前缀</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String proxyClassNamePrefix = <span class="string">&quot;$Proxy&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 代理类命名后缀，从 0 递增（原子 Long）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong nextUniqueNumber = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line">        Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class="line">        <span class="comment">// 3 参数校验</span></span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">            <span class="comment">// 验证参数 interfaces 和 ClassLoder 中加载的是同一个类</span></span><br><span class="line">            <span class="comment">// 验证参数 interfaces 是接口类型</span></span><br><span class="line">            <span class="comment">// 验证参数 interfaces 中没有重复项</span></span><br><span class="line">            <span class="comment">// 否则抛出 IllegalArgumentException</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 验证所有non-public接口来自同一个包</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4（一般地）代理类包名</span></span><br><span class="line">        <span class="comment">// public static final String PROXY_PACKAGE = &quot;com.sun.proxy&quot;;</span></span><br><span class="line">        String proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="string">&quot;.&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 代理类的全限定名</span></span><br><span class="line">        <span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">        String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6 生成字节码数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7 从字节码生成 Class 对象</span></span><br><span class="line">        <span class="keyword">return</span> defineClass0(loader, proxyName,proxyClassFile, <span class="number">0</span>, proxyClassFile.length); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6 生成字节码数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] generateProxyClass(<span class="keyword">final</span> String var0, Class[] var1) &#123;</span><br><span class="line">    ProxyGenerator var2 = <span class="keyword">new</span> ProxyGenerator(var0, var1);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] var3 = var2.generateClassFile();</span><br><span class="line">    <span class="keyword">return</span> var3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ProxyGenerator-generateClassFile"><a href="#ProxyGenerator-generateClassFile" class="headerlink" title="ProxyGenerator#generateClassFile"></a><code>ProxyGenerator#generateClassFile</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] generateClassFile() &#123;</span><br><span class="line">    <span class="comment">//1、只代理Object的hashCode、equals和toString</span></span><br><span class="line">    <span class="keyword">this</span>.addProxyMethod(hashCodeMethod, Object.class);</span><br><span class="line">    <span class="keyword">this</span>.addProxyMethod(equalsMethod, Object.class);</span><br><span class="line">    <span class="keyword">this</span>.addProxyMethod(toStringMethod, Object.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、代理接口的每个方法</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span>(var1 = <span class="number">0</span>; var1 &lt; <span class="keyword">this</span>.interfaces.length; ++var1) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3、 添加带有 InvocationHandler 参数的构造器</span></span><br><span class="line">    <span class="keyword">this</span>.methods.add(<span class="keyword">this</span>.generateConstructor());</span><br><span class="line">    var7 = <span class="keyword">this</span>.proxyMethods.values().iterator();</span><br><span class="line">    <span class="keyword">while</span>(var7.hasNext()) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//4、在每个代理的方法中调用InvocationHandler#invoke()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5、输出字节流</span></span><br><span class="line">    ByteArrayOutputStream var9 = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    DataOutputStream var10 = <span class="keyword">new</span> DataOutputStream(var9);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> var9.toByteArray();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ProxyGenerator.<span class="function">MethodInfo <span class="title">generateConstructor</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     ProxyGenerator.MethodInfo var1 = <span class="keyword">new</span> ProxyGenerator.MethodInfo(<span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(Ljava/lang/reflect/InvocationHandler;)V&quot;</span>, <span class="number">1</span>);<span class="comment">// 1165</span></span><br><span class="line">     DataOutputStream var2 = <span class="keyword">new</span> DataOutputStream(var1.code);<span class="comment">// 1169</span></span><br><span class="line">     <span class="keyword">this</span>.code_aload(<span class="number">0</span>, var2);<span class="comment">// 1171</span></span><br><span class="line">     <span class="keyword">this</span>.code_aload(<span class="number">1</span>, var2);<span class="comment">// 1173</span></span><br><span class="line">     var2.writeByte(<span class="number">183</span>);<span class="comment">// 1175</span></span><br><span class="line">     var2.writeShort(<span class="keyword">this</span>.cp.getMethodRef(<span class="string">&quot;java/lang/reflect/Proxy&quot;</span>, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(Ljava/lang/reflect/InvocationHandler;)V&quot;</span>));<span class="comment">// 1176</span></span><br><span class="line">     var2.writeByte(<span class="number">177</span>);<span class="comment">// 1180</span></span><br><span class="line">     var1.maxStack = <span class="number">10</span>;<span class="comment">// 1182</span></span><br><span class="line">     var1.maxLocals = <span class="number">2</span>;<span class="comment">// 1183</span></span><br><span class="line">     var1.declaredExceptions = <span class="keyword">new</span> <span class="keyword">short</span>[<span class="number">0</span>];<span class="comment">// 1184</span></span><br><span class="line">     <span class="keyword">return</span> var1;<span class="comment">// 1186</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>代理对象获取的核心的流程就是生成字节码文件，再使用 <code>defineClass</code> 将文件转换成Class，最后通过反射创建Class 的实例对象。JDK 动态代理生成的代理类命名为 <code>com.sun.proxy$Proxy</code>[从0开始的数字]（例如：com.sun.proxy$Proxy0），这个类继承自 <code>java.lang.reflect.Proxy</code>。其内部还有一个参数为 <code>InvocationHandler</code> 的构造器，对于代理接口的方法调用都会分发到 <code>InvocationHandler#invoke</code>。</p>
<h2 id="2-2、查看Proxy-文件"><a href="#2-2、查看Proxy-文件" class="headerlink" title="2.2、查看Proxy 文件"></a>2.2、查看Proxy 文件</h2><p>ProxyGenerator#generateProxyClass 其实是一个静态 public 方法，所以我们直接调用，并将代理类 Class 的字节流写入磁盘文件。</p>
<p>启动时 <code>-Dsun.misc.ProxyGenerator.saveGeneratedFiles=true</code></p>
<img src="/../pics/image-20220724172623025.png" alt="image-20220724172623025" style="zoom:20%;" />



<img src="/../pics/image-20220724173004155.png" alt="image-20220724173004155" style="zoom:30%;" />

<p>生成的字节码文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sun.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"><span class="keyword">import</span> proxy.dynamic.UserService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 包含5 个代理方法 其中3个 是Object 类的方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m4;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m4, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>);</span><br><span class="line">            m4 = Class.forName(<span class="string">&quot;proxy.dynamic.UserService&quot;</span>).getMethod(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">            m3 = Class.forName(<span class="string">&quot;proxy.dynamic.UserService&quot;</span>).getMethod(<span class="string">&quot;update&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，是<code>$Proxy0</code> 的声明是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">UserService</span></span></span><br></pre></td></tr></table></figure>

<p>Java 不支持多继承也就是说，<strong>jdk动态代理无法代理非接口实现类</strong>。当然非要杠的话，请移步<a href="https://juejin.cn/post/6974018412158664734#heading-15%E3%80%82">https://juejin.cn/post/6974018412158664734#heading-15。</a></p>
<h1 id="三、CGLib"><a href="#三、CGLib" class="headerlink" title="三、CGLib"></a>三、CGLib</h1><p>除了 JDK动态代理外，Java 领域应用比较广的另外一个动态代理技术是<a href="https://mp.weixin.qq.com/s?__biz=MzIwMDEzOTYzNA==&mid=2247486217&idx=1&sn=2c5e18b019c914f28c38cd8f8d9d47b3&chksm=9680fd14a1f7740289a62d67ba4da453aaf454a0be13d28ca62f9d51d53645b4f5f51bdcea90&scene=21#wechat_redirect">cglib</a>。</p>
<p>cglib实质上是通过通过字节码增强技术动态的创建代理对象，通过继承父类并重写父类的方法达到生成代理类。</p>
<p>优点：代理的类无需实现接口，执行速度相对JDK动态代理较高；</p>
<p>缺点：基于类的继承，那么final类和final方法一定无法通过cglib代理；也不能代理<code>private</code> 的方法</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
      </categories>
  </entry>
</search>
