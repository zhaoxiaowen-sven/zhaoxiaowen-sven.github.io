<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zhaoxiaowen-sven.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="ASM_01一、ASM 与ClassFile1.1、 ASM 与ClassFileClassFile文件结构我们都知道，在.class文件中，存储的是ByteCode数据。但是，这些ByteCode数据并不是杂乱无章的，而是遵循一定的数据结构。  这个.class文件遵循的数据结构就是由Java Virtual Machine Specification中定义的 The class File Fo">
<meta property="og:type" content="article">
<meta property="og:title" content="ASM01">
<meta property="og:url" content="https://zhaoxiaowen-sven.github.io/2022/12/26/Notes/ASM/ASM01/index.html">
<meta property="og:site_name" content="Sven&#39;s blog">
<meta property="og:description" content="ASM_01一、ASM 与ClassFile1.1、 ASM 与ClassFileClassFile文件结构我们都知道，在.class文件中，存储的是ByteCode数据。但是，这些ByteCode数据并不是杂乱无章的，而是遵循一定的数据结构。  这个.class文件遵循的数据结构就是由Java Virtual Machine Specification中定义的 The class File Fo">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/javac-from-dot-java-to-dot-class.jpeg">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/class-file-asm-tree.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/asm-study-three-levels.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/asm-core-classes.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/jvm-architecture.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/frame-local-variables-operand-stack.png">
<meta property="article:published_time" content="2022-12-26T12:21:08.503Z">
<meta property="article:modified_time" content="2023-01-02T09:48:56.917Z">
<meta property="article:author" content="sven">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhaoxiaowen-sven.github.io/pics/javac-from-dot-java-to-dot-class.jpeg">

<link rel="canonical" href="https://zhaoxiaowen-sven.github.io/2022/12/26/Notes/ASM/ASM01/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>ASM01 | Sven's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
      <a target="_blank" rel="noopener" href="https://github.com/zhaoxiaowen-sven" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Sven's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhaoxiaowen-sven.github.io/2022/12/26/Notes/ASM/ASM01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ASM01
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-26 20:21:08" itemprop="dateCreated datePublished" datetime="2022-12-26T20:21:08+08:00">2022-12-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ASM/" itemprop="url" rel="index"><span itemprop="name">ASM</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="ASM-01"><a href="#ASM-01" class="headerlink" title="ASM_01"></a>ASM_01</h1><h1 id="一、ASM-与ClassFile"><a href="#一、ASM-与ClassFile" class="headerlink" title="一、ASM 与ClassFile"></a>一、ASM 与ClassFile</h1><h2 id="1-1、-ASM-与ClassFile"><a href="#1-1、-ASM-与ClassFile" class="headerlink" title="1.1、 ASM 与ClassFile"></a>1.1、 ASM 与ClassFile</h2><h3 id="ClassFile文件结构"><a href="#ClassFile文件结构" class="headerlink" title="ClassFile文件结构"></a>ClassFile文件结构</h3><p>我们都知道，在<code>.class</code>文件中，存储的是ByteCode数据。但是，这些ByteCode数据并不是杂乱无章的，而是遵循一定的数据结构。</p>
<p><img src="/pics/javac-from-dot-java-to-dot-class.jpeg" alt="From Java to Class"></p>
<p>这个<code>.class</code>文件遵循的数据结构就是由<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">Java Virtual Machine Specification</a>中定义的 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">The class File Format</a>，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic;</span><br><span class="line">    u2             minor_version;</span><br><span class="line">    u2             major_version;</span><br><span class="line">    u2             constant_pool_count;</span><br><span class="line">    cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];</span><br><span class="line">    u2             access_flags;</span><br><span class="line">    u2             this_class;</span><br><span class="line">    u2             super_class;</span><br><span class="line">    u2             interfaces_count;</span><br><span class="line">    u2             interfaces[interfaces_count];</span><br><span class="line">    u2             fields_count;</span><br><span class="line">    field_info     fields[fields_count];</span><br><span class="line">    u2             methods_count;</span><br><span class="line">    method_info    methods[methods_count];</span><br><span class="line">    u2             attributes_count;</span><br><span class="line">    attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ASM与ClassFile的关系"><a href="#ASM与ClassFile的关系" class="headerlink" title="ASM与ClassFile的关系"></a>ASM与ClassFile的关系</h3><p>为了大家更直观的理解ASM与ClassFile之间关系，我们用下图来表示。其中，<strong>Java ClassFile相当于“树根”部分，ObjectWeb ASM相当于“树干”部分，而ASM的各种应用场景属于“树枝”或“树叶”部分</strong>。</p>
<p><img src="/pics/class-file-asm-tree.png" alt="ASM与ClassFile的关系"></p>
<p>学习ASM有三个不同的层次：</p>
<ul>
<li>第一个层次，<strong>ASM的应用层面</strong>。也就是说，<strong>ASM能够做什么</strong>？对于一个<code>.class</code>文件来说，我们可以使用ASM进行analysis、generation和transformation操作。</li>
<li>第二个层次，<strong>ASM的源码层面</strong>。也就是，<strong>ASM的两个组成部分</strong>，它为分Core API和Tree API的内容。</li>
<li>第三个层次，<strong>Java ClassFile层面</strong>。从JVM规范的角度，来理解<code>.class</code>文件的结构，来理解ASM中方法和参数的含义。</li>
</ul>
<p>在这里，<strong>希望大家能够将之前介绍的相关内容（ASM能够做什么、ASM的组成部分）组织在一起进行理解</strong>：</p>
<p><img src="/pics/asm-study-three-levels.png" alt="asm"></p>
<h2 id="1-2、ASMPrint"><a href="#1-2、ASMPrint" class="headerlink" title="1.2、ASMPrint"></a>1.2、ASMPrint</h2><p>在刚开始学习ASM的时候，编写ASM代码是不太容易的。或者，有些人原来对ASM很熟悉，但由于长时间不使用ASM，编写ASM代码也会有一些困难。在本文当中，我们介绍一个<code>ASMPrint</code>类，它能帮助我们将<code>.class</code>文件转换为ASM代码，这个功能非常实用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.objectweb.asm.ClassReader;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.util.ASMifier;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.util.Printer;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.util.Textifier;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.util.TraceClassVisitor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里的代码是参考自&#123;<span class="doctag">@link</span> org.objectweb.asm.util.Printer#main&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ASMPrint</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// (1) 设置参数</span></span><br><span class="line">        String className = <span class="string">&quot;sample.HelloWorld&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> parsingOptions = ClassReader.SKIP_FRAMES | ClassReader.SKIP_DEBUG;</span><br><span class="line">        <span class="keyword">boolean</span> asmCode = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (2) 打印结果</span></span><br><span class="line">        Printer printer = asmCode ? <span class="keyword">new</span> ASMifier() : <span class="keyword">new</span> Textifier();</span><br><span class="line">        PrintWriter printWriter = <span class="keyword">new</span> PrintWriter(System.out, <span class="keyword">true</span>);</span><br><span class="line">        TraceClassVisitor traceClassVisitor = <span class="keyword">new</span> TraceClassVisitor(<span class="keyword">null</span>, printer, printWriter);</span><br><span class="line">        <span class="keyword">new</span> ClassReader(className).accept(traceClassVisitor, parsingOptions);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、XXVisitor"><a href="#二、XXVisitor" class="headerlink" title="二、XXVisitor"></a>二、XXVisitor</h1><h2 id="2-1、ClassVisitor"><a href="#2-1、ClassVisitor" class="headerlink" title="2.1、ClassVisitor"></a>2.1、ClassVisitor</h2><p>在ASM Core API中，最重要的三个类就是<code>ClassReader</code>、<code>ClassVisitor</code>和<code>ClassWriter</code>类。在进行Class Generation操作的时候，<code>ClassVisitor</code>和<code>ClassWriter</code>这两个类起着重要作用，而并不需要<code>ClassReader</code>类的参与。在本文当中，我们将对<code>ClassVisitor</code>类进行介绍。</p>
<p><img src="/pics/asm-core-classes.png" alt="ASM里的核心类"></p>
<h3 id="定义的方法"><a href="#定义的方法" class="headerlink" title="定义的方法"></a>定义的方法</h3><p><code>ClassVisitor</code>类定义的方法有哪些。在ASM当中，使用到了Visitor Pattern（访问者模式），所以<code>ClassVisitor</code>当中许多的<code>visitXxx()</code>方法。</p>
<p>虽然，在<code>ClassVisitor</code>类当中，有许多<code>visitXxx()</code>方法，但是，我们只需要关注这4个方法：<code>visit()</code>、<code>visitField()</code>、<code>visitMethod()</code>和<code>visitEnd()</code>。</p>
<p>为什么只关注这4个方法呢？因为这4个方法是<code>ClassVisitor</code>类的精髓或骨架，在这个“骨架”的基础上，其它的<code>visitXxx()</code>都容易扩展；同时，将<code>visitXxx()</code>方法缩减至4个，也能减少学习过程中的认知负担，学起来更容易。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ClassVisitor &#123;</span><br><span class="line">    public void visit(</span><br><span class="line">        final int version,</span><br><span class="line">        final int access,</span><br><span class="line">        final String name,</span><br><span class="line">        final String signature,</span><br><span class="line">        final String superName,</span><br><span class="line">        final String[] interfaces);</span><br><span class="line">    public FieldVisitor visitField( // 访问字段</span><br><span class="line">        final int access,</span><br><span class="line">        final String name,</span><br><span class="line">        final String descriptor,</span><br><span class="line">        final String signature,</span><br><span class="line">        final Object value);</span><br><span class="line">    public MethodVisitor visitMethod( // 访问方法</span><br><span class="line">        final int access,</span><br><span class="line">        final String name,</span><br><span class="line">        final String descriptor,</span><br><span class="line">        final String signature,</span><br><span class="line">        final String[] exceptions);</span><br><span class="line">    public void visitEnd();</span><br><span class="line">    // ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>ClassVisitor</code>的<code>visit()</code>方法、<code>visitField()</code>方法和<code>visitMethod()</code>方法中都带有<code>signature</code>参数。这个<code>signature</code>参数与“泛型”密切相关；换句话说，如果处理的是一个带有泛型信息的类、字段或方法，那么就需要给<code>signature</code>参数提供一定的值；如果处理的类、字段或方法不带有“泛型”信息，那么将<code>signature</code>参数设置为<code>null</code>就可以了。在本次课程当中，我们不去考虑“泛型”相关的内容，所以我们都将<code>signature</code>参数设置成<code>null</code>值。</p>
<p>如果大家对<code>signature</code>参数感兴趣，我们可以使用之前介绍的<code>PrintASMCodeCore</code>类去打印一下某个泛型类的ASM代码。例如，<code>java.lang.Comparable</code>是一个泛型接口，我们就可以使用<code>PrintASMCodeCore</code>类来打印一下它的ASM代码，从来查看<code>signature</code>参数的值是什么。</p>
<h3 id="方法调用顺序"><a href="#方法调用顺序" class="headerlink" title="方法调用顺序"></a>方法调用顺序</h3><p>在<code>ClassVisitor</code>类当中，定义了多个<code>visitXxx()</code>方法。这些<code>visitXxx()</code>方法，遵循一定的调用顺序（可参考API文档）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">visit</span><br><span class="line">[visitSource][visitModule][visitNestHost][visitPermittedSubclass][visitOuterClass]</span><br><span class="line">(</span><br><span class="line"> visitAnnotation |</span><br><span class="line"> visitTypeAnnotation |</span><br><span class="line"> visitAttribute</span><br><span class="line">)*</span><br><span class="line">(</span><br><span class="line"> visitNestMember |</span><br><span class="line"> visitInnerClass |</span><br><span class="line"> visitRecordComponent |</span><br><span class="line"> visitField |</span><br><span class="line"> visitMethod</span><br><span class="line">)* </span><br><span class="line">visitEnd</span><br></pre></td></tr></table></figure>

<p>其中，涉及到一些符号，它们的含义如下：</p>
<ul>
<li><code>[]</code>: 表示最多调用一次，可以不调用，但最多调用一次。</li>
<li><code>()</code>和<code>|</code>: 表示在多个方法之间，可以选择任意一个，并且多个方法之间不分前后顺序。</li>
<li><code>*</code>: 表示方法可以调用0次或多次。</li>
</ul>
<p>在本次课程当中，我们只关注<code>ClassVisitor</code>类当中的<code>visit()</code>方法、<code>visitField()</code>方法、<code>visitMethod()</code>方法和<code>visitEnd()</code>方法这4个方法，所以上面的方法调用顺序可以简化如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">visit</span><br><span class="line">(</span><br><span class="line"> visitField |</span><br><span class="line"> visitMethod</span><br><span class="line">)* </span><br><span class="line">visitEnd</span><br></pre></td></tr></table></figure>

<p>先调用<code>visit()</code>方法，接着调用<code>visitField()</code>方法或<code>visitMethod()</code>方法，最后调用<code>visitEnd()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                ┌─── visit()</span><br><span class="line">                │</span><br><span class="line">                ├─── visitField()</span><br><span class="line">ClassVisitor ───┤</span><br><span class="line">                ├─── visitMethod()</span><br><span class="line">                │</span><br><span class="line">                └─── visitEnd()</span><br></pre></td></tr></table></figure>

<h2 id="2-2、ClassWriter介绍"><a href="#2-2、ClassWriter介绍" class="headerlink" title="2.2、ClassWriter介绍"></a>2.2、ClassWriter介绍</h2><h3 id="构造方法-constructors"><a href="#构造方法-constructors" class="headerlink" title="构造方法 constructors"></a>构造方法 constructors</h3><p><code>ClassWriter</code>的父类是<code>ClassVisitor</code>，因此<code>ClassWriter</code>类继承了<code>visit()</code>、<code>visitField()</code>、<code>visitMethod()</code>和<code>visitEnd()</code>等方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class ClassWriter extends ClassVisitor &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ClassWriter</code>定义的构造方法有两个，这里只关注其中一个，也就是只接收一个<code>int</code>类型参数的构造方法。在使用<code>new</code>关键字创建<code>ClassWriter</code>对象时，推荐使用<code>COMPUTE_FRAMES</code>参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ClassWriter extends ClassVisitor &#123;</span><br><span class="line">    /* A flag to automatically compute the maximum stack size and the maximum number of local variables of methods. */</span><br><span class="line">    public static final int COMPUTE_MAXS = 1;</span><br><span class="line">    /* A flag to automatically compute the stack map frames of methods from scratch. */</span><br><span class="line">    public static final int COMPUTE_FRAMES = 2;</span><br><span class="line"></span><br><span class="line">    // flags option can be used to modify the default behavior of this class.</span><br><span class="line">    // Must be zero or more of COMPUTE_MAXS and COMPUTE_FRAMES.</span><br><span class="line">    public ClassWriter(final int flags) &#123;</span><br><span class="line">        this(null, flags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>COMPUTE_MAXS</code>: A flag to automatically compute <strong>the maximum stack size</strong> and <strong>the maximum number of local variables</strong> of methods. If this flag is set, then the arguments of the <code>MethodVisitor.visitMaxs</code> method of the <code>MethodVisitor</code> returned by the <code>visitMethod</code> method will be ignored, and computed automatically from the signature and the bytecode of each method.</li>
<li><code>COMPUTE_FRAMES</code>: A flag to automatically compute <strong>the stack map frames</strong> of methods from scratch. If this flag is set, then the calls to the <code>MethodVisitor.visitFrame</code> method are ignored, and the stack map frames are recomputed from the methods bytecode. The arguments of the <code>MethodVisitor.visitMaxs</code> method are also ignored and recomputed from the bytecode. In other words, <code>COMPUTE_FRAMES</code> implies <code>COMPUTE_MAXS</code>.</li>
</ul>
<p>小总结：</p>
<ul>
<li><code>COMPUTE_MAXS</code>: 计算max stack和max local信息。</li>
<li><code>COMPUTE_FRAMES</code>: 既计算stack map frame信息，又计算max stack和max local信息。</li>
</ul>
<p>换句话说，<code>COMPUTE_FRAMES</code>是功能最强大的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMPUTE_FRAMES = COMPUTE_MAXS + stack map frame</span><br></pre></td></tr></table></figure>

<h3 id="如何使用ClassWriter"><a href="#如何使用ClassWriter" class="headerlink" title="如何使用ClassWriter"></a>如何使用ClassWriter</h3><p>使用<code>ClassWriter</code>生成一个Class文件，可以大致分成三个步骤：</p>
<ul>
<li>第一步，创建<code>ClassWriter</code>对象。</li>
<li>第二步，调用<code>ClassWriter</code>对象的<code>visitXxx()</code>方法。</li>
<li>第三步，调用<code>ClassWriter</code>对象的<code>toByteArray()</code>方法。</li>
</ul>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.objectweb.asm.ClassWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.objectweb.asm.Opcodes.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldGenerateCore</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] dump () <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// (1) 创建ClassWriter对象</span></span><br><span class="line">        ClassWriter cw = <span class="keyword">new</span> ClassWriter(ClassWriter.COMPUTE_FRAMES);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (2) 调用visitXxx()方法</span></span><br><span class="line">        cw.visit();</span><br><span class="line">        cw.visitField();</span><br><span class="line">        cw.visitMethod();</span><br><span class="line">        cw.visitEnd();       <span class="comment">// 注意，最后要调用visitEnd()方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// (3) 调用toByteArray()方法</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = cw.toByteArray();</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3、FieldVisitor类"><a href="#2-3、FieldVisitor类" class="headerlink" title="2.3、FieldVisitor类"></a>2.3、FieldVisitor类</h2><p>在学习<code>FieldVisitor</code>类的时候，可以与<code>ClassVisitor</code>类进行对比，这两个类在结构上有很大的相似性：两者都是抽象类，都定义了两个字段，都定义了两个构造方法，都定义了<code>visitXxx()</code>方法。</p>
<h3 id="定义的方法-1"><a href="#定义的方法-1" class="headerlink" title="定义的方法"></a>定义的方法</h3><p><code>FieldVisitor</code>类定义的方法有哪些。</p>
<p>在<code>FieldVisitor</code>类当中，一共定义了4个<code>visitXxx()</code>方法，但是，我们只需要关注其中的<code>visitEnd()</code>方法就可以了。</p>
<p>我们为什么只关注<code>visitEnd()</code>方法呢？因为我们刚开始学习ASM，有许多东西不太熟悉，为了减少我们的学习和认知“负担”，那么对于一些非必要的方法，我们就暂时忽略它；将<code>visitXxx()</code>方法精简到一个最小的认知集合，那么就只剩下<code>visitEnd()</code>方法了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldVisitor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (fv != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fv.visitEnd();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，在<code>FieldVisitor</code>类内定义的多个<code>visitXxx()</code>方法，也需要遵循一定的调用顺序，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line"> visitAnnotation |</span><br><span class="line"> visitTypeAnnotation |</span><br><span class="line"> visitAttribute</span><br><span class="line">)*</span><br><span class="line">visitEnd</span><br></pre></td></tr></table></figure>

<p>由于我们只关注<code>visitEnd()</code>方法，那么，这个调用顺序就变成如下这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visitEnd</span><br></pre></td></tr></table></figure>

<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><h4 id="预期目标"><a href="#预期目标" class="headerlink" title="预期目标"></a>预期目标</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface HelloWorld &#123;</span><br><span class="line">    int intValue = 100;</span><br><span class="line">    String strValue = &quot;ABC&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lsieun.utils.FileUtils;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.ClassWriter;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.FieldVisitor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.objectweb.asm.Opcodes.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldGenerateCore</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String relative_path = <span class="string">&quot;sample/HelloWorld.class&quot;</span>;</span><br><span class="line">        String filepath = FileUtils.getFilePath(relative_path);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (1) 生成byte[]内容</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = dump();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (2) 保存byte[]到文件</span></span><br><span class="line">        FileUtils.writeBytes(filepath, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] dump() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// (1) 创建ClassWriter对象</span></span><br><span class="line">        ClassWriter cw = <span class="keyword">new</span> ClassWriter(ClassWriter.COMPUTE_FRAMES);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (2) 调用visitXxx()方法</span></span><br><span class="line">        cw.visit(V1_8, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, <span class="string">&quot;sample/HelloWorld&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            FieldVisitor fv1 = cw.visitField(ACC_PUBLIC | ACC_FINAL | ACC_STATIC, <span class="string">&quot;intValue&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="keyword">null</span>, <span class="number">100</span>);</span><br><span class="line">            fv1.visitEnd();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            FieldVisitor fv2 = cw.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, <span class="string">&quot;strValue&quot;</span>, <span class="string">&quot;Ljava/lang/String;&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;ABC&quot;</span>);</span><br><span class="line">            fv2.visitEnd();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cw.visitEnd();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (3) 调用toByteArray()方法</span></span><br><span class="line">        <span class="keyword">return</span> cw.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4、FieldWriter类"><a href="#2-4、FieldWriter类" class="headerlink" title="2.4、FieldWriter类"></a>2.4、FieldWriter类</h2><p><code>FieldWriter</code>类继承自<code>FieldVisitor</code>类。在<code>ClassWriter</code>类里，<code>visitField()</code>方法的实现就是通过<code>FieldWriter</code>类来实现的。</p>
<p><code>FieldWriter</code>类的父类是<code>FieldVisitor</code>类。需要注意的是，<code>FieldWriter</code>类并不带有<code>public</code>修饰，因此它的有效访问范围只局限于它所处的package当中，不能像其它的<code>public</code>类一样被外部所使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldWriter</span> <span class="keyword">extends</span> <span class="title">FieldVisitor</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="fields"><a href="#fields" class="headerlink" title="fields"></a>fields</h3><p><code>FieldWriter</code>类定义的字段有哪些。在<code>FieldWriter</code>类当中，一些字段如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">final class FieldWriter extends FieldVisitor &#123;</span><br><span class="line">    private final int accessFlags;</span><br><span class="line">    private final int nameIndex;</span><br><span class="line">    private final int descriptorIndex;</span><br><span class="line">    private Attribute firstAttribute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些字段与ClassFile当中的<code>field_info</code>是对应的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">field_info &#123;</span><br><span class="line">    u2             access_flags;</span><br><span class="line">    u2             name_index;</span><br><span class="line">    u2             descriptor_index;</span><br><span class="line">    u2             attributes_count;</span><br><span class="line">    attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h3><p><code>FieldWriter</code>类定义的方法有哪些。在<code>FieldWriter</code>类当中，有两个重要的方法：<code>computeFieldInfoSize()</code>和<code>putFieldInfo()</code>方法。这两个方法会在<code>ClassWriter</code>类的<code>toByteArray()</code>方法内使用到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldWriter</span> <span class="keyword">extends</span> <span class="title">FieldVisitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">computeFieldInfoSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The access_flags, name_index, descriptor_index and attributes_count fields use 8 bytes.</span></span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">8</span>;</span><br><span class="line">        <span class="comment">// For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.</span></span><br><span class="line">        <span class="keyword">if</span> (constantValueIndex != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// ConstantValue attributes always use 8 bytes.</span></span><br><span class="line">            symbolTable.addConstantUtf8(Constants.CONSTANT_VALUE);</span><br><span class="line">            size += <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">putFieldInfo</span><span class="params">(<span class="keyword">final</span> ByteVector output)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> useSyntheticAttribute = symbolTable.getMajorVersion() &lt; Opcodes.V1_5;</span><br><span class="line">        <span class="comment">// Put the access_flags, name_index and descriptor_index fields.</span></span><br><span class="line">        <span class="keyword">int</span> mask = useSyntheticAttribute ? Opcodes.ACC_SYNTHETIC : <span class="number">0</span>;</span><br><span class="line">        output.putShort(accessFlags &amp; ~mask).putShort(nameIndex).putShort(descriptorIndex);</span><br><span class="line">        <span class="comment">// Compute and put the attributes_count field.</span></span><br><span class="line">        <span class="comment">// For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.</span></span><br><span class="line">        <span class="keyword">int</span> attributesCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (constantValueIndex != <span class="number">0</span>) &#123;</span><br><span class="line">            ++attributesCount;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        output.putShort(attributesCount);</span><br><span class="line">        <span class="comment">// Put the field_info attributes.</span></span><br><span class="line">        <span class="comment">// For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.</span></span><br><span class="line">        <span class="keyword">if</span> (constantValueIndex != <span class="number">0</span>) &#123;</span><br><span class="line">            output</span><br><span class="line">              .putShort(symbolTable.addConstantUtf8(Constants.CONSTANT_VALUE))</span><br><span class="line">              .putInt(<span class="number">2</span>)</span><br><span class="line">              .putShort(constantValueIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FieldWriter类的使用"><a href="#FieldWriter类的使用" class="headerlink" title="FieldWriter类的使用"></a>FieldWriter类的使用</h3><p>关于<code>FieldWriter</code>类的使用，它主要出现在<code>ClassWriter</code>类当中的<code>visitField()</code>和<code>toByteArray()</code>方法内。</p>
<h4 id="visitField方法"><a href="#visitField方法" class="headerlink" title="visitField方法"></a>visitField方法</h4><p>在<code>ClassWriter</code>类当中，<code>visitField()</code>方法代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ClassWriter extends ClassVisitor &#123;</span><br><span class="line">    public final FieldVisitor visitField(int access, String name, String descriptor, String signature, Object value) &#123;</span><br><span class="line">        FieldWriter fieldWriter = new FieldWriter(symbolTable, access, name, descriptor, signature, value);</span><br><span class="line">        if (firstField == null) &#123;</span><br><span class="line">            firstField = fieldWriter;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            lastField.fv = fieldWriter;</span><br><span class="line">        &#125;</span><br><span class="line">        return lastField = fieldWriter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="toByteArray方法"><a href="#toByteArray方法" class="headerlink" title="toByteArray方法"></a>toByteArray方法</h4><p>在<code>ClassWriter</code>类当中，<code>toByteArray()</code>方法代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassWriter</span> <span class="keyword">extends</span> <span class="title">ClassVisitor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] toByteArray() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// First step: compute the size in bytes of the ClassFile structure.</span></span><br><span class="line">        <span class="comment">// The magic field uses 4 bytes, 10 mandatory fields (minor_version, major_version,</span></span><br><span class="line">        <span class="comment">// constant_pool_count, access_flags, this_class, super_class, interfaces_count, fields_count,</span></span><br><span class="line">        <span class="comment">// methods_count and attributes_count) use 2 bytes each, and each interface uses 2 bytes too.</span></span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">24</span> + <span class="number">2</span> * interfaceCount;</span><br><span class="line">        <span class="keyword">int</span> fieldsCount = <span class="number">0</span>;</span><br><span class="line">        FieldWriter fieldWriter = firstField;</span><br><span class="line">        <span class="keyword">while</span> (fieldWriter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ++fieldsCount;</span><br><span class="line">            size += fieldWriter.computeFieldInfoSize();    <span class="comment">// 这里是对FieldWriter.computeFieldInfoSize()方法的调用</span></span><br><span class="line">            fieldWriter = (FieldWriter) fieldWriter.fv;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Second step: allocate a ByteVector of the correct size (in order to avoid any array copy in</span></span><br><span class="line">        <span class="comment">// dynamic resizes) and fill it with the ClassFile content.</span></span><br><span class="line">        ByteVector result = <span class="keyword">new</span> ByteVector(size);</span><br><span class="line">        result.putInt(<span class="number">0xCAFEBABE</span>).putInt(version);</span><br><span class="line">        symbolTable.putConstantPool(result);</span><br><span class="line">        <span class="keyword">int</span> mask = (version &amp; <span class="number">0xFFFF</span>) &lt; Opcodes.V1_5 ? Opcodes.ACC_SYNTHETIC : <span class="number">0</span>;</span><br><span class="line">        result.putShort(accessFlags &amp; ~mask).putShort(thisClass).putShort(superClass);</span><br><span class="line">        result.putShort(interfaceCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interfaceCount; ++i) &#123;</span><br><span class="line">            result.putShort(interfaces[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        result.putShort(fieldsCount);</span><br><span class="line">        fieldWriter = firstField;</span><br><span class="line">        <span class="keyword">while</span> (fieldWriter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fieldWriter.putFieldInfo(result);             <span class="comment">// 这里是对FieldWriter.putFieldInfo()方法的调用</span></span><br><span class="line">            fieldWriter = (FieldWriter) fieldWriter.fv;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Third step: replace the ASM specific instructions, if any.</span></span><br><span class="line">        <span class="keyword">if</span> (hasAsmInstructions) &#123;</span><br><span class="line">            <span class="keyword">return</span> replaceAsmInstructions(result.data, hasFrames);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> result.data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-5、MethodVisitor"><a href="#2-5、MethodVisitor" class="headerlink" title="2.5、MethodVisitor"></a>2.5、MethodVisitor</h2><p>从类的结构来说，<code>MethodVisitor</code>类与<code>ClassVisitor</code>类和<code>FieldVisitor</code>类是非常相似性的。</p>
<p>第一个部分，<code>MethodVisitor</code>类是一个<code>abstract</code>类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public abstract class MethodVisitor &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个部分，<code>MethodVisitor</code>类定义的字段有哪些。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodVisitor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> api;</span><br><span class="line">    <span class="keyword">protected</span> MethodVisitor mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三个部分，<code>MethodVisitor</code>类定义的构造方法有哪些。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public abstract class MethodVisitor &#123;</span><br><span class="line">    public MethodVisitor(final int api) &#123;</span><br><span class="line">        this(api, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MethodVisitor(final int api, final MethodVisitor methodVisitor) &#123;</span><br><span class="line">        this.api = api;</span><br><span class="line">        this.mv = methodVisitor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义的方法-2"><a href="#定义的方法-2" class="headerlink" title="定义的方法"></a>定义的方法</h3><p>在<code>MethodVisitor</code>类当中，定义了许多的<code>visitXxx()</code>方法，我们列出了其中的一些方法，内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodVisitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitInsn</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> opcode)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitIntInsn</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> opcode, <span class="keyword">final</span> <span class="keyword">int</span> operand)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitVarInsn</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> opcode, <span class="keyword">final</span> <span class="keyword">int</span> <span class="keyword">var</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitTypeInsn</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> opcode, <span class="keyword">final</span> String type)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitFieldInsn</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> opcode, <span class="keyword">final</span> String owner, <span class="keyword">final</span> String name, <span class="keyword">final</span> String descriptor)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitMethodInsn</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> opcode, <span class="keyword">final</span> String owner, <span class="keyword">final</span> String name, <span class="keyword">final</span> String descriptor,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">final</span> <span class="keyword">boolean</span> isInterface)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitInvokeDynamicInsn</span><span class="params">(<span class="keyword">final</span> String name, <span class="keyword">final</span> String descriptor, <span class="keyword">final</span> Handle bootstrapMethodHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="keyword">final</span> Object... bootstrapMethodArguments)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitJumpInsn</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> opcode, <span class="keyword">final</span> Label label)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitLabel</span><span class="params">(<span class="keyword">final</span> Label label)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitLdcInsn</span><span class="params">(<span class="keyword">final</span> Object value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitIincInsn</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> <span class="keyword">var</span>, <span class="keyword">final</span> <span class="keyword">int</span> increment)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitTableSwitchInsn</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> min, <span class="keyword">final</span> <span class="keyword">int</span> max, <span class="keyword">final</span> Label dflt, <span class="keyword">final</span> Label... labels)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitLookupSwitchInsn</span><span class="params">(<span class="keyword">final</span> Label dflt, <span class="keyword">final</span> <span class="keyword">int</span>[] keys, <span class="keyword">final</span> Label[] labels)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitMultiANewArrayInsn</span><span class="params">(<span class="keyword">final</span> String descriptor, <span class="keyword">final</span> <span class="keyword">int</span> numDimensions)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitTryCatchBlock</span><span class="params">(<span class="keyword">final</span> Label start, <span class="keyword">final</span> Label end, <span class="keyword">final</span> Label handler, <span class="keyword">final</span> String type)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitMaxs</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> maxStack, <span class="keyword">final</span> <span class="keyword">int</span> maxLocals)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitEnd</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这些<code>visitXxx()</code>方法，它们分别有什么作用呢？我们有三方面的资料可能参阅：</p>
<ul>
<li>第一，从ASM API的角度来讲，我们可以查看API文档，来具体了解某一个方法是要实现什么样的作用，该方法所接收的参数代表什么含义。</li>
<li>第二，从ClassFile的角度来讲，这些<code>visitXxxInsn()</code>方法的本质就是组装instruction的内容。我们可以参考<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">Java Virtual Machine Specification</a>的<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html">Chapter 6. The Java Virtual Machine Instruction Set</a>部分。</li>
<li>第三，《<a target="_blank" rel="noopener" href="https://lsieun.github.io/java/asm/java-asm-season-02.html">Java ASM系列二：OPCODE</a>》，主要是对opcode进行介绍。</li>
</ul>
<h3 id="方法调用顺序-1"><a href="#方法调用顺序-1" class="headerlink" title="方法调用顺序"></a>方法调用顺序</h3><p>在<code>MethodVisitor</code>类当中，定义了许多的<code>visitXxx()</code>方法，这些方法的调用，也要遵循一定的顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(visitParameter)*</span><br><span class="line">[visitAnnotationDefault]</span><br><span class="line">(visitAnnotation | visitAnnotableParameterCount | visitParameterAnnotation | visitTypeAnnotation | visitAttribute)*</span><br><span class="line">[</span><br><span class="line">    visitCode</span><br><span class="line">    (</span><br><span class="line">        visitFrame |</span><br><span class="line">        visitXxxInsn |</span><br><span class="line">        visitLabel |</span><br><span class="line">        visitInsnAnnotation |</span><br><span class="line">        visitTryCatchBlock |</span><br><span class="line">        visitTryCatchAnnotation |</span><br><span class="line">        visitLocalVariable |</span><br><span class="line">        visitLocalVariableAnnotation |</span><br><span class="line">        visitLineNumber</span><br><span class="line">    )*</span><br><span class="line">    visitMaxs</span><br><span class="line">]</span><br><span class="line">visitEnd</span><br></pre></td></tr></table></figure>

<p>我们可以把这些<code>visitXxx()</code>方法分成三组：</p>
<ul>
<li>第一组，在<code>visitCode()</code>方法之前的方法。这一组的方法，主要负责parameter、annotation和attributes等内容，这些内容并不是方法当中“必不可少”的一部分；在当前课程当中，我们暂时不去考虑这些内容，可以忽略这一组方法。</li>
<li>第二组，在<code>visitCode()</code>方法和<code>visitMaxs()</code>方法之间的方法。这一组的方法，主要负责当前方法的“方法体”内的opcode内容。其中，<code>visitCode()</code>方法，标志着方法体的开始，而<code>visitMaxs()</code>方法，标志着方法体的结束。</li>
<li>第三组，是<code>visitEnd()</code>方法。这个<code>visitEnd()</code>方法，是最后一个进行调用的方法。</li>
</ul>
<p>对这些<code>visitXxx()</code>方法进行精简之后，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    visitCode</span><br><span class="line">    (</span><br><span class="line">        visitFrame |</span><br><span class="line">        visitXxxInsn |</span><br><span class="line">        visitLabel |</span><br><span class="line">        visitTryCatchBlock</span><br><span class="line">    )*</span><br><span class="line">    visitMaxs</span><br><span class="line">]</span><br><span class="line">visitEnd</span><br></pre></td></tr></table></figure>

<p>这些方法的调用顺序，可以记忆如下：</p>
<ul>
<li>第一步，调用<code>visitCode()</code>方法，调用一次。</li>
<li>第二步，调用<code>visitXxxInsn()</code>方法，可以调用多次。对这些方法的调用，就是在构建方法的“方法体”。</li>
<li>第三步，调用<code>visitMaxs()</code>方法，调用一次。</li>
<li>第四步，调用<code>visitEnd()</code>方法，调用一次。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">               	 ┌─── visitCode()</span><br><span class="line">                 │</span><br><span class="line">                 │                      ┌─── visitXxxInsn()</span><br><span class="line">                 │                      │</span><br><span class="line">                 │                      ├─── visitLabel()</span><br><span class="line">                 ├─── visitXxxInsn() ───┤</span><br><span class="line">MethodVisitor ───┤                      ├─── visitFrame()</span><br><span class="line">                 │                      │</span><br><span class="line">                 │                      └─── visitTryCatchBlock()</span><br><span class="line">                 │</span><br><span class="line">                 ├─── visitMaxs()</span><br><span class="line">                 │</span><br><span class="line">                 └─── visitEnd()</span><br></pre></td></tr></table></figure>

<h2 id="2-6、MethodWriter"><a href="#2-6、MethodWriter" class="headerlink" title="2.6、MethodWriter"></a>2.6、MethodWriter</h2><p><code>MethodWriter</code>类的父类是<code>MethodVisitor</code>类。在<code>ClassWriter</code>类里，<code>visitMethod()</code>方法的实现就是通过<code>MethodWriter</code>类来实现的。</p>
<p><code>MethodWriter</code>类的父类是<code>MethodVisitor</code>类。</p>
<p>需要注意的是，<code>MethodWriter</code>类并不带有<code>public</code>修饰，因此它的有效访问范围只局限于它所处的package当中，不能像其它的<code>public</code>类一样被外部所使用。</p>
<h3 id="fields-1"><a href="#fields-1" class="headerlink" title="fields"></a>fields</h3><p><code>MethodWriter</code>类定义的字段有哪些。</p>
<p>在<code>MethodWriter</code>类当中，定义了很多的字段。下面的几个字段，是与方法的访问标识（access flag）、方法名（method name）和描述符（method descriptor）等直接相关的字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">final class MethodWriter extends MethodVisitor &#123;</span><br><span class="line">    private final int accessFlags;</span><br><span class="line">    private final int nameIndex;</span><br><span class="line">    private final String name;</span><br><span class="line">    private final int descriptorIndex;</span><br><span class="line">    private final String descriptor;</span><br><span class="line">    private Attribute firstAttribute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些字段与<code>ClassFile</code>当中的<code>method_info</code>也是对应的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">method_info &#123;</span><br><span class="line">    u2             access_flags;</span><br><span class="line">    u2             name_index;</span><br><span class="line">    u2             descriptor_index;</span><br><span class="line">    u2             attributes_count;</span><br><span class="line">    attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的几个字段，是与“方法体”直接相关的几个字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">final class MethodWriter extends MethodVisitor &#123;</span><br><span class="line">    private int maxStack;</span><br><span class="line">    private int maxLocals;</span><br><span class="line">    private final ByteVector code = new ByteVector();</span><br><span class="line">    private Handler firstHandler;</span><br><span class="line">    private Handler lastHandler;</span><br><span class="line">    private final int numberOfExceptions;</span><br><span class="line">    private final int[] exceptionIndexTable;</span><br><span class="line">    private Attribute firstCodeAttribute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些字段对应于<code>Code</code>属性结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Code_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 max_stack;</span><br><span class="line">    u2 max_locals;</span><br><span class="line">    u4 code_length;</span><br><span class="line">    u1 code[code_length];</span><br><span class="line">    u2 exception_table_length;</span><br><span class="line">    &#123;   u2 start_pc;</span><br><span class="line">        u2 end_pc;</span><br><span class="line">        u2 handler_pc;</span><br><span class="line">        u2 catch_type;</span><br><span class="line">    &#125; exception_table[exception_table_length];</span><br><span class="line">    u2 attributes_count;</span><br><span class="line">    attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重要方法-1"><a href="#重要方法-1" class="headerlink" title="重要方法"></a>重要方法</h3><p>在<code>MethodWriter</code>类当中，也有两个重要的方法：<code>computeMethodInfoSize()</code>和<code>putMethodInfo()</code>方法。这两个方法也是在<code>ClassWriter</code>类的<code>toByteArray()</code>方法内使用到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodWriter</span> <span class="keyword">extends</span> <span class="title">MethodVisitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">computeMethodInfoSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="comment">// 2 bytes each for access_flags, name_index, descriptor_index and attributes_count.</span></span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">8</span>;</span><br><span class="line">        <span class="comment">// For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.</span></span><br><span class="line">        <span class="keyword">if</span> (code.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (code.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MethodTooLargeException(symbolTable.getClassName(), name, descriptor, code.length);</span><br><span class="line">            &#125;</span><br><span class="line">            symbolTable.addConstantUtf8(Constants.CODE);</span><br><span class="line">            <span class="comment">// The Code attribute has 6 header bytes, plus 2, 2, 4 and 2 bytes respectively for max_stack,</span></span><br><span class="line">            <span class="comment">// max_locals, code_length and attributes_count, plus the ByteCode and the exception table.</span></span><br><span class="line">            size += <span class="number">16</span> + code.length + Handler.getExceptionTableSize(firstHandler);</span><br><span class="line">            <span class="keyword">if</span> (stackMapTableEntries != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> useStackMapTable = symbolTable.getMajorVersion() &gt;= Opcodes.V1_6;</span><br><span class="line">                symbolTable.addConstantUtf8(useStackMapTable ? Constants.STACK_MAP_TABLE : <span class="string">&quot;StackMap&quot;</span>);</span><br><span class="line">                <span class="comment">// 6 header bytes and 2 bytes for number_of_entries.</span></span><br><span class="line">                size += <span class="number">8</span> + stackMapTableEntries.length;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (numberOfExceptions &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            symbolTable.addConstantUtf8(Constants.EXCEPTIONS);</span><br><span class="line">            size += <span class="number">8</span> + <span class="number">2</span> * numberOfExceptions;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">putMethodInfo</span><span class="params">(<span class="keyword">final</span> ByteVector output)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> useSyntheticAttribute = symbolTable.getMajorVersion() &lt; Opcodes.V1_5;</span><br><span class="line">        <span class="keyword">int</span> mask = useSyntheticAttribute ? Opcodes.ACC_SYNTHETIC : <span class="number">0</span>;</span><br><span class="line">        output.putShort(accessFlags &amp; ~mask).putShort(nameIndex).putShort(descriptorIndex);</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="comment">// For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.</span></span><br><span class="line">        <span class="keyword">int</span> attributeCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (code.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ++attributeCount;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (numberOfExceptions &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ++attributeCount;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="comment">// For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.</span></span><br><span class="line">        output.putShort(attributeCount);</span><br><span class="line">        <span class="keyword">if</span> (code.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 2, 2, 4 and 2 bytes respectively for max_stack, max_locals, code_length and</span></span><br><span class="line">            <span class="comment">// attributes_count, plus the ByteCode and the exception table.</span></span><br><span class="line">            <span class="keyword">int</span> size = <span class="number">10</span> + code.length + Handler.getExceptionTableSize(firstHandler);</span><br><span class="line">            <span class="keyword">int</span> codeAttributeCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (stackMapTableEntries != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 6 header bytes and 2 bytes for number_of_entries.</span></span><br><span class="line">                size += <span class="number">8</span> + stackMapTableEntries.length;</span><br><span class="line">                ++codeAttributeCount;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line">            output</span><br><span class="line">                .putShort(symbolTable.addConstantUtf8(Constants.CODE))</span><br><span class="line">                .putInt(size)</span><br><span class="line">                .putShort(maxStack)</span><br><span class="line">                .putShort(maxLocals)</span><br><span class="line">                .putInt(code.length)</span><br><span class="line">                .putByteArray(code.data, <span class="number">0</span>, code.length);</span><br><span class="line">            Handler.putExceptionTable(firstHandler, output);</span><br><span class="line">            output.putShort(codeAttributeCount);</span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (numberOfExceptions &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            output</span><br><span class="line">                .putShort(symbolTable.addConstantUtf8(Constants.EXCEPTIONS))</span><br><span class="line">                .putInt(<span class="number">2</span> + <span class="number">2</span> * numberOfExceptions)</span><br><span class="line">                .putShort(numberOfExceptions);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> exceptionIndex : exceptionIndexTable) &#123;</span><br><span class="line">              output.putShort(exceptionIndex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MethodWriter类的使用"><a href="#MethodWriter类的使用" class="headerlink" title="MethodWriter类的使用"></a>MethodWriter类的使用</h3><p>关于<code>MethodWriter</code>类的使用，它主要出现在<code>ClassWriter</code>类当中的<code>visitMethod()</code>和<code>toByteArray()</code>方法内。</p>
<h4 id="visitMethod方法"><a href="#visitMethod方法" class="headerlink" title="visitMethod方法"></a>visitMethod方法</h4><p>在<code>ClassWriter</code>类当中，<code>visitMethod()</code>方法代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassWriter</span> <span class="keyword">extends</span> <span class="title">ClassVisitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> access, String name, String descriptor, String signature, String[] exceptions)</span> </span>&#123;</span><br><span class="line">        MethodWriter methodWriter = <span class="keyword">new</span> MethodWriter(symbolTable, access, name, descriptor, signature, exceptions, compute);</span><br><span class="line">        <span class="keyword">if</span> (firstMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">            firstMethod = methodWriter;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lastMethod.mv = methodWriter;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lastMethod = methodWriter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="toByteArray方法-1"><a href="#toByteArray方法-1" class="headerlink" title="toByteArray方法"></a>toByteArray方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassWriter</span> <span class="keyword">extends</span> <span class="title">ClassVisitor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] toByteArray() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// First step: compute the size in bytes of the ClassFile structure.</span></span><br><span class="line">        <span class="comment">// The magic field uses 4 bytes, 10 mandatory fields (minor_version, major_version,</span></span><br><span class="line">        <span class="comment">// constant_pool_count, access_flags, this_class, super_class, interfaces_count, fields_count,</span></span><br><span class="line">        <span class="comment">// methods_count and attributes_count) use 2 bytes each, and each interface uses 2 bytes too.</span></span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">24</span> + <span class="number">2</span> * interfaceCount;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="keyword">int</span> methodsCount = <span class="number">0</span>;</span><br><span class="line">        MethodWriter methodWriter = firstMethod;</span><br><span class="line">        <span class="keyword">while</span> (methodWriter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ++methodsCount;</span><br><span class="line">            size += methodWriter.computeMethodInfoSize();        <span class="comment">// 这里是对MethodWriter.computeMethodInfoSize()方法的调用</span></span><br><span class="line">            methodWriter = (MethodWriter) methodWriter.mv;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Second step: allocate a ByteVector of the correct size (in order to avoid any array copy in</span></span><br><span class="line">        <span class="comment">// dynamic resizes) and fill it with the ClassFile content.</span></span><br><span class="line">        ByteVector result = <span class="keyword">new</span> ByteVector(size);</span><br><span class="line">        result.putInt(<span class="number">0xCAFEBABE</span>).putInt(version);</span><br><span class="line">        symbolTable.putConstantPool(result);</span><br><span class="line">        <span class="keyword">int</span> mask = (version &amp; <span class="number">0xFFFF</span>) &lt; Opcodes.V1_5 ? Opcodes.ACC_SYNTHETIC : <span class="number">0</span>;</span><br><span class="line">        result.putShort(accessFlags &amp; ~mask).putShort(thisClass).putShort(superClass);</span><br><span class="line">        result.putShort(interfaceCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interfaceCount; ++i) &#123;</span><br><span class="line">            result.putShort(interfaces[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        result.putShort(methodsCount);</span><br><span class="line">        <span class="keyword">boolean</span> hasFrames = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> hasAsmInstructions = <span class="keyword">false</span>;</span><br><span class="line">        methodWriter = firstMethod;</span><br><span class="line">        <span class="keyword">while</span> (methodWriter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            hasFrames |= methodWriter.hasFrames();</span><br><span class="line">            hasAsmInstructions |= methodWriter.hasAsmInstructions();</span><br><span class="line">            methodWriter.putMethodInfo(result);                    <span class="comment">// 这里是对MethodWriter.putMethodInfo()方法的调用</span></span><br><span class="line">            methodWriter = (MethodWriter) methodWriter.mv;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Third step: replace the ASM specific instructions, if any.</span></span><br><span class="line">        <span class="keyword">if</span> (hasAsmInstructions) &#123;</span><br><span class="line">            <span class="keyword">return</span> replaceAsmInstructions(result.data, hasFrames);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> result.data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-7、StackFrame"><a href="#2-7、StackFrame" class="headerlink" title="2.7、StackFrame"></a>2.7、StackFrame</h2><h3 id="Frame内存结构"><a href="#Frame内存结构" class="headerlink" title="Frame内存结构"></a>Frame内存结构</h3><p>JVM Architecture由Class Loader SubSystem、Runtime Data Areas和Execution Engine三个主要部分组成，如下图所示。其中，Runtime Data Areas包括Method Area、Heap Area、Stack Area、PC Registers和Native Method Stack等部分。</p>
<p><img src="/pics/jvm-architecture.png" alt="JVM Architecture"></p>
<p>在程序运行的过程中，每一个线程（Thread）都对应一个属于自己的<strong>JVM Stack</strong>。当一个新线程（Thread）开始的时候，就会在内存上分配一个属于自己的JVM Stack；当该线程（Thread）执行结束的时候，相应的JVM Stack内存空间也就被回收了。</p>
<p>在JVM Stack当中，是栈的结构，里面存储的是frames；每一个frame空间可以称之为<strong>Stack Frame</strong>。当调用一个新方法的时候，就会在JVM Stack上分配一个frame空间（入栈操作）；当方法退出时，相应的frame空间也会JVM Stack上进行清除掉（出栈操作）。</p>
<p>在Stack Frame内存空间当中，有两个重要的结构，即<strong>local variables</strong>和<strong>operand stack</strong>。</p>
<p><img src="/pics/frame-local-variables-operand-stack.png" alt="JVM Stack Frame"></p>
<p>在Stack Frame当中，operand stack是一个栈的结构，遵循“后进先出”（LIFO）的规则，local variables则是一个数组，索引从<code>0</code>开始。</p>
<p>对于每一个方法来说，它都是在自己的Stack Frame上来运行的：</p>
<ul>
<li>在编译的时候（compile time），local variables和operand stack的空间大小就确定下来了。比如说，一个<code>.java</code>文件经过编译之后，得到<code>.class</code>文件，对于其中的某一个方法来说，它的local variable占用10个slot空间，operand stack占用4个slot空间。</li>
<li>在运行的时候（run-time），在local variables和operand stack上存放的数据，会随着方法的执行，不断发生变化。</li>
</ul>
<p>那么，在运行的时候（run-time），刚进入方法，但还没有执行任何指令（instruction），那么，此时、此刻，local variables和operand stack是一个什么样的状态呢？</p>
<p>在Stack Frame空间当中，local variables和operand stack会有<strong>一个开始的状态</strong>和<strong>一个结束的状态</strong>。</p>
<h3 id="方法的初始Frame"><a href="#方法的初始Frame" class="headerlink" title="方法的初始Frame"></a>方法的初始Frame</h3><p>在方法刚开始的时候，operand stack是空的，不需要存储任何的数据，而local variables的初始状态，则需要考虑两个因素：</p>
<ul>
<li>是否需要存储<code>this？</code>通过判断当前方法是否为static方法。<ul>
<li>如果当前方法是static方法，则不需要存储<code>this</code>。</li>
<li>如果当前方法是non-static方法，则需要在local variables索引为<code>0</code>的位置存在一个<code>this</code>变量。</li>
</ul>
</li>
<li>当前方法是否接收参数。方法接收的参数，会按照参数的声明顺序放到local variables当中。<ul>
<li>如果方法参数不是<code>long</code>和<code>double</code>类型，那么它在local variable当中占用1个位置。</li>
<li>如果方法的参数是<code>long</code>或<code>double</code>类型，那么它在local variable当中占用2个位置。</li>
</ul>
</li>
</ul>

    </div>

    
    
    
      

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>sven
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://zhaoxiaowen-sven.github.io/2022/12/26/Notes/ASM/ASM01/" title="ASM01">https://zhaoxiaowen-sven.github.io/2022/12/26/Notes/ASM/ASM01/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/12/25/Notes/AI/01_AI/" rel="prev" title="AI_01_机器学习概论">
      <i class="fa fa-chevron-left"></i> AI_01_机器学习概论
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#ASM-01"><span class="nav-text">ASM_01</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81ASM-%E4%B8%8EClassFile"><span class="nav-text">一、ASM 与ClassFile</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1%E3%80%81-ASM-%E4%B8%8EClassFile"><span class="nav-text">1.1、 ASM 与ClassFile</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ClassFile%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="nav-text">ClassFile文件结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ASM%E4%B8%8EClassFile%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-text">ASM与ClassFile的关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2%E3%80%81ASMPrint"><span class="nav-text">1.2、ASMPrint</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81XXVisitor"><span class="nav-text">二、XXVisitor</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1%E3%80%81ClassVisitor"><span class="nav-text">2.1、ClassVisitor</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">定义的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F"><span class="nav-text">方法调用顺序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2%E3%80%81ClassWriter%E4%BB%8B%E7%BB%8D"><span class="nav-text">2.2、ClassWriter介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-constructors"><span class="nav-text">构造方法 constructors</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8ClassWriter"><span class="nav-text">如何使用ClassWriter</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3%E3%80%81FieldVisitor%E7%B1%BB"><span class="nav-text">2.3、FieldVisitor类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E7%9A%84%E6%96%B9%E6%B3%95-1"><span class="nav-text">定义的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="nav-text">如何使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%84%E6%9C%9F%E7%9B%AE%E6%A0%87"><span class="nav-text">预期目标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-text">编码实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4%E3%80%81FieldWriter%E7%B1%BB"><span class="nav-text">2.4、FieldWriter类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fields"><span class="nav-text">fields</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%A6%81%E6%96%B9%E6%B3%95"><span class="nav-text">重要方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FieldWriter%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">FieldWriter类的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#visitField%E6%96%B9%E6%B3%95"><span class="nav-text">visitField方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#toByteArray%E6%96%B9%E6%B3%95"><span class="nav-text">toByteArray方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5%E3%80%81MethodVisitor"><span class="nav-text">2.5、MethodVisitor</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E7%9A%84%E6%96%B9%E6%B3%95-2"><span class="nav-text">定义的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F-1"><span class="nav-text">方法调用顺序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-6%E3%80%81MethodWriter"><span class="nav-text">2.6、MethodWriter</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fields-1"><span class="nav-text">fields</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%A6%81%E6%96%B9%E6%B3%95-1"><span class="nav-text">重要方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MethodWriter%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">MethodWriter类的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#visitMethod%E6%96%B9%E6%B3%95"><span class="nav-text">visitMethod方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#toByteArray%E6%96%B9%E6%B3%95-1"><span class="nav-text">toByteArray方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-7%E3%80%81StackFrame"><span class="nav-text">2.7、StackFrame</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Frame%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="nav-text">Frame内存结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E5%88%9D%E5%A7%8BFrame"><span class="nav-text">方法的初始Frame</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="sven"
      src="/images/sven.jpeg">
  <p class="site-author-name" itemprop="name">sven</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">80</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhaoxiaowen-sven" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhaoxiaowen-sven" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhaoxiaowen-sven@gmail.com" title="E-Mail → mailto:zhaoxiaowen-sven@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sven</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
