<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Sven&#39;s blog">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Sven&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="sven">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Sven's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
      <a target="_blank" rel="noopener" href="https://github.com/zhaoxiaowen-sven" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Sven's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/21/Notes/Java/Collections/Java%E9%9B%86%E5%90%88_04_HashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/21/Notes/Java/Collections/Java%E9%9B%86%E5%90%88_04_HashMap/" class="post-title-link" itemprop="url">Java集合_04_HashMap</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-21 21:23:24" itemprop="dateCreated datePublished" datetime="2021-04-21T21:23:24+08:00">2021-04-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/collection/" itemprop="url" rel="index"><span itemprop="name">collection</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>HashMap是Java程序员使用频率最高的用于映射(键值对)处理的数据类型。现在我们就来学习一下HashMap数据结构和功能原理，基于JDK8。</p>
<h2 id="一、数据结构"><a href="#一、数据结构" class="headerlink" title="一、数据结构"></a>一、数据结构</h2><p>HashMap使用的数据结构是<strong>数组 （这个数组通常被称为称为哈希桶或table）+ 链表</strong>，链表长度大于8时，链表升级为红黑树（JDK8新增）。</p>
<img src="/pics/image-20210310212941190.png" alt="image-20210310212941190" style="zoom:50%;" />

<p>元素存储使用的数据结构是Node，Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;	</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 默认的数组大小</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line">  <span class="comment">// 数组最大容量</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">  <span class="comment">// 负载因子</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">  <span class="comment">// 树化阈值，链表长度</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line">  <span class="comment">// 树降级为链表阈值</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line">  <span class="comment">// 树化的另一个约束阈值，数组长度超过64，2个参数要同时满足，</span></span><br><span class="line">  <span class="comment">// 这个MIN_TREEIFY_CAPACITY的值至少是TREEIFY_THRESHOLD的4倍。</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// hash表</span></span><br><span class="line">  <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line">  <span class="comment">// hash表中Node个数</span></span><br><span class="line">  <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line">  <span class="comment">// 结构修改次数（插入或删除元素时+1，替换不变）</span></span><br><span class="line">  <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line">  <span class="comment">// 扩容阈值    </span></span><br><span class="line">  <span class="keyword">int</span> threshold;</span><br><span class="line">  <span class="comment">// 用于计算扩容阈值，threshold = capacity * loadFactor</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashMap 基本工作原理:</p>
<ol>
<li>插入数据时，计算key的hash，再经过位与运算计算出索引，插入到数组中；</li>
<li>当新插入的key的index和已有的冲突时，将新节点插入到已有节点的后面，构成链表；</li>
<li>当某个链表长度大于8且数组长度大于64时，将链表转化为红黑树。</li>
</ol>
<h3 id="1-2、单链表节点"><a href="#1-2、单链表节点" class="headerlink" title="1.2、单链表节点"></a>1.2、单链表节点</h3><p>Node 的数据结构如下，比较简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;<span class="comment">//key 的hash值</span></span><br><span class="line">    <span class="keyword">final</span> K key;<span class="comment">//键</span></span><br><span class="line">    V value;<span class="comment">//值</span></span><br><span class="line">    Node&lt;K,V&gt; next;<span class="comment">//链表的下一个节点</span></span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3、二叉树节点"><a href="#1-3、二叉树节点" class="headerlink" title="1.3、二叉树节点"></a>1.3、二叉树节点</h3><p>TreeNode 既是二叉树的数据结构又是双向链表，TreeNode继承自 LinkedHashMap.Entry&lt;K,V&gt;，  LinkedHashMap.Entry又继承自Node，所以TreeNode 中包含了Node的所用属性，key、value 、hash、next 。ThreeNode具有双向链表的特性主要是为了树化和二叉树转换方便，后面在介绍。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 双向链表</span></span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、Hash规则"><a href="#二、Hash规则" class="headerlink" title="二、Hash规则"></a>二、Hash规则</h2><p>HashMap的增删改查，定位到哈希桶数组的位置都是很关键的第一步。如果 HashMap 里面的元素位置分布均匀，每个位置上的元素数量只有一个或少个，就能大大优化查找key的效率。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// 1.h = key.hashCode()，取hashCode</span></span><br><span class="line">    <span class="comment">// 2.h ^ (h &gt;&gt;&gt; 16)，异或运算，高位参与</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123; <span class="comment">//jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></span><br><span class="line">		<span class="keyword">return</span> h &amp; (length-<span class="number">1</span>); <span class="comment">// 3.位与运算，h是上一步计算完的结果，使索引落到[0,length - 1]之间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过一张图来分析下。</p>
<img src="/pics/image-20210310230422639.png" alt="image-20210310230422639" style="zoom:50%;" />

<p>Java中，Object类是所有类的父类，所有的对象，包括数组，都实现了在<code>Object</code>类中定义的方法。Object类hashCode方法返回值是int类型，int为4个字节，1个字节是8位，4个字节就是32位。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>)</span><br></pre></td></tr></table></figure>

<p>右位移 16 位，正好是 32位的一半，高半区和低半区做异或，就是为了混合原始hashCode的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。</p>
<p><strong>总结下：key的hash值是key的hashCode经过位移和异或得到的新值，hash算法增加了更多的因子，能够更好的均匀散列，减少碰撞，进一步降低hash冲突的几率</strong>。</p>
<h2 id="三、put"><a href="#三、put" class="headerlink" title="三、put"></a>三、put</h2><p>HashMap中核心方法是增加元素的put和扩容resize，我们先来看下put。</p>
<h3 id="3-1、put的过程"><a href="#3-1、put的过程" class="headerlink" title="3.1、put的过程"></a>3.1、put的过程</h3><img src="/pics/image-20210310232925256.png" alt="image-20210310232925256" style="zoom:50%;" />

<ol>
<li>hashMap使用的是懒加载，只有在执行put操作时才会创建数组。若table=null或size=0则创建table（通过扩容逻辑）。</li>
<li>对key的hashCode()高低16位异或，位与(table.length - 1)计算出要插入到table的index（第二节介绍过了）;</li>
<li>如果index没碰撞直接插到table里；</li>
<li>如果碰撞了，有三种情况：<ul>
<li>若头元素的key和插入key相同则替换；</li>
<li>若头元素是个TreeNode，则将Node插入到红黑树中，先遍历，再插入，再平衡；若相同则替换。</li>
<li>以上2种情况都不满足，说明是个链表且头元素的key和插入的不相同，遍历链表，若链表中存在相同key的Node，替换该节点值；否则，插入到链表尾，并且判断链表是否需要转换成红黑树（树化下一小节讲）。</li>
</ul>
</li>
<li>容量 ++ ，若容量达到扩容阈值，进行扩容。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 1.table未初始化时或者初始化大小=0，reSize操作</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">   <span class="comment">// 2.table的hash不存在时，头元素不存在，创建新Node</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 3.头元素相同,进行替换</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 4.相同hash的节点不存在，且当前桶位是链表情况</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//5.相同hash的table是链表结构</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//5.1 遍历到最后也没有相同节点则插入</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 插入节点到链表中</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 循环从0开始，满足这个条件时，已经循环了TREEIFY_THRESHOLD次</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                         <span class="comment">// 链表长度大于TREEIFY_THRESHOLD时，进行树化</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 5.3 找到相同值</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">// 赋值替换</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改的次数，替换不算</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 插入元素个数+1 &gt; threshold 进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2、树化"><a href="#3-2、树化" class="headerlink" title="3.2、树化"></a>3.2、树化</h3><p>树化的条件有2个，<strong>当前链表的长度&gt;8且table的长度&gt;64</strong>，<strong>如果table长度小于64，则进行一次扩容</strong>。树化步骤如下：</p>
<ol>
<li>将单链表先转化为一个双向链表，数据结构变为TreeNode</li>
<li>将双向链表转换为红黑树</li>
</ol>
<p><strong>也就是说树化后的哈希桶既是一个红黑树，也是一个双向链表</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) <span class="comment">//1. table== null 或长度小于64，进行或扩容</span></span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>,<span class="comment">//hd 是头节点</span></span><br><span class="line">        tl = <span class="keyword">null</span>;<span class="comment">// tl指向上一个节点</span></span><br><span class="line">        <span class="keyword">do</span> &#123;<span class="comment">// 2.do while 将单链表先转化为一个双向链表</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>); <span class="comment">// p 是当前TreeNode节点,将Node转化为TreeNode</span></span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>); </span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab); <span class="comment">// 3.真正的树化是TreeNode的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真正的树化 TreeNode.treeify，主要步骤有：</p>
<ol>
<li>遍历链表，若红黑树的root节点还未创建，将链表第一个节点作为root</li>
<li>遍历剩余节点，根据这些节点的hash值和key计算出dir，若dir&lt;=0 遍历红黑树的左子树，否则遍历红黑树的右子树，插入到叶子节点的位置</li>
<li>插入节点后，平衡红黑树，注意是在for循环中，每插入一次都会平衡一下</li>
<li>调整双向链表顺序，将红黑树的root节点作为当前hash桶的头节点，将当前头节点的元素作为root的下一个节点。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123; <span class="comment">// for循环，遍历双向链表</span></span><br><span class="line">        <span class="comment">// x 表示当前要插入的节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// next是x的下一个节点</span></span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">        x.left = x.right = <span class="keyword">null</span>;<span class="comment">// 将x的左右子树节点置空</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="comment">// 将第一个节点作为头节点</span></span><br><span class="line">            x.parent = <span class="keyword">null</span>;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            root = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//遍历其他节点</span></span><br><span class="line">            K k = x.key; <span class="comment">// x节点的key</span></span><br><span class="line">            <span class="keyword">int</span> h = x.hash; <span class="comment">// x节点的hash</span></span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123; <span class="comment">// 遍历这颗红黑树，p指向当前节点</span></span><br><span class="line">                <span class="keyword">int</span> dir <span class="comment">// dir &lt; 0,插入左子树;&gt; 0 插入右子树</span></span><br><span class="line">                    , ph; <span class="comment">// p节点的hash</span></span><br><span class="line">                K pk = p.key; <span class="comment">// p节点的key</span></span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h) <span class="comment">// 比较节点的hash，同一个hash桶位的节点index相同，hash值不一定相同，index取tablelength长度的低位。</span></span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp; <span class="comment">// hash值相同的情况，key也相等</span></span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    dir = tieBreakOrder(k, pk);<span class="comment">// 比较keyclass 和 key 的identityHashCode，不用太细究</span></span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p; <span class="comment">// 下面的遍历过程中 xp指的是p的父节点</span></span><br><span class="line">                <span class="comment">// 拆分成2个逻辑看:</span></span><br><span class="line">           		<span class="comment">// p = dir &lt; 0 ? p.left ：p.right,第一步根据dir遍历节点左子树或右子树</span></span><br><span class="line">                <span class="comment">// p == null //只到找到叶子节点 </span></span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123; </span><br><span class="line">                    x.parent = xp; <span class="comment">// 将x节点插入到xp后</span></span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x; <span class="comment">// &lt; 0是左节点 </span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x; <span class="comment">// &gt;0 是右节点</span></span><br><span class="line">                    root = balanceInsertion(root, x);<span class="comment">// ！！！插入后,再平衡！！！</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    moveRootToFront(tab, root); <span class="comment">//将 root节点放到table[i],作为当前hash桶的第一个元素，同时调整双向链表。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、resize"><a href="#四、resize" class="headerlink" title="四、resize"></a>四、resize</h2><p>resize主要是put元素过程中，处理扩容，触发扩容的条件是size(节点数) &gt; threshold。 </p>
<p>扩容原理主要步骤有2步：</p>
<ol>
<li>容量和扩容阈值调整</li>
<li>数据迁移</li>
</ol>
<p>先来看下容量和扩容阈值调整</p>
<h3 id="4-1、容量和扩容阈值调整"><a href="#4-1、容量和扩容阈值调整" class="headerlink" title="4.1、容量和扩容阈值调整"></a>4.1、容量和扩容阈值调整</h3><p><img src="/pics/image-20210311112923942.png" alt="image-20210311112923942"></p>
<p>步骤如下：</p>
<ol>
<li><p>oldCap &gt; 0 说明table已经初始化过，扩容时有2种情况</p>
<ul>
<li>oldCap &gt;= MAXIMUM_CAPACITY，table数组容量达到最大，不可再扩容</li>
<li>oldCap &lt; MAXIMUM_CAPACITY，新容量newCap扩大oldCap的2倍。接着再判断（newCap &lt; MAXIMUM_CAPACITY） &amp;&amp; oldCap&gt;= 16，则将扩容阈值调整为原来的2倍。一般情况下newCap &lt; MAXIMUM_CAPACITY都是成立的，主要看第二个条件，oldCap是否大于16。也就是说除非我们的oldCap容量 &lt;16, 正常扩容时容量和扩容阈值都会翻倍。&lt;16时，最终threshold = cap * factor（0.75）。</li>
</ul>
</li>
<li><p>oldCap == 0，说明table还未初始化或者未添加元素情况，也有2种：</p>
<ul>
<li><p>oldThr &gt; 0 说明使用的是非无参的构造方法（有3个入口）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上3个构造方法，都会使得threshold被tableSizeFor赋值，结果为大于且最接近cap的2的n次方；最终这个值又会被赋值到 newCap = oldThr；<strong>也就是说table的容量永远都是2的n次方。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>oldThr == 0，说明使用的hashMap的无参构造方法，也就是我们最常用的构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>​                   仅初始化负载因子为0.75；如果是这种情况，那么newCap = 16，newThr = 12。</p>
<ol start="3">
<li><p>经过以上2步，新table的容量newCap的值就被确定了，接下来就是调整扩容阈值。满足newThr == 0，有2种情况：</p>
<ul>
<li><p>扩容的oldCap &lt;16；</p>
</li>
<li><p>使用<strong>非无参构造函数初始化</strong>的hashMap。这2种情况是有联系的，只有使用非无参构造函数初始化的cap才可能小于16，当它再次扩容时出现第一种情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">    newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">              (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line">threshold = newThr;</span><br></pre></td></tr></table></figure>

<p>跟进loadFactor和newCap计算扩容阈值，如果newCap &lt; MAXIMUM_CAPACITY 且ft &lt; (float)MAXIMUM_CAPACITY,那么说明扩容阈值有效，否则说明table容量达到最大，为Integer.MAX_VALUE。最后再将计算完的扩容阈值赋值给threshold。<strong>代码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// 当前容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">// 当前扩容阈值</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 容量达到最大，不再扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 容量先翻倍，若oldCap &gt;=16 &amp;&amp; newCap &lt; max 扩容阈值也翻倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// oldCap == 0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">// oldCap == 0  </span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY; <span class="comment">// 16 </span></span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); <span class="comment">// 12</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// oldCap &lt;16 或者 使用非无参构造函数初始化后，再计算下扩容阈值</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="4-2、数据迁移"><a href="#4-2、数据迁移" class="headerlink" title="4.2、数据迁移"></a>4.2、数据迁移</h3><img src="/pics/image-20210312231650233.png" alt="image-20210312231650233" style="zoom:50%;" />

<p>步骤如下：</p>
<ol>
<li><p>创建数组newTab，大小为newCab,newCap的大小逻辑，我们刚才已经介绍过了。</p>
</li>
<li><p>遍历oldTab，开始数据迁移，假设当前位置索引为 i ，当前Node 为 e：</p>
<ul>
<li><p>e.next == null，说明哈希桶只有一个元素，复制到newTab[i]；</p>
</li>
<li><p>e 是一个treeNode，尝试将当前索引位置的红黑树进行拆分，下一节分析；</p>
</li>
<li><p>以上2种情况都不满足，说明是一个链表，将链表中的所有Node插入到新列表中。介绍下扩容插入的原理。</p>
<p>我们知道table形成链表，说明index = h &amp; (length-1)得到了相同的值。假设length = 16 ，length - 1相应的二进制是  0b1111，index若相同说明h的低4位是相同；扩容后length = 32，length - 1的表示为二进制为 0b11111，也就是说取 h 的低5位。假设我们要迁移节点的 index = 0b 0101，迁移时要取的 h 的低五位，此时 h 的第五位有2种情况 0x10101 或 0x00101（这2种情况，若取低4位index相同即扩容前），经过计算后新的index 就有2种情况，转换为10 进制 newIndex = index 或 newIndex = index + oldCap。</p>
</li>
</ul>
<p><img src="/pics/image-20210311220343714.png" alt="image-20210311220343714"></p>
<p>​         这也是为什么要扩容的原因，扩容后相同hash的链表长度会变短，分布的更加均匀，查找效率更高。 </p>
<ul>
<li>还是上面的例子，oldCap表示为二进制0b 10000，e.hash &amp; oldCap == 0说明是高位为0，扩容完的索引与原数组相同；e.hash &amp; oldCap == 1说明是高位为1，计算出的newTab的 nexIndex = [index + newCap]；</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">   <span class="comment">// ... 以上是newSize大小确定</span></span><br><span class="line">    <span class="comment">// 创建newCap大小容量</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;<span class="comment">//  当前node节点</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 回收</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 当前桶位只有单个元素，计算新的元素</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 尝试将红黑树拆分为2个链表</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">//还是链表，需要将链表拆分    </span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//低位链表，扩容前后，下标不变</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, </span><br><span class="line">                    loTail = <span class="keyword">null</span>; <span class="comment">//低位链表表尾指针</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 高位链表，扩容后，下标变为当前数组位置 + 扩容前数组长度</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, </span><br><span class="line">                    hiTail = <span class="keyword">null</span>;<span class="comment">//高位链表的表头指针</span></span><br><span class="line">                    </span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123; <span class="comment">// 说明是低位链表，放入低位链表中</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)<span class="comment">// 首个元素赋值到表头</span></span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e; <span class="comment">//指向链尾元素 </span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e; </span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 将新链表放到对应的数组里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>; <span class="comment">// 必要操作，尾节点后继置空</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3、红黑树的拆分"><a href="#4-3、红黑树的拆分" class="headerlink" title="4.3、红黑树的拆分"></a>4.3、红黑树的拆分</h3><p>我们知道，扩容时oldTab相同index的可能放到newTab数组下标是index或index + oldCap的位置，如果oldTab[index]存放的是红黑树，那么扩容完的2个位置哈希桶的元素个数可能就不足8个，此时就需要对红黑树进行拆分。拆分步骤如下：</p>
<ol>
<li>类似拆分链表，先将当前红黑树拆分为2个双向链表，高位链表hi 和 低位链表li</li>
<li> 如果低位单链表不为空，此时有2种情况，假设低位链表长度为lc</li>
</ol>
<ul>
<li>若lc &lt;= 6 则将低位红黑树转为单链表；</li>
<li>若 lc &gt; 6 时，如果hiHead == null，高位链表为空，说明原链表的所有元素都在低位链表中，不需要再进行树化；否则要对链表进行树化。</li>
</ul>
<ol start="3">
<li>如果高位链表不为空，类似低位链表的处理，&lt;=6 转换为单链表，大于6 且 低位链表为空，不需要做任何操作；否则要对链表进行树化。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">    TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> lc = <span class="number">0</span>, <span class="comment">// 低位链表长度</span></span><br><span class="line">    hc = <span class="number">0</span>; <span class="comment">// 高位链表长度</span></span><br><span class="line">    <span class="comment">// 1. 当前红黑树拆分为2个双向链表</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">        e.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">            loTail = e;</span><br><span class="line">            ++lc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">            ++hc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD) <span class="comment">// 若lc &lt;= 6 则将低位红黑树转为单链表</span></span><br><span class="line">            tab[index] = loHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若 lc &gt; 6 时，如果hiHead == null，高位链表为空，说明原链表的所有元素都在低位链表中，不需要再进行树化；否则要对链表进行树化。</span></span><br><span class="line">            tab[index] = loHead; </span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">                loHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index + bit] = hiHead;</span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                hiHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  树转成链表</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; q = <span class="keyword">this</span>; q != <span class="keyword">null</span>; q = q.next) &#123;</span><br><span class="line">        Node&lt;K,V&gt; p = map.replacementNode(q, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">            hd = p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tl.next = p;</span><br><span class="line">        tl = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、其他方法"><a href="#五、其他方法" class="headerlink" title="五、其他方法"></a>五、其他方法</h2><h3 id="5-1、get"><a href="#5-1、get" class="headerlink" title="5.1、get"></a>5.1、get</h3><p>步骤如下：</p>
<ol>
<li>计算key的hash，再根据hash得出哈希桶的index</li>
<li>取头结点不为空，判断头节点的key和需要的key是否相同，相同直接返回</li>
<li>是否是ThreeNode，遍历红黑树获取</li>
<li>以上都不满足说明是链表，遍历链表获取节点</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-2、remove"><a href="#5-2、remove" class="headerlink" title="5.2、remove"></a>5.2、remove</h2><p>remove 比较简单，就是单链表的删除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="comment">//p是头节点</span></span><br><span class="line">    <span class="keyword">int</span> n, index;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, <span class="comment">// Node是待删除的节点</span></span><br><span class="line">        e; K k; V v;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p; <span class="comment">//p是头节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">// p是ThreeNode</span></span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 链表的处理</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;<span class="comment">// 查找要删除的节点</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;<span class="comment">// p 更新为要删除节点的上一个节点</span></span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p) <span class="comment">// node是头结点</span></span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//删除node节点</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount; <span class="comment">// 修改次数 ++ </span></span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、JDK1-7"><a href="#六、JDK1-7" class="headerlink" title="六、JDK1.7"></a>六、JDK1.7</h2><h3 id="6-1、数据结构"><a href="#6-1、数据结构" class="headerlink" title="6.1、数据结构"></a>6.1、数据结构</h3><p> 与1.8的 HashMap的区别为数据结构为数组加链表，没有二叉树。</p>
<h3 id="6-2、Hash规则"><a href="#6-2、Hash规则" class="headerlink" title="6.2、Hash规则"></a>6.2、Hash规则</h3><p>hash规则与1.8 基本一致，通过高低位异或使得数据hash值更均匀。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode(); <span class="comment">// 先异或</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>); </span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>节点的table索引计算规则不变</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</span></span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-3、put"><a href="#6-3、put" class="headerlink" title="6.3、put"></a>6.3、put</h3><p>put方法采用的是头插法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 头插法插入</span></span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    <span class="comment">// 这里很关键，插入时新节点的的next -&gt; 头节点</span></span><br><span class="line">    <span class="comment">// 将新节点放到原头节点的位置</span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.2、resize 扩容</p>
<p>resize 扩容的核心算法是transfer，采用的是头插法，扩容后的链表顺序会翻转，多线程时候可能会形成循环链表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Transfers all entries from current table to newTable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123; <span class="comment">//遍历并转移</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            <span class="comment">// 扩容时采用头插法，列表被逆转</span></span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>采用的是数组 + 列表的数据结构</p>
</li>
<li><p>采用懒加载方式，数组默认的大小是16，扩容因子为0.75，扩容阈值为数组大小 size * 0.75；</p>
</li>
<li><p>触发扩容的条件是数组容量大于扩容阈值，每次扩容是原来的2倍，扩容时，将当前桶位数组的元素重新计算桶位hash，将当前桶拆出一个新桶索引是 index + oldCap</p>
</li>
<li><p>树化</p>
<p>当桶数组中链表长度达到8之后且桶数组长度大于64时，进行树化，将Node节点转换成TreeNode，TreeNode既有双向链表的特性又有树的特性；然后将当前单链表转化成双向链表；再将双向链表转化成树。</p>
</li>
<li><p>树降级</p>
<p>扩容过程中，某个桶位的元素在扩容后拆分为2个链表放到到2个桶位，导致新桶位的元素长度可能小于8，就需要将当前树降级为链表。</p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1LJ411W7dP?p=3">https://www.bilibili.com/video/BV1LJ411W7dP?p=3</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1uy4y1k7Uf">https://www.bilibili.com/video/BV1uy4y1k7Uf</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/21/Notes/Java/Collections/Java%E9%9B%86%E5%90%88_05_LinkedHashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/21/Notes/Java/Collections/Java%E9%9B%86%E5%90%88_05_LinkedHashMap/" class="post-title-link" itemprop="url">Java集合_05_LinkedHashMap</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-21 21:23:24" itemprop="dateCreated datePublished" datetime="2021-04-21T21:23:24+08:00">2021-04-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/collection/" itemprop="url" rel="index"><span itemprop="name">collection</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java集合-05-LinkedHashMap"><a href="#Java集合-05-LinkedHashMap" class="headerlink" title="Java集合_05_LinkedHashMap"></a>Java集合_05_LinkedHashMap</h1><p>LinkedHashMap的是继承自HashMap，数据结构和HashMap基本一致，区别是：</p>
<p><code>LinkedHashMap的节点Entry中增加了前驱和后继指针，将各个桶位中的元素按照添加的顺序管理起来，形成一个双向链表。</code>最终的结构类似下图。也就是说LinkedHashMap中维护了2个数据结构，桶数组和双向链表。</p>
<p><img src="/pics/image-20210421113017742.png" alt="image-20210421113017742"></p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 前驱 + 后继</span></span><br><span class="line">        Entry&lt;K,V&gt; before, after;</span><br><span class="line">        Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 头节点</span></span><br><span class="line">    <span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line">    <span class="comment">// 尾结点</span></span><br><span class="line">    <span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line">    <span class="comment">// false： 基于插入顺序  true：  基于访问顺序 </span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br><span class="line">&#125;       </span><br></pre></td></tr></table></figure>

<h2 id="相比hashMap新增函数"><a href="#相比hashMap新增函数" class="headerlink" title="相比hashMap新增函数"></a>相比hashMap新增函数</h2><p>在HashMap中提到了下面的定义,这3个函数在HashMap中并没有实现，LinkedHashMap中实现了这3个函数，顾名思义这三个函数的作用分别是：get、put、remove后做一些事情。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问后</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入后</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove 时</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="put-gt-afterNodeInsertion"><a href="#put-gt-afterNodeInsertion" class="headerlink" title="put-&gt;afterNodeInsertion"></a>put-&gt;afterNodeInsertion</h3><p>LinkedHashMap并没有重写任何put方法。但是其重写了构建新节点的newNode()方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>采用尾插法，建立节点间的关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时put之后如果需要移除最老的节点，LinkedHashMap重写了<code>afterNodeInsertion</code>方法，但是可以看到<code>removeEldestEntry</code>这个方法直接返回的false，因此如果要生效需要重写<code>removeEldestEntry</code>该方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123; <span class="comment">// 头元素出队</span></span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="get-gt-afterNodeAccess"><a href="#get-gt-afterNodeAccess" class="headerlink" title="get -&gt; afterNodeAccess"></a>get -&gt; afterNodeAccess</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder) <span class="comment">// accessOrder == true 时，需要将当前元素移动到链表尾部</span></span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果定义了accessOrder，那么就保证最近访问节点放到最后，主要操作有2步：</p>
<ol>
<li>将节点从链表中移除掉</li>
<li>将节点加入到队列尾部</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用来判断之前的列表是不是空列表</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123; <span class="comment">//</span></span><br><span class="line">        <span class="comment">// p 是当前节点</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, </span><br><span class="line">        <span class="comment">// b 是p的前驱</span></span><br><span class="line">        b = p.before, </span><br><span class="line">        <span class="comment">// a 是p的后继</span></span><br><span class="line">        a = p.after;</span><br><span class="line">        <span class="comment">// 要将p作为尾结点，所以p.after一定是null</span></span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ==========将节点从链表中移除 ==========</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)   <span class="comment">// p 是头节点</span></span><br><span class="line">            head = a;  <span class="comment">// head 指向 next</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a; <span class="comment">// b的后继指向 a，跳过了p节点 </span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>) <span class="comment">// a 不等于空，说明</span></span><br><span class="line">            a.before = b; <span class="comment">// a的前驱后继指向 b， 跳过p节点</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b; <span class="comment">// a == null，说明p是尾结点 ，last记录下</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ==========将节点加入到链表中 ==============</span></span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>) <span class="comment">// 空链表，head 指向p</span></span><br><span class="line">            head = p;<span class="comment">// </span></span><br><span class="line">        <span class="keyword">else</span> &#123;               </span><br><span class="line">            p.before = last; <span class="comment">// 非空链表插入到节点中</span></span><br><span class="line">            last.after = p; <span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">        tail = p; <span class="comment">// p 是尾结点</span></span><br><span class="line">        </span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：如果设置了accessOrder = true，那么在遍历的过程中，不可以去get元素，否则会报出异常，原因是设置了accessOrder = true，我们在get操作时，modCount发生了变化，导致 modCount != expectedModCount。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testLinkedHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LinkedHashMap&lt;String, String&gt; linkedHashMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(<span class="number">10</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    linkedHashMap.put(<span class="string">&quot;a&quot;</span>, <span class="string">&quot; 1&quot;</span>);</span><br><span class="line">    linkedHashMap.put(<span class="string">&quot;b&quot;</span>, <span class="string">&quot; 2&quot;</span>);</span><br><span class="line">    linkedHashMap.put(<span class="string">&quot;c&quot;</span>, <span class="string">&quot; 3&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : linkedHashMap.entrySet()) &#123;</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">&quot;:&quot;</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (String key : linkedHashMap.keySet()) &#123;</span><br><span class="line">        System.out.println(linkedHashMap.get(key)); <span class="comment">// 异常，Exception in thread &quot;main&quot; java.util.ConcurrentModificationException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/16180568/concurrentmodificationexception-with-linkedhashmap/16180833">https://stackoverflow.com/questions/16180568/concurrentmodificationexception-with-linkedhashmap/16180833</a></p>
<h3 id="remove-gt-afterNodeRemoval"><a href="#remove-gt-afterNodeRemoval" class="headerlink" title="remove -&gt; afterNodeRemoval"></a>remove -&gt; afterNodeRemoval</h3><p>remove 先是从HashMap的桶数组中remove掉这个值，然后再将这个节点从双向链表中删除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 省略</span></span><br><span class="line"> 	afterNodeRemoval(node);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// unlink</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e,</span><br><span class="line">    <span class="comment">// b 是p的前驱</span></span><br><span class="line">    b = p.before, </span><br><span class="line">    <span class="comment">// a 是p的后继</span></span><br><span class="line">    a = p.after;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 前驱和后继置空</span></span><br><span class="line">    p.before = p.after = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 前驱为空</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">        head = a; <span class="comment">// 头节点 指向a</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.after = a; <span class="comment">// b的后继指向a ，跳过p</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后继为空，说明是尾结点</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        tail = b; <span class="comment">// 尾结点指向b</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = b; <span class="comment">// a的前驱指向b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="LRUCache"><a href="#LRUCache" class="headerlink" title="LRUCache"></a>LRUCache</h3><p>LinkedHashMap的一个重要应用是在LruCache中，设置缓存固定大小，并且按照访问顺序排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LruCache</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;maxSize &lt;= 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">    <span class="keyword">this</span>.map = <span class="keyword">new</span> LinkedHashMap&lt;K, V&gt;(<span class="number">0</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/21/Notes/Java/Collections/Java%E9%9B%86%E5%90%88_06_CopyOnWriteArrayList/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/21/Notes/Java/Collections/Java%E9%9B%86%E5%90%88_06_CopyOnWriteArrayList/" class="post-title-link" itemprop="url">Java集合_06_CopyOnWriteArrayList</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-21 21:23:24" itemprop="dateCreated datePublished" datetime="2021-04-21T21:23:24+08:00">2021-04-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/collection/" itemprop="url" rel="index"><span itemprop="name">collection</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java集合-06-CopyOnWriteArrayList"><a href="#Java集合-06-CopyOnWriteArrayList" class="headerlink" title="Java集合_06_CopyOnWriteArrayList"></a>Java集合_06_CopyOnWriteArrayList</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chengxiao/p/6881974.html">https://www.cnblogs.com/chengxiao/p/6881974.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/21/Notes/Java/Collections/Java%E9%9B%86%E5%90%88_01_Collection%E4%BD%93%E7%B3%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/21/Notes/Java/Collections/Java%E9%9B%86%E5%90%88_01_Collection%E4%BD%93%E7%B3%BB/" class="post-title-link" itemprop="url">Java集合_01_Collection体系</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-21 21:23:24" itemprop="dateCreated datePublished" datetime="2021-04-21T21:23:24+08:00">2021-04-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/collection/" itemprop="url" rel="index"><span itemprop="name">collection</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java集合-01-Collection体系"><a href="#Java集合-01-Collection体系" class="headerlink" title="Java集合_01_Collection体系"></a>Java集合_01_Collection体系</h1><p><img src="/pics/image-20210420233635797.png" alt="image-20210420233635797"></p>
<p><a target="_blank" rel="noopener" href="https://pierrchen.blogspot.com/2014/03/java-collections-framework-cheat-sheet.html">java集合体系</a></p>
<p>在语言架构上，集合类分为了 Map 和 Collection 两个大的类别。List、Set、Queue 都继承于 Collection。</p>
<ul>
<li><p>左上角的那一块灰色里面的四个类（Dictionary、HashTable、Vector、Stack）都是 JDK 遗留下的类，太老了，已经没人使用，而且都有了对应的取代类</p>
</li>
<li><p>图片分上下两部分，最上边粉红色部分是集合类所有接口关系图，绿色部分是他们的主要实现类，也就是我们真正使用的常用集合类</p>
</li>
<li><p>下半部分中都是<code>java.util.concurrent</code> 包下内容，也就是我们常用的并发集合包。同样粉色部分是接口，绿色是其实现类。</p>
</li>
<li><p><strong>同步容器可以简单地理解为通过synchronized来实现同步的容器</strong>，比如 Vector、Hashtable 以及SynchronizedList、SynchronizedMap 等容器。</p>
</li>
</ul>
<p>对象的容器，实现了对对象常用的操作</p>
<p><strong>集合和数组的区别</strong></p>
<ol>
<li>数组长度固定，集合长度不固定</li>
<li>数组可以存储基本类型和引用类型，集合只能存储引用类型</li>
</ol>
<h1 id="to-do-。。。"><a href="#to-do-。。。" class="headerlink" title="to do 。。。"></a>to do 。。。</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/20/Notes/Java/Collections/Java%E9%9B%86%E5%90%88_03_LinkedList/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/20/Notes/Java/Collections/Java%E9%9B%86%E5%90%88_03_LinkedList/" class="post-title-link" itemprop="url">Java集合_03_LinkedList</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-20 23:23:06" itemprop="dateCreated datePublished" datetime="2021-04-20T23:23:06+08:00">2021-04-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/collection/" itemprop="url" rel="index"><span itemprop="name">collection</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java集合-03-LinkedList"><a href="#Java集合-03-LinkedList" class="headerlink" title="Java集合_03_LinkedList"></a>Java集合_03_LinkedList</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>使用的数据结构是双向链表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pointer to first node.</span></span><br><span class="line"><span class="comment">     * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">     *            (first.prev == null &amp;&amp; first.item != null)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pointer to last node.</span></span><br><span class="line"><span class="comment">     * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">     *            (last.next == null &amp;&amp; last.item != null)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点</span></span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = element;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">            <span class="keyword">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><p>尾插法插入到链表中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 新插入的元素是尾节点</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>) <span class="comment">// 首个节点</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode; <span class="comment">// 关联双向链表</span></span><br><span class="line">    </span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><p>remove 支持移除null元素，核心方法是unlink</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h3><p>unlink 中的核心原理其实就是双向链表出队的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123; <span class="comment">// 若当前节点前驱为空，说明是头节点</span></span><br><span class="line">        first = next; <span class="comment">// 将first指向它的下一个节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next; <span class="comment">// 不是头节点时，前驱不为空时，将后继赋值给前驱的后继</span></span><br><span class="line">        x.prev = <span class="keyword">null</span>; <span class="comment">// 置空它的前驱</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;<span class="comment">//若当前节点后继为空，说明它是尾结点</span></span><br><span class="line">        last = prev; <span class="comment">// 更新尾节点为他的前驱</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;<span class="comment">// 不是尾结点时，后继不为空时，将前驱赋值给后继的前驱</span></span><br><span class="line">        x.next = <span class="keyword">null</span>; <span class="comment">// 置空后继</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="keyword">null</span>; <span class="comment">// 元素置空</span></span><br><span class="line">    size--; </span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/20/Notes/Java/Collections/Java%E9%9B%86%E5%90%88_02_ArrayList/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/20/Notes/Java/Collections/Java%E9%9B%86%E5%90%88_02_ArrayList/" class="post-title-link" itemprop="url">Java集合_02_ArrayList</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-20 23:23:06" itemprop="dateCreated datePublished" datetime="2021-04-20T23:23:06+08:00">2021-04-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/collection/" itemprop="url" rel="index"><span itemprop="name">collection</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java集合-02-ArrayList"><a href="#Java集合-02-ArrayList" class="headerlink" title="Java集合_02_ArrayList"></a>Java集合_02_ArrayList</h1><p>ArrayList使用的是数据结构是数组，默认的初始容量是10，触发扩容时每次扩容为原来的1.5倍。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>ArrayList使用的是数据结构是数组，默认的初始容量是10，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 默认大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 2. 空数组，初始化容量大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 3. 默认数组，空构造函数使用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 4. 元素数组</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line">    <span class="comment">// 5. size大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 1. 初始化大小</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 默认构造使用的是空数组</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><p>添加元素的主要步骤有2个：</p>
<ol>
<li>保证容量能够满足</li>
<li>添加元素到数组中</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.保证容量能够满足</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// 2.添加元素</span></span><br><span class="line">    elementData[size++] = e; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; </span><br><span class="line">        <span class="comment">// 若是空构造函数初始化的，添加元素时，容量大小默认是10</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加的元素超过当前数组大小时，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="grow"><a href="#grow" class="headerlink" title="grow"></a>grow</h3><p>扩容规则：</p>
<ol>
<li>容量扩容为原来的1.5倍</li>
<li>将元素copy到新数组</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.minCapacity 需要的空间大小</span></span><br><span class="line">    <span class="comment">// 2.oldCapacity 当前数组大小</span></span><br><span class="line">    <span class="comment">// 3.newCapacity 扩容为原来的1.5倍</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>); <span class="comment">// 扩容规则扩容为原来的1.5倍</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.扩容后newCapacity 小于 minCapacity 有一种情况：</span></span><br><span class="line">    <span class="comment">// 初始数组大小为0时，第一次put元素时</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.如果扩容后大于 MAX_ARRAY_SIZE，取一个适当的最大值</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.将元素copy到新数组</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.minCapacity &lt; 0，表示超过int的最大值，溢出了</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="comment">// 2.minCapacity 超过MAX_ARRAY_SIZE的最大值，取Integer.MAX_VALUE，否则取 MAX_ARRAY_SIZE</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h2><p>集合的使用过程中，遍历是最常做的操作之一。</p>
<p> 使用迭代器遍历元素时（包括增强for循环，内部使用的是迭代器），若要删除元素必须使用 iterator remove，不能使用集合去删除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testNormal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    arrayList.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    arrayList.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    arrayList.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrayList.size(); i++) &#123;</span><br><span class="line">        arrayList.remove(<span class="string">&quot;b&quot;</span>); <span class="comment">//</span></span><br><span class="line">        System.out.println(arrayList.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：a c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testForEach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    arrayList.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    arrayList.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    arrayList.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String s : arrayList) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        arrayList.remove(<span class="string">&quot;b&quot;</span>); <span class="comment">// 异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出： </span></span><br><span class="line"><span class="comment">//  Exception in thread &quot;main&quot; java.util.ConcurrentModificationException</span></span><br><span class="line"><span class="comment">//	at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:909)</span></span><br><span class="line"><span class="comment">//	at java.util.ArrayList$Itr.next(ArrayList.java:859)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    arrayList.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    arrayList.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    arrayList.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    Iterator&lt;String&gt; iterator = arrayList.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">        String str = iterator.next();</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;b&quot;</span>.equals(str)) &#123;</span><br><span class="line">             <span class="comment">// iterator.remove();  // 正常</span></span><br><span class="line">            arrayList.remove(<span class="string">&quot;b&quot;</span>);  <span class="comment">// 异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  输出：</span></span><br><span class="line"><span class="comment">//  Exception in thread &quot;main&quot; java.util.ConcurrentModificationException</span></span><br><span class="line"><span class="comment">//	at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:909)</span></span><br><span class="line"><span class="comment">//	at java.util.ArrayList$Itr.next(ArrayList.java:859)</span></span><br></pre></td></tr></table></figure>

<p>解释下原因：</p>
<p><code>ArrayList</code> 中有个 modCount，用来记录数组被修改的次数（增/删时 ++）；</p>
<p>当我们构造Iterator 时，<code>Itr</code> 会使用<code>ArrayList#modCount</code>对<code>Itr#expectedModCount</code> 参数进行初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录数组被修改的次数，其实是在AbstractList </span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">        <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">        <span class="comment">// ！！！ 关键 ！！！，初始化时会将当时的modCount赋值给 expectedModCount</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ArrayList-remove"><a href="#ArrayList-remove" class="headerlink" title="ArrayList.remove"></a>ArrayList.remove</h3><p> 每次使用remove，modCount 都会自增1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ArrayList.remove </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. !!! 重点 modCount ++</span></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>) </span><br><span class="line">        <span class="comment">// 2.删除完之后，将index之后元素要往前移动一位</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h3 id="Itr-next"><a href="#Itr-next" class="headerlink" title="Itr.next"></a>Itr.next</h3><p>使用迭代器遍历过程中使用的next方法取下一个元素，每调用 next 都会check modCount 和 expectedModCount 的值；当我们在迭代过程中调用了<code>ArrayList.remove</code>方法时就会导致，这2个值不同，进而抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果使用 ArrayList.remove 会导致modCount != expectedModCount，进而会抛出异常</span></span><br><span class="line">        checkForComodification(); </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) <span class="comment">// 抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Iterator-remove"><a href="#Iterator-remove" class="headerlink" title="Iterator.remove"></a>Iterator.remove</h3><p>而使用迭代器的remove不会抛出异常为何呢？迭代器remove时中有2步：</p>
<ol>
<li>先调用 ArrayList .remove移除当前元素</li>
<li><strong>将最新的 modCount 赋值给 expectedModCount</strong>，关键就是这一步，会更新expectedModCount的值，保持和modCount 一致。 </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Iterator.remove </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    checkForComodification();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.先调用 ArrayList 移除当前元素</span></span><br><span class="line">        ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">        cursor = lastRet;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 2.更新下expectedModCount</span></span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/17/Notes/Java/JVM/JVM_08_%E6%96%B9%E6%B3%95%E5%8C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/17/Notes/Java/JVM/JVM_08_%E6%96%B9%E6%B3%95%E5%8C%BA/" class="post-title-link" itemprop="url">JVM_08_方法区</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-17 10:05:36" itemprop="dateCreated datePublished" datetime="2021-04-17T10:05:36+08:00">2021-04-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JVM-08-方法区"><a href="#JVM-08-方法区" class="headerlink" title="JVM_08_方法区"></a>JVM_08_方法区</h1><p><strong>方法区主要存放的是 Class</strong>，<strong>而堆中主要存放的是实例化的对象</strong>，<strong>方法区可以看作是一块独立于Java堆的内存空间</strong>。</p>
<ul>
<li>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域</li>
<li>多个线程同时加载统一个类时，只能有一个线程能加载该类，其他线程只能等等待该线程加载完毕，然后直接使用该类，即类只能加载一次</li>
<li>方法区在JVM启动的时候被创建，并且它的实际物理内存空间和Java堆区一样都可以是不连续的。</li>
<li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展</li>
<li>方法区是接口，元空间或者永久代是方法区的实现</li>
<li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：java.lang.OutofMemoryError:PermGen space（JDK7之前）或者 java.lang.OutOfMemoryError:Metaspace（JDK8之后）</li>
<li>关闭JVM就会释放方法区内存</li>
</ul>
<h2 id="栈、堆、方法区的交互关系"><a href="#栈、堆、方法区的交互关系" class="headerlink" title="栈、堆、方法区的交互关系"></a>栈、堆、方法区的交互关系</h2><h3 id="线程共享的角度"><a href="#线程共享的角度" class="headerlink" title="线程共享的角度"></a>线程共享的角度</h3><p><img src="/pics/image-20210416100231841.png" alt="image-20210416100231841"></p>
<p>线程共享：堆 + 方法区，存在OOM 和 GC</p>
<p>线程私有：虚拟机栈 + 本地方法栈 + PC寄存器，虚拟机栈 + 本地方法栈存在栈溢出问题，PC寄存器</p>
<h3 id="相互的关系"><a href="#相互的关系" class="headerlink" title="相互的关系"></a>相互的关系</h3><img src="/pics/image-20210416100432888.png" alt="image-20210416100432888" style="zoom:67%;" />

<p>虚拟机栈中对象引用执行堆中的Persion对象实例数据，Persion对象的class信息又是保存在方法区中的，需要通过类型数据指针指向Persion.class类型信息。</p>
<h2 id="Hotspot中方法区的演进过程"><a href="#Hotspot中方法区的演进过程" class="headerlink" title="Hotspot中方法区的演进过程"></a>Hotspot中方法区的演进过程</h2><p><strong>在 JDK7 及以前，习惯上把方法区，称为永久代。JDK8开始，使用元空间取代了永久代</strong>。</p>
<ul>
<li>本质上，方法区和永久代并不等价。仅是对Hotspot而言的可以看作等价。</li>
<li>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。</li>
<li><strong>元空间不在虚拟机的内存中，而是使用本地内存</strong>。</li>
</ul>
<img src="/pics/image-20210416102338775.png" alt="image-20210416102338775" style="zoom:70%;" />

<h3 id="永久代的演进过程"><a href="#永久代的演进过程" class="headerlink" title="永久代的演进过程"></a>永久代的演进过程</h3><p><img src="/pics/image-20210416145726419.png" alt="image-20210416145726419"></p>
<ul>
<li>JDK6，方法区由永久代实现，使用 JVM 虚拟机内存</li>
</ul>
<p><img src="/pics/image-20210416150341751.png" alt="image-20210416150341751"></p>
<ul>
<li>JDK7 方法区由永久代实现，使用 JVM 虚拟机内存，静态变量和字符串常量池保存在堆中</li>
</ul>
<p><img src="/pics/image-20210416150504193.png" alt="image-20210416150504193"></p>
<p>JDK8及以后，方法区由元空间实现，<strong>使用本地内存</strong></p>
<img src="/pics/image-20210416150414929.png" alt="image-20210416150414929" style="zoom:70%;" />

<h3 id="元空间为什么要替代永久代"><a href="#元空间为什么要替代永久代" class="headerlink" title="元空间为什么要替代永久代"></a>元空间为什么要替代永久代</h3><ul>
<li><p>官方的牵强解释：JRockit是和HotSpot融合后的结果，因为JRockit没有永久代，所以他们不需要配置永久代，HotSpot也就取消了永久代</p>
</li>
<li><p>为永久代设置空间大小是很难确定的</p>
<p>如果动态加载类过多，容易产生Perm区的OOM。<strong>元空间并不在虚拟机中，而是使用本地内存，元空间的大小仅受本地内存限制</strong></p>
</li>
<li><p>对永久代进行调优是很困难的</p>
<ul>
<li>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再用的类型，方法 区的调优主要是为了降低Full GC</li>
<li>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。</li>
</ul>
</li>
</ul>
<h2 id="设置方法区大小与OOM"><a href="#设置方法区大小与OOM" class="headerlink" title="设置方法区大小与OOM"></a>设置方法区大小与OOM</h2><p>方法区的大小不必是固定的，JVM可以根据应用的需要动态调整</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试设置方法区大小参数的默认值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * jdk7及以前：</span></span><br><span class="line"><span class="comment"> * -XX:PermSize=100m -XX:MaxPermSize=100m</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * jdk8及以后：</span></span><br><span class="line"><span class="comment"> * -XX:MetaspaceSize=100m  -XX:MaxMetaspaceSize=100m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;end...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h3><p><strong>内存泄漏就是有大量的引用指向某些对象，但是这些对象以后不会使用了</strong>，但是因为它们还和GC ROOT有关联，所以导致以后这些对象也不会被回收，这就是内存泄漏的问题</p>
<p>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。<strong>于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的</strong>。掌握了泄漏对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置。</p>
<h2 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h2><p>它用于存储已被虚拟机加载的<strong>类型信息、运行时常量池、静态变量、即时编译器编译后的代码缓存</strong>等。</p>
<p><img src="/pics/image-20210416162001528.png" alt="image-20210416162001528"></p>
<h3 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h3><p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：</p>
<ul>
<li>这个类型的完整有效名称（全类名=包名.类名）</li>
<li>这个类型直接父类的完整有效名（对于interface或是java.lang.Object，都没有父类）</li>
<li>这个类型的修饰符（public，abstract，final的某个子集）</li>
<li>这个类型直接接口的一个有序列表</li>
</ul>
<h3 id="域（Field）信息"><a href="#域（Field）信息" class="headerlink" title="域（Field）信息"></a>域（Field）信息</h3><p>JVM 必须在方法区中保存类型的所有域的相关信息以及域的声明顺序</p>
<ul>
<li><p><code>域信息</code>通俗来讲是类的成员变量（static 修饰）</p>
</li>
<li><p>域的相关信息包括：域名称、域类型、域修饰符（public、private、protected、static、final、volatile、transient 的某个子集）</p>
</li>
</ul>
<h3 id="方法（Method）信息"><a href="#方法（Method）信息" class="headerlink" title="方法（Method）信息"></a>方法（Method）信息</h3><p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p>
<ul>
<li>方法名称</li>
<li>方法的返回类型</li>
<li>方法参数的数量和类型</li>
<li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract 的一个子集）</li>
<li>方法的字符码（bytecodes）、操作数栈、局部变量表及大小（abstract 和 native 方法除外）</li>
<li>异常表（abstract 和 native 方法除外），每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li>
</ul>
<blockquote>
<p>static final 修饰的常量在编译的时候就会被分配了。</p>
</blockquote>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。</p>
<ul>
<li>运行时常量池，JVM加载类和后，就会创建对应的运行时常量池。</li>
<li>JVM为每个类都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。</li>
<li>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。<strong>此时不再是常量池中的符号应用了，这里换为直接引用（真实地址）</strong>。</li>
<li>运行时常量池，相对于Class文件常量池的另一重要特征是：<strong>具备动态性</strong>。不如可以通过String.intern() 向运行时常量池中放置常量。</li>
</ul>
<blockquote>
<p>常量池和运行时常量池</p>
<p><strong>常量池表（Constant Pool Table）是Class字节码文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中</strong>。</p>
<p><strong>运行时常量池（Runtime Constant Pool）是方法区的一部分</strong>。</p>
</blockquote>
<h4 id="为什么需要常量池？"><a href="#为什么需要常量池？" class="headerlink" title="为什么需要常量池？"></a>为什么需要常量池？</h4><p>字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外，还包含一项信息就是<strong>常量池表</strong>（<strong>Constant Pool Table</strong>），包括<strong>各种字面量（属性值）和对类型、域（成员变量）和方法的符号引用</strong>。</p>
<img src="/pics/image-20210417184336117.png" alt="image-20210417184336117" style="zoom:30%;" />

<p>Java文件中的类、接口，编译后产生字节码文件，而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，所以使用<strong>符号引用</strong>的方式存到了常量池。而这些符号引用，在程序运行时被转化为<strong>直接引用</strong>（地址），这个过程称为<strong>动态链接</strong>。</p>
<h3 id="内部结构举例"><a href="#内部结构举例" class="headerlink" title="内部结构举例"></a>内部结构举例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodInnerStrucTest</span> <span class="keyword">extends</span> <span class="title">Object</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> xx = <span class="number">1001L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> yy = <span class="number">1000L</span>;</span><br><span class="line">    <span class="keyword">private</span> String nihao = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String str = <span class="string">&quot;测试方法的内部结构&quot;</span>;</span><br><span class="line">    <span class="comment">//构造器没写</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">20</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;count = &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test2</span><span class="params">(<span class="keyword">int</span> cal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> value = <span class="number">30</span>;</span><br><span class="line">            result = value / cal;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ======反编译字节码结果====</span></span><br><span class="line">Classfile /E:/work/JavaLearn/out/production/jvm/MethodInnerStrucTest.class</span><br><span class="line">  Last modified <span class="number">2021</span>-<span class="number">4</span>-<span class="number">16</span>; size <span class="number">1646</span> bytes</span><br><span class="line">  MD5 checksum ea25c6e80bbc8e5b2650095fd4359124</span><br><span class="line">  Compiled from <span class="string">&quot;MethodInnerStructTest.java&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodInnerStrucTest</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Comparable</span>&lt;<span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class">  <span class="title">minor</span> <span class="title">version</span>: 0</span></span><br><span class="line"><span class="class">  <span class="title">major</span> <span class="title">version</span>: 52</span></span><br><span class="line"><span class="class">  <span class="title">flags</span>: <span class="title">ACC_SUPER</span></span></span><br><span class="line"><span class="class"><span class="title">Constant</span> <span class="title">pool</span>: // 常量池</span></span><br><span class="line"><span class="class">   #1 </span>= Methodref          #<span class="number">20.</span>#<span class="number">55</span>        <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">19.</span>#<span class="number">56</span>        <span class="comment">// MethodInnerStrucTest.num:I</span></span><br><span class="line">   #<span class="number">3</span> = String             #<span class="number">57</span>            <span class="comment">// hello world</span></span><br><span class="line">   #<span class="number">4</span> = Fieldref           #<span class="number">19.</span>#<span class="number">58</span>        <span class="comment">// MethodInnerStrucTest.nihao:Ljava/lang/String;</span></span><br><span class="line">   #<span class="number">5</span> = Fieldref           #<span class="number">59.</span>#<span class="number">60</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   #<span class="number">6</span> = Class              #<span class="number">61</span>            <span class="comment">// java/lang/StringBuilder</span></span><br><span class="line">   #<span class="number">7</span> = Methodref          #<span class="number">6.</span>#<span class="number">55</span>         <span class="comment">// java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">8</span> = String             #<span class="number">62</span>            <span class="comment">// count =</span></span><br><span class="line">   #<span class="number">9</span> = Methodref          #<span class="number">6.</span>#<span class="number">63</span>         <span class="comment">// java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">  #<span class="number">10</span> = Methodref          #<span class="number">6.</span>#<span class="number">64</span>         <span class="comment">// java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span></span><br><span class="line">  #<span class="number">11</span> = Methodref          #<span class="number">6.</span>#<span class="number">65</span>         <span class="comment">// java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">  #<span class="number">12</span> = Methodref          #<span class="number">66.</span>#<span class="number">67</span>        <span class="comment">// java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">  #<span class="number">13</span> = Class              #<span class="number">68</span>            <span class="comment">// java/lang/Exception</span></span><br><span class="line">  #<span class="number">14</span> = Methodref          #<span class="number">13.</span>#<span class="number">69</span>        <span class="comment">// java/lang/Exception.printStackTrace:()V</span></span><br><span class="line">  #<span class="number">15</span> = Class              #<span class="number">70</span>            <span class="comment">// java/lang/String</span></span><br><span class="line">  #<span class="number">16</span> = Methodref          #<span class="number">19.</span>#<span class="number">71</span>        <span class="comment">// MethodInnerStrucTest.compareTo:(Ljava/lang/String;)I</span></span><br><span class="line">  #<span class="number">17</span> = String             #<span class="number">72</span>            <span class="comment">// 测试方法的内部结构</span></span><br><span class="line"><span class="comment">// 省略 ...</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> num; <span class="comment">// 域信息</span></span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: <span class="function">ACC_PUBLIC</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>; <span class="comment">// 方法信息</span></span><br><span class="line">    descriptor: ()V    <span class="comment">// 方法返回值</span></span><br><span class="line">    flags: ACC_PUBLIC  <span class="comment">// 方法修饰符 </span></span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span> <span class="comment">//方法字节码信息</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">20</span></span><br><span class="line">         <span class="number">2</span>: istore_1</span><br><span class="line">         <span class="number">3</span>: getstatic     #<span class="number">5</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">6</span>: <span class="keyword">new</span>           #<span class="number">6</span>                  <span class="comment">// class java/lang/StringBuilder</span></span><br><span class="line">         <span class="number">9</span>: dup</span><br><span class="line">        <span class="number">10</span>: invokespecial #<span class="number">7</span>                  <span class="comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        <span class="number">13</span>: ldc           #<span class="number">8</span>                  <span class="comment">// String count =</span></span><br><span class="line">        <span class="number">15</span>: invokevirtual #<span class="number">9</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">        <span class="number">18</span>: iload_1</span><br><span class="line">        <span class="number">19</span>: invokevirtual #<span class="number">10</span>                 <span class="comment">// Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span></span><br><span class="line">        <span class="number">22</span>: invokevirtual #<span class="number">11</span>                 <span class="comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">        <span class="number">25</span>: invokevirtual #<span class="number">12</span>                 <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">        <span class="number">28</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">13</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">14</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">15</span>: <span class="number">28</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">29</span>     <span class="number">0</span>  <span class="keyword">this</span>   LMethodInnerStrucTest;</span><br><span class="line">            <span class="number">3</span>      <span class="number">26</span>     <span class="number">1</span> count   I</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         <span class="number">0</span>: ldc           #<span class="number">17</span>                 <span class="comment">// String 测试方法的内部结构</span></span><br><span class="line">         <span class="number">2</span>: putstatic     #<span class="number">18</span>                 <span class="comment">// Field str:Ljava/lang/String;</span></span><br><span class="line">         <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">Signature: #<span class="number">52</span>                          <span class="comment">// Ljava/lang/Object;Ljava/lang/Comparable&lt;Ljava/lang/String;&gt;;Ljava/io/Serializable;</span></span><br><span class="line">SourceFile: <span class="string">&quot;MethodInnerStructTest.java&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="字符串常量池-StringTable-为什么要调整位置？"><a href="#字符串常量池-StringTable-为什么要调整位置？" class="headerlink" title="字符串常量池 StringTable 为什么要调整位置？"></a>字符串常量池 StringTable 为什么要调整位置？</h3><p>JDK7中将StringTable放到了堆空间中。<strong>因为永久代的回收效率很低</strong>，在Full GC的时候才会执行永久代的垃圾回收，而Full GC是老年代的空间不足、永久代不足时才会触发。</p>
<p>这就导致StringTable回收效率不高，而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。<strong>放到堆里，能及时回收内存</strong>。</p>
<h3 id="静态变量对象存放在哪里？"><a href="#静态变量对象存放在哪里？" class="headerlink" title="静态变量对象存放在哪里？"></a>静态变量对象存放在哪里？</h3><p>静态变量引用对应的对象实体始终都在堆空间中（符合堆的内存分配规则） ，变量引用放在了元空间。</p>
<p><img src="/pics/image-20210418203012633.png" alt="image-20210418203012633"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 结论：</span></span><br><span class="line"><span class="comment"> *  静态变量在jdk6/7存在与永久代中，在jdk8存在于堆中 //private static byte[] arr</span></span><br><span class="line"><span class="comment"> *  静态引用对应的对象实体始终都存在堆空间 //new byte[1024 * 1024 * 100];</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * jdk7：</span></span><br><span class="line"><span class="comment"> * -Xms200m -Xmx200m -XX:PermSize=300m -XX:MaxPermSize=300m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> * jdk 8：</span></span><br><span class="line"><span class="comment"> * -Xms200m -Xmx200m -XX:MetaspaceSize=300m -XX:MaxMetaspaceSize=300m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticFieldTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>]; <span class="comment">//100MB</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(StaticFieldTest.arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h3><p>方法区内常量池之中主要存放的两大类常量：<strong>字面量和符号引用</strong></p>
<ul>
<li>字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等</li>
<li>符号引用则属于编译原理方面的概念，包括下面三类常量：<ul>
<li>类和接口的全限定名</li>
<li>域（字段）的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
</li>
</ul>
<p>HotSpot虚拟机对常量池的回收策略是很明确的，<code>只要运行时常量池中的常量没有被任何地方引用，就可以被回收</code>。</p>
<p>而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了</p>
<ul>
<li><strong>该类所有的实例都已经被回收</strong>，也就是Java堆中不存在该类及其任何派生子类的实例。</li>
<li><strong>该类的类加载器已经被回收</strong>，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</li>
<li><strong>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</strong></li>
</ul>
<p>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用<code>-verbose:class 以及 -XX：+TraceClass-Loading、-XX：+TraceClassUnLoading</code>查看类加载和卸载信息。</p>
<p>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及 OSGi 这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</p>
<h3 id="大厂面试题"><a href="#大厂面试题" class="headerlink" title="大厂面试题"></a>大厂面试题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">百度</span><br><span class="line"></span><br><span class="line">三面：说一下JVM内存模型吧，有哪些区？分别干什么的？</span><br><span class="line">字节跳动</span><br><span class="line"></span><br><span class="line">二面：Java的内存分区</span><br><span class="line">二面：讲讲vm运行时数据库区</span><br><span class="line">什么时候对象会进入老年代？</span><br><span class="line">蚂蚁金服</span><br><span class="line"></span><br><span class="line">Java8的内存分代改进</span><br><span class="line">JVM内存分哪几个区，每个区的作用是什么？</span><br><span class="line">一面：JVM内存分布/内存结构？栈和堆的区别？堆的结构？为什么两个survivor区？</span><br><span class="line">二面：Eden和survior的比例分配</span><br><span class="line">小米</span><br><span class="line"></span><br><span class="line">jvm内存分区，为什么要有新生代和老年代</span><br><span class="line">京东</span><br><span class="line"></span><br><span class="line">JVM的内存结构，Eden和Survivor比例。</span><br><span class="line">JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和survivor。</span><br><span class="line">天猫</span><br><span class="line"></span><br><span class="line">一面：Jvm内存模型以及分区，需要详细到每个区放什么。</span><br><span class="line">一面：JVM的内存模型，Java8做了什么改</span><br><span class="line">拼多多</span><br><span class="line"></span><br><span class="line">JVM内存分哪几个区，每个区的作用是什么？</span><br><span class="line">美团</span><br><span class="line"></span><br><span class="line">java内存分配</span><br><span class="line">jvm的永久代中会发生垃圾回收吗？</span><br><span class="line">一面：jvm内存分区，为什么要有新生代和老年代</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/17/Notes/Java/JVM/JVM_06_%E5%A0%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/17/Notes/Java/JVM/JVM_06_%E5%A0%86/" class="post-title-link" itemprop="url">JVM_06_堆</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-17 10:05:36" itemprop="dateCreated datePublished" datetime="2021-04-17T10:05:36+08:00">2021-04-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JVM-06-堆"><a href="#JVM-06-堆" class="headerlink" title="JVM_06_堆"></a>JVM_06_堆</h1><p>堆（Heap）存放对象实例，几乎所有的对象实例以及数据都在这里分配内存。</p>
<p>一个进程对应一个JVM实例，一个JVM实例对应一个堆空间进程包含多个线程，所以线程之间共享同一个堆空间堆也是Java内存管理的核心区域。</p>
<ul>
<li>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了，堆是JVM管理的最大一块内存空间，它的大小是可以调节的。</li>
<li>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</li>
<li>《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。</li>
<li>《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。从实际使用角度看的：“几乎”所有的对象实例都在这里分配内存。因为还有一些对象是在栈上分配的（逃逸分析，标量替换）</li>
<li>堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集（GC）的时候才会被移除。如果堆中对象马上被回收，那么用户线程就会收到影响，因为有 stop the word。</li>
</ul>
<img src="/pics/image-20210415113030622.png" alt="image-20210415113030622" style="zoom:80%;" />

<h2 id="内存划分"><a href="#内存划分" class="headerlink" title="内存划分"></a>内存划分</h2><p>Java 8之前堆内存逻辑上分为三部分：<strong>新生代 + 老年代 + 永久代</strong>，新生代又可划分为 <strong>Eden区 和 Survivor区</strong>。</p>
<p><img src="/pics/image-20210415152003048.png" alt="image-20210415152003048"></p>
<p>Java 8及之后堆内存，<code>永久代</code> 被替换成 <code>元空间</code>，<code>永久代/元空间</code>，实际上控制不到。</p>
<img src="/pics/image-20210415115152421.png" alt="image-20210415115152421" style="zoom:70%;" />



<h3 id="新生代-Young-Generation"><a href="#新生代-Young-Generation" class="headerlink" title="新生代 (Young Generation)"></a>新生代 (Young Generation)</h3><p>年轻代是所有新对象创建的地方。当填充年轻代时，执行垃圾收集。这种垃圾收集称为 <strong>Minor GC</strong>。年轻代被分为三个部分伊甸园（<strong>Eden Memory</strong>）和两个幸存区（<strong>Survivor Memory</strong>，被称为from/to或s0/s1），默认比例是<code>8:1:1</code></p>
<h3 id="老年代-Old-Generation"><a href="#老年代-Old-Generation" class="headerlink" title="老年代(Old Generation)"></a>老年代(Old Generation)</h3><p>经过多轮MinorGC 后仍然存活的对象被移动到老年代。JVM默认<strong>新生代和老年代的比例是1：2</strong>。老年代垃圾收集MajorGC，通常需要更长的时间。</p>
<p>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象），目的是避免在Eden区和两个Survivor 区之间发生大量的内存拷贝。</p>
<h3 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h3><p>不管是 JDK8 之前的永久代，还是 JDK8 及以后的元空间，都可以看作是 Java 虚拟机规范中方法区的实现。</p>
<p>虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 <strong>Non-Heap（非堆）</strong>，目的应该是与 Java 堆区分开。所以元空间放在后边的方法区再说。</p>
<h2 id="对象分配的过程"><a href="#对象分配的过程" class="headerlink" title="对象分配的过程"></a>对象分配的过程</h2><p><img src="/pics/image-20210415162006461.png" alt="image-20210415162006461"></p>
<blockquote>
<p>注意：上图中的FullGC可以理解为老年代GC ，等价于 MajorGC，不区分majorGC和FullGC。</p>
</blockquote>
<h3 id="图解对象分配"><a href="#图解对象分配" class="headerlink" title="图解对象分配"></a>图解对象分配</h3><ol>
<li>我们创建的对象，一般都是存放在Eden区的，<strong>当我们的Eden区满了后，就会触发GC操作</strong>，一般被称为 <code>YGC / Minor GC</code>操作</li>
</ol>
<p><img src="/pics/image-20210415155215283.png" alt="image-20210415155215283"></p>
<ol start="2">
<li><p>当我们进行一次垃圾收集后，红色的对象将会被回收，而绿色的独享还被占用着，存放在S0(Survivor From)区。同时我们给每个对象设置了一个年龄计数器，经过一次回收后还存在的对象，将其年龄加 1。</p>
</li>
<li><p>同时Eden区继续存放对象，当Eden区再次存满的时候，又会触发一个MinorGC操作，此时GC将会把 Eden和S0中的对象进行一次垃圾收集，把存活的对象放到 S1区，同时让存活的对象年龄 + 1</p>
<p><img src="/pics/image-20210415155539388.png" alt="image-20210415155539388"></p>
</li>
<li><p>此时若再次经历MinorGC，又会对Eden区和S1区进行清理，剩下的对象放到S0区，也就是说S0和S1（from和to）在minorGC时<code>逻辑上</code>是不停交换的</p>
</li>
<li><p>我们继续不断的进行对象生成和垃圾回收，当Survivor中的对象的年龄达到15的时候（-XX:MaxTenuringThreshold 设置），将会触发一次 <code>Promotion 晋升</code>的操作，也就是将年轻代中的对象晋升到老年代中</p>
</li>
</ol>
<p><img src="/pics/image-20210415155419659.png" alt="image-20210415155419659"></p>
<blockquote>
<p>注意：在Eden区满了的时候，才会触发MinorGC，而Survivor区满了，不会触发MinorGC操作</p>
</blockquote>
<h3 id="对象分配的特殊情况"><a href="#对象分配的特殊情况" class="headerlink" title="对象分配的特殊情况"></a>对象分配的特殊情况</h3><ol>
<li><p><strong>Eden区存放对象</strong></p>
<ol>
<li>如果 Eden 放得下，则直接放到 Eden 区</li>
<li>如果 Eden 放不下，则触发 MinorGc，执行垃圾回收；如果还不能放下，则直接放入到老年代</li>
<li>如果 Eden 区满了，MinorGC完将对象往Survivor拷贝时，发现Survivor放不下，直接晋升至老年代</li>
</ol>
</li>
<li><p><strong>将对象存放到老年代</strong></p>
<ul>
<li>如果 Eden 执行了MinorGc 还是无法放不下该对象，说明是超大对象，只能直接放到到老年代</li>
<li>老年代都放不下，则先触发MajorGC ，再看看能不能放下，如果还是放不下，就会报 OOM</li>
</ul>
</li>
</ol>
<h3 id="对象分配原则"><a href="#对象分配原则" class="headerlink" title="对象分配原则"></a>对象分配原则</h3><ul>
<li>new 对象优先分配到Eden</li>
<li>大对象直接分配到老年代</li>
<li>长期存活的对象分配到老年代</li>
<li><strong>动态对象年龄判断</strong>：如果Survivor区中相同年龄的所有对象大小的总和 大于 Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</li>
<li><strong>空间分配担保</strong>：经过Minor GC后，所有的对象都存活，因为Survivor比较小，所以就需要将Survivor无法容纳的对象，存放到老年代中</li>
</ul>
<h3 id="相关JVM参数"><a href="#相关JVM参数" class="headerlink" title="相关JVM参数"></a>相关JVM参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 设置堆空间大小的参数</span></span><br><span class="line"><span class="comment"> * -Xms 用来设置堆空间（年轻代+老年代）的初始内存大小</span></span><br><span class="line"><span class="comment"> *      -X 是jvm的运行参数</span></span><br><span class="line"><span class="comment"> *      ms 是memory start</span></span><br><span class="line"><span class="comment"> * -Xmx 用来设置堆空间（年轻代+老年代）的最大内存大小</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. 默认堆空间的大小</span></span><br><span class="line"><span class="comment"> *      初始内存大小：物理电脑内存大小 / 64</span></span><br><span class="line"><span class="comment"> *      最大内存大小：物理电脑内存大小 / 4</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3. 手动设置：-Xms600m -Xmx600m</span></span><br><span class="line"><span class="comment"> *     开发中建议将初始堆内存和最大的堆内存设置成相同的值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 4. 查看设置的参数：方式一： jps   /  jstat -gc 进程id</span></span><br><span class="line"><span class="comment"> *                  方式二：-XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSpaceInitial</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回Java虚拟机中的堆内存总量</span></span><br><span class="line">        <span class="keyword">long</span> initialMemory = Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">        <span class="comment">//返回Java虚拟机试图使用的最大堆内存量</span></span><br><span class="line">        <span class="keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-Xms : &quot;</span> + initialMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-Xmx : &quot;</span> + maxMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Minor-GC、Major-GC、Full-GC"><a href="#Minor-GC、Major-GC、Full-GC" class="headerlink" title="Minor GC、Major GC、Full GC"></a>Minor GC、Major GC、Full GC</h2><p>JVM在进行GC时，并非每次都对上面三个内存( 新生代、老年代；方法区 )区域一起回收的，大部分时候回收的都是指新生代。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）</p>
<p>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：</p>
<ul>
<li><strong>新生代收集（ Minor GC/Young GC ）</strong>：只是新生代( Eden、S0/S1 )的垃圾收集</li>
<li><strong>老年代收集（ Major GC/Old GC</strong> ）：只是老年代的垃圾收集<ul>
<li>目前，只有CMS GC会有单独收集老年代的行为</li>
<li><code>注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</code></li>
</ul>
</li>
<li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。目前，只有G1 GC会有这种行为</li>
<li><strong>整堆收集（Full GC）</strong>：收集整个java堆和方法区的垃圾收集</li>
</ul>
<h3 id="新生代-GC（Minor-GC）触发机制"><a href="#新生代-GC（Minor-GC）触发机制" class="headerlink" title="新生代 GC（Minor GC）触发机制"></a>新生代 GC（Minor GC）触发机制</h3><p>当新生代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden区满，Survivor区满不会触发GC。（每次Minor GC会清理年轻代的内存）</p>
<p>因为Java对象<code>大多都具备朝生夕灭</code>的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解</p>
<p>Minor GC会引发STW，暂停其它用户的线程，等待垃圾回收线程结束，用户线程才恢复运行</p>
<h3 id="老年代GC（Major-GC）-触发机制"><a href="#老年代GC（Major-GC）-触发机制" class="headerlink" title="老年代GC（Major GC） 触发机制"></a>老年代GC（Major GC） 触发机制</h3><ul>
<li>指发生在老年代的GC，对象从老年代消失时，我们说 “Major Gc” 或 “Full GC” 发生了</li>
<li>出现了MajorGc，经常会伴随至少一次的Minor GC但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程<ul>
<li>也就是在老年代空间不足时，会先尝试触发Minor GC，如果之后空间还不足，则触发Major GC</li>
</ul>
</li>
<li>Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长</li>
<li>如果Major GC后，内存还不足，就报OOM了</li>
</ul>
<h3 id="整堆收集（Full-GC）触发机制"><a href="#整堆收集（Full-GC）触发机制" class="headerlink" title="整堆收集（Full GC）触发机制"></a>整堆收集（Full GC）触发机制</h3><ol>
<li><p>调用System.gc( )时，系统建议执行Full GC，但是不必然执行</p>
</li>
<li><p>老年代空间不足</p>
</li>
<li><p>方法区空间不足</p>
</li>
<li><p>通过Minor GC后进入老年代的平均大小 大于 老年代的可用内存</p>
</li>
<li><p>由Eden和From区 向 To 区复制时，对象大小大于To 区的可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</p>
<p>说明：Full GC 是开发或调优中尽量要避免的。这样STW时间会短一些。</p>
</li>
</ol>
<h2 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h2><p>TLAB：Thread Local Allocation Buffer，Eden为每个线程单独分配了一个私有缓冲区域</p>
<ul>
<li><strong>JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内</strong>。</li>
<li>多线程同时分配内存时，<strong>使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量</strong>，因此我们可以将这种内存分配方式称之为<strong>快速分配策略</strong>。</li>
</ul>
<p><img src="/pics/image-20210415212342136.png" alt="image-20210415212342136"></p>
<h3 id="为什么有TLAB（Thread-Local-Allocation-Buffer）？"><a href="#为什么有TLAB（Thread-Local-Allocation-Buffer）？" class="headerlink" title="为什么有TLAB（Thread Local Allocation Buffer）？"></a>为什么有TLAB（Thread Local Allocation Buffer）？</h3><ul>
<li>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</li>
<li>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li>
<li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</li>
</ul>
<h3 id="TLAB-分配过程"><a href="#TLAB-分配过程" class="headerlink" title="TLAB 分配过程"></a>TLAB 分配过程</h3><ul>
<li><p>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选</p>
</li>
<li><p>在程序中，开发人员可以通过选项“-XX:UseTLAB”设置是否开启TLAB空间</p>
</li>
<li><p>默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选项“-</p>
<p>XX:TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小</p>
</li>
<li><p>一旦对象在TLAB空间分配内存失败时，<strong>JVM就会尝试着通过使用加锁机制确保数据操作的原子性</strong>，从而直接在Eden空间中分配内存</p>
</li>
</ul>
<p>也就是说，JVM分配对象时预先会尝试分配在TLAB上，如果对象较大，无法分配在 TLAB 上，则JVM会试图直接分配在Eden其他位置上。</p>
<img src="/pics/image-20210415211025999.png" alt="image-20210415211025999" style="zoom:80%;" />

<h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><p>逃逸分析，根据新对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p>
<p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p>
<p>逃逸分析的基本行为就是分析对象动态作用域：</p>
<ul>
<li><strong>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸</strong>。</li>
<li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li>
</ul>
<p>使用逃逸分析，编译器可以对代码做如下优化：</p>
<ul>
<li>栈上分配</li>
<li>同步省略</li>
<li>分离对象或标量替换</li>
</ul>
<h3 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h3><ul>
<li>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。</li>
<li>分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</li>
</ul>
<h3 id="同步省略"><a href="#同步省略" class="headerlink" title="同步省略"></a>同步省略</h3><ul>
<li><p>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</p>
</li>
<li><p>在动态编译同步块的时候，<code>JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程</code>。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫<code>锁消除</code>。</p>
</li>
</ul>
<h3 id="分离对象或标量替换"><a href="#分离对象或标量替换" class="headerlink" title="分离对象或标量替换"></a>分离对象或标量替换</h3><ul>
<li>标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</li>
<li>相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</li>
<li>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point point = <span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;point.x&quot;</span> + point.x + <span class="string">&quot;;point.y&quot;</span> + point.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上代码，经过标量替换后，就会变成</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;point.x = &quot;</span> + x + <span class="string">&quot;; point.y=&quot;</span> + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于逃逸分析的论文在1999年就已经发表了，但直到JDK 1.6才有实现，而且这项技术到如今也并不是十分成熟的。</p>
<p><strong>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</strong></p>
<p>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p>
<p>虽然这项技术并不十分成熟，但是他也是即时编译器优化技术中一个十分重要的手段。</p>
<p><strong>Oracle Hotspot JVM中并未这么做</strong>，Oracle Hotspot JVM是通过标量替换实现逃逸分析的</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>新生代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</p>
<p>当然，也有特殊情况，我们知道普通的对象可能会被分配在TLAB上。如果对象较大，无法分配在 TLAB 上，则JVM会试图直接分配在Eden其他位置上。如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代</p>
</li>
<li><p>老年代放置长生命周期的对象，通常都是从Survivor区域筛选拷贝过来的Java对象。</p>
</li>
<li><p>当GC只发生在新生代中，回收新生代对象的行为被称为Minor GC</p>
</li>
<li><p>当GC发生在老年代时则被称为Major GC或者Full GC。一般的，Minor GC的发生频率要比Major GC高很多，即老年代中垃圾回收发生的频率将大大低于新生代。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/17/Notes/Java/JVM/JVM_05_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/17/Notes/Java/JVM/JVM_05_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/" class="post-title-link" itemprop="url">JVM_05_虚拟机栈</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-17 10:05:36" itemprop="dateCreated datePublished" datetime="2021-04-17T10:05:36+08:00">2021-04-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JVM-05-虚拟机栈"><a href="#JVM-05-虚拟机栈" class="headerlink" title="JVM_05_虚拟机栈"></a>JVM_05_虚拟机栈</h1><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。</p>
<p>Java虚拟机栈描述的是<strong>方法执行的内存模型</strong>：每个方法执行时都会创建一个<strong>栈帧</strong>，方法从调用到执行完成，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p>
<p>Java虚拟机栈的生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了。栈是线程私有的，对于栈来说不存在垃圾回收 (GC) 问题，但存在栈溢出的情况（StackOverFlowError）</p>
<p>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。</p>
<ul>
<li>JVM直接对Java栈的操作只有两个：<ul>
<li>方法时执行入栈</li>
<li>执行结束后出栈</li>
</ul>
</li>
<li>对于栈来说不存在垃圾回收 (GC) 问题，但是栈存在溢出的情况</li>
</ul>
<p>Java 虚拟机规范允许<code>Java栈的大小是动态的或者是固定不变的</code>。</p>
<ul>
<li>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。<br>如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个<code>StackoverflowError</code> 异常（栈溢出）。</li>
<li>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 <code>OutOfMemoryError</code> 异常。</li>
</ul>
<p>可以通过参数<code>-Xss</code>来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。</p>
<h1 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h1><p>每个线程都有自己的栈，栈中的数据都是以<code>栈帧（Stack Frame）</code>为基本单位存储的。</p>
<p><strong>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</strong></p>
<p>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</p>
<h2 id="栈的运行原理"><a href="#栈的运行原理" class="headerlink" title="栈的运行原理"></a>栈的运行原理</h2><ul>
<li>JVM 直接对 Java 栈的操作只有两个，对栈帧的<strong>压栈</strong>和<strong>出栈</strong>，遵循<code>FILO</code>原则</li>
<li>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为<strong>当前栈帧</strong>（Current Frame），与当前栈帧对应的方法就是<strong>当前方法</strong>（Current Method），定义这个方法的类就是<strong>当前类</strong>（Current Class）</li>
<li>执行引擎运行的字节码指令只针对当前栈帧进行操作，PC寄存器中存储也是当前栈帧的执行地址。</li>
<li><strong>不同线程中所包含的栈帧是不允许存在相互引用的，即线程间私有数据是隔离的</strong>。</li>
<li>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，称为新的当前栈帧</li>
<li>当前方法返回时，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧</li>
<li>Java 方法有两种返回函数的方式，<strong>一种是正常的函数返回，使用 return 指令，另一种是抛出异常，不管用哪种方式，都会导致栈帧被弹出</strong></li>
</ul>
<img src="/pics/image-20210411223806924.png" alt="image-20210411223806924" style="zoom:33%;" />

<h2 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h2><p>每个<strong>栈帧</strong>（Stack Frame）中存储着：</p>
<ul>
<li><code>局部变量表（Local Variables）</code></li>
<li><code>操作数栈（Operand Stack）(或称为表达式栈)</code></li>
<li>动态链接（Dynamic Linking）：指向运行时常量池中当前方法引用</li>
<li>方法返回地址（Return Address）：方法正常退出或异常退出的地址</li>
<li>一些附加信息</li>
</ul>
<img src="/pics/image-20210411223657857.png" alt="image-20210411223657857" style="zoom:33%;" />

<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>局部变量表：Local Variables，也被称之为局部变量数组或本地变量表，是一组变量值存储空间，<strong>用于存放方法参数和方法内定义的局部变量</strong>。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li><strong>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</strong>，这些数据类型包括各类基本数据类型、对象引用（reference），以及 returnAddress(返回值) 类型</li>
<li>由于局部变量表是建立在线程的栈上，是线程的私有数据，<strong>因此不存在数据安全问题</strong></li>
<li><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的Code属性的maximum local variables数据项中，方法运行期间局部变量表的大小是不会改变。</li>
<li>对于一个方法来说<ul>
<li><strong>方法嵌套调用的次数由栈的大小决定</strong>。一般来说，栈越大，方法嵌套调用次数越多</li>
<li>方法的参数和局部变量越多，<strong>局部变量表越大，它的栈帧就越大</strong>。进而方法调用就会占用更多的栈空间，导致其嵌套调用次数就会减少</li>
</ul>
</li>
<li>局部变量表中的变量只在当前方法调用中有效<ul>
<li>在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程</li>
<li>当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁</li>
</ul>
</li>
<li><strong>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</strong></li>
</ul>
<h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>通过jclasslib 查看字节码信息，java代码及其对应的字节码结构如图所示。</p>
<img src="/pics/image-20210413113124288.png" alt="image-20210413113124288" style="zoom:100%;" /> 

<h4 id="Slot"><a href="#Slot" class="headerlink" title="Slot"></a>Slot</h4><p>Slot（变量槽），局部变量表的最基本存储单元。</p>
<ul>
<li><p>局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</p>
<ul>
<li>32位以内的类型（包括 <strong>引用类型、returnAddress类型</strong>）只占用一个slot；64位的类型（long和double）占用两个slot</li>
<li>byte、short、char 在存储前被转换为int，boolean 也被转换为int（false -&gt; 0，true- &gt; 非零），long 和 double 则占据两个Slot</li>
</ul>
</li>
<li><p>方法被调用的时候，<strong>方法参数和方法体内定义的局部变量将会按照顺序被复制到局部变量表中的每一个slot上</strong></p>
<ul>
<li>局部变量表中的每一个Slot有一个访问索引，通过这个索引可访问到局部变量值</li>
<li>访问64bit（long或double类型变量）的局部变量时，只需要使用起始索引</li>
</ul>
</li>
<li><p>对于构造方法或者实例方法，那么<strong>该对象this引用将会存放在index为0的slot处</strong>，其余的参数按照参数表顺序排列</p>
</li>
<li><p><strong>栈帧中的局部变量表中的槽位是可以重用的</strong>，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而<strong>达到节省资源的目的</strong>。下图中，this、a、b、c 理论上应该有 4 个变量，<strong>c 复用了 b 的槽</strong></p>
<img src="/pics/image-20210413221825354.png" alt="image-20210413221825354" style="zoom:70%;" /></li>
</ul>
<h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。</p>
<ul>
<li><p>操作数栈就是 JVM 执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，此时这个方法的操作数栈是空的。</p>
</li>
<li><p>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在<code>编译期</code>就定义好了，保存在方法的 Code 属性的 <code>stack</code> 数据项中</p>
<img src="/pics/image-20210415005545972.png" alt="image-20210415005545972" style="zoom:50%;" /></li>
<li><p>方法执行过程中，根据字节码指令，往操作数栈中写入数据或取出数据</p>
<ul>
<li>栈中的任何一个元素都可以是任意的 Java 数据类型。32bit 的类型占用一个栈单位深度，64bit 的类型占用两个栈单位深度</li>
<li>操作数栈并非采用索引方式进行数据访问，只能通过入栈和出栈来完成数据访问</li>
</ul>
</li>
<li><p>另外，我们说<strong>Java虚拟机的解释引擎是基于栈的执行引擎</strong>，其中的栈指的就是操作数栈</p>
</li>
</ul>
<h4 id="栈顶缓存技术-Top-Of-Stack-Cashing"><a href="#栈顶缓存技术-Top-Of-Stack-Cashing" class="headerlink" title="栈顶缓存技术(Top Of Stack Cashing)"></a>栈顶缓存技术(Top Of Stack Cashing)</h4><p>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数。</p>
<p>由于<strong>操作数是存储在内存中</strong>的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，将<code>栈顶元素</code>全部缓存在<code>物理CPU的寄存器</code>中，以此降低对内存的读/写次数，提升执行引擎的执行效率。</p>
<h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a><strong>动态链接</strong></h3><p>动态链接（Dynamic Linking），指向运行时常量池的该栈帧所属<code>方法的引用</code>。每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态链接。</p>
<p>在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为<strong>符号引用</strong>（Symbolic Reference）保存在 Class 文件的常量池中。</p>
<p>字节码中的方法调用指令就是以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或第一次使用时转化为直接引用，这种转化称为静态链接（或静态解析）。另一部分将在每一次运行期间转化为直接引用，这部分称为动态链接。</p>
<p>为什么要用常量池呢？</p>
<ul>
<li>不同的方法，都可能调用相同常量或者方法，所以<code>只需要存储一份即可，然后记录其引用即可，节省空间</code></li>
<li>常量池的作用：就是为了提供一些符号和常量，便于指令的识别</li>
</ul>
<img src="/pics/image-20210414205105346.png" alt="image-20210414205105346" style="zoom:33%;" />

<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicLinkingTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodA()....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodB()....&quot;</span>);</span><br><span class="line">        methodA();</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ============反编译字节码命令 ============</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// =====常量池===========  </span></span><br><span class="line"></span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">9.</span>#<span class="number">23</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">8.</span>#<span class="number">24</span>         <span class="comment">// cn/sxt/java1/DynamicLinkingTest.num:I</span></span><br><span class="line">   #<span class="number">3</span> = Fieldref           #<span class="number">25.</span>#<span class="number">26</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   #<span class="number">4</span> = String             #<span class="number">27</span>            <span class="comment">// methodA()....</span></span><br><span class="line">   #<span class="number">5</span> = Methodref          #<span class="number">28.</span>#<span class="number">29</span>        <span class="comment">// java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">   #<span class="number">6</span> = String             #<span class="number">30</span>            <span class="comment">// methodB()....</span></span><br><span class="line">   #<span class="number">7</span> = Methodref          #<span class="number">8.</span>#<span class="number">31</span>         <span class="comment">// cn/sxt/java1/DynamicLinkingTest.methodA:()V</span></span><br><span class="line">   #<span class="number">8</span> = Class              #<span class="number">32</span>            <span class="comment">// cn/sxt/java1/DynamicLinkingTest</span></span><br><span class="line">   #<span class="number">9</span> = Class              #<span class="number">33</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">  #<span class="number">10</span> = Utf8               num</span><br><span class="line">  #<span class="number">11</span> = Utf8               I</span><br><span class="line">  #<span class="number">12</span> = Utf8               &lt;init&gt;</span><br><span class="line">  #<span class="number">13</span> = Utf8               ()V</span><br><span class="line">  #<span class="number">14</span> = Utf8               Code</span><br><span class="line">  #<span class="number">15</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">16</span> = Utf8               LocalVariableTable</span><br><span class="line">  #<span class="number">17</span> = Utf8               <span class="keyword">this</span></span><br><span class="line">  #<span class="number">18</span> = Utf8               Lcn/sxt/java1/DynamicLinkingTest;</span><br><span class="line">  #<span class="number">19</span> = Utf8               methodA</span><br><span class="line">  #<span class="number">20</span> = Utf8               methodB</span><br><span class="line">  #<span class="number">21</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">22</span> = Utf8               DynamicLinkingTest.java</span><br><span class="line">  #<span class="number">23</span> = NameAndType        #<span class="number">12</span>:#<span class="number">13</span>        <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">24</span> = NameAndType        #<span class="number">10</span>:#<span class="number">11</span>        <span class="comment">// num:I</span></span><br><span class="line">  #<span class="number">25</span> = Class              #<span class="number">34</span>            <span class="comment">// java/lang/System</span></span><br><span class="line">  #<span class="number">26</span> = NameAndType        #<span class="number">35</span>:#<span class="number">36</span>        <span class="comment">// out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">27</span> = <span class="function">Utf8               <span class="title">methodA</span><span class="params">()</span>....</span></span><br><span class="line"><span class="function">  #28 </span>= Class              #<span class="number">37</span>            <span class="comment">// java/io/PrintStream</span></span><br><span class="line">  #<span class="number">29</span> = NameAndType        #<span class="number">38</span>:#<span class="number">39</span>        <span class="comment">// println:(Ljava/lang/String;)V</span></span><br><span class="line">  #<span class="number">30</span> = <span class="function">Utf8               <span class="title">methodB</span><span class="params">()</span>....</span></span><br><span class="line"><span class="function">  #31 </span>= NameAndType        #<span class="number">19</span>:#<span class="number">13</span>        <span class="comment">// methodA:()V</span></span><br><span class="line">  #<span class="number">32</span> = Utf8               cn/sxt/java1/DynamicLinkingTest</span><br><span class="line">  #<span class="number">33</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">34</span> = Utf8               java/lang/System</span><br><span class="line">  #<span class="number">35</span> = Utf8               out</span><br><span class="line">  #<span class="number">36</span> = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #<span class="number">37</span> = Utf8               java/io/PrintStream</span><br><span class="line">  #<span class="number">38</span> = Utf8               println</span><br><span class="line">  #<span class="number">39</span> = Utf8               (Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==== 字节码命令 ====</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: getstatic     #<span class="number">3</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">3</span>: ldc           #<span class="number">6</span>                  <span class="comment">// String methodB()....</span></span><br><span class="line">         <span class="number">5</span>: invokevirtual #<span class="number">5</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">         <span class="number">8</span>: aload_0</span><br><span class="line">         <span class="number">9</span>: invokevirtual #<span class="number">7</span>                  <span class="comment">// Method methodA:()V</span></span><br><span class="line"><span class="comment">//	...  </span></span><br></pre></td></tr></table></figure>

<p>看一下methodBn调用methodA的过程</p>
<blockquote>
<p>#7 = Methodref #8.#31<br>先找 #8 ：<br>#8 = Class #32 ：去找 #32<br>#32 = Utf8 cn/sxt/java1/DynamicLinkingTest<br>结论：通过 #8 我们找到了 DynamicLinkingTest 这个类</p>
<p>再来找 #31：<br>#31 = NameAndType #19:#13 ：去找 #19 和 #13<br>#19 = Utf8 methodA ：方法名为 methodA<br>#13 = Utf8 ()V ：方法没有形参，返回值为 void<br>结论：通过 #7 我们就能找到需要调用的 methodA( ) 方法，并进行调用</p>
</blockquote>
<p>以上的过程也是符号引用转换为直接引用，就是说通过符号引用一直查找到方法名的过程。</p>
<h3 id="返回地址"><a href="#返回地址" class="headerlink" title="返回地址"></a>返回地址</h3><p>用来存放调用该方法的 <strong>PC 寄存器的值</strong>（PC寄存器存储着下一条要执行的指令）。</p>
<p><strong>方法执行完成时，调用者的 PC 寄存器的值作为返回地址，即调用该方法的指令的下一条指令的地址。</strong>而通过异常退出的，返回地址是要通过异常表来确定的，栈帧中一般不会保存这部分信息。</p>
<img src="/pics/image-20210414232209000.png" alt="image-20210414232209000" style="zoom:50%;" />



<p>一个方法的结束，有两种方式</p>
<ul>
<li>正常执行完成</li>
<li>出现未处理的异常，非正常退出</li>
</ul>
<p>这2者区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</p>
<h4 id="正常完成出口"><a href="#正常完成出口" class="headerlink" title="正常完成出口"></a>正常完成出口</h4><p>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者正常完成<br>一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。</p>
<blockquote>
<p>在字节码指令中，返回指令包含：</p>
<ul>
<li>ireturn：当返回值是boolean，byte，char，short和int类型时使用</li>
<li>lreturn：Long类型</li>
<li>freturn：Float类型</li>
<li>dreturn：Double类型</li>
<li>areturn：引用类型</li>
<li>return：返回值类型为void的方法以及类的构造器、静态代码块</li>
</ul>
</blockquote>
<h4 id="异常完成出口"><a href="#异常完成出口" class="headerlink" title="异常完成出口"></a>异常完成出口</h4><p>在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称异常完成出口。</p>
<p><img src="/pics/image-20210414230130630.png" alt="image-20210414230130630"></p>
<p>方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码 </p>
<h3 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h3><p>栈帧中还允许携带与 Java 虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息，但这些信息取决于具体的虚拟机实现。</p>
<blockquote>
<p>一般会把动态链接、方法返回地址与其他信息归为一类，称为栈帧信息。</p>
</blockquote>
<h1 id="方法调用（解析和分派）"><a href="#方法调用（解析和分派）" class="headerlink" title="方法调用（解析和分派）"></a>方法调用（解析和分派）</h1><p>方法调用并不等同于方法中的代码被执行，方法调用阶段唯一的任务就是确定被调用方法，暂时还未涉及方法内部的具体运行过程。一切方法调用在Class文件里面存储的都只是符号引用，我们知道符号引用在运行时需要转化为直接引用（方法在实际运行时内存布局中的入口地址），转换的情况有2种分别是：静态链接与动态链接。</p>
<h2 id="静态链接与动态链接"><a href="#静态链接与动态链接" class="headerlink" title="静态链接与动态链接"></a>静态链接与动态链接</h2><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p>
<ul>
<li>静态链接：<br>当一个字节码文件被装载进JVM内部时，<strong>如果被调用的目标方法在编译期确定</strong>，且运行期保持不变时，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接</li>
<li>动态链接：<br>如果被调用的方法在编译期无法被确定下来，也就是说，<strong>只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性</strong>，因此也被称之为动态链接。</li>
</ul>
<p>静态链接和动态链接对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</p>
<h4 id="方法的绑定机制"><a href="#方法的绑定机制" class="headerlink" title="方法的绑定机制"></a>方法的绑定机制</h4><ul>
<li>早期绑定<br>早期绑定就是指被调用的目标方法<strong>如果在编译期可知，且运行期保持不变时</strong>，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</li>
<li>晚期绑定<br>如果被调用的方法在编译期无法被确定下来，<strong>只能够在程序运行期根据实际的类型绑定相关的方法</strong>，这种绑定方式也就被称之为晚期绑定。</li>
</ul>
<p>随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</p>
<blockquote>
<p>解析一定是个静态的过程，在编译期间就能完全确定，而分派可能是静态的也可能是动态的。也就是说解析一定是静态链接，而分派可能是动态链接也可能是静态链接。</p>
</blockquote>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>所有方法调用的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能够成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。</p>
<p>换句话说，调用目标在程序代码写好、编译器进行编译那一刻就已经确定下来。这类方法的调用被称为<strong>解析（Resolution）</strong>。</p>
<h3 id="方法的分类"><a href="#方法的分类" class="headerlink" title="方法的分类"></a>方法的分类</h3><ul>
<li>非虚方法：如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为<code>非虚方法</code>。</li>
<li>其他方法称为虚方法。</li>
</ul>
<h3 id="方法调用指令"><a href="#方法调用指令" class="headerlink" title="方法调用指令"></a>方法调用指令</h3><ul>
<li><code>invokestatic</code>：用于调用静态方法。</li>
<li><code>invokespecial</code>：用于调用实例构造器<init>()方法、私有方法和父类中的方法。</li>
<li><code>invokevirtual</code>：用于调用所有的虚方法。</li>
<li><code>invokeinterface</code>：用于调用接口方法，会在运行时再确定一个实现该接口的对象。</li>
<li><code>invokedynamic</code>：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。</li>
</ul>
<blockquote>
<p>以上指令的区别：</p>
<ol>
<li>invokestatic指令和invokespecial指令调用的方法称为非虚方法</li>
<li>invokevirtual 除（final修饰）称为虚方法。</li>
<li>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预而invokedynamic指令则支持由用户确定方法版本</li>
</ol>
</blockquote>
<h2 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h2><p><strong>分派会解释多态性特征的一些最基本的体现，如“重载”、“重写”在Java虚拟机中是如何实现的</strong>，当然这里的实现不是语法上该怎么写，我们关心的是虚拟机如何确定正确的目标方法。</p>
<p>分派（Dispatch）它可能是静态的也可能是动态的，按照分派依据的宗量数可分为单分派和多分派。这两类分派方式两两组合就构成了静态单分派、静态多分派、动态单分派、动态多分派4种分派组合情况。</p>
<h3 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h3><p><strong>依赖静态类型来决定方法执行版本的分派动作，都称为静态分派</strong>。静态分派的最典型应用表现就是<strong>方法重载</strong>，虚拟机（或者准确地说是编译器）在重载时是通过参数的静态类型来作为判定依据的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Human guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,guy!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Man guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,gentleman!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Woman guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,lady!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        StaticDispatch sr = <span class="keyword">new</span> StaticDispatch();</span><br><span class="line">        sr.sayHello(man);</span><br><span class="line">        sr.sayHello(woman);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line">hello,guy!</span><br><span class="line">hello,guy!</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Human man = <span class="keyword">new</span> Man();</span><br></pre></td></tr></table></figure>

<p>这里的<code>Human </code>就是变量的“静态类型”（Static Type），或者叫“外观类型”（Apparent Type）；<code>Man</code>就是变量的“实际类型”（Actual Type）或者叫“运行时类型”（Runtime Type）。</p>
<h3 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h3><p><strong>在运行期根据实际类型确定方法执行版本的分派过程称为动态分派</strong>。最典型的表现就是重写。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello,Man!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello,Woman!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">        woman.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果：</span></span><br><span class="line">hello,Man!</span><br><span class="line">hello,Woman!</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反编译字节码</span></span><br><span class="line">...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class com/xiaolyuh/DynamicDispatch$Man</span></span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         <span class="number">4</span>: invokespecial #<span class="number">3</span>                  <span class="comment">// Method com/xiaolyuh/DynamicDispatch$Man.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">7</span>: astore_1</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">new</span>           #<span class="number">4</span>                  <span class="comment">// class com/xiaolyuh/DynamicDispatch$Woman</span></span><br><span class="line">        <span class="number">11</span>: dup</span><br><span class="line">        <span class="number">12</span>: invokespecial #<span class="number">5</span>                  <span class="comment">// Method com/xiaolyuh/DynamicDispatch$Woman.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        <span class="number">15</span>: astore_2</span><br><span class="line">        <span class="number">16</span>: aload_1</span><br><span class="line">        <span class="number">17</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method com/xiaolyuh/DynamicDispatch$Human.sayHello:()V</span></span><br><span class="line">        <span class="number">20</span>: aload_2</span><br><span class="line">        <span class="number">21</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method com/xiaolyuh/DynamicDispatch$Human.sayHello:()V</span></span><br><span class="line">        <span class="number">24</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">27</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">28</span>: <span class="number">8</span></span><br><span class="line">        line <span class="number">29</span>: <span class="number">16</span></span><br><span class="line">        line <span class="number">30</span>: <span class="number">20</span></span><br><span class="line">        line <span class="number">31</span>: <span class="number">24</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">25</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">8</span>      <span class="number">17</span>     <span class="number">1</span>   man   Lcom/xiaolyuh/DynamicDispatch$Human;</span><br><span class="line">           <span class="number">16</span>       <span class="number">9</span>     <span class="number">2</span> woman   Lcom/xiaolyuh/DynamicDispatch$Human;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>通过字节码我们发现：在main方法中，<code>sayHello()</code>方法的调用对应的<strong>符号引用是一样的</strong>，<code>com/xiaolyuh/DynamicDispatch$Human.sayHello:()V </code>。在这里我们可以得出一个结论：<strong>在动态分派的情况下，在编译时期我们是无法确定方法的直接引用的</strong>，那么它是怎么实现重载方法的调用的呢？问题关键是在<code>invokevirtual</code>指令上，在执行<code>invokevirtual</code>指令时，<code>invokevirtual</code>指令会去确定方法的调用版本。</p>
<h4 id="invokevirtual指令的运行过程"><a href="#invokevirtual指令的运行过程" class="headerlink" title="invokevirtual指令的运行过程"></a>invokevirtual指令的运行过程</h4><ol>
<li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。</li>
<li>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError 异常</li>
<li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</li>
</ol>
<blockquote>
<p>正是因为invokevirtual指令执行的第一步就是在运行期确定接收者的实际类型，所以两次调用中的invokevirtual指令并不是把常量池中方法的符号引用解析到直接引用上就结束了，还会根据方法接收者的实际类型来选择方法版本，这个过程就是Java语言中方法重写的本质</p>
</blockquote>
<h4 id="动态分派的实现"><a href="#动态分派的实现" class="headerlink" title="动态分派的实现"></a>动态分派的实现</h4><p>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。</p>
<p>因此，为了提高性能，JVM在方法区建立一个<strong>虚方法表（virtual method table）</strong>，表中存放着各个虚方法的实际入口，非虚方法不会出现在表中。</p>
<p>虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表中的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类虚方法表中的地址也会被替换为指向子类实现版本的入口地址。</p>
<img src="/pics/image-20210415000959425.png" alt="image-20210415000959425" style="zoom:33%;" />

<blockquote>
<p><strong>虚方法表是什么时候被创建的呢？</strong></p>
<p>虚方法表会在类加载的链接阶段被创建并开始初始化，类变量初始值准备完成之后，JVM会把该类的虚方法表也初始化完毕。</p>
</blockquote>
<h3 id="单分派与多分派"><a href="#单分派与多分派" class="headerlink" title="单分派与多分派"></a>单分派与多分派</h3><p>方法的接收者与方法的参数统称为方法的宗量。分派基于多少种宗量，可以将分派划分为单分派和多分派两种。单分派是根据一个宗量对目标方法进行选择，多分派则是根据两个及以上的宗量对目标方法进行选择。</p>
<ul>
<li><p>静态分派需要根据<strong>静态类型和方法参数</strong>两个宗量来确定方法调用，所以属于多分派。</p>
</li>
<li><p>动态分派只需要根据<strong>实际类型</strong>一个宗量来确定方法的调用，所以属于单分派。</p>
<p>在动态分派的过程中，方法签名是确定的，所以方法参数就不会变，方法调用就取决于参数的实际类型。</p>
</li>
</ul>
<h2 id="动态类型语言和静态类型语言"><a href="#动态类型语言和静态类型语言" class="headerlink" title="动态类型语言和静态类型语言"></a>动态类型语言和静态类型语言</h2><p>动态类型语言和静态类型语言两者的区别就在于<strong>对类型的检查是在编译期还是在运行期</strong>，满足前者就是静态类型语言，反之是动态类型语言。</p>
<p>说的再直白一点就是，静态类型语言是判断<strong>变量自身的类型信息</strong>；动态类型语言是判断<strong>变量值的类型信息</strong>，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Java语言：String info = <span class="string">&quot;mogu blog&quot;</span>;     		(Java是静态类型语言的，会先编译再进行类型检查)</span><br><span class="line">JS语言：<span class="keyword">var</span> name = <span class="string">&quot;shkstart&quot;</span>;  <span class="keyword">var</span> name = <span class="number">10</span>;	（运行时才进行检查）</span><br><span class="line">Python语言：info = <span class="number">130.5</span>;  （动态类型语言）</span><br></pre></td></tr></table></figure>

<img src="/pics/image-20210414233954002.png" alt="image-20210414233954002" style="zoom:33%;" />

<h3 id="invokedynamic"><a href="#invokedynamic" class="headerlink" title="invokedynamic"></a>invokedynamic</h3><p>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现<code>【动态类型语言】</code>支持而做的一种改进。</p>
<p>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。<strong>直到Java8的 Lambda表达式 的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。</strong></p>
<p>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>线程执行方法时，会创建一个栈帧，用来保存方法需要的信息。其中，局部变量表中存储着方法需要的各个变量信息；操作数栈用于存储方法执行过程中的中间变量；动态连接指向的是常量池中方法的引用；返回地址存储的是调用该方法的 PC 寄存器的值，PC寄存器存储着下一条要执行的指令。</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sj15814963053/article/details/109922984">https://blog.csdn.net/sj15814963053/article/details/109922984</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/17/Notes/Java/JVM/JVM_04_PC%E5%AF%84%E5%AD%98%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/17/Notes/Java/JVM/JVM_04_PC%E5%AF%84%E5%AD%98%E5%99%A8/" class="post-title-link" itemprop="url">JVM_04_PC寄存器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-17 10:05:36" itemprop="dateCreated datePublished" datetime="2021-04-17T10:05:36+08:00">2021-04-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JVM-04-PC寄存器"><a href="#JVM-04-PC寄存器" class="headerlink" title="JVM_04_PC寄存器"></a>JVM_04_PC寄存器</h1><p>PC寄存器（<strong>Program Counter Register</strong>）或称为程序计数器，<code>记录正在执行的虚拟机字节码指令地址</code>。Register 的命名源于 CPU 的寄存器，寄存器存储指令相关的线程信息，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器（CPU寄存器，不是我们程PCRegister）才能够运行</p>
<p>这里，并非是广义上所指的物理寄存器，叫程序计数器（或PC计数器或指令计数器）会更加贴切，并且也不容易引起一些不必要的误会。<strong>JVM 中的 PC 寄存器是对物理 PC 寄存器的一种抽象模拟</strong>。</p>
<blockquote>
<p>PC寄存器的作用有2种定义：</p>
<p>第一种解释：记录正在执行的虚拟机字节码指令地址（深入理解Java虚拟机）</p>
<p>第二种解释：用来存储指向下一条指令的地址，也就是即将要执行的指令代码。</p>
<p>这2种解释其实都可以，我们主要理解PC寄存器记录的是虚拟机栈执行的字节码指令就好，至于是下一条还是当前，不必细究。</p>
</blockquote>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域</li>
<li>在 JVM 规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期一致</li>
<li>任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。如果当前线程正在执行的是 Java 方法，程序计数器记录的是 JVM 字节码指令地址，如果是执行 natice 方法，则是未指定值（undefined）</li>
<li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖它来完成</li>
<li>字节码解释器工作 时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令</li>
<li>它是唯一一个在 JVM 规范中没有规定任何 <code>OutOfMemoryError</code> 情况的区域，<code>也不存在GC</code>。</li>
</ul>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><code>PC寄存器用来存储指向下一条指令的地址，也就是即将要执行的指令代码。</code>由执行引擎读取下一条指令，并执行该指令。</p>
<img src="/pics/image-20210411210734629.png" alt="image-20210411210734629" style="zoom:33%;" />

<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PCRegisterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">int</span> k = i + j;</span><br><span class="line">        System.out.println(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用反编译：javap -v PCRegisterTest.class 或通过 IDEA 插件 <code>Jclasslib</code> 查看字节码指令。</p>
<img src="/pics/image-20210411212618773.png" alt="image-20210411212618773" style="zoom:33%;" />

<p><strong>理解下方法执行的过程：</strong></p>
<blockquote>
<ol>
<li>Java代码执行时，代码会首先被编译成字节码命令</li>
<li>某个方法执行时，相应的代码的字节码指令会被压入虚拟机栈</li>
<li>方法执行的线程中的PC寄存器会记录当前字节码执行的偏移地址</li>
<li>执行引擎会读取PC寄存器当前偏移地址的字节码指令，转换成机器指令，再由cpu执行</li>
</ol>
</blockquote>
<p>以上的步骤画图理解下：</p>
<img src="/pics/image-20210411210630941.png" alt="image-20210411210630941" style="zoom:33%;" />



<h2 id="CPU时间片"><a href="#CPU时间片" class="headerlink" title="CPU时间片"></a>CPU时间片</h2><p>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</p>
<ul>
<li>在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</li>
<li>但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</li>
</ul>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ul>
<li><p><code>使用PC寄存器存储字节码指令地址有什么用呢？为什么使用PC寄存器记录当前线程的执行地址呢？</code></p>
<p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p>
</li>
<li><p><code>PC寄存器为什么会被设定为线程私有的？</code></p>
<p>多线程在一个特定的时间段内只会执行其中某一个线程方法，CPU会不停的做任务切换，这样必然会导致经常中断或恢复。为了能够准确的记录各个线程正在执行的当前字节码指令地址，所以为每个线程都分配了一个PC寄存器，每个线程都独立计算，不会互相影响。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sj15814963053/article/details/109864077">https://blog.csdn.net/sj15814963053/article/details/109864077</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="sven"
      src="/images/sven.jpeg">
  <p class="site-author-name" itemprop="name">sven</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">58</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhaoxiaowen-sven" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhaoxiaowen-sven" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhaoxiaowen-sven@gmail.com" title="E-Mail → mailto:zhaoxiaowen-sven@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sven</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
