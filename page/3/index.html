<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Sven&#39;s blog">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Sven&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="sven">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Sven's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
      <a target="_blank" rel="noopener" href="https://github.com/zhaoxiaowen-sven" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Sven's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/09/Notes/Java/JUC/JUC01_Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/09/Notes/Java/JUC/JUC01_Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">JUC_01_JMM</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-09 23:52:52" itemprop="dateCreated datePublished" datetime="2021-04-09T23:52:52+08:00">2021-04-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/JUC/" itemprop="url" rel="index"><span itemprop="name">JUC</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JUC-01-JMM"><a href="#JUC-01-JMM" class="headerlink" title="JUC_01_JMM"></a>JUC_01_JMM</h1><p>介绍 Java 内存模型之前，先温习下计算机硬件内存模型。</p>
<p>计算机在执行程序的时候，每条指令都是在 CPU 中执行的，而执行的时候，又免不了要和数据打交道。而计算机上面的数据，是存放在主存当中的，也就是计算机的物理内存。</p>
<p>计算机硬件架构简易图：</p>
<img src="/pics/image-20210318234901621.png" alt="image-20210318234901621" style="zoom:50%;" />

<p>我们以多核 CPU 为例，每个CPU 核都包含<strong>一组 「CPU 寄存器」</strong>，这些寄存器本质上是在 CPU 内存中。CPU 在这些寄存器上执行操作的速度要比在主内存(RAM)中执行的速度快得多。</p>
<p>因为<strong>CPU速率高， 内存速率慢，为了让存储体系可以跟上CPU的速度，所以中间又加上 Cache 层，就是我们说的 「CPU 高速缓存」</strong>。</p>
<h3 id="CPU多级缓存"><a href="#CPU多级缓存" class="headerlink" title="CPU多级缓存"></a>CPU多级缓存</h3><p>由于CPU的运算速度远远超越了1级缓存的数据IO能力，CPU厂商又引入了多级的缓存结构。通常L1、L2 是每个CPU 核有一个，L3 是多个核共用一个。</p>
<h3 id="Cache-Line"><a href="#Cache-Line" class="headerlink" title="Cache Line"></a>Cache Line</h3><p>Cache又是由很多个<strong>「缓存行」</strong>(Cache line) 组成的。Cache line 是 Cache 和 RAM 交换数据的最小单位。</p>
<p>Cache 存储数据是固定大小为单位的，称为一个<strong>Cache entry</strong>，这个单位称为<strong>Cache line</strong>或<strong>Cache block</strong>。给定Cache 容量大小和 Cache line size 的情况下，它能存储的条目个数(number of cache entries)就是固定的。因为Cache 是固定大小的，所以它从主内存获取数据也是固定大小。对于X86来讲，是 64Bytes。对于ARM来讲，较旧的架构的Cache line是32Bytes，但一次内存访存只访问一半的数据也不太合适，所以它经常是一次填两个 Cache line，叫做 double fill。</p>
<h3 id="缓存的工作原理"><a href="#缓存的工作原理" class="headerlink" title="缓存的工作原理"></a>缓存的工作原理</h3><p>这里的缓存的工作原理和我们项目中用 memcached、redis 做常用数据的缓存层是一个道理。</p>
<p>当 CPU 要读取一个数据时，首先从缓存中查找，如果找到就立即读取并送给CPU处理；如果没有找到，就去内存中读取并送给 CPU 处理，同时把这个数据所在的<strong>数据块</strong>（就是我们上边说的 Cache block）调入缓存中，即把临近的共 64 Byte 的数据也一同载入，因为临近的数据在将来被访问的可能性更大，可以使得以后对整块数据的读取都从缓存中进行，<strong>不必再调用内存</strong>。</p>
<p>这就增加了CPU读取缓存的<strong>命中率</strong>（Cache hit）了。</p>
<h3 id="计算机层级存储"><a href="#计算机层级存储" class="headerlink" title="计算机层级存储"></a>计算机层级存储</h3><p>计算机存储系统是有层次结构的，类似一个金字塔，顶层的寄存器读写速度较高，但是空间较小。底层的读写速度较低，但是空间较大。</p>
<img src="/pics/image-20210318235811049.png" alt="image-20210318235811049" style="zoom:50%;" />

<h3 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h3><p>既然每个核中都有单独的缓存，那我的 4 核 8 线程 CPU 处理主内存数据的时候，不就会出现数据不一致问题了吗？</p>
<p>为了解决这个问题，先后有过两种方法：<strong>总线锁机制</strong>和<strong>缓存锁机制</strong>。</p>
<p>总线锁就是使用 CPU 提供的一个<code>LOCK#</code>信号，当一个处理器在总线上输出此信号，其他处理器的请求将被阻塞，那么该处理器就可以独占共享锁。这样就保证了数据一致性。</p>
<p>但是总线锁开销太大，我们需要控制锁的粒度，所以又有了缓存锁，核心就是“<strong>缓存一致性协议</strong>”，不同的 CPU 硬件厂商实现方式稍有不同，有MSI、MESI、MOSI等。</p>
<h3 id="代码乱序执行优化"><a href="#代码乱序执行优化" class="headerlink" title="代码乱序执行优化"></a>代码乱序执行优化</h3><p>为了使得处理器内部的运算单元尽量被充分利用，提高运算效率，处理器可能会对输入的代码进行「乱序执行」**(Out-Of-Order Execution)，处理器会在计算之后将乱序执行的结果重组，**乱序优化可以保证在单线程下该执行结果与顺序执行的结果是一致的，但不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致。</p>
<p><strong>乱序执行技术是处理器为提高运算速度而做出违背代码原有顺序的优化</strong>。在单核时代，处理器保证做出的优化不会导致执行结果远离预期目标，但在多核环境下却并非如此。</p>
<p>多核环境下， 如果存在一个核的计算任务依赖另一个核的计算任务的中间结果，而且对相关数据读写没做任何防护措施，那么其顺序性并不能靠代码的先后顺序来保证，处理器最终得出的结果和我们逻辑得到的结果可能会大不相同。</p>
<h4 id="编译器指令重排"><a href="#编译器指令重排" class="headerlink" title="编译器指令重排"></a>编译器指令重排</h4><p>除了上述由处理器和缓存引起的乱序之外，现代编译器同样提供了乱序优化。之所以出现编译器乱序优化其根本原因在于处理器每次只能分析一小块指令，但编译器却能在很大范围内进行代码分析，从而做出更优的策略，充分利用处理器的乱序执行功能。</p>
<h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><p>尽管我们看到乱序执行初始目的是为了提高效率，但是它看来其好像在这多核时代不尽人意，其中的某些”自作聪明”的优化导致多线程程序产生各种各样的意外。因此有必要存在一种机制来消除乱序执行带来的坏影响，也就是说应该允许程序员显式的告诉处理器对某些地方禁止乱序执行。这种机制就是所谓内存屏障。不同架构的处理器在其指令集中提供了不同的指令来发起内存屏障，对应在编程语言当中就是提供特殊的关键字来调用处理器相关的指令，JMM里我们再探讨。</p>
<h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><p>Java 内存模型即 <code>Java Memory Model</code>，简称 <strong>JMM</strong>。</p>
<p>这里的内存模型可不是 JVM 里的运行时数据区。</p>
<p>「内存模型」可以理解为<strong>在特定操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象</strong>。</p>
<p>不同架构的物理计算机可以有不一样的内存模型，Java虚拟机也有自己的内存模型。</p>
<p>Java虚拟机规范中试图定义一种「 <strong>Java 内存模型</strong>」来<strong>屏蔽掉各种硬件和操作系统的内存访问差异</strong>，以实现<strong>让 Java 程序在各种平台下都能达到一致的内存访问效果</strong>，不必因为不同平台上的物理机的内存模型的差异，对各平台定制化开发程序。</p>
<p>Java 内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。这里的变量与我们写 Java 代码中的变量不同，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量和方法参数，因为他们是线程私有的，不会被共享。</p>
<h3 id="JMM-组成"><a href="#JMM-组成" class="headerlink" title="JMM 组成"></a>JMM 组成</h3><ul>
<li><p><strong>主内存</strong>：Java 内存模型规定了所有变量都存储在主内存(Main Memory)中（此处的主内存与物理硬件的主内存RAM 名字一样，两者可以互相类比，但此处仅是虚拟机内存的一部分）。</p>
</li>
<li><p><strong>工作内存</strong>：每条线程都有自己的工作内存(Working Memory，又称本地内存，可与CPU高速缓存类比)，线程的工作内存中保存了该线程使用到的主内存中的共享变量的副本拷贝。<strong>线程对变量的所有操作都必须在工作内存进行，而不能直接读写主内存中的变量</strong>。<strong>工作内存是 JMM 的一个抽象概念，并不真实存在</strong>。</p>
<img src="/pics/image-20210318234012867.png" alt="image-20210318234012867" style="zoom:50%;" /></li>
</ul>
<h3 id="JMM-与-JVM-内存结构"><a href="#JMM-与-JVM-内存结构" class="headerlink" title="JMM 与 JVM 内存结构"></a>JMM 与 JVM 内存结构</h3><p>JMM 与 Java 内存区域中的堆、栈、方法区等并不是同一个层次的内存划分，两者基本没有关系。如果一定要勉强对应，那从变量、主内存、工作内存的定义看，<strong>主内存主要对应 Java 堆中的对象实例数据部分，工作内存则对应虚拟机栈的部分区域</strong>（与上图对应着看哈）。</p>
<img src="/pics/image-20210319000613709.png" alt="image-20210319000613709" style="zoom:50%;" />

<h3 id="JMM-与计算机内存结构"><a href="#JMM-与计算机内存结构" class="headerlink" title="JMM 与计算机内存结构"></a>JMM 与计算机内存结构</h3><p>Java 内存模型和硬件内存体系结构也没有什么关系。硬件内存体系结构不区分栈和堆。在硬件上，线程栈和堆都位于主内存中。线程栈和堆的一部分有时可能出现在高速缓存和CPU寄存器中。如下图所示:</p>
<img src="/pics/image-20210319000711299.png" alt="image-20210319000711299" style="zoom:50%;" />

<p>当对象和变量可以存储在计算机中不同的内存区域时，这就可能会出现某些问题。两个主要问题是:</p>
<ul>
<li><strong>线程更新(写)到共享变量的可见性</strong></li>
<li><strong>读取、检查和写入共享变量时的竞争条件</strong></li>
</ul>
<h4 id="可见性问题（Visibility-of-Shared-Objects）"><a href="#可见性问题（Visibility-of-Shared-Objects）" class="headerlink" title="可见性问题（Visibility of Shared Objects）"></a>可见性问题（Visibility of Shared Objects）</h4><p>如果两个或多个线程共享一个对象，则一个线程对共享对象的更新可能对其他线程不可见（当然可以用 Java 提供的关键字 volatile）。 假设共享对象最初存储在主内存中。在 CPU 1上运行的线程将共享对象读入它的CPU缓存后修改，但是还没来得及即刷新回主内存，这时其他 CPU 上运行的线程就不会看到共享对象的更改。这样，每个线程都可能以自己的线程结束，就出现了可见性问题，如下</p>
<img src="/pics/image-20210319004455084.png" alt="image-20210319004455084" style="zoom:50%;" />

<h4 id="竞争条件（Race-Conditions）"><a href="#竞争条件（Race-Conditions）" class="headerlink" title="竞争条件（Race Conditions）"></a>竞争条件（Race Conditions）</h4><p>这个其实就是我们常说的原子问题。</p>
<p>如果两个或多个线程共享一个对象，并且多个线程更新该共享对象中的变量，则可能出现竞争条件。</p>
<p>想象一下，如果线程 A 将一个共享对象的变量读入到它的 CPU 缓存中。此时，线程 B 执行相同的操作，但是进入不同的 CPU 缓存。现在线程A执行 +1 操作，线程B也这样做。现在该变量增加了两次，在每个 CPU 缓存中一次。</p>
<p>如果这些增量是按顺序执行的，则变量结果会是 3，并将原始值 +2 写回主内存。但是，这两个增量是同时执行的，没有适当的同步。不管将哪个线程的结构写回主内存，更新后的值只比原始值高1，显然是有问题的。如下（当然可以用 Java 提供的关键字 Synchronized）</p>
<img src="/pics/image-20210319004553218.png" alt="image-20210319004553218" style="zoom:50%;" />

<h3 id="JMM-特性"><a href="#JMM-特性" class="headerlink" title="JMM 特性"></a>JMM 特性</h3><p>JMM 就是用来解决如上问题的。 <strong>JMM是围绕着并发过程中如何处理可见性、原子性和有序性这 3 个 特征建立起来的</strong></p>
<ul>
<li><p><strong>可见性</strong>：<strong>可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改</strong>。Java 中的 volatile、synchronzied、final 都可以实现可见性</p>
</li>
<li><p><strong>原子性</strong>：即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。<strong>即使在多个线程一起执行的时候</strong>，一个操作一旦开始，就不会被其他线程所干扰。</p>
</li>
<li><p><strong>有序性</strong>：计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排，一般分为以下 3 种：</p>
<p><img src="/pics/image-20210319001149455.png" alt="image-20210319001149455">单线程环境里确保程序最终执行结果和代码顺序执行的结果一致；</p>
<p>处理器在进行重排序时必须要考虑指令之间的<strong>数据依赖性</strong>；</p>
<p>多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。</p>
</li>
</ul>
<h3 id="内存之间的交互操作"><a href="#内存之间的交互操作" class="headerlink" title="内存之间的交互操作"></a>内存之间的交互操作</h3><p>关于主内存和工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java 内存模型中定义了 8 种 操作来完成，<strong>虚拟机实现必须保证每一种操作都是原子的、不可再拆分的</strong>（double和long类型例外）</p>
<ul>
<li><strong>lock</strong>（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</li>
<li><strong>unlock</strong>（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li><strong>read</strong>（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li>
<li><strong>load</strong>（载入）：作用于工作内存的变量，它把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li><strong>use</strong>（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</li>
<li><strong>assign</strong>（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li><strong>store</strong>（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的 write操作使用。</li>
<li><strong>write</strong>（写入）：作用于主内存的变量，它把 store 操作从工作内存中得到的变量的值放入主内存的变量中。</li>
</ul>
<p>如果需要把一个变量从主内存复制到工作内存，那就要顺序地执行 <strong>read 和 load 操作</strong>，如果要把变量从工作内存同步回主内存，就要顺序地执行 <strong>store 和 write 操作</strong>。注意，<strong>Java 内存模型只要求上述两个操作必须按顺序执行，而没有保证是连续执行</strong>。也就是说 read 与 load 之间、store 与write 之间是可插入其他指令的，如对主内存中的变量 a、b 进行访问时，一种可能出现顺序是 read a、read b、load b、load a。</p>
<img src="/pics/image-20210319001848007.png" alt="image-20210319001848007" style="zoom:50%;" />

<p>除此之外，Java 内存模型还规定了在执行上述 8 种基本操作时必须满足如下规则</p>
<ul>
<li>不允许 read 和 load、store 和 write 操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。</li>
<li>不允许一个线程丢弃它的最近的 assign 操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li>
<li>不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从线程的工作内存同步回主内存。</li>
<li>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load 或 assign）的变量，换句话说，就是对一个变量实施 use、store 操作之前，必须先执行过了 assign 和 load 操作。</li>
<li>一个变量在同一时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。</li>
<li>如果对一个变量执行 lock 操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值。</li>
<li>如果一个变量事先没有被 lock 操作锁定，那就不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定住的变量。</li>
<li>对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中（执行 store、write 操作）。</li>
</ul>
<h4 id="long-和-double-型变量的特殊规则"><a href="#long-和-double-型变量的特殊规则" class="headerlink" title="long 和 double 型变量的特殊规则"></a>long 和 double 型变量的特殊规则</h4><p>Java 内存模型要求 lock，unlock，read，load，assign，use，store，write 这 8 个操作都具有原子性，但对于64 位的数据类型（ long 或 double），在模型中定义了一条相对宽松的规定，允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作划分为两次 32 位的操作来进行，即允许虚拟机实现选择可以不保证 64 位数据类型的load，store，read，write 这 4 个操作的原子性，即 <strong>long 和 double 的非原子性协定</strong>。</p>
<p>如果多线程的情况下double 或 long 类型并未声明为 volatile，可能会出现“半个变量”的数值，也就是既非原值，也非修改后的值。</p>
<p>虽然 Java 规范允许上面的实现，但商用虚拟机中基本都采用了原子性的操作，因此在日常使用中几乎不会出现读取到“半个变量”的情况，so，这个了解下就行。</p>
<h3 id="先行发生原则（这8种情况不可以重排序，必须加屏障）"><a href="#先行发生原则（这8种情况不可以重排序，必须加屏障）" class="headerlink" title="先行发生原则（这8种情况不可以重排序，必须加屏障）"></a>先行发生原则（这8种情况不可以重排序，必须加屏障）</h3><p>先行发生（happens-before）是 Java 内存模型中定义的两项操作之间的偏序关系，<strong>如果操作A 先行发生于操作B，那么A的结果对B可见</strong>。happens-before关系的分析需要分为<strong>单线程和多线程</strong>的情况：</p>
<ul>
<li><strong>单线程下的 happens-before</strong> 字节码的先后顺序天然包含 happens-before 关系：因为单线程内共享一份工作内存，不存在数据一致性的问题。 在程序控制流路径中靠前的字节码 happens-before 靠后的字节码，即靠前的字节码执行完之后操作结果对靠后的字节码可见。然而，这并不意味着前者一定在后者之前执行。实际上，如果后者不依赖前者的运行结果，那么它们可能会被重排序。</li>
<li><strong>多线程下的 happens-before</strong> 多线程由于每个线程有共享变量的副本，如果没有对共享变量做同步处理，线程 1 更新执行操作 A 共享变量的值之后，线程 2 开始执行操作 B，此时操作 A 产生的结果对操作 B 不一定可见。</li>
</ul>
<p>为了方便程序开发，Java 内存模型实现了下述的先行发生关系（“天然的”先行发生关系，无需任何同步器协助就存在）：</p>
<ul>
<li><strong>程序次序规则：</strong> 一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作。</li>
<li><strong>管程锁定规则：</strong> 一个 unLock 操作先行发生于后面对同一个锁的 lock 操作。</li>
<li><strong>volatile变量规则：</strong> 对一个变量的写操作先行发生于后面对这个变量的读操作。</li>
<li><strong>传递规则：</strong> 如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出操作 A 先行发生于操作 C。</li>
<li><strong>线程启动规则：</strong> Thread对象的 <code>start()</code> 方法先行发生于此线程的每一个动作。</li>
<li><strong>线程中断规则：</strong> 对线程 <code>interrupt()</code> 方法的调用先行发生于被中断线程的代码检测到中断事件的发生。</li>
<li><strong>线程终结规则：</strong> 线程中所有的操作都先行发生于线程的终止检测，我们可以通过<code>Thread.join()</code>方法结束、<code>Thread.isAlive()</code>的返回值手段检测到线程已经终止执行。</li>
<li><strong>对象终结规则：</strong> 一个对象的初始化完成先行发生于它的 <code>finalize()</code>方法的开始</li>
</ul>
<h3 id="内存屏障-1"><a href="#内存屏障-1" class="headerlink" title="内存屏障"></a>内存屏障</h3><p>上边的一系列操作保证了数据一致性，Java 中如何保证底层操作的有序性和可见性？可以通过内存屏障。</p>
<p>内存屏障是被插入两个 CPU 指令之间的一种指令，用来禁止处理器指令发生重排序（像屏障一样），从而保障<strong>有序性</strong>的。另外，为了达到屏障的效果，它也会使处理器写入、读取值之前，将主内存的值写入高速缓存，清空无效队列，从而保障<strong>可见性</strong>。eg:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Store1; </span><br><span class="line">Store2;   </span><br><span class="line">Load1;   </span><br><span class="line">StoreLoad;  //内存屏障</span><br><span class="line">Store3;   </span><br><span class="line">Load2;   </span><br><span class="line">Load3;</span><br></pre></td></tr></table></figure>

<p>StoreLoad 屏障之前的 Store 指令无法与 StoreLoad 屏障之后的 Load 指令进行交换位置，即<strong>重排序</strong>。但是 StoreLoad 屏障之前和之后的指令是可以互换位置的，即 Store1 可以和 Store2 互换，Load2 可以和 Load3 互换。</p>
<p>常见的 4 种屏障：<strong>注意这些不是cpu的指令，而是JVM的规范要求，</strong>不同的CPU有不同的实现。 </p>
<ul>
<li><p><strong>LoadLoad</strong> 屏障： 对于这样的语句 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Load1; LoadLoad; Load2</span><br></pre></td></tr></table></figure>

<p>在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</p>
</li>
<li><p><strong>StoreStore</strong> 屏障： 对于这样的语句 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Store1; StoreStore; Store2</span><br></pre></td></tr></table></figure>

<p>在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</p>
</li>
<li><p><strong>LoadStore</strong> 屏障： 对于这样的语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Load1; LoadStore; Store2</span><br></pre></td></tr></table></figure>

<p>在Store2及后续写入操作被执行前，保证Load1要读取的数据被读取完毕。</p>
</li>
<li><p><strong>StoreLoad</strong> 屏障： 对于这样的语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Store1; StoreLoad; Load2</span><br></pre></td></tr></table></figure>

<p>在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的（冲刷写缓冲器，清空无效化队列）。在大多数处理器的实现中，这个屏障也被称为<strong>全能屏障</strong>，兼具其它三种内存屏障的功能。</p>
</li>
</ul>
<p>Java 中对内存屏障的使用在一般的代码中不太容易见到，常见的有 volatile 和 synchronized 关键字修饰的代码块，还可以通过 Unsafe 这个类来使用内存屏障。（下一章扯扯这些）</p>
<p>Java 内存模型就是通过定义的这些来解决可见性、原子性和有序性的。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="JMM-是什么？"><a href="#JMM-是什么？" class="headerlink" title="JMM 是什么？"></a>JMM 是什么？</h3><p>JMM，java内存模型，定义了内存中变量的访问规范（JVM和RAM交互规则），是一种抽象的概念。目的是为了让<strong>java程序在各种平台下都能达到一致的并发效果</strong>，屏蔽掉各种硬件和操作系统的差异。</p>
<p>JMM规定了内存主要划分为<strong>主内存</strong>和<strong>工作内存</strong>两种。</p>
<ul>
<li>主内存(Main Memory)：JMM规定<strong>所有的变量都存储在主内存</strong>中。</li>
<li>工作内存：线程私有的，每条线程都有自己的工作内存。保存了该线程使用到的主内存中的共享变量的副本。<strong>线程对变量的所有操作都必须在工作内存进行，而不能直接读写主内存中的变量</strong>。</li>
</ul>
<h3 id="JMM解决什么问题？"><a href="#JMM解决什么问题？" class="headerlink" title="JMM解决什么问题？"></a>JMM解决什么问题？</h3><p>JMM主要是为了解决并发过程中<strong>可见性问题和竞争问题</strong>，围绕着并发过程中如何处理可见性、原子性和有序性这3个特性建立起来的。</p>
<ul>
<li><p>原子性</p>
<p>一个操作是不可分割、不可中断的，<strong>一个线程在执行时不会被其他线程干扰</strong>。synchronized + lock + cas</p>
</li>
<li><p>可见性</p>
<p>当一个线程修改共享变量的值，其他线程能够立即知道。 volatile  + synchronized + lock</p>
</li>
<li><p>有序性</p>
<p>程序执行的顺序按照代码的先后顺序执行。程序执行过程中，编译器和处理器对指令进行的重排序优化，使得<strong>并发过程中代码的执行顺序和代码的先后顺序不一致</strong>，导致最终的结果无法预测。synchronized + happensbefore + lock</p>
</li>
</ul>
<h3 id="JMM中的8种内存交互操作？"><a href="#JMM中的8种内存交互操作？" class="headerlink" title="JMM中的8种内存交互操作？"></a>JMM中的8种内存交互操作？</h3><ul>
<li>lock + unlock : 作用于主内存中的变量；lock，加锁，表示线程独占；unlock ，释放锁，允许其他线程再锁定</li>
<li>read +  write ：作用于主内存变量，read把变量从主内存传输到工作线程；load把变量从工作线程写入到主内存</li>
<li>load + store  ：作用于工作内存的变量，load把read 操作从主内存中得到的变量放入工作内存的变量副本中；store 把工作内存中一个变量的值传送到主内存中，以便随后的 write操作使用</li>
<li>use + assign ：作用于工作内存的变量，use把工作内存中一个变量的值传递给执行引擎；assgin把一个从执行引擎接收到的值赋给工作内存的变量</li>
</ul>
<h3 id="内存屏障？"><a href="#内存屏障？" class="headerlink" title="内存屏障？"></a>内存屏障？</h3><p>保证底层操作的有序性和可见性</p>
<ul>
<li>就像一套栅栏分割前后的代码，阻止栅栏前后的没有数据依赖性的代码进行指令重排序，保证程序在一定程度上的<strong>有序性</strong>。</li>
<li>强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效，保证数据的<strong>可见性</strong>。</li>
</ul>
<h3 id="happens-before原则理解？"><a href="#happens-before原则理解？" class="headerlink" title="happens-before原则理解？"></a>happens-before原则理解？</h3><p>先行发生（happens-before）是 Java 内存模型中定义的两项操作之间的偏序关系，<strong>如果操作A 先行发生于操作B，那么A的结果对B可见</strong>。共定义了8种规则，单线程是天然有序的，对于多线程来说，多个并发线程间必需要符合这个规则中的任一条，否则就不能保证有序。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://yq.aliyun.com/articles/750655">https://yq.aliyun.com/articles/750655</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/54chensongxia/p/12120117.html">https://www.cnblogs.com/54chensongxia/p/12120117.html</a></p>
<p>《深入理解 Java 虚拟机》第二版</p>
<p><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/java-memory-model.html">http://tutorials.jenkov.com/java-concurrency/java-memory-model.html</a> <a target="_blank" rel="noopener" href="https://juejin.im/post/5bf2977751882505d840321d#heading-5">https://juejin.im/post/5bf2977751882505d840321d#heading-5</a> <a target="_blank" rel="noopener" href="http://rsim.cs.uiuc.edu/Pubs/popl05.pdf">http://rsim.cs.uiuc.edu/Pubs/popl05.pdf</a> <a target="_blank" rel="noopener" href="http://ifeve.com/wp-content/uploads/2014/03/JSR133%E4%B8%AD%E6%96%87%E7%89%88.pdf">http://ifeve.com/wp-content/uploads/2014/03/JSR133中文版.pdf</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/20/Notes/Android/Framework/APK%E7%AD%BE%E5%90%8D%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/20/Notes/Android/Framework/APK%E7%AD%BE%E5%90%8D%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">APK签名机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-20 10:15:14" itemprop="dateCreated datePublished" datetime="2021-03-20T10:15:14+08:00">2021-03-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="APK签名机制"><a href="#APK签名机制" class="headerlink" title="APK签名机制"></a>APK签名机制</h1><h1 id="1、什么是apk签名"><a href="#1、什么是apk签名" class="headerlink" title="1、什么是apk签名"></a>1、什么是apk签名</h1><p>android应用在安装过程中会对apk进行签名校验，主要用于验证apk的可靠性、安全性以及唯一性，保证apk是有可信性的发布者发布，防止发布后被篡改；另外在apk升级时除了包名一致，签名也要一致。要了解签名和验签过程需要先了解以下几个基本概念。</p>
<h2 id="1-1、基本概念"><a href="#1-1、基本概念" class="headerlink" title="1.1、基本概念"></a>1.1、基本概念</h2><h3 id="1-1-1、数字摘要"><a href="#1-1-1、数字摘要" class="headerlink" title="1.1.1、数字摘要"></a>1.1.1、数字摘要</h3><p>数字摘要就是采用单向Hash函数将需要加密的明文“摘要”成一串固定长度（128位）的密文这一串密文又称为数字指纹，它有固定的长度，而且不同的明文摘要成密文，其结果总是不同的，而同样的明文其摘要必定一致。常用的数字摘要技术（Digital Digest）也称作为安全HASH编码法（SHA：Secure Hash Algorithm）。对所要传输的数据进行运算生成信息摘要，它并不是一种加密机制，但却能产生信息的数字”指纹”，它的目的是为了确保数据没有被修改或变化，保证信息的完整性不被破坏。</p>
<h3 id="1-1-2、数字签名"><a href="#1-1-2、数字签名" class="headerlink" title="1.1.2、数字签名"></a>1.1.2、数字签名</h3><p>数字签名的作用就是保证信息传输的完整性、发送者的身份认证、防止交易中的抵赖发生。<strong>数字签名技术是将摘要信息用发送者的私钥加密</strong>，与原文一起传送给接收者。接收者只有<strong>用发送者的公钥才能解密被加密的摘要信息然后用HASH函数对收到的原文产生一个摘要信息，与解密的摘要信息对比</strong>。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。</p>
<h3 id="1-1-3、数字证书"><a href="#1-1-3、数字证书" class="headerlink" title="1.1.3、数字证书"></a>1.1.3、数字证书</h3><p>数字证书是由权威公证的第三方认证机构（即CA，Certificate Authority）负责签发和管理的、个人或企业的网络数字身份证明。A的数字签名可以类比为现实世界中的签名，用来证明一个文件或者消息是A签署的，通常是使用A的私钥对消息摘要加密而得到，其他人可以使用A的公钥对数字签名进行验证。但是怎么才能信任A的公钥呢？让A自己证明自己是一件很难的事情，因此就需要第三方来证明，这就是数字证书的意义所在。</p>
<h2 id="1-2、apk签名和验签原理"><a href="#1-2、apk签名和验签原理" class="headerlink" title="1.2、apk签名和验签原理"></a>1.2、apk签名和验签原理</h2><p><img src="/pics/image-20201216113655542.png" alt="image-20201216113655542"></p>
<h3 id="1-2-1、APK签名"><a href="#1-2-1、APK签名" class="headerlink" title="1.2.1、APK签名"></a>1.2.1、APK签名</h3><ol>
<li>计算摘要：使用数字摘要算法计算出apk的摘要；</li>
<li>签名：通过私钥对摘要进行加密，加密后的信息就是签名；</li>
<li>写入签名：将签名信息、证书以及公钥写入到文件中。</li>
</ol>
<h3 id="1-2-2、APK验签"><a href="#1-2-2、APK验签" class="headerlink" title="1.2.2、APK验签"></a>1.2.2、APK验签</h3><ol>
<li>解密签名：通过公钥解密签名信息获得摘要；</li>
<li>计算摘要：使用摘要算法从接收的数据中计算摘要；</li>
<li>比较摘要：比较解密出的摘要和通过文件计算的摘要，若一致，则校验通过。</li>
</ol>
<p>接下来介绍下现有的4种apk签名的方式。</p>
<h1 id="2、v1-签名"><a href="#2、v1-签名" class="headerlink" title="2、v1 签名"></a>2、v1 签名</h1><p>V1签名又称为JAR签名，是对jar包进行签名的一种机制，由于jar包apk本质上都是zip包，所以可以应用到对apk的签名。解压apk后，META-INF目录中存放的就是签名相关的文件。</p>
<h2 id="2-1-v1签名过程"><a href="#2-1-v1签名过程" class="headerlink" title="2.1 v1签名过程"></a>2.1 v1签名过程</h2><p><img src="/pics/image-20201221200634926.png" alt="image-20201221200634926"></p>
<p>MANIFEST.MF、CERT.SF、CERT.RSA是签名过程中生成的文件（<a target="_blank" rel="noopener" href="https://android.googlesource.com/platform/build/+/7e447ed/tools/signapk/SignApk.java">apksigner源码</a>），作用如下：</p>
<h3 id="2-1-1、MANIFEST-MF"><a href="#2-1-1、MANIFEST-MF" class="headerlink" title="2.1.1、MANIFEST.MF"></a>2.1.1、MANIFEST.MF</h3><p>对APK中所有文件计算摘要保存到该文件中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: <span class="number">1.0</span></span><br><span class="line">Created-By: <span class="number">1.8</span><span class="number">.0_212</span> (Oracle Corporation)</span><br><span class="line"></span><br><span class="line">Name: AndroidManifest.xml <span class="comment">//apk各个文件的摘要</span></span><br><span class="line">SHA1-Digest: GpiU1HOPO9rxpTPh43kG1XVG8iw=</span><br><span class="line"></span><br><span class="line">Name: META-INF/BdTuringSdk_cnRelease.kotlin_module</span><br><span class="line">SHA1-Digest: PVHPdoZ9+09Zq0PF+eJz0yRVf10=</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="2-1-2、CERT-SF"><a href="#2-1-2、CERT-SF" class="headerlink" title="2.1.2、CERT.SF"></a>2.1.2、CERT.SF</h3><ul>
<li>SHA1-Digest-Manifest-Main-Attributes：MANIFEST.MF主属性的数据摘要。</li>
<li>SHA1-Digest-Manifest： MANIFEST.MF 文件计算摘要。</li>
<li>SHA1-Digest：MANIFEST.MF 的各个条目摘要。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Signature-Version: <span class="number">1.0</span></span><br><span class="line">SHA1-Digest-Manifest-Main-Attributes: TN5zBsqBLAij6alOeMWe+Ejwd4g= <span class="comment">//主属性记录了MANIFEST.MF文件所有主属性的数据摘要</span></span><br><span class="line">SHA1-Digest-Manifest: PBUX5Kag9TIOJy4jZ57vwuAur1Y= <span class="comment">//整个MANIFEST.MF文件的数据摘要</span></span><br><span class="line">Created-By: <span class="number">1.8</span><span class="number">.0_45</span>-internal (Oracle Corporation)</span><br><span class="line"></span><br><span class="line">Name: res/layout/ac.xml</span><br><span class="line">SHA1-Digest: mYQig54fsd3pTRQTmTwMD2oO5CM= <span class="comment">//MANIFEST.MF 各个条目的摘要</span></span><br></pre></td></tr></table></figure>

<h3 id="2-1-3、CERT-RSA"><a href="#2-1-3、CERT-RSA" class="headerlink" title="2.1.3、CERT.RSA"></a>2.1.3、CERT.RSA</h3><p><strong>对CERT.SF 文件的摘要通过私钥加密生成校验串</strong>, 然后和<strong>数字签名、公钥、数字证书</strong>一同写入 CERT.RSA 中保存。很多文章将校验串描述成签名，这样的理解是不准确的。可以比较2个同一个公司出品的apk的RSA文件，你会发现可能除了结尾部分不太一样外，其他部分基本相同，原因其实就是同一个公司出品的apk，它的签名，证书，公钥通常都是相同的，只有通过私钥加密的CERT.SF的摘要不同。 如下图：</p>
<p><img src="/pics/image-20201217160514944.png" alt="image-20201217160514944"></p>
<h4 id="1、查看证书与公钥"><a href="#1、查看证书与公钥" class="headerlink" title="1、查看证书与公钥"></a>1、查看证书与公钥</h4><p>1、将.rsa 后缀改为.p7b文件，双击直接打开</p>
<p>2、openssl 命令查看证书信息（公钥在证书信息中）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 查看.RSA文件中证书信息</span><br><span class="line">openssl pkcs7 -inform DER -in XXX.RSA -noout -print_certs -text</span><br><span class="line"></span><br><span class="line">// 查看本地证书的公钥和私钥</span><br><span class="line">keytool -list -rfc --keystore test.jks | openssl x509 -inform pem -pubkey</span><br></pre></td></tr></table></figure>

<p>通过一个实例去理解一下这两种方式的区别和联系。</p>
<ol>
<li>使用AS或keytool生成一个.jks签名文件； <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b28a5be05029">Android studio 如何生成jks签名文件</a></li>
<li>使用签名文件对apk进行签名；</li>
<li>通过相关命令查看.jks文件以及解压apk中的.rsa 文件。</li>
</ol>
<p><img src="/pics/image-20201217162850396.png" alt="image-20201217162850396"></p>
<h4 id="2、查看签名"><a href="#2、查看签名" class="headerlink" title="2、查看签名"></a>2、查看签名</h4><p>其实能看到也是签名的摘要，不是真正的签名。</p>
<ol>
<li>将.rsa 后缀改为.p7b文件，双击直接打开</li>
<li>使用keytool的命令查看.RSA文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -printcert -file xxx.RSA</span><br></pre></td></tr></table></figure>

<p><strong>证书信息：</strong></p>
<p><img src="/pics/image-20201217163225037.png" alt="image-20201217163225037"></p>
<h2 id="2-2、v1验签过程"><a href="#2-2、v1验签过程" class="headerlink" title="2.2、v1验签过程"></a>2.2、<a target="_blank" rel="noopener" href="https://android.googlesource.com/platform/frameworks/base/+/android-5.1.1_r38/services/core/java/com/android/server/pm/PackageManagerService.java">v1验签过程</a></h2><ol>
<li><p><strong>首先校验cert.sf文件的签名</strong></p>
<p>计算cert.sf文件的摘要，与通过签名者公钥解密CERT.RSA文件得到的摘要进行对比，如果一致则进入下一步；</p>
</li>
<li><p><strong>校验manifest.mf文件的完整性</strong></p>
<p>计算manifest.mf文件的摘要，与cert.sf主属性中记录的摘要进行对比，如一致则逐一校验mf文件各个条目的完整性；</p>
</li>
<li><p><strong>校验apk中每个文件的完整性</strong></p>
<p>逐一计算apk中每个文件（META-INF目录除外）的摘要，与mf中的记录进行对比，如全部一致，刚校验通过；</p>
</li>
<li><p><strong>校验签名的一致性</strong></p>
<p>如果是升级安装，还需校验证书签名是否与已安装app一致。</p>
</li>
</ol>
<h2 id="2-3、v1签名的劣势"><a href="#2-3、v1签名的劣势" class="headerlink" title="2.3、v1签名的劣势"></a>2.3、v1签名的劣势</h2><ol>
<li><p>签名校验速度慢</p>
<p>校验过程中需要对apk中所有文件进行摘要计算，在apk资源很多、性能较差的机器上签名校验会花费较长时间，导致安装速度慢；</p>
</li>
<li><p>完整性保障不够</p>
<p>META-INF目录用来存放签名，自然此目录本身是不计入签名校验过程的，可以随意在这个目录中添加文件，比如一些快速批量打包方案就选择在这个目录中添加渠道文件。</p>
<p>为了解决这两个问题，Android 7.0推出了全新的签名方案V2，下面介绍下v2签名。</p>
</li>
</ol>
<h1 id="2、v2签名"><a href="#2、v2签名" class="headerlink" title="2、v2签名"></a>2、v2签名</h1><h2 id="2-1、ZIP文件结构"><a href="#2-1、ZIP文件结构" class="headerlink" title="2.1、ZIP文件结构"></a>2.1、ZIP文件结构</h2><p>我们先来了解下v1签名文件的apk结构，也就是zip文件的结构。</p>
<p><img src="/pics/image-20201217175101791.png" alt="image-20201217175101791"></p>
<p>zip文件分为3部分：</p>
<ol>
<li><p><strong>数据区</strong></p>
<p>主要存放压缩的文件数据</p>
</li>
<li><p><strong>中央目录</strong></p>
<p>存放数据区压缩文件的索引</p>
</li>
<li><p><strong>中央目录结尾记录</strong></p>
<p>存放中央目录的文件索引</p>
</li>
</ol>
<p>查找压缩文件中数据可以先中央目录起始偏移量和size即可定位到中央目录，再遍历中央目录条目，根据本地文件头的起始偏移量即可在数据区中找到相应数据。</p>
<h2 id="2-2、v2签名原理"><a href="#2-2、v2签名原理" class="headerlink" title="2.2、v2签名原理"></a>2.2、v2签名原理</h2><p>JAR签名是在apk文件中添加META-INF目录，即需要修改数据区、中央目录，此外，添加文件后会导致中央目录大小和偏移量发生变化，还需要修改中央目录结尾记录。</p>
<p>v2方案为加强数据完整性保证，不在数据区和中央目录中插入数据，选择在 数据区和中央目录之间插入一个APK签名分块，从而保证了原始数据的完整性。</p>
<img src="/pics/image-20201217174414400.png" alt="image-20201217174414400" style="zoom:150%;" />

<p>APK 签名方案 v2 负责保护第 1、3、4 部分的完整性，以及第 2 部分包含的“APK 签名方案 v2 分块”中的 <code>signed data</code> 分块的完整性。第 1、3 和 4 部分的完整性通过其内容的一个或多个摘要来保护，这些摘要存储在 <code>signed data</code> 分块中，而这些分块则通过一个或多个签名来保护。</p>
<h3 id="2-2-1、APK摘要计算"><a href="#2-2-1、APK摘要计算" class="headerlink" title="2.2.1、APK摘要计算"></a>2.2.1、APK摘要计算</h3><p><img src="/pics/image-20201217202801891.png" alt="image-20201217202801891"></p>
<p>第 1、3 和 4 部分的摘要采用以下计算方式：</p>
<ol>
<li>将APK拆分成多个大小为 1 MB大小的连续块，最后一个块可能小于1M。之所以分块，是为了可以通过并行计算摘要以加快计算速度；</li>
<li>计算块的摘要，以字节 0xa5 + 块的长度（字节数） + 块的内容 进行计算；</li>
<li>计算整体摘要，字节 0x5a + 块数 + 块的摘要的连接（按块在 APK 中的顺序）进行计算。</li>
</ol>
<h2 id="2-3、签名过程"><a href="#2-3、签名过程" class="headerlink" title="2.3、签名过程"></a>2.3、签名过程</h2><p>介绍APK签名过程前，需要先了解下使用apk签名块的结构和v2签名块的结构。</p>
<h3 id="2-3-1、APKSigning-Block"><a href="#2-3-1、APKSigning-Block" class="headerlink" title="2.3.1、APKSigning Block"></a>2.3.1、APKSigning Block</h3><p>APK签名分块包含了4部分：分块长度、ID-VALUE序列、分块长度、固定magic值。其中APK 签名方案 <strong>v2分块</strong>存放在ID为<strong>0x7109871a</strong>的ID-VALUE区中。</p>
<p><img src="/pics/image-20201217212653708.png" alt="image-20201217212653708"></p>
<h3 id="2-3-2、v2-Block"><a href="#2-3-2、v2-Block" class="headerlink" title="2.3.2、v2 Block"></a>2.3.2、v2 Block</h3><p>v2分块主要由签名数据，数字签名以及公钥组成，具体结构如下。</p>
<p><img src="/pics/image-20201219104001970.png" alt="image-20201219104001970"></p>
<h3 id="2-3-3、签名过程"><a href="#2-3-3、签名过程" class="headerlink" title="2.3.3、签名过程"></a>2.3.3、签名过程</h3><p>V2签名块的生成可参考<a target="_blank" rel="noopener" href="https://android.googlesource.com/platform/build/+/dd910c5/tools/signapk/src/com/android/signapk/ApkSignerV2.java">ApkSignerV2</a>，整体结构和流程如下图所示：</p>
<p><img src="/pics/image-20201219153651713.png" alt="image-20201219153651713"></p>
<h2 id="2-4、v2验签过程"><a href="#2-4、v2验签过程" class="headerlink" title="2.4、v2验签过程"></a>2.4、v2验签过程</h2><p>在 Android 7.0 及更高版本中，可以根据 APK 签名方案 v2+ 或 JAR 签名（v1 方案）验证 APK。更低版本的平台会忽略 v2 签名，仅验证 v1 签名。</p>
<p><img src="/pics/image-20201221204054757.png" alt="image-20201221204054757"></p>
<h3 id="2-4-1、v2签名块定位"><a href="#2-4-1、v2签名块定位" class="headerlink" title="2.4.1、v2签名块定位"></a>2.4.1、v2签名块定位</h3><p>APK签名分块包含了4部分：分块长度、ID-VALUE序列、分块长度、固定magic值。其中APK 签名方案 v2分块存放在ID为0x7109871a的键值对中。</p>
<p>在进行签名校验时，先找到zip中央目录结尾记录，从该记录中找到中央目录起始偏移量，再通过magic值（APK Sig Block 42）即可确定前方可能是APK签名分块，再通过前后两个分块长度字段，即可确定APK签名分块的位置，最后通过ID（0x7109871a）定位APK 签名方案 v2分块位置。</p>
<h3 id="2-4-2、v2-验证过程"><a href="#2-4-2、v2-验证过程" class="headerlink" title="2.4.2、v2 验证过程"></a>2.4.2、v2 验证过程</h3><p><img src="/pics/image-20210319101806758.png" alt="image-20210319101806758"></p>
<h3 id="2-4-3、防回滚保护"><a href="#2-4-3、防回滚保护" class="headerlink" title="2.4.3、防回滚保护"></a>2.4.3、防回滚保护</h3><p><img src="/pics/image-20210319102400692.png" alt="image-20210319102400692"></p>
<h1 id="3、v3签名"><a href="#3、v3签名" class="headerlink" title="3、v3签名"></a>3、<a target="_blank" rel="noopener" href="https://source.android.com/security/apksigning/v3.html">v3签名</a></h1><p>v3和v2一样签名块存储在中央目录区之前，v3 签名会存储的ID为<strong>0xf05368c0</strong>，新增了 ID为<strong>0x3ba06f8c</strong> 的proof-of-rotation 结构中用来支持应用替换签名证书。在 Android 9 及更高版本中，可以根据 APK 签名方案 v3、v2 或 v1 验证 APK。较旧的平台会忽略 v3 签名而尝试验证 v2 签名，然后尝试验证 v1 签名。</p>
<p><img src="/pics/image-20201222203051481.png" alt="image-20201222203051481"></p>
<h1 id="4、v4签名"><a href="#4、v4签名" class="headerlink" title="4、v4签名"></a>4、v4签名</h1><p>Android 11 通过 APK 签名方案 v4 支持与流式传输兼容的签名方案（来支持增量安装APK）。v4 签名基于根据 APK 的所有字节计算得出的 Merkle 哈希树。</p>
<p><a target="_blank" rel="noopener" href="https://source.android.google.cn/security/apksigning/v4">https://</a><a target="_blank" rel="noopener" href="https://source.android.google.cn/security/apksigning/v4">source.android.google.cn/security/apksigning/v4</a> </p>
<h1 id="5、多渠道打包原理"><a href="#5、多渠道打包原理" class="headerlink" title="5、多渠道打包原理"></a>5、多渠道打包原理</h1><p>同一个app，需要上线各种平台，比如：小米，华为，百度等，我们多数称之为渠道，如果发的渠道多，可能有上百个渠道。</p>
<p>针对每个渠道，我们希望可以获取各个渠道的一些独立的统计信息，比如：下载量等。</p>
<p><strong>那么，如何区分各个渠道呢？</strong></p>
<p>Gradle Plugin为我们提供了一个自动化的方案，我们可以利用占位符，然后在build.gradle中去配置多个渠道信息，这样就可以将枯燥重复的任务自动化了。</p>
<p>这样的方式最大的问题，就是效率问题，每个渠道包，都要执行一遍构建流程，打包效率太低，目前市面比较出名的方案有美团<a target="_blank" rel="noopener" href="https://tech.meituan.com/2017/01/13/android-apk-v2-signature-scheme.html">Walle</a>，腾讯的<a target="_blank" rel="noopener" href="https://github.com/Tencent/VasDolly">VasDolly</a>所谓万变不离其宗，下面就介绍下市面上多渠道打包方案的基本原理。</p>
<h2 id="5-1、v1方案"><a href="#5-1、v1方案" class="headerlink" title="5.1、v1方案"></a>5.1、v1方案</h2><h3 id="5-1-1、EOCD"><a href="#5-1-1、EOCD" class="headerlink" title="5.1.1、EOCD"></a>5.1.1、EOCD</h3><p>我们知道要在apk中定位某个文件的位置必须要先解析出EOCD的结果，根据EOCD的结构推断出中央目录区，再根据中央目录区定位到v2签名块或者文件的情况。下面是EOCD的结构，主要包括几部分：</p>
<ol>
<li>魔数 0x06054B50，标记EOCD</li>
<li>中央目录信息（起始位置，记录数，长度）</li>
<li>注释区长度n（前2个字节）以及注释内容（Comment）</li>
</ol>
<p><img src="/pics/image-20201219155013207.png" alt="image-20201219155013207"></p>
<h3 id="5-1-2、v1方案"><a href="#5-1-2、v1方案" class="headerlink" title="5.1.2、v1方案"></a>5.1.2、v1方案</h3><p>根据之前的V1签名和校验机制可知，v1签名只会检验第一部分的所有压缩文件，而不理会后两部分内容。因此，我们可以向注释区中写入渠道。写入过程如下：</p>
<p><img src="/pics/image-20201222201238671.png" alt="image-20201222201238671"></p>
<p>这里添加魔数的好处是方便从后向前读取数据，定位渠道信息。因此，读取渠道信息包括以下几步：</p>
<ol>
<li>定位到魔数（8字节）</li>
<li>向前读两个字节，确定渠道信息的长度LEN（2字节）</li>
<li>继续向前读LEN字节，就是渠道信息了。</li>
</ol>
<h2 id="5-2、v2方案"><a href="#5-2、v2方案" class="headerlink" title="5.2、v2方案"></a>5.2、v2方案</h2><p>对于v2签名，Android系统只会关注ID为<strong>0x7109871a</strong>的v2签名块，并且忽略其他的ID-Value，同时v2签名只会保护APK本身，不包含签名块。所以可以将渠道写入到ID-Value键值对区。写入过程如下：</p>
<ol>
<li>从apk文件结尾，通过ID <strong>0x06054B50定</strong>位到<strong>EOCD</strong></li>
<li>通过EOCD找到<strong>中央目录结尾起始偏移</strong></li>
<li>定位APKSigning Block，</li>
<li>定位v2block</li>
<li>获取已有的ID-Value Pair</li>
<li><strong>添加包含渠道信息的ID-Value</strong></li>
<li>基于所有的ID-Value生成新的签名</li>
<li>修改EOCD的中央目录的偏移量(修改EOCD的中央目录偏移量，不会导致数据摘要校验失败）</li>
</ol>
<p>读取过程和写入过程基本相同，忽略。</p>
<h2 id="5-3、v3-方案"><a href="#5-3、v3-方案" class="headerlink" title="5.3、v3 方案"></a>5.3、v3 方案</h2><p>v3和v2的方案基本相同，但是v3签名<strong>限制了签名块大小是4096的倍数</strong>（<a target="_blank" rel="noopener" href="https://www.cnblogs.com/yrstudy/p/11884996.html">参考</a>）在不写入渠道时读取下APK Singing Block，其大小刚好是4096。若写入渠道后不满足该条件，如果不是的话，就会去生成一个ByteBuffer来填充签名块，其ID为0x42726577。所以写入渠道后，<strong>可以通过修改0x42726577的value的大小保证签名块长度是4096的倍数即可</strong>。源码：</p>
<p><a target="_blank" rel="noopener" href="https://android.googlesource.com/platform/tools/apksig/+/master/src/main/java/com/android/apksig/internal/apk/ApkSigningBlockUtils.java">generateApkSigningBlock</a></p>
<p><img src="/pics/image-20201222211918992.png" alt="image-20201222211918992"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/286d2b372334">https://www.jianshu.com/p/286d2b372334</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903473310334984">https://juejin.cn/post/6844903473310334984</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/108036144">https://zhuanlan.zhihu.com/p/108036144</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/709mXKfEzSuLrd0WCqrmbghttps://github.com/Meituan-Dianping/walle">https://mp.weixin.qq.com/s/709mXKfEzSuLrd0WCqrmbghttps://github.com/Meituan-Dianping/walle</a>)</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yrstudy/p/11884996.html">https://www.cnblogs.com/yrstudy/p/11884996.html</a></p>
<p><a target="_blank" rel="noopener" href="https://source.android.google.cn/security/apksigning/v2?hl=zh-cn">https://source.android.google.cn/security/apksigning/v2?hl=zh-cn</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/27/Notes/Android/Framework/FrameWork_00_Handler%20%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/27/Notes/Android/Framework/FrameWork_00_Handler%20%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6md/" class="post-title-link" itemprop="url">Android Handler消息机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-27 23:52:26" itemprop="dateCreated datePublished" datetime="2021-02-27T23:52:26+08:00">2021-02-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Android-Handler消息机制"><a href="#Android-Handler消息机制" class="headerlink" title="Android Handler消息机制"></a>Android Handler消息机制</h1><p>Handler是Android中一种线程间传递消息的机制。主要应用的场景，将子线程中待更新的UI信息传递到主线程。本文将从以下几个方面介绍Handler：</p>
<ol>
<li>Handler的消息发送和分发过程</li>
<li>Looper，Message 以及和Handler的关系</li>
<li>Message组成和类型以及复用机制</li>
<li>IdleHandler等一些不常见的知识</li>
</ol>
<p>下面正式开始，故事从sendMessage开始讲起。</p>
<h1 id="一、消息分发过程"><a href="#一、消息分发过程" class="headerlink" title="一、消息分发过程"></a>一、消息分发过程</h1><h2 id="1-1、从sendMessage开始"><a href="#1-1、从sendMessage开始" class="headerlink" title="1.1、从sendMessage开始"></a>1.1、从sendMessage开始</h2><p>Handler常见的用法如下，主线程中创建Handler，子线程中使用sendMessage发送消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Handler mHandler;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        mHandler = <span class="keyword">new</span> Handler()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//收到消息后，更新 ui</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//发送消息</span></span><br><span class="line">                    mHandler.sendMessage();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了上面这种写法外，常见的写法还有post这种：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mHandler = <span class="keyword">new</span> Handler();</span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//ui操作</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;); </span><br><span class="line">       &#125;</span><br><span class="line">   &#125;).start();</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>以上2种方式最终都是殊途同归，最终调用的都是Handler的<strong>sendMessageAtTime</strong>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    MessageQueue queue = mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="keyword">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">        Log.w(<span class="string">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不同地方在于post 将Runnable赋值给msg.callback，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    Message m = Message.obtain();</span><br><span class="line">    m.callback = r;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后在dispatchMessage处理消息时，post方式msg.callback不为空，会执行handleCalback，最终回调Runnable的run方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// post的执行</span></span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleCalback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// sendMessage的执行</span></span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    message.callback.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>细心的读者可能会问mCallback又是什么呢？其实mCallback就是你在new Handler时可以传的一个参数，如果你像下面这样在Handler.Callback中返回true，就可以拦截消息不让消息在Handler的handler的handleMessage中处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Handler handler1 = <span class="keyword">new</span> Handler(<span class="keyword">new</span> Handler.Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="1-2、发送消息"><a href="#1-2、发送消息" class="headerlink" title="1.2、发送消息"></a>1.2、发送消息</h2><p>sendMessageAtTime后发生了什么？继续分析sendMessageAtTime方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    MessageQueue queue = mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="keyword">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">        Log.w(<span class="string">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(<span class="meta">@NonNull</span> MessageQueue queue, <span class="meta">@NonNull</span> Message msg,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将Handler赋值给msg.target,消息分发的时候会用到</span></span><br><span class="line">        msg.target = <span class="keyword">this</span>;</span><br><span class="line">        msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>经过一系列的调用sendMessageAtTime最终调用到了MessagQueue.enqueueMessage。</p>
<p>enqueueMessage将所有收到的消息按发送时间进行排序，加入到MessageQueue（消息队列）中，MessageQueue更多的细节后面再讲。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Message must have a target.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">&quot; This message is already in use.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">            IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    msg.target + <span class="string">&quot; sending message to a Handler on a dead thread&quot;</span>);</span><br><span class="line">            Log.w(TAG, e.getMessage(), e);</span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        <span class="comment">//1、拿到队列头部消息</span></span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="comment">//2、如果消息不需要延时，或者消息的执行时间比头部消息早，插到队列头部</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span></span><br><span class="line">            <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">            <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="comment">// 3、根据时间，将消息插到队列中合适的位置</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="comment">// 4、唤醒机制</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>22 - 24行：对收到的消息按发送时间进行排序，如果当前消息不需要延时，放到头部；若是延时消息，则根据发送时间放到队列合适位置。</p>
<p><strong>总结一下：sendMessage就是讲消息加到MessageQueue的队列中。</strong></p>
<p>至此，消息的发送过程全部结束了，什么！那消息是怎么分发的呢？我们先给出答案，是通过Looper.loop。</p>
<h2 id="1-3、消息分发"><a href="#1-3、消息分发" class="headerlink" title="1.3、消息分发"></a>1.3、消息分发</h2><p>刚才说了Handler的消息分发是通过Looper.loop，接下来看下代码，上车！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">     <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 1、从Looper中消息队列</span></span><br><span class="line">     <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">         <span class="comment">// 2、从消息队列中取出消息</span></span><br><span class="line">         Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">         <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"><span class="comment">// 省略 ...</span></span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">// 3、调用handler.dispatchMessage</span></span><br><span class="line">             msg.target.dispatchMessage(msg);</span><br><span class="line">             end = (slowDispatchThresholdMs == <span class="number">0</span>) ? <span class="number">0</span> : SystemClock.uptimeMillis();</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                 Trace.traceEnd(traceTag);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     </span><br><span class="line"><span class="comment">//省略 ...</span></span><br><span class="line">         msg.recycleUnchecked();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>主要步骤如下：</p>
<p>6行：从Looper中取出消息队列</p>
<p>9行：开启死循环，然后不断地调用的MessageQueue的next()方法，这个next()方法就是消息队列的出队方法。如果当前MessageQueue中存在待处理的消息，就将这个消息出队，否则就进入一个阻塞状态，一直等到有新的消息入队。</p>
<p>19行：消息分发msg.target的dispatchMessage()方法中，那这里msg.target又是什么呢？其实就是handler，回头看下enqueueMessage。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Handle system messages here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>28行：消息回收过程，这里涉及到Message的回收和复用，后面再讲。</p>
<p><strong>总结一下：Handler通过sendMessage将消息加入到消息队列中，最后在通过Looper.loop从消息队列中逐个取出消息执行。</strong>整体原理如下图所示：</p>
<p><img src="../../pics/image-20210226151751578.png" alt="image-20210226151751578"></p>
<p>好了，Handler的消息分发机制就介绍完了。如果只是想简单了解下Handler机制，到这里就可以了。</p>
<p>就这？当然不！上述介绍过程中涉及到几个概念Looper，MessageQueue，还没详细说呢？我们先来看下Looper。</p>
<h1 id="二、Looper"><a href="#二、Looper" class="headerlink" title="二、Looper"></a>二、Looper</h1><p>通过以上的介绍我们知道Looper是handler中消息分发的核心，那它是怎么来的？我们先来看下Handler的构造函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="meta">@Nullable</span> Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// loop赋值</span></span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()</span><br><span class="line">                    + <span class="string">&quot; that has not called Looper.prepare()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Looper的赋值是通过looper.myLooper()，最终调到了sThreadLocal.get()。这个sThreadLocal又是什么？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sThreadLocal.get() will return null unless you&#x27;ve called prepare().</span></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br></pre></td></tr></table></figure>

<p>这个sThreadLocal是一个ThreadLocal对象，存的是Looper对象。什么？ThreadLocal也不懂？来来来，先记住个概念，后面再解释：ThreadLocal提供了线程的局部变量，每个线程都可以通过set()和get()来对这个局部变量进行操作，但不会和其他线程的局部变量进行冲突，实现了线程的数据隔离。也就说通<strong>过ThreadLocal可以存取当前线程的Looper对象</strong>。</p>
<p>仔细看sThreadLocal的注释，除非您已调用prepare()，否则sThreadLocal.get()将返回null。那就看下loop.prepare吧。</p>
<h2 id="2-1、loop-prepare"><a href="#2-1、loop-prepare" class="headerlink" title="2.1、loop.prepare"></a>2.1、loop.prepare</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 每个线程只能初始化一次looper</span></span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 注意，这是messageQueue初始化的地方</span></span><br><span class="line">   mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">   mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>10行：新建一个Looper对象并存到sThreadLocal中。</p>
<p>14行：注意这里，handler中的MessageQuee就是Looper初始化时构造出来的。</p>
<p>也就是说，new Hanlder 之前必须要调用 Looper.prepare方法，那为何在主线程中使用是不需要呢？其实Android在程序启动的时候，通过ActivityThread帮我们创建主线程时已经初始化好了，代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line">    <span class="comment">// 1、 主线程Looper.parpare!</span></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">    thread.attach(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">        Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                LogPrinter(Log.DEBUG, <span class="string">&quot;ActivityThread&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2、看这里looper.loop</span></span><br><span class="line">    Looper.loop();</span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3行：调用了 Looper.prepareMainLooper()，再调用到Looper的prepare。</p>
<p>14行：<strong>Looper.looper，开启循环，不停取出消息。主线程中其实先开启循环不停取消息，再才是发送消息。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the current thread as a looper, marking it as an</span></span><br><span class="line"><span class="comment"> * application&#x27;s main looper. See also: &#123;<span class="doctag">@link</span> #prepare()&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@deprecated</span> The main looper for your application is created by the Android environment,</span></span><br><span class="line"><span class="comment"> *   so you should never need to call this function yourself.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The main Looper has already been prepared.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意prepareMainLooper的注释，prepare只能调用一次，ActivityThread中已经调用过了，再调用到这里会报异常（12行）。到这里我们已经搞明白主线程中的looper是怎么来的。刚才遗留了一个问题ThreadLocal是怎么存取Loope，下面就来介绍下ThreadLocal。</p>
<h2 id="2-2、ThreadLocal"><a href="#2-2、ThreadLocal" class="headerlink" title="2.2、ThreadLocal"></a>2.2、ThreadLocal</h2><p>先来看下ThreadLocal的set过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1、获取当前线程</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">// 2、获取当前线程的ThreadMap对象</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 2.1、map不为空存value到map中</span></span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 2.2、map为空则创建map并value存进去</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">                              </span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ThreadLocalMap存储的值是弱引用</span></span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要步骤有2点：</p>
<ol>
<li>获取当前线程的ThreadMap对象 , ThreadMap其实是Thread的一个成员变量，但是是通过ThreadLocal来维护的。Thread.threadLocals为空时先创建。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/* ThreadLocal values pertaining to this thread. This map is maintained</span><br><span class="line"> * by the ThreadLocal class. */</span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = null;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>将value值存到ThreadMap中，key是当前threadLocal对象，也就是说一个Thread可以存多个不同ThreadLocal的值，一个ThreadLocal只能存一个值。</li>
</ol>
<p>我们再理解下Looper.myLooper对应的get过程，先获取线程的threadLocals（ThreadMap对象），再通过get（key是当前ThreadLocal对象）获取到looper。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                T result = (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结一下：Looper通过prepare会初始化一个Looper对象，通过ThreadLocal将Thread和Looper对象绑定在一起。Looper.loop会从MessageQueue中不断取出消息，进行分发。</strong></p>
<h1 id="三、MessageQueue"><a href="#三、MessageQueue" class="headerlink" title="三、MessageQueue"></a>三、MessageQueue</h1><p>MessagQueue，顾名思义，消息队列，在Looper的介绍中，我们提到了MessageQueue其实是在Looper构造创建生成的，Handler中的mQueue其实就是Looper.mQueue，Looper和MessageQueue是一一对应的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="meta">@Nullable</span> Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()</span><br><span class="line">                    + <span class="string">&quot; that has not called Looper.prepare()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 看这里</span></span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在前面章节我们讲了sengMessage最终会调用到MessageQueue.enqueueMessage，下面具体分析enqueueMessage的代码。</p>
<h2 id="3-1、消息入队"><a href="#3-1、消息入队" class="headerlink" title="3.1、消息入队"></a>3.1、消息入队</h2><p>关于enqueueMessage消息入队逻辑在1.2节已经介绍过了；除此之外，消息加入队列时，两种情况会唤醒looper.loop，为什么要唤醒，后面再说：</p>
<ol>
<li>（队列为空，消息无需延时或消息执行时间比队列头部消息早) &amp;&amp; (线程处于挂起状态时（mBlocked = true）)</li>
<li>【线程挂起（mBlocked = true）&amp;&amp; 消息循环处于同步屏障状态】，这时如果插入的是一个异步消息，则需要唤醒。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">          <span class="keyword">boolean</span> needWake;</span><br><span class="line">         <span class="comment">//1、队列为空，消息无需延时或消息执行时间比队列头部消息早) &amp;&amp; (线程处于挂起状态时（mBlocked = true）)</span></span><br><span class="line">          <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">              <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">              msg.next = p;</span><br><span class="line">              mMessages = msg;</span><br><span class="line">              needWake = mBlocked;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span></span><br><span class="line">              <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">              <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">              <span class="comment">// 2、线程挂起（mBlocked = true）&amp;&amp; 消息循环处于同步屏障状态】，这时如果插入的是一个异步消息，则需要唤醒。</span></span><br><span class="line">              needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">              Message prev;</span><br><span class="line">              <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                  prev = p;</span><br><span class="line">                  p = p.next;</span><br><span class="line">                  <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                      needWake = <span class="keyword">false</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">              prev.next = msg;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">          <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">              nativeWake(mPtr);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2、消息出队"><a href="#3-2、消息出队" class="headerlink" title="3.2、消息出队"></a>3.2、消息出队</h2><p>在1.3节我们介绍过Looper.Looper负责消息出队，其实是通过Queue.next()取队列中的消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">    <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">    <span class="comment">// which is not supported.</span></span><br><span class="line">    <span class="comment">// 1、通过Looper.quit调用到Message.quit后会执行到这里</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2、nextPollTimeoutMillis = -1 阻塞</span></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">            Message msg = mMessages;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 3、屏障消息</span></span><br><span class="line">                <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// 4、时间没到，设定下次唤醒的时间</span></span><br><span class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Got a message.</span></span><br><span class="line">                    mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">           <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">           <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">          	<span class="comment">// 第一次执行时，确定IdleHandler的数目</span></span><br><span class="line">           <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                   &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">               pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">               mBlocked = <span class="keyword">true</span>;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">               mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">           &#125;</span><br><span class="line">           mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run the idle handlers.</span></span><br><span class="line">        <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">        <span class="comment">// 遍历执行idleHandler</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="comment">// 非keep的执行完后移除掉</span></span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">        <span class="comment">// idleHandler</span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line">        <span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要的步骤：</p>
<ol>
<li><p>判断MessageQueue是不是退出了，如果退出，整个Looper.loop都退出，通常是通过调用Looper.quit退出。</p>
</li>
<li><p>nativePollOnce，我们知道Looper.looper是一个死循环，如果没有消息，还会继续执行吗？显然不可能，在消息队列为空的时候，Looper实际上处于休眠状态，当nextPollTimeoutMillis =-1 时阻塞，CPU进入休眠；对于deleyMessage，nextPollTimeoutMillis&gt;0，时间到了后唤醒。Message Queue共有2种情况唤醒：1.加入消息新消息时唤醒（上一节介绍过） ；2.delayMsg时间到了唤醒。</p>
<p>那么是怎么实现的呢？这里涉及到linux的epoll机制，handler这里就不展开讲了，参考（<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/H8mHoYHyTe6oOaUwfYh6_g%EF%BC%89%E3%80%82">https://mp.weixin.qq.com/s/H8mHoYHyTe6oOaUwfYh6_g）。</a></p>
</li>
<li><p>屏障消息和idleHandler相关，后面介绍。</p>
</li>
</ol>
<p><strong>总结一下：MessageQueue负责消息的存取，Looper的looper并不会一直执行，当nativePollOnce的参数nextPollTimeoutMillis=-1时会休眠，唤醒有2种方式一种是队列有新消息入队时；另一种是delayMsg时刻到了。</strong></p>
<h1 id="四、Message"><a href="#四、Message" class="headerlink" title="四、Message"></a>四、Message</h1><p>先看下Message的数据结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> what;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> arg1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> arg2;</span><br><span class="line">    <span class="keyword">public</span> Object obj;</span><br><span class="line">    <span class="keyword">public</span> Messenger replyTo; <span class="comment">// Messager对象</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">long</span> when; <span class="comment">//消息发送时间</span></span><br><span class="line">    <span class="comment">/*package*/</span> <span class="keyword">int</span> flags; <span class="comment">// 标记消息消息类型是否是异步</span></span><br><span class="line">    <span class="comment">/*package*/</span> Handler target; <span class="comment">//指向接收消息的handler</span></span><br><span class="line">    <span class="comment">/*package*/</span> Message next; <span class="comment">//指向下一个消息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Message sPool; <span class="comment">// Message内部复用队列的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Message对象都有一个同类型的next字段，这个next字段指向的就是下一个可用的Message，最后Message的next为空，组成Message链表，sPool 永远指向的是整个链表的第一个元素。</p>
<h2 id="4-1、Message的复用机制"><a href="#4-1、Message的复用机制" class="headerlink" title="4.1、Message的复用机制"></a>4.1、Message的复用机制</h2><p>通常我们获取一个Message都是通过Message的obtain方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// sometimes we store linked lists of these things</span></span><br><span class="line">    <span class="comment">/*package*/</span> Message next;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object sPoolSync = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Message sPool;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sPoolSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * Return a new Message instance from the global pool. Allows us to</span></span><br><span class="line"><span class="comment">      * avoid allocating new objects in many cases.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Message m = sPool;</span><br><span class="line">                sPool = m.next;</span><br><span class="line">                m.next = <span class="keyword">null</span>;</span><br><span class="line">                m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">                sPoolSize--;</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Message();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>17 - 18行，当使用obtain方法获取一个Message对象时，其实获取的就是链表中的第一个元素，同时将sPool在指向下一个Message。</p>
<p>那么这些Message对象是在什么时候被放到链表中的呢，在Message类的说明中有这样一句话：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">While the constructor of Message is public, the best way to getone of these is to call &#123;@link #obtain Message.obtain()&#125; or one of the methods, which will pull them from a pool of recycled objects。</span><br></pre></td></tr></table></figure>

<p>原来在创建Message时不会将Message放入队列而是在recycle时才会加入到队列，让我们先来看下recylce方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isInUse()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (gCheckRecycle) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;This message cannot be recycled because it &quot;</span></span><br><span class="line">                    + <span class="string">&quot;is still in use.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    recycleUnchecked();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recycles a Message that may be in-use.</span></span><br><span class="line"><span class="comment"> * Used internally by the MessageQueue and Looper when disposing of queued Messages.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Mark the message as in use while it remains in the recycled object pool.</span></span><br><span class="line">    <span class="comment">// Clear out all other details.</span></span><br><span class="line">    flags = FLAG_IN_USE;</span><br><span class="line">    what = <span class="number">0</span>;</span><br><span class="line">    arg1 = <span class="number">0</span>;</span><br><span class="line">    arg2 = <span class="number">0</span>;</span><br><span class="line">    obj = <span class="keyword">null</span>;</span><br><span class="line">    replyTo = <span class="keyword">null</span>;</span><br><span class="line">    sendingUid = -<span class="number">1</span>;</span><br><span class="line">    when = <span class="number">0</span>;</span><br><span class="line">    target = <span class="keyword">null</span>;</span><br><span class="line">    callback = <span class="keyword">null</span>;</span><br><span class="line">    data = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">            next = sPool;</span><br><span class="line">            sPool = <span class="keyword">this</span>;</span><br><span class="line">            sPoolSize++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>12- 8行：判断Message是否在被使用中，如果没有，则执行回收操作。</p>
<p>19-35行：回收先清空Message的各字段，并将flag置为FLAG_IN_USE，这个flag在obtain时会被置为0。然后继续判断是否要将该消息放17到回收池中，如果池的大小小于MAX_POOL_SIZE（50），那么就进行链表操作，将这个Message放到链表的表头。</p>
<p>总结一下：Message 通过在内部构建一个链表维护一个被回收的Message对象的对象池，当用户调用obtain函数时优先从池中获取，如果池中没有可以复用的对象则创建一个新的Message对象。这些新创建的Message对象再被使用完之后会被回收到这个对象池中，当下次再调用obtain函数时，他们就会被复用。<br>结合的Looper.loop方法，在使用完一个Message对象后就将会将它回收，避免系统中创建太多Message对象。</p>
<h2 id="4-2、同步消息、屏障消息和异步消息"><a href="#4-2、同步消息、屏障消息和异步消息" class="headerlink" title="4.2、同步消息、屏障消息和异步消息"></a>4.2、同步消息、屏障消息和异步消息</h2><p>在Handler构造函数，如果看到的足够仔细的话</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="meta">@Nullable</span> Callback callback, <span class="keyword">boolean</span> async)</span> </span></span><br></pre></td></tr></table></figure>

<p>我们会发现构造参数里有个async，异步？这个参数代表什么意思？</p>
<p>其实在MessageQueue中消息有三种类型：同步消息，异步消息以及屏障消息。</p>
<h3 id="4-1-1、同步消息"><a href="#4-1-1、同步消息" class="headerlink" title="4.1.1、同步消息"></a>4.1.1、同步消息</h3><p>默认的消息类型，同步消息在MessageQueue里的存和取完全就是按照时间（msg.when）排序的。</p>
<h3 id="4-1-2、异步消息"><a href="#4-1-2、异步消息" class="headerlink" title="4.1.2、异步消息"></a>4.1.2、异步消息</h3><p>异步消息有2种构造方式：</p>
<ol>
<li>handler构造参数指定 async =true</li>
<li>Message构造时，指定setAsynchronous（true）</li>
</ol>
<p>在sendMessage中，我们可以看到这2者的关系</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(<span class="meta">@NonNull</span> MessageQueue queue, <span class="meta">@NonNull</span> Message msg,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    msg.target = <span class="keyword">this</span>;</span><br><span class="line">    msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line">	<span class="comment">// mAsynchronous 就是构造参数中的 async </span></span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若Handler的构造参数中的async设置为true，该Handler所有的消息都会被设置为异步消息。</p>
<h3 id="4-1-3、屏障消息"><a href="#4-1-3、屏障消息" class="headerlink" title="4.1.3、屏障消息"></a>4.1.3、屏障消息</h3><p>屏障(Barrier) 是一种特殊的Message，它最大的特征就是target为null(只有屏障的target可以为null，如果我们自己设置Message的target为null的话会报异常)，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Message must have a target.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且arg1属性被用作屏障的标识符来区别不同的屏障。屏障的作用是用于拦截队列中同步消息，放行异步消息。</p>
<p>那么屏障消息是怎么被添加和删除的呢？ 我们可以看到在MessageQueue里有添加和删除屏障消息的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">(<span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Enqueue a new sync barrier token.</span></span><br><span class="line">    <span class="comment">// We don&#x27;t need to wake the queue because the purpose of a barrier is to stall it.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> token = mNextBarrierToken++;</span><br><span class="line">        <span class="keyword">final</span> Message msg = Message.obtain();</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        msg.arg1 = token;</span><br><span class="line"></span><br><span class="line">        Message prev = <span class="keyword">null</span>;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">         <span class="comment">// 根据时间找到第一个比屏障消息晚的消息，将屏障消息插入到该消息之前；</span></span><br><span class="line">         <span class="comment">// 屏障只会影响到队列中它之后的消息</span></span><br><span class="line">        <span class="keyword">if</span> (when != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.when &lt;= when) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果prev是null,屏障消息插入到消息队列的头部</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeSyncBarrier</span><span class="params">(<span class="keyword">int</span> token)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Remove a sync barrier token from the queue.</span></span><br><span class="line">        <span class="comment">// If the queue is no longer stalled by a barrier then wake it.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            Message prev = <span class="keyword">null</span>;</span><br><span class="line">            Message p = mMessages;</span><br><span class="line">        <span class="comment">// 前面在插入屏障消息后会生成一个token，这个token就是用来删除该屏障消息用的。</span></span><br><span class="line">        <span class="comment">// 所以这里通过判断target和token来找到该屏障消息，从而进行删除操作</span></span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; (p.target != <span class="keyword">null</span> || p.arg1 != token)) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The specified message queue synchronization &quot;</span></span><br><span class="line">                        + <span class="string">&quot; barrier token has not been posted or has already been removed.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> needWake;</span><br><span class="line">            <span class="comment">// 删除屏障消息，原理是链表的删除</span></span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                prev.next = p.next;</span><br><span class="line">                needWake = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mMessages = p.next;</span><br><span class="line">                needWake = mMessages == <span class="keyword">null</span> || mMessages.target != <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p.recycleUnchecked();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the loop is quitting then it is already awake.</span></span><br><span class="line">            <span class="comment">// We can assume mPtr != 0 when mQuitting is false.</span></span><br><span class="line">            <span class="comment">// 屏障消息删除后可再次之前的同步消息</span></span><br><span class="line">            <span class="keyword">if</span> (needWake &amp;&amp; !mQuitting) &#123;</span><br><span class="line">                nativeWake(mPtr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>介绍完屏障消息的插入和删除，那么屏障消息的作用是什么？和同步及异步消息有何关系呢？ 我们可以看到MessageQueue的next方法里有这么一段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前消息是屏障消息时（msg.target==null）, 如果存在屏障消息，那么在它之后进来的消息中，只放行异步消息</span></span><br><span class="line"><span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prevMsg = msg;</span><br><span class="line">        msg = msg.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入屏障消息后，只放行队列中的异步消息，在Android系统里面为了更快响应UI刷新在<strong>ViewRootImpl.scheduleTraversals</strong>也有应用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 1、为主线程的MessageQueue设置了个消息屏障</span></span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        <span class="comment">// 2、这里发送了个异步消息mTraversalRunnable，这个mTraversalRunnable最终会执行doTraversal(),也就是会触发View的绘制流程</span></span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line"> 		</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// postCallback 经过层层调用到这里Choreographer.postCallbackDelayedInternal</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postCallbackDelayedInternal</span><span class="params">(<span class="keyword">int</span> callbackType,</span></span></span><br><span class="line"><span class="params"><span class="function">        Object action, Object token, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">  		<span class="comment">// 省略...</span></span><br><span class="line">        <span class="keyword">if</span> (dueTime &lt;= now) &#123;</span><br><span class="line">            scheduleFrameLocked(now);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">            msg.arg1 = callbackType;</span><br><span class="line">            <span class="comment">// 设置为异步消息</span></span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">            mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>scheduleTraversals时通过设置屏障消息，会把主线程的同步消息先阻塞，优先执行View绘制这个异步消息进行界面绘制。让界面绘制的任务优先执行，避免出现界面卡顿。</p>
<p>另外App层如果发送同步屏障postSyncBarrier需要反射才能使用，Android不建议使用，主线程中滥用的话就是和界面绘制抢资源了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postSyncBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Method method = MessageQueue.class.getDeclaredMethod(<span class="string">&quot;postSyncBarrier&quot;</span>);</span><br><span class="line">  token = (<span class="keyword">int</span>) method.invoke(Looper.getMainLooper().getQueue());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeSyncBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Method method = MessageQueue.class.getDeclaredMethod(<span class="string">&quot;removeSyncBarrier&quot;</span>, <span class="keyword">int</span>.class);</span><br><span class="line">   method.invoke(Looper.getMainLooper().getQueue(), token);&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="五、IdleHandler"><a href="#五、IdleHandler" class="headerlink" title="五、IdleHandler"></a>五、IdleHandler</h1><p>IdleHandler，空闲的处理器（就是说我是在消息队列空闲的时候才会执行的，如果消息队列里有其他非IdleHandler消息在执行，则我先不执行），它其实就是一个接口，我们就认为它是空闲消息吧，只不过它不是存在MessageQueue里，而是以数组的形式保存的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Callback interface for discovering when a thread is going to block</span><br><span class="line"> * waiting for more messages.</span><br><span class="line"> */</span><br><span class="line">public static interface IdleHandler &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Called when the message queue has run out of messages and will now</span><br><span class="line">     * wait for more.  Return true to keep your idle handler active, false</span><br><span class="line">     * to have it removed.  This may be called if there are still messages</span><br><span class="line">     * pending in the queue, but they are all scheduled to be dispatched</span><br><span class="line">     * after the current time.</span><br><span class="line">     */</span><br><span class="line">    boolean queueIdle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MessageQueue有添加和删除IdleHandler的方法，IdleHandler被保存在一个ArrayList里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;IdleHandler&gt; mIdleHandlers = <span class="keyword">new</span> ArrayList&lt;IdleHandler&gt;();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addIdleHandler</span><span class="params">(<span class="meta">@NonNull</span> IdleHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;Can&#x27;t add a null IdleHandler&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        mIdleHandlers.add(handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeIdleHandler</span><span class="params">(<span class="meta">@NonNull</span> IdleHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        mIdleHandlers.remove(handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，它是怎么实现在消息队列空闲的间隙得到执行的呢？细心的同学应该注意到了，也是在MessageQueue.next()方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">    <span class="comment">// 1、这个参数很重要，控制</span></span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">          	<span class="comment">// 省略...</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">            <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">            <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">            <span class="comment">// 首次for循环 &amp;&amp; 消息队列处于空闲 当前消息队列没有消息或者要执行的消息晚于当前时间</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                <span class="comment">// 赋值</span></span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run the idle handlers.</span></span><br><span class="line">        <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果queueIdle返回true，则该空闲消息不会被自动删除，在下次执行next的时候，如果还出现队列空闲，会再次执行。</span></span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果返回false，则该空闲消息会在执行完后，被自动删除掉。</span></span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">        <span class="comment">// 这里把空闲消息标志置为0，而不置为-1，防止一直执行；一直到下一次调用 MessageQueue.next() 方法.</span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当执行了 IdleHander 之后, 会消耗一段时间, 这时候消息队列里可能已经有消息到达可执行时间, 所以重置 nextPollTimeoutMillis 回去重新检查消息队列.</span></span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下：IdleHandler是在MessageQueuer队列空闲时执行的且只会执行一次，但如果将queueIdle的返回值改为true，会在每一次MessageQueue.next方法执行时在执行一次，也就是说如果队列中有新的消息到达就会再次执行。</p>
<h1 id="六、常见问题"><a href="#六、常见问题" class="headerlink" title="六、常见问题"></a>六、常见问题</h1><h2 id="6-1、子线程中更新UI的方法"><a href="#6-1、子线程中更新UI的方法" class="headerlink" title="6.1、子线程中更新UI的方法"></a>6.1、子线程中更新UI的方法</h2><p>除了Handler的sendMessage和post之外，我们还有以下2种方法可以在子线程中进行UI操作，一句话解释完，请看注释！！！</p>
<h3 id="6-1-1、View的post-方法"><a href="#6-1-1、View的post-方法" class="headerlink" title="6.1.1、View的post()方法"></a>6.1.1、View的post()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Causes the Runnable to be added to the message queue.</span></span><br><span class="line"><span class="comment"> * The runnable will be run on the user interface thread.&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class="line">    <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> attachInfo.mHandler.post(action);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Postpone the runnable until we know on which thread it needs to run.</span></span><br><span class="line">    <span class="comment">// Assume that the runnable will be successfully placed after attach.</span></span><br><span class="line">    getRunQueue().post(action);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-1-2、Activity的runOnUiThread-方法"><a href="#6-1-2、Activity的runOnUiThread-方法" class="headerlink" title="6.1.2、Activity的runOnUiThread()方法"></a>6.1.2、Activity的runOnUiThread()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Runs the specified action on the UI thread. If the current thread is the UI</span></span><br><span class="line"><span class="comment">* thread, then the action is executed immediately. If the current thread is</span></span><br><span class="line"><span class="comment">* not the UI thread, the action is posted to the event queue of the UI thread.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> action the action to run on the UI thread</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runOnUiThread</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (Thread.currentThread() != mUiThread) &#123;</span><br><span class="line">           mHandler.post(action);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           action.run();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-2、主线程中Looper-Loop的不会卡死？"><a href="#6-2、主线程中Looper-Loop的不会卡死？" class="headerlink" title="6.2、主线程中Looper.Loop的不会卡死？"></a>6.2、主线程中Looper.Loop的不会卡死？</h2><p>1、Looper.Loop会调用到MessageQueue.next()方法，没有消息时会阻塞在nativePollOnce，此时主线程会释放CPU进入休眠状态，并不会消耗CPU资源。直到有下个消息到达，这里依赖的是Linux pipe/epoll机制。</p>
<p>2、ANR的原理，任务再特定时间内没有执行完。以Service ANR原理为例，首先startService之后，经过一系列的调用，最终会调用到AMS的startService相关方法，发送一个SERVICE_TIMEOUT_MSG的延时消息；紧接着再通过消息机制调用到ActivityThread.H.handleMessag中先执行Service的onCreate，再回到AMS找中，执行serviceDoneExecuting，移除SERVICE_TIMEOUT_MSG消息。也就是说如果onCreate执行时间过长导致SERVICE_TIMEOUT_MSG消息没有被及时移除，就会触发ANR。这里涉及到2个handler，一个ActivityThread，一个是AMS的，ActivityThread的Handler是和应用主线程绑定的；而AMS.MainHandler是SystemServer的ServerThread绑定的，用于处理service、process、provider的超时问题。另外input的超时处理过程并非发生在ActivityManager线程，而是inputDispatcher线程发生的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>Looper 作为消息循环的核心，其内部包含了一个消息队列 MessageQueue ，用于记录所有待处理的消息；Handler通过sendMessage添加消息，通过Looper.loop()不断地从MessageQueue中抽取Message，按分发机制将消息分发给目标处理者，可以看成是消息泵。注意，线程切换就是在这一步完成的。</li>
<li>MessageQueue 则作为一个消息队列，则包含了一系列链接在一起的 Message ；不要被这个Queue的名字给迷惑了，就以为它是一个队列，但其实内部通过单链表的数据结构来维护消息列表，等待Looper的抽取。</li>
<li>Message 则是消息体，内部又包含了一个目标处理器 target ，这个 target 正是最终处理它的 Handler。</li>
<li><strong>Looper和Thread以及MessageQueue是一一对应的</strong>，<strong>而一个Handler只能关联一个Looper，一个Looper可以关联多个Handler</strong>, Handler的messagequeue就是Looper的messagequeue。  </li>
</ul>
<p><strong>参考资料：</strong><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/guolin_blog/article/details/9991569">http://blog.csdn.net/guolin_blog/article/details/9991569</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904068129751047">https://juejin.cn/post/6844904068129751047</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/H8mHoYHyTe6oOaUwfYh6_g">https://mp.weixin.qq.com/s/H8mHoYHyTe6oOaUwfYh6_g</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/71OV_K7YJas7pLtsPY-jeQ">https://mp.weixin.qq.com/s/71OV_K7YJas7pLtsPY-jeQ</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/26/Notes/Android/Framework/Android%20Service%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/26/Notes/Android/Framework/Android%20Service%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-26 18:49:09" itemprop="dateCreated datePublished" datetime="2021-02-26T18:49:09+08:00">2021-02-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p> 一、 startService 和 bindService的区别<br>    <img src="https://leanote.com/api/file/getImage?fileId=59341fcbab64415b02001748"></p>
<ul>
<li>执行startService时，Service会经历onCreate-&gt;onStartCommand。当执行stopService时，直接调用onDestroy方法。调用者如果没有stopService，Service会一直在后台运行，下次调用者再起来仍然可以stopService。</li>
<li>执行bindService时，Service会经历onCreate-&gt;onBind。这个时候调用者和Service绑定在一起。调用者调用unbindService方法或者调用者Context不存在了（如Activity被finish了），Service就会调用onUnbind-&gt;onDestroy。这里所谓的绑定在一起就是说两者共存亡了。</li>
<li>多次调用startService，该Service只能被创建一次，即该Service的onCreate方法只会被调用一次。但是每次调用startService，onStartCommand方法都会被调用。Service的onStart方法在API5时被废弃，替代它的是onStartCommand方法。</li>
<li>第一次执行bindService时，onCreate和onBind方法会被调用，但是多次执行bindService时，onCreate和onBind方法并不会被多次调用，即并不会多次创建服务和绑定服务。</li>
</ul>
<p>二、startService的过程<br><a target="_blank" rel="noopener" href="http://0.0.0.1/">http://www.jianshu.com/p/c0aadd5bf7a5</a><br><a target="_blank" rel="noopener" href="http://0.0.0.2/">http://wujingchao.com/2016/02/10/art-of-android-development-notes-startservice/</a></p>
<p>1.frameworks/base/core/java/android/content/ContextWrapper.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ComponentName <span class="title">startService</span><span class="params">(Intent service)</span> </span>&#123;</span><br><span class="line">        warnIfCallingFromSystemProcess();</span><br><span class="line">        <span class="keyword">return</span> startServiceCommon(service, mUser);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> ComponentName <span class="title">startServiceCommon</span><span class="params">(Intent service, UserHandle user)</span> </span>&#123;</span><br><span class="line">    ComponentName cn = ActivityManagerNative.getDefault().startService(</span><br><span class="line">        mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(</span><br><span class="line">                    getContentResolver()), getOpPackageName(), user.getIdentifier());    </span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.通过ActivityManagerNative.getDefault().startService的ActivityManagerNative-&gt;ActivityManagerService-&gt;ActiveServices.startServiceLocked</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ComponentName <span class="title">startServiceLocked</span><span class="params">(IApplicationThread caller, Intent service, String resolvedType,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid, String callingPackage, <span class="keyword">int</span> userId)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">…</span><br><span class="line"><span class="comment">//PackageManagerService解析出Intent得到要启动的ServiceRecord</span></span><br><span class="line">ServiceLookupResult res =</span><br><span class="line">retrieveServiceLocked(service, resolvedType, callingPackage,</span><br><span class="line">callingPid, callingUid, userId, <span class="keyword">true</span>, callerFg);</span><br><span class="line">    ServiceRecord r = res.record;            </span><br><span class="line">... </span><br><span class="line"><span class="keyword">return</span> startServiceInnerLocked(smap, service, r, callerFg, addToStarting);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ComponentName <span class="title">startServiceInnerLocked</span><span class="params">(ServiceMap smap, Intent service, ServiceRecord r,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">boolean</span> callerFg, <span class="keyword">boolean</span> addToStarting)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">…</span><br><span class="line">String error = bringUpServiceLocked(r, service.getFlags(), callerFg, <span class="keyword">false</span>);</span><br><span class="line">…</span><br><span class="line"><span class="keyword">return</span> r.name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> String <span class="title">bringUpServiceLocked</span><span class="params">(ServiceRecord r,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">int</span> intentFlags, <span class="keyword">boolean</span> execInFg, <span class="keyword">boolean</span> whileRestarting)</span> </span>&#123;</span><br><span class="line"><span class="comment">//如果进程已经存在的情况下就不是处理下面的流程，直接处理onStart的流程</span></span><br><span class="line"><span class="keyword">if</span> (r.app != <span class="keyword">null</span> &amp;&amp; r.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">sendServiceArgsLocked(r, execInFg, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处于restart的状态(在onStartCommand里面处理了服务被杀之后的行为)也不会处理</span></span><br><span class="line"><span class="keyword">if</span> (!whileRestarting &amp;&amp; r.restartDelay &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mRestartingServices.remove(r)) &#123;</span><br><span class="line">clearRestartingIfNeededLocked(r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (r.delayed) &#123;</span><br><span class="line">getServiceMap(r.userId).mDelayedStartList.remove(r);</span><br><span class="line">r.delayed = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//…</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> isolated = (r.serviceInfo.flags&amp;ServiceInfo.FLAG_ISOLATED_PROCESS) != <span class="number">0</span>;</span><br><span class="line"><span class="keyword">final</span> String procName = r.processName;</span><br><span class="line">ProcessRecord app;</span><br><span class="line"><span class="comment">//独立的进程运行isolated为true,</span></span><br><span class="line"><span class="keyword">if</span> (!isolated) &#123;</span><br><span class="line">app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">app.addPackage(r.appInfo.packageName, r.appInfo.versionCode, mAm.mProcessStats);</span><br><span class="line"><span class="comment">//直接启动服务，不用开启新的进程</span></span><br><span class="line">realStartServiceLocked(r, app, execInFg);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">Slog.w(TAG, “Exception when starting service ” + r.shortName, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">app = r.isolatedProc;</span><br><span class="line">&#125;</span><br><span class="line">第一次创建时，走到这里，先创建一个service的进程</span><br><span class="line"><span class="keyword">if</span> (app == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//开启新的进程 </span></span><br><span class="line">    <span class="keyword">if</span> ((app=mAm.startProcessLocked(procName, r.appInfo, <span class="keyword">true</span>, intentFlags,</span><br><span class="line">            <span class="string">&quot;service&quot;</span>, r.name, <span class="keyword">false</span>, isolated, <span class="keyword">false</span>))== <span class="keyword">null</span>) &#123;</span><br><span class="line">        bringDownServiceLocked(r);</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isolated) &#123;</span><br><span class="line">        r.isolatedProc = app;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将ServiceRecord加入即将启动mPendingServices列表里，后面进程启动成功后在启动Service</span></span><br><span class="line"><span class="keyword">if</span> (!mPendingServices.contains(r)) &#123;</span><br><span class="line">    mPendingServices.add(r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果进程已经存在的情况下就不是处理下面的流程，直接调用realStartServiceLocked处理onStart的流程。ActivityManagerService.startProcessLocked开启进程，procName为AndroidManifest中Service标签了process指定的进程名，默认是包名。</p>
<pre><code>final ProcessRecord startProcessLocked(String processName, ApplicationInfo info,
boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName,
boolean allowWhileBooting, boolean isolated, int isolatedUid, boolean keepIfLarge,
String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler) &#123;
    ProcessRecord app;
    if (!isolated) &#123;
    app = getProcessRecordLocked(processName, info.uid, keepIfLarge);
    &#125; else &#123;
        // If this is an isolated process, it can&#39;t re-use an existing process.
        app = null;
    &#125;
    //...
    String hostingNameStr = hostingName != null
            ? hostingName.flattenToShortString() : null;
   //...
   if (app == null) &#123;
        //构建一个新的的ProcessRecord
        app = newProcessRecordLocked(info, processName, isolated, isolatedUid);
        app.crashHandler = crashHandler;
        mProcessNames.put(processName, app.uid, app);
        if (isolated) &#123;
            mIsolatedProcesses.put(app.uid, app);
        &#125;
    &#125; 
    //...
    startProcessLocked(
            app, hostingType, hostingNameStr, abiOverride, entryPoint, entryPointArgs);
    return (app.pid != 0) ? app : null;
&#125;
</code></pre>
<p>构建新的ProcessRecord，startProcessLocked开启进程:</p>
<pre><code>private final void startProcessLocked(ProcessRecord app, String hostingType,
        String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) &#123;
    //...
    try &#123;
        int uid = app.uid;
        int[] gids = null;
        int mountExternal = Zygote.MOUNT_EXTERNAL_NONE;
        if (!app.isolated) &#123;
            //...
        &#125;
        int debugFlags = 0;
        //...
        boolean isActivityProcess = (entryPoint == null);
        if (entryPoint == null) entryPoint = &quot;android.app.ActivityThread&quot;;
        Process.ProcessStartResult startResult = Process.start(entryPoint,
                app.processName, uid, uid, gids, debugFlags, mountExternal,
                app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,
                app.info.dataDir, entryPointArgs);
        //...
&#125;
</code></pre>
<p>调用Process.start开启一个新的进程，新进程的入口点就是android.app.ActivityThread，执行里面的main方法。</p>
<pre><code> public final class ActivityThread &#123;
    final ApplicationThread mAppThread = new ApplicationThread();
    public static void main(String[] args) &#123;
        //...
        Looper.prepareMainLooper();
        ActivityThread thread = new ActivityThread();
        thread.attach(false);
        if (sMainThreadHandler == null) &#123;
            sMainThreadHandler = thread.getHandler();
        &#125;
        Looper.loop();
        throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);
    &#125;
     private void attach(boolean system) &#123;
        //...
        if (!system) &#123;
            //...
            final IActivityManager mgr = ActivityManagerNative.getDefault();
            try &#123;
                mgr.attachApplication(mAppThread);
            &#125; catch (RemoteException ex) &#123;
                // Ignore
            &#125;
            //...
        &#125; 
    &#125;
&#125;
</code></pre>
<p>准备主线程的Looper，调用attachApplication通知ActiviyManangerService主线程准备完毕，然后loop开始消息循环。<br>ApplicationThread通过IPC向ActivityManagerService调用attachApplication，并传递mAppThread给ActivityManagerService，mAppThread是一个Binder对象，用于ActivityManagerService向我们发起调用。注意从这里开始已经是在新进程里面执行了。<br>ApplicationThread对象继承自ApplicationThreadNative.java，在ActivityThread对象被创建时，它也被构造了，我前面已经提到过了，它继承了ApplicationThreadNative类，熟悉进程通信代理机制的朋友就清楚了，ApplicationThread就是一个通信代理存根实现类，我们可以看它的实现方法，都是调用queueOrSendMessage方法，派发消息交给ActivityThread的mH去处理，那么我们很清楚了，ActivityThread代理存根对象，它负责执行来自远程的调用，这些远程的调用大部分来自system_process，所以，system_process很容易通过ApplicationThread的客户端代理对象控制ActivityThread，事实就是如此，后面我们可以很好地看到这一点</p>
<pre><code>    base/core/java/android/app/ActivityManagerNative.java
    
    class ActivityManagerProxy implements IActivityManager&#123;
    public void attachApplication(IApplicationThread app) throws RemoteException
    &#123;
        Parcel data = Parcel.obtain();
        Parcel reply = Parcel.obtain();
        data.writeInterfaceToken(IActivityManager.descriptor);
        data.writeStrongBinder(app.asBinder());
        mRemote.transact(ATTACH_APPLICATION_TRANSACTION, data, reply, 0);
        reply.readException();
        data.recycle();
        reply.recycle();
    &#125;
&#125;
</code></pre>
<p>遂进入到ActivityManagerService:</p>
<pre><code>public final void attachApplication(IApplicationThread thread) &#123;
synchronized (this) &#123;
    int callingPid = Binder.getCallingPid();
    final long origId = Binder.clearCallingIdentity();
    attachApplicationLocked(thread, callingPid);
    Binder.restoreCallingIdentity(origId);
&#125;
</code></pre>
<p>attachApplicationLocked</p>
<pre><code>private final boolean attachApplicationLocked(IApplicationThread thread,
        int pid) &#123;
    ProcessRecord app;
    ...
    final String processName = app.processName;
    ...
    app.makeActive(thread, mProcessStats);
    app.curAdj = app.setAdj = -100;
    app.curSchedGroup = app.setSchedGroup = Process.THREAD_GROUP_DEFAULT;
    app.forcingToForeground = null;
    updateProcessForegroundLocked(app, false, false);
    app.hasShownUi = false;
    app.debugging = false;
    app.cached = false;
    app.killedByAm = false;
    ...
     //使用ApplicationThread发起IPC调用bindApplication -&gt;ActivityThread．bindApplication:
        thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,
                profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,
                app.instrumentationUiAutomationConnection, testMode, enableOpenGlTrace,
                isRestrictedBackupMode || !normalMode, app.persistent,
                new Configuration(mConfiguration), app.compat,
                getCommonServicesLocked(app.isolated),
                mCoreSettingsObserver.getCoreSettingsLocked());
    ...   
        
    boolean badApp = false;
    //...
    // Find any services that should be running in this process...
    if (!badApp) &#123;
        try &#123;
            //接着调用ActivieServices的attachApplicationLocked通知客户端启动Service:
            didSomething |= mServices.attachApplicationLocked(app, processName);
        &#125; catch (Exception e) &#123;
            Slog.wtf(TAG, &quot;Exception thrown starting services in &quot; + app, e);
            badApp = true;
        &#125;
    &#125;
   //...
    return true;
&#125;
</code></pre>
<p>使用ApplicationThread发起IPC调用bindApplication -&gt;ActivityThread.bindApplication:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bindApplication</span><span class="params">(String processName, ApplicationInfo appInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">                List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName,</span></span></span><br><span class="line"><span class="params"><span class="function">                ProfilerInfo profilerInfo, Bundle instrumentationArgs,</span></span></span><br><span class="line"><span class="params"><span class="function">                IInstrumentationWatcher instrumentationWatcher,</span></span></span><br><span class="line"><span class="params"><span class="function">                IUiAutomationConnection instrumentationUiConnection, <span class="keyword">int</span> debugMode,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">boolean</span> enableOpenGlTrace, <span class="keyword">boolean</span> isRestrictedBackupMode, <span class="keyword">boolean</span> persistent,</span></span></span><br><span class="line"><span class="params"><span class="function">                Configuration config, CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services,</span></span></span><br><span class="line"><span class="params"><span class="function">                Bundle coreSettings)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//... init</span></span><br><span class="line">            IPackageManager pm = getPackageManager();</span><br><span class="line">            android.content.pm.PackageInfo pi = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pi = pm.getPackageInfo(appInfo.packageName, <span class="number">0</span>, UserHandle.myUserId());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pi != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">//处理sharedUid的情况</span></span><br><span class="line">               <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">            AppBindData data = <span class="keyword">new</span> AppBindData();</span><br><span class="line">            data.processName = processName;</span><br><span class="line">            data.appInfo = appInfo;</span><br><span class="line">            data.providers = providers;</span><br><span class="line">            data.instrumentationName = instrumentationName;</span><br><span class="line">            data.instrumentationArgs = instrumentationArgs;</span><br><span class="line">            data.instrumentationWatcher = instrumentationWatcher;</span><br><span class="line">            data.instrumentationUiAutomationConnection = instrumentationUiConnection;</span><br><span class="line">            data.debugMode = debugMode;</span><br><span class="line">            data.enableOpenGlTrace = enableOpenGlTrace;</span><br><span class="line">            data.restrictedBackupMode = isRestrictedBackupMode;</span><br><span class="line">            data.persistent = persistent;</span><br><span class="line">            data.config = config;</span><br><span class="line">            data.compatInfo = compatInfo;</span><br><span class="line">            data.initProfilerInfo = profilerInfo;</span><br><span class="line">            sendMessage(H.BIND_APPLICATION, data);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">int</span> what, Object obj)</span> </span>&#123;</span><br><span class="line">        sendMessage(what, obj, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> H mH = <span class="keyword">new</span> H();</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">int</span> what, Object obj, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    Message msg = Message.obtain();</span><br><span class="line">    msg.what = what;</span><br><span class="line">    msg.obj = obj;</span><br><span class="line">    msg.arg1 = arg1;</span><br><span class="line">    msg.arg2 = arg2;</span><br><span class="line">    <span class="keyword">if</span> (async) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mH.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p> 主线程的Looper前面已经在ActivityThread主线程里面初始化了，然后向Handler发消息实现进程切换(因为bindApplication是在客户端Binder线程池里面调用的)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">case</span> BIND_APPLICATION:</span><br><span class="line">                       AppBindData data = (AppBindData)msg.obj;</span><br><span class="line">                       handleBindApplication(data);</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>接着调用ActivityThread的handleBindApplication，主要是然客户端初始化应用程序的一些状态比如时区地域，Instrumentation，LoadedApk等等。</p>
<pre><code>private void handleBindApplication(AppBindData data) &#123;
    mBoundApplication = data;
    mConfiguration = new Configuration(data.config);
    mCompatConfiguration = new Configuration(data.config);
    //...
    TimeZone.setDefault(null);
    //...
    Locale.setDefault(data.config.locale);
    //...
&#125;
</code></pre>
<p>再回到ActivityManagerService中的attachApplicationLocked，接着调用ActivieServices的attachApplicationLocked通知客户端启动Service</p>
<pre><code>    if (!badApp) &#123;
        try &#123;
            didSomething |= mServices.attachApplicationLocked(app, processName);
        &#125; catch (Exception e) &#123;
            Slog.wtf(TAG, &quot;Exception thrown starting services in &quot; + app, e);
            badApp = true;
        &#125;
    &#125;
</code></pre>
<p>attachApplicationLocked，mPendingServices就是前面加入列表的ServiceRecord，过滤要启动的ServiceRecord，调用realStartServiceLocked:   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(ProcessRecord proc, String processName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> didSomething = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// Collect any services that are waiting for this process to come up.</span></span><br><span class="line">    <span class="keyword">if</span> (mPendingServices.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ServiceRecord sr = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mPendingServices.size(); i++) &#123; sr = mPendingServices.get(i); <span class="comment">//过滤我们客户端当前的进程 </span></span><br><span class="line">                                                           <span class="keyword">if</span> (proc != sr.isolatedProc &amp;&amp; (proc.uid != sr.appInfo.uid || !processName.equals(sr.processName))) &#123; <span class="keyword">continue</span>; &#125; mPendingServices.remove(i); i--; proc.addPackage(sr.appInfo.packageName, sr.appInfo.versionCode, mAm.mProcessStats); realStartServiceLocked(sr, proc, sr.createdFromFg); didSomething = <span class="keyword">true</span>; &#125; &#125; <span class="keyword">catch</span> (RemoteException e) &#123; Slog.w(TAG, <span class="string">&quot;Exception in new application when starting service &quot;</span> - sr.shortName, e); <span class="keyword">throw</span> e; &#125; &#125; <span class="keyword">if</span> (mRestartingServices.size()&gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">//处理restart的状态</span></span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> didSomething;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>pendingStarts在放入要执行start操作的列表里面，在执行sendServiceArgsLocked告诉客户端执行onStart:</p>
<pre><code>private final void realStartServiceLocked(ServiceRecord r,
        ProcessRecord app, boolean execInFg) throws RemoteException &#123;
    //..
    r.app = app;
    r.restartTime = r.lastActivity = SystemClock.uptimeMillis();
    app.services.add(r);
    //将Service加入到正在执行的executingServices(ProcessRecord)列表里
    bumpServiceExecutingLocked(r, execInFg, &quot;create&quot;);
    mAm.updateLruProcessLocked(app, false, null);
    mAm.updateOomAdjLocked();
    boolean created = false;
    try &#123;
        //...
        app.thread.scheduleCreateService(r, r.serviceInfo,
                mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),
                app.repProcState);
        //前台进程显示Notification
        r.postNotification();
        created = true;
    &#125; catch (DeadObjectException e) &#123;
      //...
  &#125;
    // If the service is in the started state, and there are no
    // pending arguments, then fake up one so its onStartCommand() will
    // be called.
    if (r.startRequested &amp;&amp; r.callStart &amp;&amp; r.pendingStarts.size() == 0) &#123;
        r.pendingStarts.add(new ServiceRecord.StartItem(r, false, r.makeNextStartId(),
                null, null));
    &#125;
    sendServiceArgsLocked(r, execInFg, true);
    //...
&#125;
</code></pre>
<p> 先看ActivityThread的scheduleCreateService,这里对应的token就是ActivityManagerService创建的ServiceRecord，ServiceInfo是ActivityManagerService为我们解析AndroidManifest的Service标签:</p>
<pre><code>public final void scheduleCreateService(IBinder token,
        ServiceInfo info, CompatibilityInfo compatInfo, int processState) &#123;
    updateProcessState(processState, false);
    CreateServiceData s = new CreateServiceData();
    s.token = token;
    s.info = info;
    s.compatInfo = compatInfo;
    sendMessage(H.CREATE_SERVICE, s);
&#125;
</code></pre>
<p>同样是向Handler发送消息实现进程切换:</p>
<pre><code> private class H extends Handler &#123;
    public void handleMessage(Message msg) &#123;
        //...
         case CREATE_SERVICE:
            handleCreateService((CreateServiceData)msg.obj);
            break;
        //...
    &#125;
&#125;
</code></pre>
<p>执行ActivityThread的handleCreateService，实现创建服务并执行onCreate，调用ActivityManagerService的serviceDoneExecuting，onCreate更新下Service的一些状态</p>
<pre><code> private void handleCreateService(CreateServiceData data) &#123;
    ...
        Service service = null;
        ...
            java.lang.ClassLoader cl = packageInfo.getClassLoader();
            service = (Service) cl.loadClass(data.info.name).newInstance();
            ...
            service.attach(context, this, data.info.name, data.token, app,
                    ActivityManagerNative.getDefault());
            service.onCreate();
            mServices.put(data.token, service);
            ...
            //serviceDoneExecuting的主要工作是当service启动完成，则移除service Timeout消息。
                ActivityManagerNative.getDefault().serviceDoneExecuting(
                        data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);
            ...
    &#125;
</code></pre>
<p>再回到上面的ActivieServices的sendServiceArgsLocked告诉客户端要执行onStartCommand，将要执行的onStart的参数（例如startId）传回客户端:</p>
<pre><code>    private final void sendServiceArgsLocked(ServiceRecord r, boolean execInFg,
        boolean oomAdjusted) &#123;
    //...
    while (r.pendingStarts.size() &gt; 0) &#123;
        try &#123;
            ServiceRecord.StartItem si = r.pendingStarts.remove(0);
            //...
            si.deliveredTime = SystemClock.uptimeMillis();
            r.deliveredStarts.add(si);
            si.deliveryCount++;
            //更新正在执行的状态
            bumpServiceExecutingLocked(r, execInFg, &quot;start&quot;);
            int flags = 0;
            if (si.deliveryCount &gt; 1) &#123;
                flags |= Service.START_FLAG_RETRY;
            &#125;
            if (si.doneExecutingCount &gt; 0) &#123;
                flags |= Service.START_FLAG_REDELIVERY;
            &#125;
            //IPC过程 ApplicationThreadNative -&gt; ActivityThread
            r.app.thread.scheduleServiceArgs(r, si.taskRemoved, si.id, flags, si.intent);
        &#125; catch (RemoteException e) &#123;
            //...
        &#125; 
    &#125;
&#125;
</code></pre>
<p>接着执行ActivityThread里的scheduleServiceArgs:</p>
<pre><code>public final void scheduleServiceArgs(IBinder token, boolean taskRemoved, int startId,
            int flags ,Intent args) &#123;
            ServiceArgsData s = new ServiceArgsData();
            s.token = token;
            s.taskRemoved = taskRemoved;
            s.startId = startId;
            s.flags = flags;
            s.args = args;
            sendMessage(H.SERVICE_ARGS, s);
        &#125;
</code></pre>
<p>同样发送消息给主线程执行handleServiceArgs，mServices为客户端维护的Service列表:</p>
<pre><code>    private void handleServiceArgs(ServiceArgsData data) &#123;
    Service s = mServices.get(data.token);
    ...
            int res;
            if (!data.taskRemoved) &#123;
                res = s.onStartCommand(data.args, data.flags, data.startId);
           ...
           //通知AMSservice的状态
           ActivityManagerNative.getDefault().serviceDoneExecuting(
                    data.token, SERVICE_DONE_EXECUTING_START, data.startId, res);
           
&#125;
</code></pre>
<p>onStartCommand执行完后会返回一个参数，用于控制Service的一些行为，例如进程被杀死之后Service的行为。<br>随后调用serviceDoneExecuting告诉ActivityManagerService，onStart已经执行完了，ActivityManagerService再更新一些状态，就这样Service就运行起来了。</p>
<p>三、bindService的过程分析<br>    这个过程中Service所在的进程是已经别启动了的<br>    <a target="_blank" rel="noopener" href="http://0.0.0.1/">http://www.jianshu.com/p/37e0e66979a6</a><br>    <a target="_blank" rel="noopener" href="http://0.0.0.2/">http://blog.csdn.net/jelly_fang/article/details/50488915</a><br>    <a target="_blank" rel="noopener" href="http://0.0.0.3/">http://www.cnblogs.com/android-blogs/p/5718302.html</a></p>
<p>frameworks\base\core\java\android\app\ContextImpl.java</p>
<pre><code> public boolean bindService(Intent service, ServiceConnection conn,
            int flags) &#123;
        warnIfCallingFromSystemProcess();
        return bindServiceCommon(service, conn, flags, Process.myUserHandle());
    &#125;
    private boolean bindServiceCommon(Intent service, ServiceConnection conn, int flags,
            UserHandle user) &#123;
        IServiceConnection sd;
        ...
        1.onbind最终回调ServiceConnection的onServiceConnected方法
        if (mPackageInfo != null) &#123;
            sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(),
                    mMainThread.getHandler(), flags);
        &#125; 
        ...
        2.AMS中bind过程
        int res = ActivityManagerNative.getDefault().bindService(
                mMainThread.getApplicationThread(), getActivityToken(), service,
                service.resolveTypeIfNeeded(getContentResolver()),
                sd, flags, getOpPackageName(), user.getIdentifier());    
        ...
    &#125;
</code></pre>
<p>分析1过程：<br>sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(),<br>                mMainThread.getHandler(), flags);</p>
<pre><code>frameworks\base\core\java\android\app\LoadedApk.java

public final IServiceConnection getServiceDispatcher(ServiceConnection c,
        Context context, Handler handler, int flags) &#123;
    synchronized (mServices) &#123;
        //创建ServiceDispatcher
        LoadedApk.ServiceDispatcher sd = null;
        ...
        if (sd == null) &#123;
            sd = new ServiceDispatcher(c, context, handler, flags);
            ...
        &#125;
        ...
        //返回的是ServiceDispatcher的内部类InnerConnection
        return sd.getIServiceConnection();
    &#125;
&#125;
</code></pre>
<p>   ServiceDispatcher类中的方法</p>
<pre><code>static final class ServiceDispatcher &#123;
    private final ServiceDispatcher.InnerConnection mIServiceConnection;
    private final ServiceConnection mConnection;
    private final Context mContext;
    private final Handler mActivityThread;
    private final ServiceConnectionLeaked mLocation;
    private final int mFlags;
    ...
    //ServiceDispatcher的内部类
    private static class InnerConnection extends IServiceConnection.Stub &#123;
        final WeakReference&lt;LoadedApk.ServiceDispatcher&gt; mDispatcher;

        InnerConnection(LoadedApk.ServiceDispatcher sd) &#123;
            mDispatcher = new WeakReference&lt;LoadedApk.ServiceDispatcher&gt;(sd);
        &#125;
        //保存当前激活的Serviceconnection的Map
        private final ArrayMap&lt;ComponentName, ServiceDispatcher.ConnectionInfo&gt; mActiveConnections
        = new ArrayMap&lt;ComponentName, ServiceDispatcher.ConnectionInfo&gt;();
        
        public void connected(ComponentName name, IBinder service) throws RemoteException &#123;
            LoadedApk.ServiceDispatcher sd = mDispatcher.get();
            if (sd != null) &#123;
                //调用到了外部类ServiceDispatcher中的connected
                sd.connected(name, service);
            &#125;
        &#125;
    &#125;
    //ServiceDispatcher的connected方法
    public void connected(ComponentName name, IBinder service) &#123;
        if (mActivityThread != null) &#123;
            mActivityThread.post(new RunConnection(name, service, 0));
        &#125; else &#123;
        //调用到ServiceDispatcher的doConnected
            doConnected(name, service);
        &#125;
    &#125;
    
    public void doConnected(ComponentName name, IBinder service) &#123;
        ...
        if (service != null) &#123;
                // A new service is being connected... set it all up.
                mDied = false;
                info = new ConnectionInfo();
                info.binder = service;
                info.deathMonitor = new DeathMonitor(name, service);
                ...
        &#125;   
        ...
        // If there is a new service, it is now connected.
        if (service != null) &#123;
            //调用了 mConnection.onServiceConnected(name, service)这个方法,后面会通过InnerConnection实例来远程回调这个方法。
            //这个mConnection其实就是一开始ServiceDispatcher 的构造函数中传进来的ServiceConnection实例。
            mConnection.onServiceConnected(name, service);
        &#125;
    &#125;
</code></pre>
<p> 分析2过程：<br>    int res = ActivityManagerNative.getDefault().bindService(<br>            mMainThread.getApplicationThread(), getActivityToken(), service,<br>            service.resolveTypeIfNeeded(getContentResolver()),<br>            sd, flags, getOpPackageName(), user.getIdentifier());</p>
<p>   ActivityManagerNative.getDefault() 最终都会调用ActiveServices.bindServiceLocked方法,细致的不去跟踪<br>   frameworks\base\services\core\java\com\android\server\am\ActiveServices.java<br>   s（ServiceRecord ）、b（AppBindRecord ）、c（ConnectionRecord ）、callerApp （ProcessRecord） 这四个类型的一些保存之类的操作，方便以后调用</p>
<pre><code>    int bindServiceLocked(IApplicationThread caller, IBinder token, Intent service,
        String resolvedType, IServiceConnection connection, int flags,
        String callingPackage, int userId) throws TransactionTooLargeException &#123;
    ...
  
    final ProcessRecord callerApp = mAm.getRecordForAppLocked(caller);
    ...
    ServiceLookupResult res =
        retrieveServiceLocked(service, resolvedType, callingPackage,
                Binder.getCallingPid(), Binder.getCallingUid(), userId, true, callerFg);
    if (res == null) &#123;
        return 0;
    &#125;
    if (res.record == null) &#123;
        return -1;
    &#125;
    ServiceRecord s = res.record;
    ...
    try &#123;
        mAm.startAssociationLocked(callerApp.uid, callerApp.processName,
                s.appInfo.uid, s.name, s.processName);
        //获取一个ServiceRecord对象，如果不存在就创建        
        AppBindRecord b = s.retrieveAppBindingLocked(service, callerApp);
        ConnectionRecord c = new ConnectionRecord(b, activity,connection, flags, clientLabel, clientIntent);
        
        //这个binder其实可以简单的看做成IServiceConnection ，后面可以通过它asInterface方法获取binder驱动来远程调用IServiceConnection （其实就是IServiceConnection–&gt;InnerConnection –&gt;ServiceDispatcher ）里面的方法。然后把这个binder放到了s（ServiceRecord ）的connections的集合中,clist就是一个connectionRecord的集合，应为可能不止一个activity或者组件需要绑定这个service。
        IBinder binder = connection.asBinder();
        
        ArrayList&lt;ConnectionRecord&gt; clist = s.connections.get(binder);
        if (clist == null) &#123;
            clist = new ArrayList&lt;ConnectionRecord&gt;();
            s.connections.put(binder, clist);
        &#125;
        clist.add(c);
        ...
        if ((flags&amp;Context.BIND_AUTO_CREATE) != 0) &#123;
            s.lastActivity = SystemClock.uptimeMillis();
            //执行bringUpServiceLocked,bringUpServiceLocked调用到realStartServiceLocked;
            if (bringUpServiceLocked(s, service.getFlags(), callerFg, false) != null) &#123;
                return 0;
            &#125;
        &#125;
</code></pre>
<p>​<br>​            if (s.app != null &amp;&amp; b.intent.received) {<br>​                // Service is already running, so we can immediately<br>​                // publish the connection.<br>​                …<br>​                    //重复bind时会走这里，直接调用requestServiceBindingLocked<br>​                    c.conn.connected(s.name, b.intent.binder);<br>​                …<br>​                // If this is the first app connected back to this binding,<br>​                // and the service had previously asked to be told when<br>​                // rebound, then do so.<br>​                if (b.intent.apps.size() == 1 &amp;&amp; b.intent.doRebind) {<br>​                    requestServiceBindingLocked(s, b.intent, callerFg, true);<br>​                }<br>​            } else if (!b.intent.requested) {<br>​                requestServiceBindingLocked(s, b.intent, callerFg, false);<br>​<br>            }<br>        …<br>        return 1;<br>    }</p>
<p>bringUpServiceLocked</p>
<pre><code> private final String bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean execInFg, boolean whileRestarting) throws TransactionTooLargeException &#123;
        ...
        if (!isolated) &#123;
            app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, false);
            if (DEBUG_MU) Slog.v(TAG_MU, &quot;bringUpServiceLocked: appInfo.uid=&quot; + r.appInfo.uid
                        + &quot; app=&quot; + app);
            if (app != null &amp;&amp; app.thread != null) &#123;
                try &#123;
                    app.addPackage(r.appInfo.packageName, r.appInfo.versionCode, mAm.mProcessStats);
                    realStartServiceLocked(r, app, execInFg);
                    return null;
                &#125; catch (TransactionTooLargeException e) &#123;
                    throw e;
                &#125; catch (RemoteException e) &#123;
                    Slog.w(TAG, &quot;Exception when starting service &quot; + r.shortName, e);
                &#125;
            &#125;
        &#125;
        ...
        return null;
    &#125;
</code></pre>
<p> realStartServiceLocked</p>
<pre><code>private final void realStartServiceLocked(ServiceRecord r,
            ProcessRecord app, boolean execInFg) throws RemoteException &#123;

        r.app = app;
       ...
        //3.调用ActivityThread的scheduleCreateService,创建一个Service
            app.thread.scheduleCreateService(r, r.serviceInfo,
                    mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),
                    app.repProcState);
            r.postNotification();
     ...
        //4. 等待3的service被创建完成bindService
        requestServiceBindingsLocked(r, execInFg);
        updateServiceClientActivitiesLocked(app, null, true);
    &#125;
</code></pre>
<p>分析3过程<br>app.thread.scheduleCreateService(r, r.serviceInfo,<br>                    mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),<br>                    app.repProcState);</p>
<pre><code>//scheduleCreateService 发送一个消息
public final void scheduleCreateService(IBinder token,
            ServiceInfo info, CompatibilityInfo compatInfo, int processState) &#123;
        updateProcessState(processState, false);
        CreateServiceData s = new CreateServiceData();
        s.token = token;
        s.info = info;
        s.compatInfo = compatInfo;

        sendMessage(H.CREATE_SERVICE, s);
&#125;
//handleCreateService
private void handleCreateService(CreateServiceData data) &#123;
...
    初始化一个service ，并执行回调
    Service service = null;
    ...
        java.lang.ClassLoader cl = packageInfo.getClassLoader();
        service = (Service) cl.loadClass(data.info.name).newInstance();
        ...
        service.attach(context, this, data.info.name, data.token, app,
                ActivityManagerNative.getDefault());
        service.onCreate();
        mServices.put(data.token, service);
        ...
        //serviceDoneExecuting的主要工作是当service启动完成，则移除service Timeout消息。
        ActivityManagerNative.getDefault().serviceDoneExecuting(
                    data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);
        ...
&#125;
</code></pre>
<p>分析4过程：<br>requestServiceBindingsLocked(r, execInFg);</p>
<pre><code>private final boolean requestServiceBindingLocked(ServiceRecord r, IntentBindRecord i,
        boolean execInFg, boolean rebind) throws TransactionTooLargeException &#123;
        ...
        //调用ActivityThread的scheduleBindService
        r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,
                    r.app.repProcState);
        ...
&#125;
</code></pre>
<p>接下来的过程类似于 onCreate 的过程scheduleBindService -&gt; handleMessage -&gt; handleBindService 调用到ActiveServices.publishServiceLocked</p>
<pre><code>private void handleBindService(BindServiceData data) &#123;
    Service s = mServices.get(data.token);
    ...
    //类似于之前的过程 最终调用到 ActiveServices 的 publishServiceLocked
        ActivityManagerNative.getDefault().publishService(
                            data.token, data.intent, binder);
    ...
&#125;
</code></pre>
<p>//取出在bindServiceLock中放到ServiceRecord中的ConnectionRecord </p>
<pre><code>void publishServiceLocked(ServiceRecord r, Intent intent, IBinder service) &#123;
    for (int conni=r.connections.size()-1; conni&gt;=0; conni--) &#123;
         ArrayList&lt;ConnectionRecord&gt; clist = r.connections.valueAt(conni);
             for (int i=0; i&lt;clist.size(); i++) &#123; ConnectionRecord c = clist.get(i); ... //回调到onServiceConnected，bindService结束 即是方法ConnectionRecord.ServiceDispatcher.InnerConnection.connected c.conn.connected(r.name, service); ... &#125; &#125; &#125; 四、startService和bindService的流程的区别在于： 4.1在bringUpServiceLocked 中开启新的进程后，绕一圈再调用到realStartServiceLocked ActivityManagerService.startProcessLocked-&gt;ActivityThread.main-&gt;ActivityManagerNative.getDefault().attachApplicationLocked-&gt; 
</code></pre>
<p>ActivityManagerService.attachApplicationLocked-&gt;ActiveServices.attachApplicationLocked-&gt;ActiveServices.realStartServiceLocked<br>4.2当realStartServiceLocked 中执行时，bindService会调用requestServiceBindingsLocked做绑定服务的下一步处理，这里创建的Service并不会回调onStartCommand，在realStartServiceLocked中对start和bind的操作做了区分<br>    //bringUpServiceLocked</p>
<pre><code> private final String bringUpServiceLocked(ServiceRecord r,int intentFlags, boolean execInFg, boolean whileRestarting) &#123;
         if (app == null) &#123;
                if ((app=mAm.startProcessLocked(procName, r.appInfo, true, intentFlags,
                        &quot;service&quot;, r.name, false, isolated, false)) == null) &#123;
                   //...
            &#125;  
        &#125;
</code></pre>
<p>//开启新的进程</p>
<pre><code>public final class ActivityThread &#123;
            public static void main(String[] args) &#123;
                Looper.prepareMainLooper();
                ActivityThread thread = new ActivityThread();
                thread.attach(false);
                Looper.loop();
                throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);
            &#125;
            private void attach(boolean system) &#123;
                ...
                 mgr.attachApplication(mAppThread);
                ...
        &#125;
</code></pre>
<p>   ActivityManagerService.attachApplicationLocked</p>
<pre><code> private final boolean attachApplicationLocked(IApplicationThread thread,
            int pid) &#123;
          //...
            thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,
                    profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,
                    app.instrumentationUiAutomationConnection, testMode, enableOpenGlTrace,
                    isRestrictedBackupMode || !normalMode, app.persistent,
                    new Configuration(mConfiguration), app.compat,
                    getCommonServicesLocked(app.isolated),
                    mCoreSettingsObserver.getCoreSettingsLocked());
        ...
        // Find any services that should be running in this process...
        //这里继续调用到ActiveService.attachApplicationLocked
             didSomething |= mServices.attachApplicationLocked(app, processName);
      //...
        return true;
    &#125;
</code></pre>
<p> ActiveServices.attachApplicationLocked   </p>
<pre><code> boolean attachApplicationLocked(ProcessRecord proc, String processName)
        throws RemoteException &#123;
        ...
        realStartServiceLocked(sr, proc, sr.createdFromFg);
        didSomething = true;
        ...
    return didSomething;
&#125;
</code></pre>
<p>ActiveServices.realStartServiceLocked</p>
<pre><code>    private final void realStartServiceLocked(ServiceRecord r,
        ProcessRecord app, boolean execInFg) throws RemoteException &#123;
    //...
    r.app = app;
    r.restartTime = r.lastActivity = SystemClock.uptimeMillis();
    app.services.add(r);
    bumpServiceExecutingLocked(r, execInFg, &quot;create&quot;);
    mAm.updateLruProcessLocked(app, false, null);
    mAm.updateOomAdjLocked();
    boolean created = false;
    try &#123;
        //通知创建Service并执行onCreate
        app.thread.scheduleCreateService(r, r.serviceInfo,
                mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),
                app.repProcState);
        r.postNotification();
        created = true;
    &#125; catch (DeadObjectException e) &#123;
      //...
    &#125; finally &#123;
        //...
    &#125;
    //bindService 会执行这里,最终回调到方法onServiceConnected
      scheduleBindService -&gt; handleMessage -&gt; handleBindService 调用到ActiveServices.publishServiceLocked
    requestServiceBindingsLocked(r, execInFg);
    updateServiceClientActivitiesLocked(app, null, true);
    //这里不会加入到pendingStarts里面，所以不会执行onStartCommand
    if (r.startRequested &amp;&amp; r.callStart &amp;&amp; r.pendingStarts.size() == 0) &#123;
        r.pendingStarts.add(new ServiceRecord.StartItem(r, false, r.makeNextStartId(),
                null, null));
    &#125;
    //startService 过程继续执行这里
    sendServiceArgsLocked(r, execInFg, true);
    //...
&#125;
</code></pre>
<p>ActiveServices.requestServiceBindingsLocked,bindService 会执行这里,最终回调到方法onServiceConnected<br>          scheduleBindService -&gt; handleMessage -&gt; handleBindService,调用到ActiveServices.publishServiceLocked     </p>
<pre><code>private final void requestServiceBindingsLocked(ServiceRecord r, boolean execInFg)
        throws TransactionTooLargeException &#123;
    for (int i=r.bindings.size()-1; i&gt;=0; i--) &#123;
        IntentBindRecord ibr = r.bindings.valueAt(i);
        if (!requestServiceBindingLocked(r, ibr, execInFg, false)) &#123;
            break;
        &#125;
    &#125;
&#125; 
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/24/Notes/Android/other/other/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/24/Notes/Android/other/other/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-24 23:08:49" itemprop="dateCreated datePublished" datetime="2021-02-24T23:08:49+08:00">2021-02-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="http://blog.leanote.com/post/svenpaper/Android-SharePreference-%E6%80%BB%E7%BB%93">http://blog.leanote.com/post/svenpaper/Android-SharePreference-%E6%80%BB%E7%BB%93</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.leanote.com/post/svenpaper/Android-O-%E7%89%88%E6%9C%AC%E5%AE%89%E8%A3%85%E5%8C%85%E5%A4%A7%E5%B0%8F%E8%8E%B7%E5%8F%96%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E5%8F%8A%E8%A7%A3%E5%86%B3">http://blog.leanote.com/post/svenpaper/Android-O-%E7%89%88%E6%9C%AC%E5%AE%89%E8%A3%85%E5%8C%85%E5%A4%A7%E5%B0%8F%E8%8E%B7%E5%8F%96%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E5%8F%8A%E8%A7%A3%E5%86%B3</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.leanote.com/post/svenpaper/JobService-%E5%92%8C-Jobschedule">http://blog.leanote.com/post/svenpaper/JobService-%E5%92%8C-Jobschedule</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/24/Notes/Android/Framework/FrameWork_07_SharePreference%20%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/24/Notes/Android/Framework/FrameWork_07_SharePreference%20%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">FrameWork_08_SharedPreferences</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-24 23:08:49" itemprop="dateCreated datePublished" datetime="2021-02-24T23:08:49+08:00">2021-02-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="FrameWork-08-SharedPreference"><a href="#FrameWork-08-SharedPreference" class="headerlink" title="FrameWork_08_SharedPreference"></a>FrameWork_08_SharedPreference</h1><p>SharePreferences是一个轻量级的存储类，特别适合用于保存软件配置参数。使用SharedPreferences保存数据，其背后是用xml文件存放数据，文件存放在/data/data/ &lt; package name &gt; /shared_prefs目录下，本文主要介绍下sp的用法并且从源码的角度分析下sp的写入过程。</p>
<h2 id="1-获取sp的三种方式"><a href="#1-获取sp的三种方式" class="headerlink" title="1.获取sp的三种方式"></a>1.获取sp的三种方式</h2><p>1.this.getPreferences (int mode)<br>    通过Activity对象获取，获取的是本Activity私有的Preference，保存在系统中的xml形式的文件的名称为这个Activity的名字，因此一个Activity只能有一个，属于这个Activity。</p>
<p>2.context.getSharedPreferences (String name, int mode)<br>    因为Activity继承了ContextWrapper，因此也是通过Activity对象获取，但是属于整个应用程序，可以有多个，以第一参数的name为文件名保存在系统中。</p>
<p>3.PreferenceManager.getDefaultSharedPreferences(this);<br>    PreferenceManager的静态函数，保存PreferenceActivity中的设置，属于整个应用程序，但是只有一个，命名为packagename_preferences。</p>
<h2 id="2-写入模式"><a href="#2-写入模式" class="headerlink" title="2. 写入模式"></a>2. 写入模式</h2><pre><code>Activity.MODE_PRIVATE,//默认操作模式，代表该文件是私有数据，只能被应用本身访问，在该模式下，写入的内容会覆盖原文件的内容，如果想把新写入的内容追加到原文件中，可以使用Activity.MODE_APPEND 
Activity.MODE_APPEND //该模式会检查文件是否存在，存在就往文件追加内容，否则就创建新文件
以下2种模式已废弃，不安全
Activity.MODE_WORLD_READABLE,//表示当前文件可以被其他应用读取，  
Activity.MODE_WORLD_WRITEABLE,//表示当前文件可以被其他应用写入；
</code></pre>
<h2 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3.源码分析"></a>3.源码分析</h2><h3 id="1-获取SharedPreferences对象"><a href="#1-获取SharedPreferences对象" class="headerlink" title="1.获取SharedPreferences对象"></a>1.获取SharedPreferences对象</h3><p>contextImpl.getSharedPreferences()，这里使用到了单例模式，涉及到的几个对象如下：</p>
<pre><code>ArrayMap&lt;String, File&gt; mSharedPrefsPaths ： 保存sp的路径和文件
ArrayMap&lt;String, ArrayMap&lt;File, SharedPreferencesImpl&gt;&gt; sSharedPrefsCache key 是packageName， vlaue是 file 和 对应的spImpl对象。
</code></pre>
<p>整个过程分为2步，先获取对应name的sp文件，如果没有就new一个文件放到 mSharedPrefsPaths 中，<br>再根据文件名获取对应的spImpl对象。</p>
<p>对于一个相同的SharedPreferences name，获取到的都是同一个SharedPreferences对象，也就是SharedPreferencesImpl对象。</p>
<pre><code>public SharedPreferences getSharedPreferences(String name, int mode) &#123;
    // At least one application in the world actually passes in a null
    // name.  This happened to work because when we generated the file name
    // we would stringify it to &quot;null.xml&quot;.  Nice.
    if (mPackageInfo.getApplicationInfo().targetSdkVersion &lt;
            Build.VERSION_CODES.KITKAT) &#123;
        if (name == null) &#123;
            name = &quot;null&quot;;
        &#125;
    &#125;
    
    File file;
    synchronized (ContextImpl.class) &#123;
        if (mSharedPrefsPaths == null) &#123;
            mSharedPrefsPaths = new ArrayMap&lt;&gt;();
        &#125;
        file = mSharedPrefsPaths.get(name);
        if (file == null) &#123;
            file = getSharedPreferencesPath(name);
            mSharedPrefsPaths.put(name, file);
        &#125;
    &#125;
    return getSharedPreferences(file, mode);
&#125;

 public SharedPreferences getSharedPreferences(File file, int mode) &#123;
    ...
    SharedPreferencesImpl sp;
    synchronized (ContextImpl.class) &#123;
        final ArrayMap&lt;File, SharedPreferencesImpl&gt; cache = getSharedPreferencesCacheLocked();
        sp = cache.get(file);
        if (sp == null) &#123;
            sp = new SharedPreferencesImpl(file, mode);
            cache.put(file, sp);
            return sp;
        &#125;
    &#125;
    if ((mode &amp; Context.MODE_MULTI_PROCESS) != 0 ||
        getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) &#123;
        // If somebody else (some other process) changed the prefs
        // file behind our back, we reload it.  This has been the
        // historical (if undocumented) behavior.
        sp.startReloadIfChangedUnexpectedly();
    &#125;
    return sp;
&#125;

private ArrayMap&lt;File, SharedPreferencesImpl&gt; getSharedPreferencesCacheLocked() &#123;
    if (sSharedPrefsCache == null) &#123;
        sSharedPrefsCache = new ArrayMap&lt;&gt;();
    &#125;

    final String packageName = getPackageName();
    ArrayMap&lt;File, SharedPreferencesImpl&gt; packagePrefs = sSharedPrefsCache.get(packageName);
    if (packagePrefs == null) &#123;
        packagePrefs = new ArrayMap&lt;&gt;();
        sSharedPrefsCache.put(packageName, packagePrefs);
    &#125;

    return packagePrefs;
&#125;
</code></pre>
<h3 id="2-sp-的初始化"><a href="#2-sp-的初始化" class="headerlink" title="2.sp 的初始化"></a>2.sp 的初始化</h3><p>对于一个SharedPreferences文件name，第一次调用getSharedPreferences时会去创建一个SharedPreferencesImpl对象，它会开启一个子线程，将所有的数据以Map的形式保存在内存中。</p>
<pre><code> SharedPreferencesImpl(File file, int mode) &#123;
    mFile = file;
    mBackupFile = makeBackupFile(file);
    mMode = mode;
    mLoaded = false;
    mMap = null;
    startLoadFromDisk();
&#125;

private void startLoadFromDisk() &#123;
    synchronized (mLock) &#123;
        mLoaded = false;
    &#125;
    new Thread(&quot;SharedPreferencesImpl-load&quot;) &#123;
        public void run() &#123;
            loadFromDisk();
        &#125;
    &#125;.start();
&#125;

private void loadFromDisk() &#123;
    synchronized (mLock) &#123;
        if (mLoaded) &#123;
            return;
        &#125;
        if (mBackupFile.exists()) &#123;
            mFile.delete();
            mBackupFile.renameTo(mFile);
        &#125;
    &#125;

    // Debugging
    if (mFile.exists() &amp;&amp; !mFile.canRead()) &#123;
        Log.w(TAG, &quot;Attempt to read preferences file &quot; + mFile + &quot; without permission&quot;);
    &#125;

    Map map = null;
    StructStat stat = null;
    try &#123;
        stat = Os.stat(mFile.getPath());
        if (mFile.canRead()) &#123;
            BufferedInputStream str = null;
            try &#123;
                str = new BufferedInputStream(
                        new FileInputStream(mFile), 16*1024);
                map = XmlUtils.readMapXml(str);
            &#125; catch (Exception e) &#123;
                Log.w(TAG, &quot;Cannot read &quot; + mFile.getAbsolutePath(), e);
            &#125; finally &#123;
                IoUtils.closeQuietly(str);
            &#125;
        &#125;
    &#125; catch (ErrnoException e) &#123;
        /* ignore */
    &#125;

    synchronized (mLock) &#123;
        mLoaded = true;
        if (map != null) &#123;
            mMap = map;
            mStatTimestamp = stat.st_mtime;
            mStatSize = stat.st_size;
        &#125; else &#123;
            mMap = new HashMap&lt;&gt;();
        &#125;
        mLock.notifyAll();
    &#125;
&#125;
</code></pre>
<h2 id="3-sp的读取"><a href="#3-sp的读取" class="headerlink" title="3. sp的读取"></a>3. sp的读取</h2><p>当我们在ui线程种这样调用时：</p>
<pre><code>SharedPreferences sp = getSharedPreferences(&quot;test&quot;, Context.MODE_PRIVATE);
String name = sp.getString(&quot;name&quot;, null)
</code></pre>
<p>调用getString时那个SharedPreferencesImpl构造方法开启的子线程可能还没执行完（比如文件比较大时全部读取会比较久），这时getString当然还不能获取到相应的值，必须阻塞到那个子线程读取完为止，getString方法：</p>
<pre><code>public String getString(String key, @Nullable String defValue) &#123;
    synchronized (this) &#123;
        awaitLoadedLocked();
        String v = (String)mMap.get(key);
        return v != null ? v : defValue;
    &#125;
&#125;
</code></pre>
<p>显然这个awaitLoadedLocked方法就是用来等this这个锁的，在loadFromDiskLocked方法的最后我们也可以看到它调用了notifyAll方法，这时如果getString之前阻塞了就会被唤醒。那么现在这里有一个问题，我们的getString是写在UI线程中，如果那个getString被阻塞太久了，比如60s，这时就会出现ANR，因此要根据具体情况考虑是否需要把SharedPreferences的读写放在子线程中。这里回答第二个 问题，在UI线程中调用getXXX可能会导致ANR。同时可以回答第三个问题，SharedPreferences只能用来存放少量数据，如果一个SharedPreferences对应的xml文件很大的话，在初始化时会把这个文件的所有数据都加载到内存中，这样就会占用大量的内存，有时我们只是想读取某个xml文件中一个key的value，结果它把整个文件都加载进来了，显然如果必要的话这里需要进行相关优化处理。</p>
<h2 id="4-sp的写入"><a href="#4-sp的写入" class="headerlink" title="4.sp的写入"></a>4.sp的写入</h2><pre><code>SharedPreferences.Editor editor = getSharedPreferences(&quot;test&quot;, Context.MODE_PRIVATE).edit();
editor.putString(&quot;name&quot;, &quot;test&quot;);
editor.commit();
</code></pre>
<p>首先写一个SharedPreferences文件都是先要调用edit方法获取到一个Editor对象：   </p>
<pre><code>public Editor edit() &#123;
    synchronized (this) &#123;
        awaitLoadedLocked();
    &#125;
    return new EditorImpl();
&#125;
</code></pre>
<p>这个Editor对象是SharedPreferencesImpl的一个内部类：</p>
<pre><code>public final class EditorImpl implements Editor &#123;
    private final Map&lt;String, Object&gt; mModified = Maps.newHashMap();
    private boolean mClear = false;
    public Editor putString(String key, @Nullable String value) &#123;
        synchronized (this) &#123;
            mModified.put(key, value);
            return this;
        &#125;
    &#125;
    ...
&#125;
</code></pre>
<p>可以看到它有一个Map对象mModified，用来保存修改的数据，也就是你每次put的时候其实是把那个键值对放到这个mModified 中，最后调用apply或者commit才会真正把数据写入文件中。调用commit 和 apply时都会调用到commitToMemory 和 enqueueDiskWrite这2个方法。这里我们以commit 为例先看下整个写入的过程。 </p>
<h3 id="4-1-commit"><a href="#4-1-commit" class="headerlink" title="4.1 commit"></a>4.1 commit</h3><pre><code>public boolean commit() &#123;
    MemoryCommitResult mcr = commitToMemory();
    SharedPreferencesImpl.this.enqueueDiskWrite(
        mcr, null /* sync write on this thread okay */);
    try &#123;
        mcr.writtenToDiskLatch.await();
    &#125; catch (InterruptedException e) &#123;
        return false;
    &#125;
    notifyListeners(mcr);
    return mcr.writeToDiskResult;
&#125;
</code></pre>
<h3 id="4-2-commitToMemory"><a href="#4-2-commitToMemory" class="headerlink" title="4.2 commitToMemory"></a>4.2 commitToMemory</h3><p>这个方法对应了editor的增删改查方法，这里涉及了2个对象，mMap 和mModified，一个保存当前sp中的键值对，一个保存了修改的键值对。遍历mModified键值对时可以看到这个方法中首先处理了clear标志，它调用的是mMap.clear()，然后再遍历mModified将新的键值对put进mMap，也就是说在一次commit事务中，如果同时put一些键值对和调用clear，那么clear掉的只是之前的键值对，这次put进去的键值对还是会被写入的。</p>
<pre><code>// Returns true if any changes were made
private MemoryCommitResult commitToMemory() &#123;
    MemoryCommitResult mcr = new MemoryCommitResult();
    ...
        synchronized (this) &#123;
            if (mClear) &#123;
                if (!mMap.isEmpty()) &#123;
                    mcr.changesMade = true;
                    mMap.clear();
                &#125;
                mClear = false;
            &#125;

            for (Map.Entry&lt;String, Object&gt; e : mModified.entrySet()) &#123;
                String k = e.getKey();
                Object v = e.getValue();
                // &quot;this&quot; is the magic value for a removal mutation. In addition,
                // setting a value to &quot;null&quot; for a given key is specified to be
                // equivalent to calling remove on that key.
                if (v == this || v == null) &#123;
                    if (!mMap.containsKey(k)) &#123;
                        continue;
                    &#125;
                    mMap.remove(k);
                &#125; else &#123;
                    if (mMap.containsKey(k)) &#123;
                        Object existingValue = mMap.get(k);
                        if (existingValue != null &amp;&amp; existingValue.equals(v)) &#123;
                            continue;
                        &#125;
                    &#125;
                    mMap.put(k, v);
                &#125;

                mcr.changesMade = true;
                if (hasListeners) &#123;
                    mcr.keysModified.add(k);
                &#125;
            &#125;

            mModified.clear();
        &#125;
    &#125;
    return mcr;
&#125;
</code></pre>
<p>遍历mModified时，需要处理一个特殊情况，就是如果一个键值对的value是this（SharedPreferencesImpl）或者是null那么表示将此键值对删除，这个在remove方法中可以看到： </p>
<pre><code>public Editor remove(String key) &#123;
    synchronized (this) &#123;
        mModified.put(key, this);
        return this;
    &#125;
&#125;
</code></pre>
<h2 id="4-3-enqueueDiskWrite"><a href="#4-3-enqueueDiskWrite" class="headerlink" title="4.3 enqueueDiskWrite"></a>4.3 enqueueDiskWrite</h2><p>先定义一个Runnable，注意实现Runnable与继承Thread的区别，Runnable表示一个任务，不一定要在子线程中执行，一般优先考虑使用Runnable。这个Runnable中先调用writeToFile进行写操作，写操作需要先获得mWritingToDiskLock，也就是写锁。然后执行mDiskWritesInFlight–，表示正在等待写的操作减少1。最后判断postWriteRunnable是否为null，调用commit时它为null，而调用apply时它不为null。<br>Runnable定义完，就判断这次是commit还是apply，如果是commit，即isFromSyncCommit为true，而且有1个写操作需要执行，那么就调用writeToDiskRunnable.run()，注意这个调用是在当前线程中进行的。如果不是commit，那就是apply，这时调用QueuedWork.singleThreadExecutor().execute(writeToDiskRunnable)，这个QueuedWork类其实很简单，里面有一个SingleThreadExecutor，用于异步执行这个writeToDiskRunnable。 </p>
<pre><code>private void enqueueDiskWrite(final MemoryCommitResult mcr,
                              final Runnable postWriteRunnable) &#123;
    final Runnable writeToDiskRunnable = new Runnable() &#123;
            public void run() &#123;
                synchronized (mWritingToDiskLock) &#123;
                    writeToFile(mcr);
                &#125;
                synchronized (SharedPreferencesImpl.this) &#123;
                    mDiskWritesInFlight--;
                &#125;
                if (postWriteRunnable != null) &#123;
                    postWriteRunnable.run();
                &#125;
            &#125;
        &#125;;

    final boolean isFromSyncCommit = (postWriteRunnable == null);

    // Typical #commit() path with fewer allocations, doing a write on
    // the current thread.
    if (isFromSyncCommit) &#123;
        boolean wasEmpty = false;
        synchronized (SharedPreferencesImpl.this) &#123;
            wasEmpty = mDiskWritesInFlight == 1;
        &#125;
        if (wasEmpty) &#123;
            writeToDiskRunnable.run();
            return;
        &#125;
    &#125;

    QueuedWork.singleThreadExecutor().execute(writeToDiskRunnable);
&#125;
</code></pre>
<h3 id="4-4-writeToFile"><a href="#4-4-writeToFile" class="headerlink" title="4.4 writeToFile"></a>4.4 writeToFile</h3><p>SharedPreferences在写入时会先把之前的xml文件改成名成一个备份文件mBackupFile，然后再将要写入的数据写到一个新的文件中，如果这个过程执行成功的话，就会把备份文件删除。由此可见每次即使只是添加一个键值对，也会重新写入整个文件的数据，这也说明SharedPreferences只适合保存少量数据，文件太大会有性能问题。</p>
<pre><code>private void writeToFile(MemoryCommitResult mcr) &#123;
    // Rename the current file so it may be used as a backup during the next read
    if (mFile.exists()) &#123;
        if (!mcr.changesMade) &#123;
            // If the file already exists, but no changes were
            // made to the underlying map, it&#39;s wasteful to
            // re-write the file.  Return as if we wrote it
            // out.
            mcr.setDiskWriteResult(true);
            return;
        &#125;
        if (!mBackupFile.exists()) &#123;
            if (!mFile.renameTo(mBackupFile)) &#123;
                Log.e(TAG, &quot;Couldn&#39;t rename file &quot; + mFile
                      + &quot; to backup file &quot; + mBackupFile);
                mcr.setDiskWriteResult(false);
                return;
            &#125;
        &#125; else &#123;
            mFile.delete();
        &#125;
    &#125;

    // Attempt to write the file, delete the backup and return true as atomically as
    // possible.  If any exception occurs, delete the new file; next time we will restore
    // from the backup.
    try &#123;
        FileOutputStream str = createFileOutputStream(mFile);
        if (str == null) &#123;
            mcr.setDiskWriteResult(false);
            return;
        &#125;
        XmlUtils.writeMapXml(mcr.mapToWriteToDisk, str);
        FileUtils.sync(str);
        str.close();
        ContextImpl.setFilePermissionsFromMode(mFile.getPath(), mMode, 0);
        try &#123;
            final StructStat stat = Os.stat(mFile.getPath());
            synchronized (this) &#123;
                mStatTimestamp = stat.st_mtime;
                mStatSize = stat.st_size;
            &#125;
        &#125; catch (ErrnoException e) &#123;
            // Do nothing
        &#125;
        // Writing was successful, delete the backup file if there is one.
        mBackupFile.delete();
        mcr.setDiskWriteResult(true);
        return;
    &#125; catch (XmlPullParserException e) &#123;
        Log.w(TAG, &quot;writeToFile: Got exception:&quot;, e);
    &#125; catch (IOException e) &#123;
        Log.w(TAG, &quot;writeToFile: Got exception:&quot;, e);
    &#125;
    // Clean up an unsuccessfully written file
    if (mFile.exists()) &#123;
        if (!mFile.delete()) &#123;
            Log.e(TAG, &quot;Couldn&#39;t clean up partially-written file &quot; + mFile);
        &#125;
    &#125;
    mcr.setDiskWriteResult(false);
&#125;
</code></pre>
<h3 id="5-使用apply导致的anr"><a href="#5-使用apply导致的anr" class="headerlink" title="5.使用apply导致的anr"></a>5.使用apply导致的anr</h3><p>其实无节制的使用apply方法也时会造成anr的，在主线程中无节制的使用apply其实也会造成anr，在调用apply时，会将等待写入到文件系统的任务awaitCommit放在QueuedWork的等待完成队列里。</p>
<pre><code>public void apply() &#123;
    final MemoryCommitResult mcr = commitToMemory();
    final Runnable awaitCommit = new Runnable() &#123;
            public void run() &#123;
                try &#123;
                    mcr.writtenToDiskLatch.await();
                &#125; catch (InterruptedException ignored) &#123;
                &#125;
            &#125;
        &#125;;

    QueuedWork.add(awaitCommit);

    Runnable postWriteRunnable = new Runnable() &#123;
            public void run() &#123;
                awaitCommit.run();
                QueuedWork.remove(awaitCommit);
            &#125;
        &#125;;

    SharedPreferencesImpl.this.enqueueDiskWrite(mcr, postWriteRunnable);

    // Okay to notify the listeners before it&#39;s hit disk
    // because the listeners should always get the same
    // SharedPreferences instance back, which has the
    // changes reflected in memory.
    notifyListeners(mcr);
&#125;
</code></pre>
<p>所以如果我们使用SharedPreference的apply方法,虽然该方法可以很快返回， 并在其它线程里将键值对写入到文件系统， 但是当Activity的onPause等方法被调用时，会调用等待写入到文件系统的任务完成，</p>
<pre><code>/**
 * Finishes or waits for async operations to complete.
 * (e.g. SharedPreferences$Editor#startCommit writes)
 *
 * Is called from the Activity base class&#39;s onPause(), after
 * BroadcastReceiver&#39;s onReceive, after Service command handling,
 * etc.  (so async work is never lost)
 */
public static void waitToFinish() &#123;
    Runnable toFinish;
    while ((toFinish = sPendingWorkFinishers.poll()) != null) &#123;
        toFinish.run();
    &#125;
&#125;
</code></pre>
<p>在执行任务writeToDiskRunnable时，会先等待postrunable执行完成，也就是awaitCommit执行完成，</p>
<pre><code>final Runnable awaitCommit = new Runnable() &#123;
            public void run() &#123;
                try &#123;
                    mcr.writtenToDiskLatch.await();
                &#125; catch (InterruptedException ignored) &#123;
                &#125;
            &#125;
        &#125;;
</code></pre>
<p>所以如果写入比较慢，主线程就会出现ANR问题。</p>
<p><a target="_blank" rel="noopener" href="http://www.cloudchou.com/android/post-988.html">http://www.cloudchou.com/android/post-988.html</a></p>
<p>结论：<br>1.对于一个相同的SharedPreferences name，获取到的都是同一个SharedPreferences对象，它其实是SharedPreferencesImpl对象。<br>2.在UI线程中调用getXXX可能会导致ANR。<br>3.SharedPreferences只能用来存放少量数据，如果一个SharedPreferences对应的xml文件很大的话，在初始化时会把这个文件的所有数据都加载到内存中，这样就会占用大量的内存，有时我们只是想读取某个xml文件中一个key的value，结果它把整个文件都加载进来了，显然如果必要的话这里需要进行相关优化处理。<br>4.commit的写操作是在调用线程中执行的，而apply内部是用一个单线程的线程池实现的，因此写操作是在子线程中执行的。<br>5.SharedPreferences每次写入都是整个文件重新写入，不是增量写入。<br>6.apply也会造成anr。<br>参考：<br><a target="_blank" rel="noopener" href="http://blog.csdn.net/u012619640/article/details/50940074">http://blog.csdn.net/u012619640/article/details/50940074</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/24/Notes/Android/Framework/Android%E7%B3%BB%E7%BB%9F%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/24/Notes/Android/Framework/Android%E7%B3%BB%E7%BB%9F%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-24 23:08:49" itemprop="dateCreated datePublished" datetime="2021-02-24T23:08:49+08:00">2021-02-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="http://参考博客/">http://gityuan.com/2016/06/04/broadcast-receiver/</a><br><a target="_blank" rel="noopener" href="http://流程图/">https://rawgit.com/prife/VirtualAppDoc/master/pngs/Broadcast.svg</a></p>
<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>广播(Broadcast)机制用于进程/线程间通信，广播分为广播发送和广播接收两个过程，其中广播接收者BroadcastReceiver便是Android四大组件之一。</p>
<p>BroadcastReceiver分为两类：</p>
<pre><code>静态广播接收者：通过AndroidManifest.xml的标签来申明的BroadcastReceiver。
动态广播接收者：通过AMS.registerReceiver()方式注册的BroadcastReceiver，动态注册更为灵活，可在不需要时通过unregisterReceiver()取消注册。
</code></pre>
<p>从广播发送方式可分为三类：</p>
<pre><code>普通广播：通过Context.sendBroadcast()发送，可并行处理
有序广播：通过Context.sendOrderedBroadcast()发送，串行处理
Sticky广播：通过Context.sendStickyBroadcast()发送
</code></pre>
<h1 id="二、广播的注册过程"><a href="#二、广播的注册过程" class="headerlink" title="二、广播的注册过程"></a>二、广播的注册过程</h1><h1 id="2-1-registerReceiver-BroadcastReceiver-receiver-IntentFilter-filter"><a href="#2-1-registerReceiver-BroadcastReceiver-receiver-IntentFilter-filter" class="headerlink" title="2.1 registerReceiver(BroadcastReceiver receiver, IntentFilter filter)"></a>2.1 registerReceiver(BroadcastReceiver receiver, IntentFilter filter)</h1><h1 id="2-2-ContextWrapper-registerReceiver-receiver-filter"><a href="#2-2-ContextWrapper-registerReceiver-receiver-filter" class="headerlink" title="2.2 ContextWrapper.registerReceiver(receiver,filter)"></a>2.2 ContextWrapper.registerReceiver(receiver,filter)</h1><h1 id="2-3-ContextImpl-registerReceiver-receiver-filter"><a href="#2-3-ContextImpl-registerReceiver-receiver-filter" class="headerlink" title="2.3 ContextImpl.registerReceiver(receiver,filter)"></a>2.3 ContextImpl.registerReceiver(receiver,filter)</h1><pre><code>public Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter,
        String broadcastPermission, Handler scheduler) &#123;
    return registerReceiverInternal(receiver, getUserId(),
            filter, broadcastPermission, scheduler, getOuterContext());
&#125;

private Intent registerReceiverInternal(BroadcastReceiver receiver, int userId,
        IntentFilter filter, String broadcastPermission,
        Handler scheduler, Context context) &#123;
    //rd 的类型是LoadApk.ReceiverDispatcher.InnerReceiver的一个对象
    IIntentReceiver rd = null;
    if (receiver != null) &#123;
        if (mPackageInfo != null &amp;&amp; context != null) &#123;
            if (scheduler == null) &#123;
                scheduler = mMainThread.getHandler();
            &#125;
            rd = mPackageInfo.getReceiverDispatcher(
                receiver, context, scheduler,
                mMainThread.getInstrumentation(), true);
        &#125; else &#123;
            if (scheduler == null) &#123;
                scheduler = mMainThread.getHandler();
            &#125;
            rd = new LoadedApk.ReceiverDispatcher(
                    receiver, context, scheduler, null, true).getIIntentReceiver();
        &#125;
    &#125;
    try &#123;
        //调用到AMS的registerReceiver方法
        return ActivityManagerNative.getDefault().registerReceiver(
                mMainThread.getApplicationThread(), mBasePackageName,
                rd, filter, broadcastPermission, userId);
    &#125; catch (RemoteException e) &#123;
        return null;
    &#125;
&#125;
</code></pre>
<h1 id="step1：-rd-的创建过程"><a href="#step1：-rd-的创建过程" class="headerlink" title="step1： rd 的创建过程"></a>step1： rd 的创建过程</h1><p>ReceiverDispatcher(广播分发者)有一个内部类InnerReceiver，该类继承于IIntentReceiver.Stub。显然，这是一个Binder服务端，广播分发者通过rd.getIIntentReceiver()可获取该Binder服务端对象InnerReceiver，用于Binder IPC通信。</p>
<pre><code>frameworks/base/core/java/android/app/LoadedApk.java

static final class ReceiverDispatcher &#123;

    final static class InnerReceiver extends IIntentReceiver.Stub &#123;
        final WeakReference&lt;LoadedApk.ReceiverDispatcher&gt; mDispatcher;
        final LoadedApk.ReceiverDispatcher mStrongRef;

        InnerReceiver(LoadedApk.ReceiverDispatcher rd, boolean strong) &#123;
            mDispatcher = new WeakReference&lt;LoadedApk.ReceiverDispatcher&gt;(rd);
            mStrongRef = strong ? rd : null;
        &#125;
       ...
    &#125;

    final IIntentReceiver.Stub mIIntentReceiver;
    final BroadcastReceiver mReceiver;
    ...

     ReceiverDispatcher(BroadcastReceiver receiver, Context context,
            Handler activityThread, Instrumentation instrumentation,
            boolean registered) &#123;
        if (activityThread == null) &#123;
            throw new NullPointerException(&quot;Handler must not be null&quot;);
        &#125;

        mIIntentReceiver = new InnerReceiver(this, !registered);
        mReceiver = receiver;
        mContext = context;
        mActivityThread = activityThread;
        mInstrumentation = instrumentation;
        mRegistered = registered;
        mLocation = new IntentReceiverLeaked(null);
        mLocation.fillInStackTrace();
    &#125;
    ...
    IIntentReceiver getIIntentReceiver() &#123;
        return mIIntentReceiver;
    &#125;
</code></pre>
<h1 id="2-4-在AMS中注册"><a href="#2-4-在AMS中注册" class="headerlink" title="2.4 在AMS中注册"></a>2.4 在AMS中注册</h1><p>其中mRegisteredReceivers记录着所有已注册的广播，以receiver IBinder为key, ReceiverList为value为HashMap。另外，这个过程涉及对象ReceiverList，BroadcastFilter，BroadcastRecord的创建。</p>
<p>在BroadcastQueue中有两个广播队列mParallelBroadcasts,mOrderedBroadcasts，数据类型都为ArrayList：</p>
<pre><code>mParallelBroadcasts:并行广播队列，可以立刻执行，而无需等待另一个广播运行完成，该队列只允许动态已注册的广播，从而避免发生同时拉起大量进程来执行广播，前台的和后台的广播分别位于独立的队列。
mOrderedBroadcasts：有序广播队列，同一时间只允许执行一个广播，该队列顶部的广播便是活动广播，其他广播必须等待该广播结束才能运行，也是独立区别前台的和后台的广播。

public Intent registerReceiver(IApplicationThread caller, String callerPackage,
            IIntentReceiver receiver, IntentFilter filter, String permission, int userId) &#123;
        synchronized (this) &#123;
            if (callerApp != null &amp;&amp; (callerApp.thread == null
                    || callerApp.thread.asBinder() != caller.asBinder())) &#123;
                return null;
            &#125;
            //ReceiverList rl保存了相同InnerReceiver注册的广播接收者BroadcastFilter
            //mRegisteredReceivers的 final HashMap&lt;IBinder, ReceiverList&gt; mRegisteredReceivers
            //通过不同的InnerReceiver来区分不同的广播
            ReceiverList rl = mRegisteredReceivers.get(receiver.asBinder());
            if (rl == null) &#123;
                rl = new ReceiverList(this, callerApp, callingPid, callingUid,
                        userId, receiver);
                if (rl.app != null) &#123;
                    rl.app.receivers.add(rl);
                &#125; else &#123;
                    try &#123;
                        receiver.asBinder().linkToDeath(rl, 0);
                    &#125; catch (RemoteException e) &#123;
                        return sticky;
                    &#125;
                    rl.linkedToDeath = true;
                &#125;
                mRegisteredReceivers.put(receiver.asBinder(), rl);
            &#125; 
            //描述正在注册的广播接收者
            BroadcastFilter bf = new BroadcastFilter(filter, rl, callerPackage,
                    permission, callingUid, userId);
            //将注册的广播接收者BroadcastFilter 加入到ReceiverList中
            rl.add(bf);
            if (!bf.debugCheck()) &#123;
                Slog.w(TAG, &quot;==&gt; For Dynamic broadcast&quot;);
            &#125;
            //将广播接收者保存到内部的类成员变量mReceiverResolver中，所以BroadcastReceiver和InnerReceiver是成对存在的
            //final IntentResolver&lt;BroadcastFilter, BroadcastFilter&gt; mReceiverResolver
            mReceiverResolver.addFilter(bf);

            if (allSticky != null) &#123;
                ArrayList receivers = new ArrayList();
                receivers.add(bf);

                final int stickyCount = allSticky.size();
                for (int i = 0; i &lt; stickyCount; i++) &#123;
                    Intent intent = allSticky.get(i);
                    BroadcastQueue queue = broadcastQueueForIntent(intent);
                    BroadcastRecord r = new BroadcastRecord(queue, intent, null,
                            null, -1, -1, null, null, AppOpsManager.OP_NONE, null, receivers,
                            null, 0, null, null, false, true, true, -1);
                    queue.enqueueParallelBroadcastLocked(r);
                    queue.scheduleBroadcastsLocked();
                &#125;
            &#125;

            return sticky;
        &#125;
    &#125;
</code></pre>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>注册广播的过程，主要功能：<br>创建ReceiverList(接收者队列)，并添加到AMS.mRegisteredReceivers(已注册广播队列)；<br>创建BroadcastFilter(广播过滤者)，并添加到AMS.mReceiverResolver(接收者的解析人)；<br>当注册的是Sticky广播，则创建BroadcastRecord，并添加到BroadcastQueue的mParallelBroadcasts(并行广播队列)，注册后调用AMS来尽快处理该广播。</p>
<p>三、广播的发送过程</p>
<h1 id="3-1-sendBroadcast-intent"><a href="#3-1-sendBroadcast-intent" class="headerlink" title="3.1 sendBroadcast(intent)"></a>3.1 sendBroadcast(intent)</h1><h1 id="3-2-ContextWrapper-sendBroadcast-intent"><a href="#3-2-ContextWrapper-sendBroadcast-intent" class="headerlink" title="3.2 ContextWrapper.sendBroadcast(intent)"></a>3.2 ContextWrapper.sendBroadcast(intent)</h1><pre><code>frameworks/base/core/java/android/content/ContextWrapper.java

public void sendBroadcast(Intent intent) &#123;
        mBase.sendBroadcast(intent);
&#125;
</code></pre>
<h1 id="3-3-ContextImpl-sendBroadcast"><a href="#3-3-ContextImpl-sendBroadcast" class="headerlink" title="3.3 ContextImpl.sendBroadcast"></a>3.3 ContextImpl.sendBroadcast</h1><pre><code>frameworks/base/core/java/android/app/ContextImpl.java

public void sendBroadcast(Intent intent) &#123;
        warnIfCallingFromSystemProcess();
        String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
        try &#123;
            intent.prepareToLeaveProcess();
            ActivityManagerNative.getDefault().broadcastIntent(
                    mMainThread.getApplicationThread(), intent, resolvedType, null,
                    Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false,
                    getUserId());
        &#125; catch (RemoteException e) &#123;
            throw new RuntimeException(&quot;Failure from system&quot;, e);
        &#125;
    &#125;
</code></pre>
<h1 id="3-4-ActivityManagerProxy-broadcastIntent"><a href="#3-4-ActivityManagerProxy-broadcastIntent" class="headerlink" title="3.4 ActivityManagerProxy.broadcastIntent"></a>3.4 ActivityManagerProxy.broadcastIntent</h1><pre><code>frameworks/base/core/java/android/app/ActivityManagerNative.java

    public int broadcastIntent(IApplicationThread caller,
        Intent intent, String resolvedType, IIntentReceiver resultTo,
        int resultCode, String resultData, Bundle map,
        String[] requiredPermissions, int appOp, Bundle options, boolean serialized,
        boolean sticky, int userId) throws RemoteException
&#123;
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IActivityManager.descriptor);
    data.writeStrongBinder(caller != null ? caller.asBinder() : null);
    intent.writeToParcel(data, 0);
    data.writeString(resolvedType);
    data.writeStrongBinder(resultTo != null ? resultTo.asBinder() : null);
    data.writeInt(resultCode);
    data.writeString(resultData);
    data.writeBundle(map);
    data.writeStringArray(requiredPermissions);
    data.writeInt(appOp);
    data.writeBundle(options);
    data.writeInt(serialized ? 1 : 0);
    data.writeInt(sticky ? 1 : 0);
    data.writeInt(userId);
    mRemote.transact(BROADCAST_INTENT_TRANSACTION, data, reply, 0);
    reply.readException();
    int res = reply.readInt();
    reply.recycle();
    data.recycle();
    return res;
&#125;
</code></pre>
<h1 id="3-5-ActivityManagerService-broadcastIntent"><a href="#3-5-ActivityManagerService-broadcastIntent" class="headerlink" title="3.5 ActivityManagerService.broadcastIntent"></a>3.5 ActivityManagerService.broadcastIntent</h1><pre><code>frameworks/base/services/java/com/android/server/am/ActivityManagerService.java

public final int broadcastIntent(IApplicationThread caller,
        Intent intent, String resolvedType, IIntentReceiver resultTo,
        int resultCode, String resultData, Bundle resultExtras,
        String[] requiredPermissions, int appOp, Bundle options,
        boolean serialized, boolean sticky, int userId) &#123;
    enforceNotIsolatedCaller(&quot;broadcastIntent&quot;);
    synchronized(this) &#123;
        intent = verifyBroadcastLocked(intent);

        final ProcessRecord callerApp = getRecordForAppLocked(caller);
        final int callingPid = Binder.getCallingPid();
        final int callingUid = Binder.getCallingUid();
        final long origId = Binder.clearCallingIdentity();
        int res = broadcastIntentLocked(callerApp,
                callerApp != null ? callerApp.info.packageName : null,
                intent, resolvedType, resultTo, resultCode, resultData, resultExtras,
                requiredPermissions, appOp, null, serialized, sticky,
                callingPid, callingUid, userId);
        Binder.restoreCallingIdentity(origId);
        return res;
    &#125;
</code></pre>
<h1 id="3-6-ActivityManagerService-broadcastIntentLocked-分解为8个步骤解析"><a href="#3-6-ActivityManagerService-broadcastIntentLocked-分解为8个步骤解析" class="headerlink" title="3.6 ActivityManagerService.broadcastIntentLocked 分解为8个步骤解析"></a>3.6 ActivityManagerService.broadcastIntentLocked 分解为8个步骤解析</h1><h1 id="step1-设置广播flag"><a href="#step1-设置广播flag" class="headerlink" title="step1: 设置广播flag"></a>step1: 设置广播flag</h1><pre><code>添加flag=FLAG_EXCLUDE_STOPPED_PACKAGES，保证已停止app不会收到该广播；
当系统还没有启动完成，则不允许启动新进程，，即只有动态注册receiver才能接受广播
当非USER_ALL广播且当前用户并没有处于Running的情况下，除非是系统升级广播或者关机广播，否则直接返回。

BroadcastReceiver还有其他flag，位于Intent.java常量:
    FLAG_RECEIVER_REGISTERED_ONLY //只允许已注册receiver接收广播
    FLAG_RECEIVER_REPLACE_PENDING //新广播会替代相同广播
    FLAG_RECEIVER_FOREGROUND //只允许前台receiver接收广播
    FLAG_RECEIVER_NO_ABORT //对于有序广播，先接收到的receiver无权抛弃广播
    FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT //Boot完成之前，只允许已注册receiver接收广播
    FLAG_RECEIVER_BOOT_UPGRADE //升级模式下，允许系统准备就绪前可以发送广播

private final int broadcastIntentLocked(ProcessRecord callerApp,
        String callerPackage, Intent intent, String resolvedType,
        IIntentReceiver resultTo, int resultCode, String resultData,
        Bundle resultExtras, String[] requiredPermissions, int appOp, Bundle options,
        boolean ordered, boolean sticky, int callingPid, int callingUid, int userId) &#123;
    intent = new Intent(intent);

    // By default broadcasts do not go to stopped apps.
    intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
    
    // If we have not finished booting, don&#39;t allow this to launch new processes.
    if (!mProcessesReady &amp;&amp; (intent.getFlags()&amp;Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) &#123;
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
    &#125;
    
     // Make sure that the user who is receiving this broadcast is running.
    // If not, we will just skip it. Make an exception for shutdown broadcasts
    // and upgrade steps.

    if (userId != UserHandle.USER_ALL &amp;&amp; !isUserRunningLocked(userId, false)) &#123;
        if ((callingUid != Process.SYSTEM_UID
                || (intent.getFlags() &amp; Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0)
                &amp;&amp; !Intent.ACTION_SHUTDOWN.equals(intent.getAction())) &#123;
            Slog.w(TAG, &quot;Skipping broadcast of &quot; + intent
                    + &quot;: user &quot; + userId + &quot; is stopped&quot;);
            return ActivityManager.BROADCAST_FAILED_USER_STOPPED;
        &#125;
    &#125;
</code></pre>
<h1 id="step2-广播权限验证"><a href="#step2-广播权限验证" class="headerlink" title="step2: 广播权限验证"></a>step2: 广播权限验证</h1><p>对于callingAppId为SYSTEM_UID，PHONE_UID，SHELL_UID，BLUETOOTH_UID，NFC_UID之一或者callingUid == 0时都畅通无阻；<br>否则对于调用者进程为空并且不是persistent进程的情况下：<br>    1.当发送的是受保护广播mProtectedBroadcasts(只允许系统使用)，则抛出异常；<br>    2.当action为ACTION_APPWIDGET_CONFIGURE时，虽然不希望该应用发送这种广播，处于兼容性考虑，限制该广播只允许发送给自己，否则抛出异常。</p>
<pre><code>/*
     * Prevent non-system code (defined here to be non-persistent
     * processes) from sending protected broadcasts.
     */
    int callingAppId = UserHandle.getAppId(callingUid);
    if (callingAppId == Process.SYSTEM_UID || callingAppId == Process.PHONE_UID
        || callingAppId == Process.SHELL_UID || callingAppId == Process.BLUETOOTH_UID
        || callingAppId == Process.NFC_UID || callingUid == 0) &#123;
        // Always okay.
    &#125; else if (callerApp == null || !callerApp.persistent) &#123;
        try &#123;
            if (AppGlobals.getPackageManager().isProtectedBroadcast(
                    intent.getAction())) &#123;
                String msg = &quot;Permission Denial: not allowed to send broadcast &quot;
                        + intent.getAction() + &quot; from pid=&quot;
                        + callingPid + &quot;, uid=&quot; + callingUid;
                Slog.w(TAG, msg);
                throw new SecurityException(msg);
            &#125; else if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(intent.getAction())) &#123;
                // Special case for compatibility: we don&#39;t want apps to send this,
                // but historically it has not been protected and apps may be using it
                // to poke their own app widget.  So, instead of making it protected,
                // just limit it to the caller.
                if (callerApp == null) &#123;
                    String msg = &quot;Permission Denial: not allowed to send broadcast &quot;
                            + intent.getAction() + &quot; from unknown caller.&quot;;
                    Slog.w(TAG, msg);
                    throw new SecurityException(msg);
                &#125; else if (intent.getComponent() != null) &#123;
                    // They are good enough to send to an explicit component...  verify
                    // it is being sent to the calling app.
                    if (!intent.getComponent().getPackageName().equals(
                            callerApp.info.packageName)) &#123;
                        String msg = &quot;Permission Denial: not allowed to send broadcast &quot;
                                + intent.getAction() + &quot; to &quot;
                                + intent.getComponent().getPackageName() + &quot; from &quot;
                                + callerApp.info.packageName;
                        Slog.w(TAG, msg);
                        throw new SecurityException(msg);
                    &#125;
                &#125; else &#123;
                    // Limit broadcast to their own package.
                    intent.setPackage(callerApp.info.packageName);
                &#125;
            &#125;
        &#125; catch (RemoteException e) &#123;
            Slog.w(TAG, &quot;Remote exception&quot;, e);
            return ActivityManager.BROADCAST_SUCCESS;
        &#125;
    &#125;
</code></pre>
<h1 id="step3-处理系统相关广播"><a href="#step3-处理系统相关广播" class="headerlink" title="step3: 处理系统相关广播"></a>step3: 处理系统相关广播</h1><pre><code>这个过程代码较长，主要处于系统相关的广播，如下10个case：
case Intent.ACTION_UID_REMOVED: //uid移除
case Intent.ACTION_PACKAGE_REMOVED: //package移除，
case Intent.ACTION_PACKAGE_CHANGED: //package改变
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE: //外部设备不可用时，强制停止所有波及的应用并清空cache数据
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE: //外部设备可用
case Intent.ACTION_PACKAGE_ADDED: //增加package，处于兼容考虑

case Intent.ACTION_TIMEZONE_CHANGED: //时区改变，通知所有运行中的进程
case Intent.ACTION_TIME_CHANGED: //时间改变，通知所有运行中的进程
case Intent.ACTION_CLEAR_DNS_CACHE: //dns缓存清空
case Proxy.PROXY_CHANGE_ACTION: //网络代理改变

final String action = intent.getAction();
if (action != null) &#123;
    switch (action) &#123;
        case Intent.ACTION_UID_REMOVED:
            mBatteryStatsService.removeUid(uid);
            mAppOpsService.uidRemoved(uid);
            break;
        case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
            String list[] = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
            if (list != null &amp;&amp; list.length &gt; 0) &#123;
                for (int i = 0; i &lt; list.length; i++) &#123;
                    forceStopPackageLocked(list[i], -1, false, true, true,
                            false, false, userId, &quot;storage unmount&quot;);
                &#125;
                mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
                sendPackageBroadcastLocked(
                    IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE, list,userId);
            &#125;
            break;
        case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE
            mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
            break;
        case Intent.ACTION_PACKAGE_REMOVED:
        case Intent.ACTION_PACKAGE_CHANGED:
            Uri data = intent.getData();
            boolean removed = Intent.ACTION_PACKAGE_REMOVED.equals(action);
            boolean fullUninstall = removed &amp;&amp; !intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
            final boolean killProcess = !intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP, false);
            if (killProcess) &#123;
                forceStopPackageLocked(ssp, UserHandle.getAppId(
                        intent.getIntExtra(Intent.EXTRA_UID, -1)),
                        false, true, true, false, fullUninstall, userId,
                        removed ? &quot;pkg removed&quot; : &quot;pkg changed&quot;);
            &#125;
            if (removed) &#123;
                sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REMOVED,new String[] &#123;ssp&#125;, userId);
                if (fullUninstall) &#123;
                    mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID, -1), ssp);
                    removeUriPermissionsForPackageLocked(ssp, userId, true);
                    removeTasksByPackageNameLocked(ssp, userId);
                    mBatteryStatsService.notePackageUninstalled(ssp);
                &#125;
            &#125; else &#123;
                cleanupDisabledPackageComponentsLocked(ssp, userId, killProcess,
                        intent.getStringArrayExtra(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST));
            &#125;
            break;

        case Intent.ACTION_PACKAGE_ADDED:
            Uri data = intent.getData();
            final boolean replacing =intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
            mCompatModePackages.handlePackageAddedLocked(ssp, replacing);
            ApplicationInfo ai = AppGlobals.getPackageManager().getApplicationInfo(ssp, 0, 0);
            break;
        case Intent.ACTION_TIMEZONE_CHANGED:
            mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
            break;
        case Intent.ACTION_TIME_CHANGED:
            final int is24Hour = intent.getBooleanExtra(Intent.EXTRA_TIME_PREF_24_HOUR_FORMAT, false) ? 1: 0;
            mHandler.sendMessage(mHandler.obtainMessage(UPDATE_TIME, is24Hour, 0));
            BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();
            synchronized (stats) &#123;
                stats.noteCurrentTimeChangedLocked();
            &#125;
            break;
        case Intent.ACTION_CLEAR_DNS_CACHE:
            mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
            break;
        case Proxy.PROXY_CHANGE_ACTION:
            ProxyInfo proxy = intent.getParcelableExtra(Proxy.EXTRA_PROXY_INFO);
            mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG, proxy));
            break;
    &#125;
&#125;
</code></pre>
<h1 id="step4：增加sticky广播"><a href="#step4：增加sticky广播" class="headerlink" title="step4：增加sticky广播"></a>step4：增加sticky广播</h1><pre><code>这个过程主要是将sticky广播增加到list，并放入mStickyBroadcasts里面。

if (sticky) &#123;
    if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,
            callingPid, callingUid)
            != PackageManager.PERMISSION_GRANTED) &#123;
        throw new SecurityException(&quot;&quot;);
    &#125;
    if (requiredPermissions != null &amp;&amp; requiredPermissions.length &gt; 0) &#123;
        return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
    &#125;

    if (intent.getComponent() != null) &#123;
       //当sticky广播发送给指定组件，则throw Exception
    &#125;
    if (userId != UserHandle.USER_ALL) &#123;
       //当非USER_ALL广播跟USER_ALL广播出现冲突,则throw Exception
    &#125;

    ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt; stickies = mStickyBroadcasts.get(userId);
    if (stickies == null) &#123;
        stickies = new ArrayMap&lt;&gt;();
        mStickyBroadcasts.put(userId, stickies);
    &#125;
    ArrayList&lt;Intent&gt; list = stickies.get(intent.getAction());
    if (list == null) &#123;
        list = new ArrayList&lt;&gt;();
        stickies.put(intent.getAction(), list);
    &#125;
    final int stickiesCount = list.size();
    int i;
    for (i = 0; i &lt; stickiesCount; i++) &#123;
        if (intent.filterEquals(list.get(i))) &#123;
            //替换已存在的sticky intent
            list.set(i, new Intent(intent));
            break;
        &#125;
    &#125;
    //新的intent追加到list
    if (i &gt;= stickiesCount) &#123;
        list.add(new Intent(intent));
    &#125;
&#125;
</code></pre>
<h1 id="step5：查询receivers和registeredReceivers"><a href="#step5：查询receivers和registeredReceivers" class="headerlink" title="step5：查询receivers和registeredReceivers"></a>step5：查询receivers和registeredReceivers</h1><p>receivers：记录着匹配当前intent的所有静态注册广播接收者；<br>registeredReceivers：记录着匹配当前的所有动态注册的广播接收者。<br>其中，mReceiverResolver是AMS的成员变量，记录着已注册的广播接收者的resolver.</p>
<pre><code>int[] users;
if (userId == UserHandle.USER_ALL) &#123;
    users = mStartedUserArray; //广播给所有已启动用户
&#125; else &#123;
    users = new int[] &#123;userId&#125;; //广播给指定用户
&#125;

List receivers = null;
List&lt;BroadcastFilter&gt; registeredReceivers = null;
//找出所有能接收该广播的receivers
if ((intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) &#123;
    //根据intent查找相应的receivers,查询静态注册的广播
    receivers = collectReceiverComponents(intent, resolvedType, callingUid, users);
&#125;
if (intent.getComponent() == null) &#123;
    if (userId == UserHandle.USER_ALL &amp;&amp; callingUid == Process.SHELL_UID) &#123;
        UserManagerService ums = getUserManagerLocked();
        for (int i = 0; i &lt; users.length; i++) &#123;
            //shell用户是否开启允许debug功能
            if (ums.hasUserRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES, users[i])) &#123;
                continue;
            &#125;
            // 查询动态注册的广播
            List&lt;BroadcastFilter&gt; registeredReceiversForUser =
                    mReceiverResolver.queryIntent(intent,
                            resolvedType, false, users[i]);
            if (registeredReceivers == null) &#123;
                registeredReceivers = registeredReceiversForUser;
            &#125; else if (registeredReceiversForUser != null) &#123;
                registeredReceivers.addAll(registeredReceiversForUser);
            &#125;
        &#125;
    &#125; else &#123;
        // 查询动态注册的广播
        registeredReceivers = mReceiverResolver.queryIntent(intent,
                resolvedType, false, userId);
    &#125;
&#125;

AMS.collectReceiverComponents：

private List&lt;ResolveInfo&gt; collectReceiverComponents(Intent intent, String resolvedType,
    int callingUid, int[] users) &#123;
List&lt;ResolveInfo&gt; receivers = null;
for (int user : users) &#123;
    //调用PKMS.queryIntentReceivers，可获取AndroidManifest.xml声明的接收者信息
    List&lt;ResolveInfo&gt; newReceivers = AppGlobals.getPackageManager()
            .queryIntentReceivers(intent, resolvedType, STOCK_PM_FLAGS, user);
    if (receivers == null) &#123;
        receivers = newReceivers;
    &#125; else if (newReceivers != null) &#123;
        ...
        //将所用户的receiver整合到receivers
    &#125;
 &#125;
return receivers;
&#125;
</code></pre>
<h1 id="step6：处理并行广播"><a href="#step6：处理并行广播" class="headerlink" title="step6：处理并行广播"></a>step6：处理并行广播</h1><p>广播队列中有一个成员变量mParallelBroadcasts，类型为ArrayList，记录着所有的并行广播。</p>
<pre><code>//用于标识是否需要用新intent替换旧的intent。
final boolean replacePending = (intent.getFlags()&amp;Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
//处理并行广播
int NR = registeredReceivers != null ? registeredReceivers.size() : 0;
if (!ordered &amp;&amp; NR &gt; 0) &#123;
    final BroadcastQueue queue = broadcastQueueForIntent(intent);
    //创建BroadcastRecord对象
    BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp,
            callerPackage, callingPid, callingUid, resolvedType, requiredPermissions,
            appOp, brOptions, registeredReceivers, resultTo, resultCode, resultData,
            resultExtras, ordered, sticky, false, userId);

    final boolean replaced = replacePending &amp;&amp; queue.replaceParallelBroadcastLocked(r);
    if (!replaced) &#123;
        //将BroadcastRecord加入到并行广播队列
        queue.enqueueParallelBroadcastLocked(r);
        //处理广播【见小节4.1】
        queue.scheduleBroadcastsLocked();
    &#125;
    registeredReceivers = null;
    NR = 0;
&#125;
</code></pre>
<h1 id="step7：合并registeredReceivers到receivers"><a href="#step7：合并registeredReceivers到receivers" class="headerlink" title="step7：合并registeredReceivers到receivers"></a>step7：合并registeredReceivers到receivers</h1><pre><code>int ir = 0;
if (receivers != null) &#123;
    //防止应用监听该广播，在安装时直接运行。
    String skipPackages[] = null;
    if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction())
            || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction())
            || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) &#123;
        Uri data = intent.getData();
        if (data != null) &#123;
            String pkgName = data.getSchemeSpecificPart();
            if (pkgName != null) &#123;
                skipPackages = new String[] &#123; pkgName &#125;;
            &#125;
        &#125;
    &#125; else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) &#123;
        skipPackages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
    &#125;

    //将skipPackages相关的广播接收者从receivers列表中移除
    if (skipPackages != null &amp;&amp; (skipPackages.length &gt; 0)) &#123;
        for (String skipPackage : skipPackages) &#123;
            if (skipPackage != null) &#123;
                int NT = receivers.size();
                for (int it=0; it&lt;NT; it++) &#123; ResolveInfo curt = (ResolveInfo)receivers.get(it); if (curt.activityInfo.packageName.equals(skipPackage)) &#123; receivers.remove(it); it--; NT--; &#125; &#125; &#125; &#125; &#125; //前面part6有一个处理动态广播的过程，处理完后再执行将动态注册的registeredReceivers合并到receivers int NT = receivers != null ? receivers.size() : 0; int it = 0; ResolveInfo curt = null; BroadcastFilter curr = null; while (it &lt; NT &amp;&amp; ir &lt; NR) &#123; if (curt == null) &#123; curt = (ResolveInfo)receivers.get(it); &#125; if (curr == null) &#123; curr = registeredReceivers.get(ir); &#125; if (curr.getPriority()&gt;= curt.priority) &#123;
            receivers.add(it, curr);
            ir++;
            curr = null;
            it++;
            NT++;
        &#125; else &#123;
            it++;
            curt = null;
        &#125;
    &#125;
&#125;
while (ir &lt; NR) &#123;
    if (receivers == null) &#123;
        receivers = new ArrayList();
    &#125;
    receivers.add(registeredReceivers.get(ir));
    ir++;
&#125;
</code></pre>
<h1 id="step8-处理串行广播"><a href="#step8-处理串行广播" class="headerlink" title="step8: 处理串行广播"></a>step8: 处理串行广播</h1><p>广播队列中有一个成员变量mOrderedBroadcasts，类型为ArrayList，记录着所有的有序广播。</p>
<pre><code>    if ((receivers != null &amp;&amp; receivers.size() &gt; 0)
        || resultTo != null) &#123;
    BroadcastQueue queue = broadcastQueueForIntent(intent);
    //创建BroadcastRecord
    BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp,
            callerPackage, callingPid, callingUid, resolvedType,
            requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode,
            resultData, resultExtras, ordered, sticky, false, userId);

    boolean replaced = replacePending &amp;&amp; queue.replaceOrderedBroadcastLocked(r);
    if (!replaced) &#123;
        //将BroadcastRecord加入到有序广播队列
        queue.enqueueOrderedBroadcastLocked(r);
        //处理广播【见小节4.1】
        queue.scheduleBroadcastsLocked();
    &#125;
&#125;
</code></pre>
<h1 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h1><pre><code>注册广播的小节[2.4]阶段, 会处理Sticky广播;
发送广播的[step 6]阶段, 会处理并行广播;
发送广播的[step 8]阶段, 会处理串行广播;
</code></pre>
<p>上述3个处理过程都是通过调用scheduleBroadcastsLocked()方法来完成的,接下来再来看看这个方法.</p>
<h1 id="四、-处理广播"><a href="#四、-处理广播" class="headerlink" title="四、 处理广播"></a>四、 处理广播</h1><p>在发送广播过程中会执行scheduleBroadcastsLocked方法来处理相关的广播</p>
<pre><code>base/services/core/java/com/android/server/am/BroadcastQueue
</code></pre>
<h1 id="4-1-scheduleBroadcastsLocked"><a href="#4-1-scheduleBroadcastsLocked" class="headerlink" title="4.1 scheduleBroadcastsLocked"></a>4.1 scheduleBroadcastsLocked</h1><pre><code>public void scheduleBroadcastsLocked() &#123;
        if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;Schedule broadcasts [&quot;
                + mQueueName + &quot;]: current=&quot;
                + mBroadcastsScheduled);

        if (mBroadcastsScheduled) &#123;
            return;
        &#125;
        mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this));
        mBroadcastsScheduled = true;
    &#125;
</code></pre>
<h1 id="4-2-handleMessage"><a href="#4-2-handleMessage" class="headerlink" title="4.2 handleMessage"></a>4.2 handleMessage</h1><p>调用到processNextBroadcast</p>
<pre><code>private final class BroadcastHandler extends Handler &#123;
    public BroadcastHandler(Looper looper) &#123;
        super(looper, null, true);
    &#125;

    @Override
    public void handleMessage(Message msg) &#123;
        switch (msg.what) &#123;
            case BROADCAST_INTENT_MSG: &#123;
                if (DEBUG_BROADCAST) Slog.v(
                        TAG_BROADCAST, &quot;Received BROADCAST_INTENT_MSG&quot;);
                processNextBroadcast(true);
            &#125; break;
            ...
            &#125;
</code></pre>
<h1 id="4-3-processNextBroadcast"><a href="#4-3-processNextBroadcast" class="headerlink" title="4.3 processNextBroadcast"></a>4.3 processNextBroadcast</h1><p>此处mService为AMS，整个流程还是比较长的，全程持有AMS锁，所以广播效率低的情况下，直接会严重影响这个手机的性能与流畅度，这里应该考虑细化同步锁的粒度。</p>
<pre><code>final void processNextBroadcast(boolean fromMsg) &#123;
synchronized(mService) &#123;
    //step1: 处理并行广播
    //step2: 处理当前有序广播
    //step3: 获取下条有序广播
    //step4: 处理下条有序广播
    &#125;
&#125;
</code></pre>
<h1 id="step1-处理并行广播"><a href="#step1-处理并行广播" class="headerlink" title="step1: 处理并行广播"></a>step1: 处理并行广播</h1><pre><code>BroadcastRecord r;
mService.updateCpuStats(); //更新CPU统计信息
if (fromMsg)  mBroadcastsScheduled = false;

while (mParallelBroadcasts.size() &gt; 0) &#123;
    r = mParallelBroadcasts.remove(0);
    r.dispatchTime = SystemClock.uptimeMillis();
    r.dispatchClockTime = System.currentTimeMillis();
    final int N = r.receivers.size();
    for (int i=0; i&lt;N; i++) &#123; Object target = r.receivers.get(i); //分发广播给已注册的receiver 【见小节4.3】 deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, false); &#125; addBroadcastToHistoryLocked(r);//将广播添加历史统计 &#125; # step2: 处理当前有序广播 if (mPendingBroadcast != null) &#123; boolean isDead; synchronized (mService.mPidsSelfLocked) &#123; //从mPidsSelfLocked获取正在处理该广播进程，判断该进程是否死亡 ProcessRecord proc = mService.mPidsSelfLocked.get(mPendingBroadcast.curApp.pid); isDead = proc == null || proc.crashing; &#125; if (!isDead) &#123; //正在处理广播的进程保持活跃状态，则继续等待其执行完成 return; &#125; else &#123; mPendingBroadcast.state = BroadcastRecord.IDLE; mPendingBroadcast.nextReceiver = mPendingBroadcastRecvIndex; mPendingBroadcast = null; &#125; &#125; boolean looped = false; do &#123; if (mOrderedBroadcasts.size() == 0) &#123; //所有串行广播处理完成，则调度执行gc mService.scheduleAppGcsLocked(); if (looped) &#123; mService.updateOomAdjLocked(); &#125; return; &#125; r = mOrderedBroadcasts.get(0); boolean forceReceive = false; //获取所有该广播所有的接收者 int numReceivers = (r.receivers != null) ? r.receivers.size() : 0; if (mService.mProcessesReady &amp;&amp; r.dispatchTime&gt; 0) &#123;
        long now = SystemClock.uptimeMillis();
        if ((numReceivers &gt; 0) &amp;&amp;
                (now &gt; r.dispatchTime + (2*mTimeoutPeriod*numReceivers))) &#123;
            //当广播处理时间超时，则强制结束这条广播
            broadcastTimeoutLocked(false);
            forceReceive = true;
            r.state = BroadcastRecord.IDLE;
        &#125;
    &#125;

    if (r.state != BroadcastRecord.IDLE) &#123;
        return;
    &#125;

    if (r.receivers == null || r.nextReceiver &gt;= numReceivers
            || r.resultAbort || forceReceive) &#123;
        if (r.resultTo != null) &#123;
            //处理广播消息消息，调用到onReceive()
            performReceiveLocked(r.callerApp, r.resultTo,
                new Intent(r.intent), r.resultCode,
                r.resultData, r.resultExtras, false, false, r.userId);
            r.resultTo = null;
        &#125;
        //取消BROADCAST_TIMEOUT_MSG消息
        cancelBroadcastTimeoutLocked();

        addBroadcastToHistoryLocked(r);
        mOrderedBroadcasts.remove(0);
        r = null;
        looped = true;
        continue;
    &#125;
&#125; while (r == null);
</code></pre>
<h1 id="step3-获取下条有序广播"><a href="#step3-获取下条有序广播" class="headerlink" title="step3: 获取下条有序广播"></a>step3: 获取下条有序广播</h1><p>mTimeoutPeriod，对于前台广播则为10s，对于后台广播则为60s。广播超时为2<em>mTimeoutPeriod</em>numReceivers，接收者个数numReceivers越多则广播超时总时长越大。</p>
<pre><code>//获取下一个receiver的index
int recIdx = r.nextReceiver++;

r.receiverTime = SystemClock.uptimeMillis();
if (recIdx == 0) &#123;
    r.dispatchTime = r.receiverTime;
    r.dispatchClockTime = System.currentTimeMillis();
&#125;
if (!mPendingBroadcastTimeoutMessage) &#123;
    long timeoutTime = r.receiverTime + mTimeoutPeriod;
    //设置广播超时时间，发送BROADCAST_TIMEOUT_MSG
    setBroadcastTimeoutLocked(timeoutTime);
&#125;

final BroadcastOptions brOptions = r.options;
//获取下一个广播接收者
final Object nextReceiver = r.receivers.get(recIdx);

if (nextReceiver instanceof BroadcastFilter) &#123;
    //对于动态注册的广播接收者，deliverToRegisteredReceiverLocked处理广播
    BroadcastFilter filter = (BroadcastFilter)nextReceiver;
    deliverToRegisteredReceiverLocked(r, filter, r.ordered);
    if (r.receiver == null || !r.ordered) &#123;
        r.state = BroadcastRecord.IDLE;
        scheduleBroadcastsLocked();
    &#125; else &#123;
        ...
    &#125;
    return;
&#125;

//对于静态注册的广播接收者
ResolveInfo info = (ResolveInfo)nextReceiver;
ComponentName component = new ComponentName(
        info.activityInfo.applicationInfo.packageName,
        info.activityInfo.name);
...
//执行各种权限检测，此处省略，当权限不满足时skip=true

if (skip) &#123;
    r.receiver = null;
    r.curFilter = null;
    r.state = BroadcastRecord.IDLE;
    scheduleBroadcastsLocked();
    return;
&#125;

r.state = BroadcastRecord.APP_RECEIVE;
String targetProcess = info.activityInfo.processName;
r.curComponent = component;
final int receiverUid = info.activityInfo.applicationInfo.uid;
if (r.callingUid != Process.SYSTEM_UID &amp;&amp; isSingleton
        &amp;&amp; mService.isValidSingletonCall(r.callingUid, receiverUid)) &#123;
    info.activityInfo = mService.getActivityInfoForUser(info.activityInfo, 0);
&#125;
r.curReceiver = info.activityInfo;
...

//Broadcast正在执行中，stopped状态设置成false
AppGlobals.getPackageManager().setPackageStoppedState(
        r.curComponent.getPackageName(), false, UserHandle.getUserId(r.callingUid));
</code></pre>
<h1 id="step4-处理下条有序广播"><a href="#step4-处理下条有序广播" class="headerlink" title="step4: 处理下条有序广播"></a>step4: 处理下条有序广播</h1><p>如果是动态广播接收者，则调用deliverToRegisteredReceiverLocked处理；<br>如果是静态广播接收者，且对应进程已经创建，则调用processCurBroadcastLocked处理；<br>如果是静态广播接收者，且对应进程尚未创建，则调用startProcessLocked创建进程。</p>
<pre><code>//该receiver所对应的进程已经运行，则直接处理
    ProcessRecord app = mService.getProcessRecordLocked(targetProcess,
            info.activityInfo.applicationInfo.uid, false);
    if (app != null &amp;&amp; app.thread != null) &#123;
        try &#123;
            app.addPackage(info.activityInfo.packageName,
                    info.activityInfo.applicationInfo.versionCode, mService.mProcessStats);
            processCurBroadcastLocked(r, app);
            return;
        &#125; catch (RemoteException e) &#123;
        &#125; catch (RuntimeException e) &#123;
            finishReceiverLocked(r, r.resultCode, r.resultData, r.resultExtras, r.resultAbort, false);
            scheduleBroadcastsLocked();
            r.state = BroadcastRecord.IDLE; //启动receiver失败则重置状态
            return;
        &#125;
    &#125;
    
    //该receiver所对应的进程尚未启动，则创建该进程
    if ((r.curApp=mService.startProcessLocked(targetProcess,
            info.activityInfo.applicationInfo, true,
            r.intent.getFlags() | Intent.FLAG_FROM_BACKGROUND,
            &quot;broadcast&quot;, r.curComponent,
            (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_BOOT_UPGRADE) != 0, false, false))
                    == null) &#123;
        //创建失败，则结束该receiver
        finishReceiverLocked(r, r.resultCode, r.resultData,
                r.resultExtras, r.resultAbort, false);
        scheduleBroadcastsLocked();
        r.state = BroadcastRecord.IDLE;
        return;
    &#125;
    mPendingBroadcast = r;
    mPendingBroadcastRecvIndex = recIdx;
</code></pre>
<h1 id="4-3-deliverToRegisteredReceiverLocked"><a href="#4-3-deliverToRegisteredReceiverLocked" class="headerlink" title="4.3 deliverToRegisteredReceiverLocked"></a>4.3 deliverToRegisteredReceiverLocked</h1><pre><code>private void deliverToRegisteredReceiverLocked(BroadcastRecord r,
        BroadcastFilter filter, boolean ordered) &#123;
        ...
        //检查发送者是否有BroadcastFilter所需权限
        //以及接收者是否有发送者所需的权限等等
        //当权限不满足要求，则skip=true。
    
        if (!skip) &#123;
            //并行广播ordered = false，只有串行广播才进入该分支
            if (ordered) &#123;
                r.receiver = filter.receiverList.receiver.asBinder();
                r.curFilter = filter;
                filter.receiverList.curBroadcast = r;
                r.state = BroadcastRecord.CALL_IN_RECEIVE;
                if (filter.receiverList.app != null) &#123;
                    r.curApp = filter.receiverList.app;
                    filter.receiverList.app.curReceiver = r;
                    mService.updateOomAdjLocked(r.curApp);
                &#125;
            &#125;
            // 处理广播【见小节4.4】
            performReceiveLocked(filter.receiverList.app, filter.receiverList.receiver,
                    new Intent(r.intent), r.resultCode, r.resultData,
                    r.resultExtras, r.ordered, r.initialSticky, r.userId);
            if (ordered) &#123;
                r.state = BroadcastRecord.CALL_DONE_RECEIVE;
            &#125;
            ...
        &#125;
    &#125;
</code></pre>
<h1 id="4-4-performReceiveLocked"><a href="#4-4-performReceiveLocked" class="headerlink" title="4.4 performReceiveLocked"></a>4.4 performReceiveLocked</h1><pre><code>private static void performReceiveLocked(ProcessRecord app, IIntentReceiver receiver,
    Intent intent, int resultCode, String data, Bundle extras,
    boolean ordered, boolean sticky, int sendingUser) throws RemoteException &#123;
//通过binder异步机制，向receiver发送intent
if (app != null) &#123;
    if (app.thread != null) &#123;
        //调用ApplicationThreadProxy类对应的方法 【4.5】
        app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode,
                data, extras, ordered, sticky, sendingUser, app.repProcState);
    &#125; else &#123;
        //应用进程死亡，则Recevier并不存在
        throw new RemoteException(&quot;app.thread must not be null&quot;);
    &#125;
&#125; else &#123;
    //调用者进程为空，则执行该分支
    receiver.performReceive(intent, resultCode, data, extras, ordered,
            sticky, sendingUser);
&#125;
</code></pre>
<p>}</p>
<h1 id="4-5-ATP-scheduleRegisteredReceiver"><a href="#4-5-ATP-scheduleRegisteredReceiver" class="headerlink" title="4.5 ATP.scheduleRegisteredReceiver"></a>4.5 ATP.scheduleRegisteredReceiver</h1><p>ATP位于system_server进程，是Binder Bp端通过Binder驱动向Binder Bn端发送消息, ATP所对应的Bn端位于发送广播调用端所在进程的ApplicationThread，即进入AT.scheduleRegisteredReceiver， 接下来说明该方</p>
<pre><code>public void scheduleRegisteredReceiver(IIntentReceiver receiver, Intent intent,
        int resultCode, String dataStr, Bundle extras, boolean ordered,
        boolean sticky, int sendingUser, int processState) throws RemoteException &#123;
    Parcel data = Parcel.obtain();
    data.writeInterfaceToken(IApplicationThread.descriptor);
    data.writeStrongBinder(receiver.asBinder());
    intent.writeToParcel(data, 0);
    data.writeInt(resultCode);
    data.writeString(dataStr);
    data.writeBundle(extras);
    data.writeInt(ordered ? 1 : 0);
    data.writeInt(sticky ? 1 : 0);
    data.writeInt(sendingUser);
    data.writeInt(processState);

    //command=SCHEDULE_REGISTERED_RECEIVER_TRANSACTION
    mRemote.transact(SCHEDULE_REGISTERED_RECEIVER_TRANSACTION, data, null,
            IBinder.FLAG_ONEWAY);
    data.recycle();
&#125;
</code></pre>
<h1 id="4-6-scheduleRegisteredReceiver"><a href="#4-6-scheduleRegisteredReceiver" class="headerlink" title="4.6 scheduleRegisteredReceiver"></a>4.6 scheduleRegisteredReceiver</h1><p>IPC过程 最终调用到ActivityThread.scheduleRegisteredReceiver,此处receiver是注册广播时创建的，见小节[2.3]，可知该receiver=LoadedApk.ReceiverDispatcher.InnerReceiver。</p>
<pre><code>public void scheduleRegisteredReceiver(IIntentReceiver receiver, Intent intent,
        int resultCode, String dataStr, Bundle extras, boolean ordered,
        boolean sticky, int sendingUser, int processState) throws RemoteException &#123;
    //更新虚拟机进程状态
    updateProcessState(processState, false);
    //【见小节4.7】
    receiver.performReceive(intent, resultCode, dataStr, extras, ordered,
            sticky, sendingUser);
&#125;
</code></pre>
<h1 id="4-7-InnerReceiver-performReceive"><a href="#4-7-InnerReceiver-performReceive" class="headerlink" title="4.7 InnerReceiver.performReceive"></a>4.7 InnerReceiver.performReceive</h1><pre><code>base/core/java/android/app/LoadedApk.java
public void performReceive(Intent intent, int resultCode, String data,
        Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123;
    LoadedApk.ReceiverDispatcher rd = mDispatcher.get();
    if (rd != null) &#123;
        //【4.8】
        rd.performReceive(intent, resultCode, data, extras, ordered, sticky, sendingUser);
    &#125; else &#123;
       ...
    &#125;
&#125;
</code></pre>
<h1 id="4-8-ReceiverDispatcher-performReceive"><a href="#4-8-ReceiverDispatcher-performReceive" class="headerlink" title="4.8 ReceiverDispatcher.performReceive"></a>4.8 ReceiverDispatcher.performReceive</h1><p>其中Args继承于BroadcastReceiver.PendingResult，实现了接口Runnable。这里mActivityThread.post(args) 消息机制，关于Handler消息机制，见Android消息机制1-Handler(Java层)，把消息放入MessageQueue，再调用Args的run()方法。</p>
<pre><code>public void performReceive(Intent intent, int resultCode, String data,
        Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123;
    Args args = new Args(intent, resultCode, data, extras, ordered,
            sticky, sendingUser);
    //通过handler消息机制发送args.
    if (!mActivityThread.post(args)) &#123;
        if (mRegistered &amp;&amp; ordered) &#123;
            IActivityManager mgr = ActivityManagerNative.getDefault();
            args.sendFinished(mgr);
        &#125;
    &#125;
&#125;
</code></pre>
<h1 id="4-9-Args-run"><a href="#4-9-Args-run" class="headerlink" title="4.9 Args.run"></a>4.9 Args.run</h1><p>最终调用BroadcastReceiver具体实现类的onReceive()方法，至此广播的处理过程结束,后续是AMS的一些处理过程</p>
<pre><code>public final class LoadedApk &#123;
  static final class ReceiverDispatcher &#123;
    final class Args extends BroadcastReceiver.PendingResult implements Runnable &#123;
        public void run() &#123;
            final BroadcastReceiver receiver = mReceiver;
            final boolean ordered = mOrdered;

            final IActivityManager mgr = ActivityManagerNative.getDefault();
            final Intent intent = mCurIntent;
            mCurIntent = null;

            if (receiver == null || mForgotten) &#123;
                if (mRegistered &amp;&amp; ordered) &#123;
                    sendFinished(mgr);
                &#125;
                return;
            &#125;

            try &#123;
                //获取mReceiver的类加载器
                ClassLoader cl =  mReceiver.getClass().getClassLoader();
                intent.setExtrasClassLoader(cl);
                setExtrasClassLoader(cl);
                receiver.setPendingResult(this);
                //回调广播onReceive方法
                receiver.onReceive(mContext, intent);
            &#125; catch (Exception e) &#123;
                ...
            &#125;
            //调用到BroadcastReceiver.finishReceiver
            if (receiver.getPendingResult() != null) &#123;
                finish();
            &#125;
        &#125;
      &#125;
    &#125;
</code></pre>
<p>​        </p>
<h1 id="4-10-PendingResult-finish"><a href="#4-10-PendingResult-finish" class="headerlink" title="4.10 PendingResult.finish"></a>4.10 PendingResult.finish</h1><p>此处AMP.finishReceiver，经过binder调用，进入AMS.finishReceiver方法,</p>
<pre><code>base/core/java/android/content/BroadcastReceiver.java

public final void finish() &#123;
    final IActivityManager mgr = ActivityManagerNative.getDefault();
    sendFinished(mgr);
    ...
&#125;

public void sendFinished(IActivityManager am) &#123;
    synchronized (this) &#123;
        try &#123;
            if (mResultExtras != null) &#123;
                mResultExtras.setAllowFds(false);
            &#125;
            if (mOrderedHint) &#123;
                //串行广播
                am.finishReceiver(mToken, mResultCode, mResultData, mResultExtras,
                        mAbortBroadcast, mFlags);
            &#125; else &#123;
                //并行广播
                am.finishReceiver(mToken, 0, null, null, false, mFlags);
            &#125;
        &#125; catch (RemoteException ex) &#123;
        &#125;
    &#125;
&#125;
</code></pre>
<h1 id="4-11-AMS-finishReceiver"><a href="#4-11-AMS-finishReceiver" class="headerlink" title="4.11 AMS.finishReceiver"></a>4.11 AMS.finishReceiver</h1><pre><code>public void finishReceiver(IBinder who, int resultCode, String resultData,
        Bundle resultExtras, boolean resultAbort, int flags) &#123;
    ...
    final long origId = Binder.clearCallingIdentity();
    try &#123;
        boolean doNext = false;
        BroadcastRecord r;

        synchronized(this) &#123;
            BroadcastQueue queue = (flags &amp; Intent.FLAG_RECEIVER_FOREGROUND) != 0
                    ? mFgBroadcastQueue : mBgBroadcastQueue;
            r = queue.getMatchingOrderedReceiver(who);
            if (r != null) &#123;
                doNext = r.queue.finishReceiverLocked(r, resultCode,
                    resultData, resultExtras, resultAbort, true);
            &#125;
        &#125;

        if (doNext) &#123;
            //处理下一条广播
            r.queue.processNextBroadcast(false);
        &#125;
        trimApplications();
    &#125; finally &#123;
        Binder.restoreCallingIdentity(origId);
    &#125;
&#125;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/24/Notes/Android/IPC/2.%20IPC%E7%9A%84%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/24/Notes/Android/IPC/2.%20IPC%E7%9A%84%E6%96%B9%E5%BC%8F/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-24 23:08:49" itemprop="dateCreated datePublished" datetime="2021-02-24T23:08:49+08:00">2021-02-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Android中IPC的方式："><a href="#Android中IPC的方式：" class="headerlink" title="Android中IPC的方式："></a>Android中IPC的方式：</h1><pre><code>1.Bundle
2.文件共享：适合在对数据同步要求不高的进程中通信
3.Messenger 和 Message
4.AIDL
5.contentProvider 数据共享,数据库
6.Socket （未学习）
</code></pre>
<h1 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL:"></a>AIDL:</h1><h2 id="1-支持的数据类型："><a href="#1-支持的数据类型：" class="headerlink" title="1.支持的数据类型："></a>1.支持的数据类型：</h2><pre><code>1.基本数据类型（int、long、char、boolean、double等）
2.String和charSequence
3.List只支持ArrayList （CopyOnWriteArrayList支持并发）
4.Map 只支持 HashMap （ConcurrentHashMap 支持并发）
5.Parcelable 实现了Parcelable接口的对象
6.AIDL 接口本身
</code></pre>
<h2 id="2-RemoteCallbackList：监听者的注册与解注册"><a href="#2-RemoteCallbackList：监听者的注册与解注册" class="headerlink" title="2.RemoteCallbackList：监听者的注册与解注册"></a>2.RemoteCallbackList：监听者的注册与解注册</h2><pre><code>private RemoteCallbackList&lt;IOnNewBookArrivedListener&gt; mListenerList = new RemoteCallbackList&lt;IOnNewBookArrivedListener&gt;();
 
mListenerList.register(listener);

mListenerList.unregister(listener);

final int N = mListenerList.beginBroadcast();
for(int i = 0; i &lt;N ;i++)&#123; IOnNewBookArrivedListener l = mListenerList.getBroadcastItem(i); 
if (l != null)&#123; Log.i(TAG, &quot;real onNewBookArrived...&quot;); 
try &#123; l.onNewBookArrived(book); &#125;catch (RemoteException e)&#123; e.printStackTrace(); &#125; &#125; &#125; mListenerList.finishBroadcast(); 
</code></pre>
<h2 id="3-不要在UI线程中调用远程的耗时方法-例如：在onServiceConnected-和-onServiceDisconnected中调用"><a href="#3-不要在UI线程中调用远程的耗时方法-例如：在onServiceConnected-和-onServiceDisconnected中调用" class="headerlink" title="3.不要在UI线程中调用远程的耗时方法 例如：在onServiceConnected 和 onServiceDisconnected中调用"></a>3.不要在UI线程中调用远程的耗时方法 例如：在onServiceConnected 和 onServiceDisconnected中调用</h2><h2 id="4-监听Binder意外死亡的2中方式"><a href="#4-监听Binder意外死亡的2中方式" class="headerlink" title="4.监听Binder意外死亡的2中方式"></a>4.监听Binder意外死亡的2中方式</h2><pre><code>1.onServiceDisconnected 
2.给binder设置DeathRecipient private IBookManager iBookManager; 
privateServiceConnection mServiceConn = new ServiceConnection() &#123; 
    @Override public void onServiceConnected(ComponentName name, IBinderservice) &#123; 
        iBookManager = IBookManager.Stub.asInterface(service); 
        try &#123; service.linkToDeath(mDeathRecipient,0); ... 
    &#125; catch(RemoteException e) &#123; 
        e.printStackTrace(); 
        &#125; 
    &#125; 
    @Override public void onServiceDisconnected(ComponentName name) &#123;
    Log.i(TAG,&quot;onServiceDisconnected ...&quot;); 
        iBookManager = null; Intent intent = new Intent(MainActivity.this,BookManagerService.class); bindService(intent,mServiceConn, Context.BIND_AUTO_CREATE); &#125; 
    &#125;; 
    private IBinder.DeathRecipientmDeathRecipient = new IBinder.DeathRecipient()&#123; 
    @Override 
    public void binderDied() &#123;
        Log.i(TAG,&quot;binderDied ...&quot;);
        if(iBookManager == null) return; 
        iBookManager.asBinder().unlinkToDeath(mDeathRecipient, 0); 
        iBookManager = null; //rebindremote service &#125; 
    &#125;; 
&#125;
</code></pre>
<h2 id="5-连接服务时添加权限验证-1-onBind：验证不通过返回null，无法绑定服务2-onTransact：验证失败返回false，服务端不会执行AIDL中的方法-…"><a href="#5-连接服务时添加权限验证-1-onBind：验证不通过返回null，无法绑定服务2-onTransact：验证失败返回false，服务端不会执行AIDL中的方法-…" class="headerlink" title="5.连接服务时添加权限验证 1.onBind：验证不通过返回null，无法绑定服务2.onTransact：验证失败返回false，服务端不会执行AIDL中的方法 …"></a>5.连接服务时添加权限验证 1.onBind：验证不通过返回null，无法绑定服务2.onTransact：验证失败返回false，服务端不会执行AIDL中的方法 …</h2><p>1.服务端定义权限并且声明服务需要该权限<br>    <permission android:name="com.example.zxw.self.permission"/><br>    <service android:permission="com.example.zxw.self.permission" android:name=".BookManagerService" android:enabled="true" android:exported="true" android:process=":remote">    </p>
<p>2.客户端绑定时：</p>
<pre><code>&lt;uses-permission android:name=&quot;com.example.zxw.self.permission&quot;/&gt;
</code></pre>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>private Binder mBinder = new IBookManager.Stub()&#123;
    ...
    @Override
    public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;
        Log.i(TAG, &quot;onTransact ...&quot;);
            int check = checkCallingOrSelfPermission(&quot;com.example.zxw.self.permission&quot;);
            if(check == PackageManager.PERMISSION_DENIED)&#123;
                return false;
            &#125;
        return super.onTransact(code, data, reply, flags);
    &#125;
&#125;;

@Override
public IBinder onBind(Intent intent) &#123;
    Log.i(TAG,&quot;onBind ...&quot;);
    int check = checkCallingOrSelfPermission(&quot;com.example.zxw.self.permission&quot;);
    Log.i(TAG,&quot;check = &quot;+check);
    if(check == PackageManager.PERMISSION_DENIED)&#123;
        return null;
    &#125;
    return mBinder;
&#125;
</code></pre>
<h3 id="区别：都是无法调用aidl的方法"><a href="#区别：都是无法调用aidl的方法" class="headerlink" title="区别：都是无法调用aidl的方法"></a>区别：都是无法调用aidl的方法</h3><pre><code>      但是onbind 中校验不过根本没有连接
      onTransact 有连接，客户端能监听到连接的断开
</code></pre>
<h2 id="6-onDestroy中解绑"><a href="#6-onDestroy中解绑" class="headerlink" title="6.onDestroy中解绑"></a>6.onDestroy中解绑</h2><pre><code>protected void onDestroy() &#123;
    super.onDestroy();
    Log.i(TAG, &quot;onDestroy&quot;);
    if(iBookManager != null &amp;&amp; iBookManager.asBinder().isBinderAlive())&#123;
        try &#123;
            iBookManager.unregesterListener(mOnNewBookArrivedListener);
        &#125; catch (RemoteException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
    unbindService(mServiceConn);
    iBookManager = null;
&#125;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/22/Notes/Android/FourComponents/ContentProvider%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/22/Notes/Android/FourComponents/ContentProvider%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-22 23:45:13" itemprop="dateCreated datePublished" datetime="2021-02-22T23:45:13+08:00">2021-02-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ContentProvider-基础知识"><a href="#ContentProvider-基础知识" class="headerlink" title="ContentProvider 基础知识"></a>ContentProvider 基础知识</h1><p>ContentProvider 用户跨进程访问数据，通常和数据库以及ContentResolver配合使用，可以保证数据的安全性。</p>
<h2 id="一、ContentResolver"><a href="#一、ContentResolver" class="headerlink" title="一、ContentResolver"></a>一、ContentResolver</h2><p>对于每一个应用程序来说，如果想要访问内容提供器中共享的数据，就一定要借助ContentResolver类，可以通过Context中的getContentResolver()方法获取到该类的实例。 ContentResolver中提供了一系列的方法用于对数据进行CRUD操作，其中insert()方法用于添加数据，update()方法用于更新数据，delete()方法用于删除数据，query()方法用于查询数据。有没有似曾相识的感觉？没错，SQLiteDatabase中也是使用的这几个方法来进行 CRUD 操作的，只不过它们在方法参数上稍微有一些区别。不同于SQLiteDatabase，ContentResolver中的增删改查方法都是不接收表名参数的，而是使用一个 Uri参数代替，这个参数被称为内容 URI，下面会详细介绍它的格式定义。在得到了内容URI字符串之后，我们还需要将它解析成Uri对象才可以作为参数传入。 只需要调用 Uri.parse()方法，就可以将内容URI字符串解析成 Uri对象： </p>
<pre><code>Uri uri = Uri.parse(&quot;content://com.example.app.provider/table1&quot;) 
</code></pre>
<p>再调用contentResolver的CURD方法就可完成对应的操作。</p>
<pre><code>Cursor cursor = context.getContentResolver().query(uri, null, null, null, null);
</code></pre>
<h2 id="二、内容-URI"><a href="#二、内容-URI" class="headerlink" title="二、内容 URI"></a>二、内容 URI</h2><p>无论是通过ContentResolver访问数据，还是实现自定义的ContentProvider都需要内容URI才能够通信。URI给内容提供器中的数据建立了唯一标志符，基本格式如下：</p>
<pre><code>content://Authority/Path/Id
</code></pre>
<p>content:// 固定格式<br>Authority：权限，用于对不同的应用程序进行区分，一般为了避免冲突，都会采用包名.provider<br>Path: 路径，用于对同一个程序中的不同表做区分<br>Id: 数据Id，用于区分表中的不同数据<br>URI的格式主要有如下2种：</p>
<pre><code>   content://com.example.app.provider/table 
   content://com.example.app.provider/table1/1 
</code></pre>
<p>以路径结尾表示期望访问该表中所有的数据， 以 id结尾就表示期望访问该表中拥有相应 id的数据。我们可以使用通配符的方式来分别匹 配这两种格式的内容 URI，规则如下。</p>
<ol>
<li><p>*：表示匹配任意长度的任意字符 </p>
</li>
<li><p>#：表示匹配任意长度的数字<br>所以，一个能够匹配任意表的内容 URI格式就可以写成：</p>
<p> content://com.example.app.provider/* </p>
</li>
</ol>
<p>而一个能够匹配 table1表中任意一行数据的内容 URI格式就可以写成</p>
<pre><code>content://com.example.app.provider/table1/#
</code></pre>
<p>我们再借助UriMatcher这个类就可以轻松地实现匹配内容URI的功能。UriMatcher中提供了一个addURI()方法，这个方法接收三个参数，可以分别把权限、路径和一个自定义代码传进去。这样，当调用UriMatcher的match()方法时，就可以将一个 Uri对象传入，返回值是某个能够匹配这个Uri对象所对应的自定义代码，利用这个代码，我们就可以判断出调用方期望访问的是哪张表中的数据了。</p>
<h2 id="三、ContentProvider方法介绍"><a href="#三、ContentProvider方法介绍" class="headerlink" title="三、ContentProvider方法介绍"></a>三、ContentProvider方法介绍</h2><p>通过继承ContentProvider，并且实现抽象方法就可完成自定义的ContentProvider共享数据了。</p>
<h3 id="1-onCreate"><a href="#1-onCreate" class="headerlink" title="1.onCreate()"></a>1.onCreate()</h3><p>初始化内容提供器的时候调用。通常会在这里完成对数据库的创建和升级等操作，返回true表示内容提供器初始化成功，返回false 则表示失败。注意，只有当存在 ContentResolver尝试访问我们程序中的数据时，内容提供器才会被初始化。</p>
<h3 id="2-query"><a href="#2-query" class="headerlink" title="2.query()"></a>2.query()</h3><p>从内容提供器中查询数据。使用uri参数来确定查询哪张表，projection参数用于确定查询哪些列，selection和selectionArgs参数用于约束查询哪些行，sortOrder参数用于对结果进行排序，查询的结果存放在Cursor对象中返回。 </p>
<h3 id="3-insert"><a href="#3-insert" class="headerlink" title="3.insert()"></a>3.insert()</h3><p>向内容提供器中添加一条数据。使用uri参数来确定要添加到的表，待添加的数据保存在values参数中。添加完成后，返回一个用于表示这条新记录的 URI。</p>
<h3 id="4-update"><a href="#4-update" class="headerlink" title="4.update()"></a>4.update()</h3><p>更新内容提供器中已有的数据。使用uri参数来确定更新哪一张表中的数据，新数据保存在values参数中，selection和selectionArgs参数用于约束更新哪些行，受影响的 行数将作为返回值返回。</p>
<h3 id="5-delete"><a href="#5-delete" class="headerlink" title="5.delete()"></a>5.delete()</h3><p>从内容提供器中删除数据。使用uri参数来确定删除哪一张表中的数据，selection和selectionArgs参数用于约束删除哪些行，被删除的行数将作为返回值返回。</p>
<h3 id="6-getType"><a href="#6-getType" class="headerlink" title="6.getType()"></a>6.getType()</h3><p>根据传入的内容 URI来返回相应的 MIME类型。它是所有的内容提供器都必须提供的一个方法，用于获取Uri对象所对应的MIME类型。一个内容URI所对应的MIME字符串主要由三部分组分，Android对这三个部分做了如下格式规定。<br>    1. 必须以vnd开头。<br>    2. 如果内容URI以路径结尾，则后接android.cursor.dir/，如果内容URI以id结尾，则后接android.cursor.item/<br>    3. 最后接上 vnd.authority.path</p>
<p>所以，对于 content://com.example.app.provider/table1这个内容 URI，它所对应的 MIME 类型就可以写成：</p>
<pre><code>vnd.android.cursor.dir/vnd.com.example.app.provider.table1 
</code></pre>
<p>对于 content://com.example.app.provider/table1/1这个内容 URI，它所对应的 MIME类型 就可以写成：</p>
<pre><code> vnd.android.cursor.item/vnd.com.example.app.provider.table1
</code></pre>
<h2 id="四、call-方法"><a href="#四、call-方法" class="headerlink" title="四、call 方法"></a>四、call 方法</h2><p>上面的方法都是访问或修改数据库的，如果需要跨进程访问里一个应用其他数据，例如sharePreference数据，可以通过call方法来调用自定义的函数。</p>
<h3 id="1-provider中复写call-方法，并且添加自定义的方法"><a href="#1-provider中复写call-方法，并且添加自定义的方法" class="headerlink" title="1.provider中复写call 方法，并且添加自定义的方法"></a>1.provider中复写call 方法，并且添加自定义的方法</h3><pre><code>@Override
public Bundle call(@NonNull String method, @Nullable String arg, @Nullable Bundle extras) &#123;
    switch (method)&#123;
        case &quot;getData&quot;:
            return getData();
        default:
            break;
    &#125;
    return null;
&#125;

//自定义函数
public Bundle getData()&#123;
    Bundle b = new Bundle();
    b.putString(&quot;name&quot;,&quot;call getData&quot;);
    return b;
&#125;
</code></pre>
<h3 id="2-查询方传入要调用的provider的自定义方法名和参数"><a href="#2-查询方传入要调用的provider的自定义方法名和参数" class="headerlink" title="2.查询方传入要调用的provider的自定义方法名和参数"></a>2.查询方传入要调用的provider的自定义方法名和参数</h3><pre><code>// uri格式最后一定要带一个 /
Uri uriCall = Uri.parse(&quot;content://&quot; + AUTHORITY + &quot;/&quot;);
Bundle b = getContentResolver().call(uriCall, &quot;getData&quot;, null, null);
Log.i(TAG, &quot;&quot;+b.get(&quot;name&quot;));
</code></pre>
<h2 id="五、MatrixCursor"><a href="#五、MatrixCursor" class="headerlink" title="五、MatrixCursor"></a>五、MatrixCursor</h2><p>ContentProvider的Query方法返回的是一个cursor，如果要对cursor中的数据做处理后再返回给查询的一方，可以通过MatrixCursor 对现有数据封装后返回。</p>
<pre><code>Cursor cursor1 = db.query(&quot;users&quot;, null, &quot;id = ?&quot;, new String[]&#123;&quot;1&quot;&#125;,null, null, null);
MatrixCursor m = new MatrixCursor(new String[]&#123;&quot;c1&quot;, &quot;c2&quot;, &quot;c3&quot;&#125;);
while(cursor1.moveToNext()) &#123;
    String name = cursor1.getString(1);
    int age = cursor1.getInt(2);
    String address = cursor1.getString(3);
    Log.i(TAG, name + &quot;age = &quot;+age + &quot;address = &quot;+address);
    m.addRow(new Object[]&#123;name, age, address&#125;);
&#125;
return m
</code></pre>
<p>Demo：</p>
<p>参考资料：<br>第一行代码——Android 郭霖<br><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/17224766/what-is-getcontentresolver-call-and-how-to-use-it">https://stackoverflow.com/questions/17224766/what-is-getcontentresolver-call-and-how-to-use-it</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/22/Notes/Android/FourComponents/Android%20Service%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/22/Notes/Android/FourComponents/Android%20Service%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-22 23:09:43" itemprop="dateCreated datePublished" datetime="2021-02-22T23:09:43+08:00">2021-02-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Android-Service-基础知识"><a href="#Android-Service-基础知识" class="headerlink" title="Android Service 基础知识"></a>Android Service 基础知识</h1><p>Service 作为android 四大组件之一，主要用于再后台处理一些耗时的逻辑或者去执行一些长期运行的任务。</p>
<h1 id="一、startService-和-bindService"><a href="#一、startService-和-bindService" class="headerlink" title="一、startService 和 bindService"></a>一、startService 和 bindService</h1><h2 id="1-生命周期和启动方式："><a href="#1-生命周期和启动方式：" class="headerlink" title="1. 生命周期和启动方式："></a>1. 生命周期和启动方式：</h2><p><img src="https://leanote.com/api/file/getImage?fileId=595288b4ab6441560e001f51" alt="service_lifecircle"><br>1.1 启动<br>通过startService启动服务时，如果是第一次启动，会调用onCreate-&gt;onStartCommand，但是多次启动时不会再调用onCreate，只有onStartCommand会被调用多次。<br>通过bindService绑定服务时，如果服务还未启动，会调用onCreate-&gt;onBind，创建并且绑定服务，多次调用bindService并不会多次调用onBind()，除非是多个客户端来绑定服务。</p>
<p>1.2 销毁<br>如果组件通过调用 startService() 启动服务，则服务将一直运行，直到服务使用 stopSelf()自行停止运行，或由其他组件通过调用 stopService() 停止它为止。无论服务被启动了多少次，只要调用一次stopService，便可终止（不考虑被绑定过的情况）。</p>
<p>如果组件是通过调用 bindService()来创建服务（且未调用onStartCommand()），则服务只会在该组件与其绑定时运行。一旦该服务与所有客户端之间的绑定全部取消，系统便会销毁它。</p>
<h2 id="2-starService和bindService一起使用："><a href="#2-starService和bindService一起使用：" class="headerlink" title="2. starService和bindService一起使用："></a>2. starService和bindService一起使用：</h2><p>如果一个Service又被启动又被绑定，则该Service会一直在后台运行。首先不管如何调用，onCreate始终只会调用一次。startService调用多少次，Service的onStartCommand方法便会调用多少次。Service的终止，需要unbindService和stopService同时调用才行。不管startService与bindService的调用顺序，如果先调用unbindService，此时服务不会自动终止，再调用stopService之后，服务才会终止；如果先调用stopService，此时服务也不会终止，再次调用unbindService或者<strong>之前调用bindService的Context不存在了</strong>（如Activity被finish的时候）之后，服务才会停止。</p>
<h2 id="3-使用场景："><a href="#3-使用场景：" class="headerlink" title="3. 使用场景："></a>3. 使用场景：</h2><p>   startService 主要用于开启服务，例如后台下载和播放音乐<br>   bindService 主要为了使用服务中的一些功能或者与服务进行交互<br>   这2种模式不是完全分离的。你可以可以绑定到一个通过startService()启动的服务。如一个intent想要播放音乐，通过startService启动后台播放音乐的service。然后，也许用户想要操作播放器或者获取当前正在播放的乐曲的信息，一个activity就会通过bindService建立一个到此service的连接. 这种情况下 stopService() 在全部的连接关闭后才会真正停止service。</p>
<h3 id="Tips："><a href="#Tips：" class="headerlink" title="Tips："></a>Tips：</h3><ol>
<li>服务的onCreate和onDestroy在一个生命周期中只会执行一次</li>
<li>service的stopself方法的功能是，当完成所有功能之后，将service停掉</li>
<li>Service中onRebind方法被调用的时机，需要满足2个条件：<br>(1)服务中onUnBind方法返回值为true<br>(2)服务对象被解绑后没有被销毁，之后再次被绑定</li>
</ol>
<h2 id="2-onStartCommand的返回值："><a href="#2-onStartCommand的返回值：" class="headerlink" title="2. onStartCommand的返回值："></a>2. onStartCommand的返回值：</h2><p>请注意，onStartCommand() 方法必须返回整型数。整型数是一个值，用于描述系统应该如何在服务终止的情况下继续运行服务（如上所述，IntentService 的默认实现将为您处理这种情况，不过您可以对其进行修改）。从onStartCommand()返回的值必须是以下常量之一：</p>
<h2 id="1-START-NOT-STICKY"><a href="#1-START-NOT-STICKY" class="headerlink" title="1. START_NOT_STICKY"></a>1. START_NOT_STICKY</h2><p>如果系统在 onStartCommand() 返回后终止服务，则除非有挂起 Intent 要传递，否则系统不会重建服务。这是最安全的选项，可以避免在不必要时以及应用能够轻松重启所有未完成的作业时运行服务。</p>
<h2 id="2-START-STICKY"><a href="#2-START-STICKY" class="headerlink" title="2. START_STICKY"></a>2. START_STICKY</h2><p>如果系统在 onStartCommand() 返回后终止服务，则会重建服务并调用 onStartCommand()，但不会重新传递最后一个 Intent。相反，除非有挂起 Intent 要启动服务（在这种情况下，将传递这些 Intent ），否则系统会通过空 Intent 调用 onStartCommand()。这适用于不执行命令、但无限期运行并等待作业的媒体播放器（或类似服务）。</p>
<h2 id="3-START-REDELIVER-INTENT"><a href="#3-START-REDELIVER-INTENT" class="headerlink" title="3. START_REDELIVER_INTENT"></a>3. START_REDELIVER_INTENT</h2><p>如果系统在 onStartCommand() 返回后终止服务，则会重建服务，并通过传递给服务的最后一个 Intent 调用 onStartCommand()。任何挂起 Intent 均依次传递。这适用于主动执行应该立即恢复的作业（例如下载文件）的服务。</p>
<h1 id="二、前台服务"><a href="#二、前台服务" class="headerlink" title="二、前台服务"></a>二、前台服务</h1><p>Service几乎都是在后台运行的，一直以来它都是默默地做着辛苦的工作。但是Service的系统优先级还是比较低的，当系统出现内存不足情况时，就有可能会回收掉正在后台运行的Service。如果你希望Service可以一直保持运行状态，而不会由于系统内存不足的原因导致被回收，就可以考虑使用前台Service。前台Service和普通Service最大的区别就在于，它会一直有一个正在运行的图标在系统的状态栏显示，下拉状态栏后可以看到更加详细的信息，非常类似于通知的效果。当然有时候你也可能不仅仅是为了防止Service被回收才使用前台Service，有些项目由于特殊的需求会要求必须使用前台Service，比如说墨迹天气。</p>
<pre><code>    Intent intent = new Intent(this, MainActivity.class);
    //需要让Activity运行在新的任务栈中
    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    Notification.Builder builder = new Notification.Builder(this);
    Notification notification = builder.setSmallIcon(R.mipmap.ic_launcher)
            .setContentText(&quot;this is a notify&quot;)
            .setContentTitle(&quot;notify!!!&quot;).setTicker(&quot;notify&quot;)
            .setContentIntent(PendingIntent.
                    getActivity(ServiceB.this, 0, intent, PendingIntent.FLAG_CANCEL_CURRENT))
            .build();
    startForeground(1, notification);
</code></pre>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips:"></a>Tips:</h3><ol>
<li>startForeground让服务变成前台服务并显示通知，这时必须要setSmallIcon，否则会显示默认的通知，不显示自定义通知</li>
<li>如何让服务一直存活 <a target="_blank" rel="noopener" href="http://zhoujianghua.com/2015/07/28/black_technology_in_alipay/">http://zhoujianghua.com/2015/07/28/black_technology_in_alipay/</a></li>
</ol>
<h1 id="三、Service-和-Thread"><a href="#三、Service-和-Thread" class="headerlink" title="三、Service 和 Thread"></a>三、Service 和 Thread</h1><p>之所以有不少人会把它们联系起来，主要就是因为Service的后台概念。Thread我们大家都知道，是用于开启一个子线程，在这里去执行一些耗时操作就不会阻塞主线程的运行。而Service我们最初理解的时候，总会觉得它是用来处理一些后台任务的，一些比较耗时的操作也可以放在这里运行，这就会让人产生混淆了。但其实Service其实是运行在主线程里的，所以说service的主进程中不能执行耗时的任务，需要另外启动线程执行，例如IntentService的内部就是使用了HandlerThread的实现。</p>
<h1 id="四、IntentService"><a href="#四、IntentService" class="headerlink" title="四、IntentService"></a>四、IntentService</h1><p>IntentService是Service 的子类，它使用工作线程逐一处理所有启动请求。如果不要求服务同时处理多个请求，这是最好的选择。只需实现 onHandleIntent() 方法即可，该方法会接收每个启动请求的Intent，能够执行后台工作。由于大多数启动服务都不必同时处理多个请求，因此使用 IntentService 类实现服务也许是最好的选择。</p>
<p>IntentService的特点：</p>
<ol>
<li>IntentService 会创建一个线程，来处理所有传给onStartCommand()的Intent请求</li>
<li>创建一个请求队列，用于将 Intent 逐一传递给 onHandleIntent() 实现，不必担心多线程问题</li>
<li>在所有的请求执行完毕后结束Service</li>
<li>提供 onBind() 的默认实现（返回 null）</li>
<li>提供默认的 onStartCommand() 实现，将intent传入等待队列中，然后到onHandleIntent()的实现。所以如果需要重写onStartCommand() 方法一定要调用父类的实现。</li>
</ol>
<h3 id="Tips-1"><a href="#Tips-1" class="headerlink" title="Tips:"></a>Tips:</h3><ol>
<li>IntentService是针对StarteService设计的，由于它默认实现的onBind()方法返回值是null，所以不适合bindService()</li>
<li>多次startService请求执行耗时任务，不会并发执行onHandleIntent()方法，而是一个一个顺序执行。当所有的任务执行完成，IntentService会自动销毁</li>
</ol>
<p>问题：onStartCommand的返回值的具体应用场景？</p>
<p>Demo：</p>
<p>参考资料：<br><a target="_blank" rel="noopener" href="https://developer.android.com/guide/components/services.html">https://developer.android.com/guide/components/services.html</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/guolin_blog/article/details/11952435">http://blog.csdn.net/guolin_blog/article/details/11952435</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="sven"
      src="/images/sven.jpeg">
  <p class="site-author-name" itemprop="name">sven</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhaoxiaowen-sven" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhaoxiaowen-sven" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhaoxiaowen-sven@gmail.com" title="E-Mail → mailto:zhaoxiaowen-sven@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sven</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
