<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Sven&#39;s blog">
<meta property="og:url" content="http://example.com/page/5/index.html">
<meta property="og:site_name" content="Sven&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="sven">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Sven's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
      <a target="_blank" rel="noopener" href="https://github.com/zhaoxiaowen-sven" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Sven's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/09/Notes/Java/JUC/JUC06_CountDownLatch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/09/Notes/Java/JUC/JUC06_CountDownLatch/" class="post-title-link" itemprop="url">JUC_06_CountDownLatch</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-09 23:52:52" itemprop="dateCreated datePublished" datetime="2021-04-09T23:52:52+08:00">2021-04-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/JUC/" itemprop="url" rel="index"><span itemprop="name">JUC</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JUC-06-CountDownLatch"><a href="#JUC-06-CountDownLatch" class="headerlink" title="JUC_06_CountDownLatch"></a>JUC_06_CountDownLatch</h1><p>CountDownLatch，让一个或多个线程等待其他线程完成操作。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CountDownlatchTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// do sth</span></span><br><span class="line">                System.out.println(<span class="string">&quot;do sth&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><ol>
<li>CountDownLatch 初始化时，设置 state 值为count 值；</li>
<li>所有调用await方法的线程会阻塞并构造节点加入同步队列；</li>
<li>直到通过调用countDown值使state为0，再唤醒同步队列所有节点的线程继续执行。</li>
</ol>
<img src="../pics/image-20210405142433953.png" alt="image-20210405142433953" style="zoom:50%;" />

<p>CountDownLatch 也是基于AQS的，内部同步器Sync实现了AQS的tryAcquireShared等方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123; <span class="comment">// 构造方法</span></span><br><span class="line">      <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;count &lt; 0&quot;</span>); <span class="comment">// count 必须&gt;0</span></span><br><span class="line">      <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count); <span class="comment">// 初始化 Sync</span></span><br><span class="line">  	&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    		<span class="comment">//...  </span></span><br><span class="line">        Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">              setState(count); <span class="comment">// 设置state的初始值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看下await的原理。</p>
<h1 id="await"><a href="#await" class="headerlink" title="await"></a>await</h1><h2 id="CDL-await"><a href="#CDL-await" class="headerlink" title="CDL.await"></a>CDL.await</h2><p>await 调用到 sync.acquireSharedInterruptibly</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>); <span class="comment">// 参数值 1 无意义 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AQS-acquireSharedInterruptibly"><a href="#AQS-acquireSharedInterruptibly" class="headerlink" title="AQS.acquireSharedInterruptibly"></a>AQS.acquireSharedInterruptibly</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted()) <span class="comment">// 在await前线程已经被中断了，直接抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>) <span class="comment">// 返回值小于 0 表示state &gt; 0</span></span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CDL.Sync.tryAcquireShared</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来重点看下AQS.doAcquireSharedInterruptibly的实现。</p>
<h3 id="AQS-doAcquireSharedInterruptibly"><a href="#AQS-doAcquireSharedInterruptibly" class="headerlink" title="AQS.doAcquireSharedInterruptibly"></a>AQS.doAcquireSharedInterruptibly</h3><p>作用有2个：</p>
<ol>
<li>阻塞 所有调用 <code>await</code> 的线程</li>
<li>通过countDown 使state == 0时，唤醒后继节点</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED); <span class="comment">// 添加节点到同步队列中，节点的类型为SHARED</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg); <span class="comment">// 检测节点的当前状态</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r); <span class="comment">// r&gt;=0,表示锁已经释放，唤醒下个节点</span></span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; <span class="comment">// 设置节点的前驱为 Signal </span></span><br><span class="line">                parkAndCheckInterrupt()) <span class="comment">// 阻塞当前线程</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="setHeadAndPropagate"><a href="#setHeadAndPropagate" class="headerlink" title="setHeadAndPropagate"></a>setHeadAndPropagate</h3><p>唤醒同步队列中的下个节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    setHead(node); <span class="comment">// 设置当前节点为head节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared(); <span class="comment">// 唤醒下个节点，下面再讲</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="countDown"><a href="#countDown" class="headerlink" title="countDown"></a>countDown</h1><h2 id="CDL-countDown"><a href="#CDL-countDown" class="headerlink" title="CDL.countDown"></a>CDL.countDown</h2><p>countDown 调用搭配 Sync.releaseShared 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AQS-releaseShared"><a href="#AQS-releaseShared" class="headerlink" title="AQS.releaseShared"></a>AQS.releaseShared</h2><p>判断当前state值是否为0，唤醒同步队列中的所有节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123; <span class="comment">// tryReleaseShared 表示 state == 0 ，需要唤醒同步队列中的所有节点</span></span><br><span class="line">        doReleaseShared(); <span class="comment">// 唤醒后面的节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CDL-Sync-tryReleaseShared"><a href="#CDL-Sync-tryReleaseShared" class="headerlink" title="CDL.Sync.tryReleaseShared"></a>CDL.Sync.tryReleaseShared</h3><p>tryReleaseShared，判断锁是否已经完全释放。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) <span class="comment">// 表示之前已经 state 已经是 0 了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">        <span class="keyword">int</span> nextc = c-<span class="number">1</span>; <span class="comment">// state - 1</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc)) <span class="comment">// cas 设置最新的state</span></span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>; <span class="comment">// state == 0 表示锁已经完全释放了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AQS-doReleaseShared"><a href="#AQS-doReleaseShared" class="headerlink" title="AQS.doReleaseShared"></a>AQS.doReleaseShared</h3><p>唤醒阻塞线程，联系前面的方法。也就是说，</p>
<ol>
<li>通过countDown 使state == 0 后，先doReleaseShared -&gt; unparkSuccessor 唤醒同步队列中阻塞的节点线程后；</li>
<li>唤醒后的线程会执行doAcquireSharedInterruptibly获取锁，再调用setHeadAndPropagate，继续唤醒下个节点；</li>
<li>setHeadAndPropagate会再次调用到doReleaseShared中，直到同步队列中所有的等待节点都被唤醒。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123; <span class="comment">//将当前节点状态改为 0 </span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h); <span class="comment">// 唤醒阻塞线程</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>countDownLatch的特性：</p>
<ol>
<li><p> 管理一个大于零的计数器值； </p>
</li>
<li><p> 每countDown一次则state就减1一次，直到许可证数量等于0则释放队列中所有的等待线程；</p>
</li>
<li><p> 也可以通过countDown/await组合一起使用，来实现CyclicBarrier的功能，举例</p>
</li>
</ol>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CountDownlatchTest2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CountDownLatch waitLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    CountDownLatch signalLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;waitLatch await  i&quot;</span> + index);</span><br><span class="line">                    waitLatch.await();</span><br><span class="line">                    sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;signalLatch countDown &quot;</span> + index);</span><br><span class="line">                    signalLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保证子线程先执行</span></span><br><span class="line">    sleep(<span class="number">500</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;waitLatch countDown &quot;</span>);</span><br><span class="line">    waitLatch.countDown();</span><br><span class="line">    System.out.println(<span class="string">&quot;signalLatch await &quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        signalLatch.await();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/09/Notes/Java/JUC/JUC05_AQS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/09/Notes/Java/JUC/JUC05_AQS/" class="post-title-link" itemprop="url">JUC_05_AQS</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-09 23:52:52" itemprop="dateCreated datePublished" datetime="2021-04-09T23:52:52+08:00">2021-04-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/JUC/" itemprop="url" rel="index"><span itemprop="name">JUC</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JUC-05-AQS"><a href="#JUC-05-AQS" class="headerlink" title="JUC_05_AQS"></a>JUC_05_AQS</h1><p>Java中的大部分同步类（Lock、Semaphore、ReentrantLock等）都是基于AbstractQueuedSynchronizer（简称为AQS）实现的。AQS是一种提供了原子式管理同步状态、阻塞和唤醒线程功能以及队列模型的简单框架。</p>
<h1 id="一、AQS-原理"><a href="#一、AQS-原理" class="headerlink" title="一、AQS 原理"></a>一、AQS 原理</h1><p>AQS核心思想是，如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。</p>
<p>CHL是单向链表，AQS中的队列是CLH变体的虚拟双向队列（FIFO），AQS是通过将每条请求<strong>共享资源的线程封装成一个节点来实现锁</strong>的分配。</p>
<img src="../../../pics/image-20210328225113130.png" alt="image-20210328225113130" style="zoom:50%;" />

<p>AQS使用一个Volatile的int类型的成员变量<strong>state来表示同步状态</strong>，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State值的修改。</p>
<h2 id="1-1、数据结构"><a href="#1-1、数据结构" class="headerlink" title="1.1、数据结构"></a>1.1、数据结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 共享模式</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">        <span class="comment">// 独占模式</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// waitStatus状态</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 节点在队列中的状态</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同步队列中节点的前驱</span></span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line">        <span class="comment">// 同步队列中节点的后继</span></span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line">        <span class="comment">// 当前节点的线程</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 条件队列的下一个节点</span></span><br><span class="line">        Node nextWaiter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line">	  <span class="comment">// 尾结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line">	 <span class="comment">// 锁状态 &gt;0 表示锁定</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>AQS中维护了一个名为state的字段，意为同步状态，state也就是加锁状态，下图展示了独占锁和共享锁中state的不同意义，本文分析的ReentrantLock是独占锁。</p>
<img src="../../pics/image-20210328231610295.png?lastModify=1617201243" alt="image-20210328231610295" style="zoom:33%;" />

<h3 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h3><p>同步队列中存储着所有竞争锁的线程节点，在前面节点释放锁或线程被中断后，同步队列中的节点开始竞争锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头结点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line">  <span class="comment">// 尾结点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br></pre></td></tr></table></figure>
<h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>同步队列中的节点</p>
<table>
<thead>
<tr>
<th align="left">方法和属性值</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">waitStatus</td>
<td align="left">当前节点在队列中的状态</td>
</tr>
<tr>
<td align="left">thread</td>
<td align="left">表示处于该节点的线程</td>
</tr>
<tr>
<td align="left">prev</td>
<td align="left">前驱指针</td>
</tr>
<tr>
<td align="left">next</td>
<td align="left">后继指针</td>
</tr>
<tr>
<td align="left">predecessor</td>
<td align="left">返回前驱节点，没有的话抛出 NullPointerException</td>
</tr>
<tr>
<td align="left">nextWaiter</td>
<td align="left">指向下一个处于 CONDITION 状态的节点</td>
</tr>
</tbody></table>
<h3 id="等待状态"><a href="#等待状态" class="headerlink" title="等待状态"></a>等待状态</h3><p>waitStatus</p>
<table>
<thead>
<tr>
<th align="left">枚举</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">当一个 Node 被初始化的时候的默认值，同步队列中的</td>
</tr>
<tr>
<td align="left">CANCELLED</td>
<td align="left">为 1，表示线程获取锁的请求已经取消了</td>
</tr>
<tr>
<td align="left">CONDITION</td>
<td align="left">为 -2，表示节点在等待队列中，节点线程等待唤醒</td>
</tr>
<tr>
<td align="left">PROPAGATE</td>
<td align="left">为 -3，当前线程处在 SHARED 情况下，该字段才会使用</td>
</tr>
<tr>
<td align="left">SIGNAL</td>
<td align="left">为 -1，表示节点的后继需要唤醒</td>
</tr>
</tbody></table>
<h2 id="1-2、重要方法"><a href="#1-2、重要方法" class="headerlink" title="1.2、重要方法"></a>1.2、重要方法</h2><p>AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单而又高效地构造出同步器。AQS的设计采用了模板方法模式的，也就是说，如果我们要借助AQS自定义锁，只需要需要实现AQS的以下方法：</p>
<img src="../../pics/image-20210330222313955.png" alt="image-20210330222313955" style="zoom:70%;" />

<p>自定义同步器要么是独占方式，要么是共享方式，它们也只需实现 <code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code> 中的一种即可。除此之外, 同步器加解锁的核心方法acquire、release，acquireShared - releaseShared 等等AQS都帮我们实现好了，在后面的讲解中再介绍。</p>
<h1 id="二、ReentrantLock"><a href="#二、ReentrantLock" class="headerlink" title="二、ReentrantLock"></a>二、ReentrantLock</h1><h2 id="2-1-ReentrantLock特性概览"><a href="#2-1-ReentrantLock特性概览" class="headerlink" title="2.1 ReentrantLock特性概览"></a>2.1 ReentrantLock特性概览</h2><p>ReentrantLock意思为可重入锁，指的是一个线程多次加锁。为了帮助大家更好地理解ReentrantLock的特性，我们先将ReentrantLock跟常用的Synchronized进行比较：</p>
<img src="../../pics/image-20210330221805165.png" alt="image-20210330221805165" style="zoom:70%;" />



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// **************************Synchronized的使用方式**************************</span></span><br><span class="line"><span class="comment">// 1.用于代码块</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;&#125;</span><br><span class="line"><span class="comment">// 2.用于对象</span></span><br><span class="line"><span class="keyword">synchronized</span> (object) &#123;&#125;</span><br><span class="line"><span class="comment">// 3.用于方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span> <span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 4.可重入</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// **************************ReentrantLock的使用方式**************************</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span> <span class="params">()</span> throw Exception </span>&#123;</span><br><span class="line">	<span class="comment">// 1.初始化选择公平锁、非公平锁</span></span><br><span class="line">	ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">	<span class="comment">// 2.可用于代码块</span></span><br><span class="line">	lock.lock();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 3.支持多种加锁方式，比较灵活; 具有可重入特性</span></span><br><span class="line">			<span class="keyword">if</span>(lock.tryLock(<span class="number">100</span>, TimeUnit.MILLISECONDS))&#123; &#125;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">// 4.手动释放锁</span></span><br><span class="line">			lock.unlock()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		lock.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReentrantLock分为公平锁和非公平锁，内部的实现依赖于AQS。ReentrantLock和AQS的继承关系如下图所示：</p>
<div align="center">
<img src="../pics/image-20210330213019476.png" alt="image-20210330213019476" style="zoom:90%;" />
</div>  
可以看到，ReentrantLock中的内部抽象类Sync 继承自AQS，而公平锁的同步器FairSync和非公平锁的同步器NonfairSync又继承自Sync。

<p>公平锁和非公平的锁的区别是什么呢？我们来看下<code>FairSync</code> 和 <code>NonfairSync</code>。</p>
<h2 id="2-2、公平锁和非公平锁"><a href="#2-2、公平锁和非公平锁" class="headerlink" title="2.2、公平锁和非公平锁"></a>2.2、公平锁和非公平锁</h2><p>ReentLock 默认的构造方法使用的是非公平锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用ReentrantLock.lock 加锁时，lock方法最终调用到了Sync.lock</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Sync类在ReentLock 有有2种实现，FairSync 和 NonfairSync，分别对应的是 <code>公平锁</code> 和 <code>非公平锁</code>的队列同步器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公平锁同步器</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>); <span class="comment">// 不同之处1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; <span class="comment">// 不同之处2</span></span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是非公平锁同步器</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread()); <span class="comment">// 不同之处1</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nonfairTryAcquire是Sync的方法先贴过来</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123; <span class="comment">// 不同之处2</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较之后我们知道看到共有2个不同之处：</p>
<ol>
<li>lock 方法中后<strong>，非公平锁会先调用 CAS 进行一次抢锁</strong>，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</li>
<li> tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁；<strong>但是公平锁会判断同步队列中是否有等待节点</strong>，如果有则不去抢锁，乖乖排到后面。</li>
</ol>
<p>如果非公平锁这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。</p>
<p>相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</p>
<p>对比完公平锁和非公平锁，下面我们就从锁常用的4个方法<strong>lock、unlock、await、notify</strong>来介绍下ReenLock和AQS的原理，我们以<strong>公平锁</strong>为例，公平锁相对非公平锁要更复杂一点。</p>
<h2 id="2-3、lock过程分析"><a href="#2-3、lock过程分析" class="headerlink" title="2.3、lock过程分析"></a>2.3、lock过程分析</h2><p>加锁的调用链如下：</p>
<div align="center">
    <img src="../pics/image-20210330222928614.png" alt="image-20210330213019476" style="zoom:90%;" />
</div>
### ReentrantLock.lock

<p>加锁首先lock，公平锁lock 最终调用到acquire方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>); <span class="comment">// 不同之处1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AQS-acquire"><a href="#AQS-acquire" class="headerlink" title="AQS.acquire"></a>AQS.acquire</h3><p>acquire是AQS的核心方法，分解下：</p>
<ol>
<li>调用tryAcquire获取锁，获取成功立刻结束；获取失败调用addWaiter</li>
<li>addWaiter，将获取锁的线程封装成节点加入到等待队列中</li>
<li>acquireQueued，竞争失败后挂起当前线，待唤醒后再次竞争锁</li>
<li>selfInterrupt，节点唤醒后设置线程状态为中断，返回给业务方。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) <span class="comment">//</span></span><br><span class="line">        &amp;&amp; acquireQueued(</span><br><span class="line">            addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        <span class="comment">// 设置线程状态为中断</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FairSync-tryAcquire"><a href="#FairSync-tryAcquire" class="headerlink" title="FairSync.tryAcquire"></a>FairSync.tryAcquire</h3><p>公平锁的tryAcquire的方法获取锁，成功返回true，失败返回false。</p>
<ol>
<li>state == 0， 表示当前AQS处于无锁状态，在满足以下2个条件后，设置当前独占线程为当前线程<ul>
<li>hasQueuedPredecessors，同步队列中没有等待的节点</li>
<li>compareAndSetState ，抢占锁成功</li>
</ul>
</li>
<li>current == getExclusiveOwnerThread()，表示当前获取锁的线程再次进行了加锁，state自增</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// state == 0,表示没有被加锁</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; <span class="comment">// 同步队列中是否有待唤醒的节点，后面再说</span></span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123; <span class="comment">// cas 抢占锁成功</span></span><br><span class="line">                setExclusiveOwnerThread(current);  <span class="comment">// 设置线程为当前线程</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">//支持可重入</span></span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// 越界判断，当重入次数达到int值最大之，会变负数</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tryAcquire线程抢占锁成功时直接放回，抢占失败后，addWaiter线程加入到同步队列中。</p>
<h3 id="AQS-addWaiter"><a href="#AQS-addWaiter" class="headerlink" title="AQS.addWaiter"></a>AQS.addWaiter</h3><p>addWaiter将当前线程加入到同步队列中</p>
<ol>
<li>如果当前队尾元素不为空也就是队列不为空，使用尾插法入队</li>
<li>如果当前是空队列或者cas失败，使用enq方法 <strong>自旋 + cas</strong> 入队</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred; <span class="comment">//// 先赋值前驱 + cas tail 可以保证tail.prev 一定是有值的，释放锁的时候会用到</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123; <span class="comment">//尾插法入队</span></span><br><span class="line">            <span class="comment">// 这里有并发，联系到hasQueuedPredecessors</span></span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node); <span class="comment">//自旋入队</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AQS-enq"><a href="#AQS-enq" class="headerlink" title="AQS.enq"></a>AQS.enq</h4><p> enq，自旋入队，只有当前node入队成功后，才会跳出循环，<strong>返回当前尾节点前驱节点</strong>（这里没有使用到这个特性，后面在讲）。有2种情况：</p>
<ol>
<li>tail节点为空，空队列时，<strong>先增加一个虚节点作为头节点</strong>；第二次循环时，将当前节点入队；</li>
<li>尾插法入队，通过自旋，保证一定可以入队。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">// 自旋</span></span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node())) <span class="comment">// 添加一个虚节点</span></span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t; <span class="comment">// 先赋值前驱 + cas tail 可以保证tail.prev 一定是有值的，释放锁的时候会用到</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123; <span class="comment">// 尾插法入队</span></span><br><span class="line">                t.next = node; <span class="comment">// 这里可能存在并发，tail有值，但是tail.next不一定有值。</span></span><br><span class="line">                <span class="comment">// ！！！注意返回的是当前尾节点前驱节点 ！！！</span></span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;当enq入队成功，进入acquireQueued方法。</span><br></pre></td></tr></table></figure>

<h4 id="AQS-hasQueuedPredecessors"><a href="#AQS-hasQueuedPredecessors" class="headerlink" title="AQS.hasQueuedPredecessors"></a>AQS.hasQueuedPredecessors</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp; <span class="comment">// 条件 1</span></span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> <span class="comment">//条件 2</span></span><br><span class="line">         || s.thread != Thread.currentThread()); <span class="comment">// 条件 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里补充下hasQueuedPredecessors的判断逻辑，未方便描述这3个条件分别做了如上标记：</p>
<ol>
<li><p>条件1 h != t ，很好理解，头尾不同，说明同步队列至少有2个节点，由于同步队列的第一个节点为虚节点，其实并不存储任何信息，只是占位，所以还要继续判断。</p>
</li>
<li><p>(s = h.next) == null || s.thread != Thread.currentThread() ，别忘了此时<code>条件1</code>是成立的，再分解下：</p>
<ul>
<li><p>h != t 成立情况下，若<code>条件2</code>成立 ，说明等待队列中的第二个节点正在加入同步队列过程中（前一个节点是个虚节点）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node.prev = t; <span class="comment">// 先赋值前驱 + cas tail 可以保证tail.prev 一定是有值的，释放锁的时候会用到</span></span><br><span class="line"><span class="keyword">if</span> (compareAndSetTail(t, node)) &#123; <span class="comment">// 尾插法入队</span></span><br><span class="line">		t.next = node; <span class="comment">// 这里可能存在并发，tail有值，但是tail.next不一定有值。</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>条件3</code>成立，<code>条件1成立</code> 且 <code>条件2不成立</code>，如果(s = h.next) != null，说明此时队列中至少有一个有效节点, 如果s.thread != Thread.currentThread()，说明<strong>等待队列的第一个有效节点线程与当前线程不同</strong>，当前线程必须加入进等待队列。</p>
</li>
</ul>
</li>
</ol>
<p>总结下：hasQueuedPredecessors的逻辑是，同步队列中至少有一个有效节点且这个节点和当前要插入的节点线程不同。</p>
<h3 id="AQS-acquireQueued"><a href="#AQS-acquireQueued" class="headerlink" title="AQS.acquireQueued"></a>AQS.acquireQueued</h3><p>acquireQueued通过自旋的方式让<code>同步队列</code>中的节点竞争锁，返回值表示<strong>线程在<code>同步队列</code>中竞争锁过程中是否被中断过</strong>。在<strong>线程获取锁</strong>或<strong>线程被唤醒的场景下</strong>：</p>
<ol>
<li><p>如果当前节点是head-&gt;next节点，尝试竞争锁（head-&gt;next节点在任何情况下都有权利去争夺锁）</p>
<ol>
<li>如果<strong>竞争成功，退出自旋并返回中断标记</strong>，将当前节点设置为头节点，回收老的头节点；</li>
<li>否则，继续挂起。</li>
</ol>
</li>
<li><p>如果节点不是head -&gt;next, 挂起当前节点的线程</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//什么时候会执行这里？</span></span><br><span class="line">            <span class="comment">//1.进入for循环时 在线程尚未park前会执行</span></span><br><span class="line">            <span class="comment">//2.线程park之后 被唤醒后，也会执行这里...</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// p 是当前节点的前驱</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">             <span class="comment">// 当前节点是head的next节点，head-&gt;next节点在任何情况下都有权利去争夺锁，进入这里的情况有2种：</span></span><br><span class="line">             <span class="comment">//   1.被唤醒</span></span><br><span class="line">             <span class="comment">//   2.走到这里时，前一个线程已经释放了锁，当前节点tryAcquire成功</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node); <span class="comment">// 将当前节点设置为头节点</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 获取到锁时退出，返回当前线程的中断标记</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//  haed-&gt;next 竞争失败或者非head-&gt;next节点</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; <span class="comment">// 2.挂起当前线程</span></span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">// ！！！中断信号唤醒时，线程状态改为true ！！！</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node); <span class="comment">//通常用于响应中断的锁，普通lock只有一种情况走到这里，tryAcquire中锁多次重入，导致state越界变成负数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续看下线程挂起相关的逻辑shouldParkAfterFailedAcquire 和 parkAndCheckInterrupt 这2个方法。</p>
<h4 id="AQS-shouldParkAfterFailedAcquire"><a href="#AQS-shouldParkAfterFailedAcquire" class="headerlink" title="AQS.shouldParkAfterFailedAcquire"></a>AQS.shouldParkAfterFailedAcquire</h4><p>主要作用是找到<strong>当前节点的有效前驱</strong>，并将<strong>前驱节点状态改为SIGNAL（-1）</strong>，表示<strong>该节点释放后要继续唤醒它的后继节点</strong>，具体有三种情况：</p>
<ol>
<li>前驱节点的状态已经是SIGNAL了，直接返回</li>
<li>前驱节点的状态是CANCELLED，从后向前，找到前驱中非CANCELLED节点并且移除 查找过程中其他的CANCELLED状态节点。</li>
<li>前驱节点的状态是 0 ，设置为SIGNAL。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注意pred是当前节点的前驱节点</span></span><br><span class="line">    <span class="comment">//  前置节点的状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">// 设置前置节点状态是SIGNAL，返回后park当前线程  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="comment">// 表示cancel</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 找到cancel节点的前status&lt;=0的节点，并移除cancel状态节点，为啥会有cancle的节点后面再说</span></span><br><span class="line">        pred.next = node;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 设置前驱节点状态为-1.表示该节点释放锁之后要唤醒它的后继节点</span></span><br><span class="line">        <span class="comment">// 第一次进入时，将空节点waitStatus设置为-1 ，</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AQS-parkAndCheckInterrupt"><a href="#AQS-parkAndCheckInterrupt" class="headerlink" title="AQS.parkAndCheckInterrupt"></a>AQS.parkAndCheckInterrupt</h4><p>挂起当前线程，并且在唤醒之后返回线程中断的状态。park方法执行后，当前线程就会被挂起，直到被前一个节点释放锁之后再唤醒或者线程被中断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 挂起当前线程</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 唤醒后走到这里，返回当前线程的中断状态，并且清除中断标记</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释下LockSupport.park, 阻塞（挂起）当前线程，不会释放锁，park后，程序在下述三种情况会继续向下执行：</p>
<ol>
<li>被 unpark </li>
<li>被中断(interrupt)</li>
<li>其他不合逻辑的返回才会继续向下执行</li>
</ol>
<p>也就是说 通常只有2种方式唤醒unpark和中断(interrupt)。</p>
<h3 id="AQS-selfInterrupt"><a href="#AQS-selfInterrupt" class="headerlink" title="AQS.selfInterrupt"></a>AQS.selfInterrupt</h3><p>让我们在回到acquire方法中，selfInterrupt是怎么回事呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg)  <span class="comment">//必定成立</span></span><br><span class="line">        &amp;&amp; acquireQueued(</span><br><span class="line">            addWaiter(Node.EXCLUSIVE), arg)) <span class="comment">// acquireQueued 成立说明是抢锁成功且被中断过</span></span><br><span class="line">        <span class="comment">// 唤醒之后执行</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;        </span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 获取锁成功后，返回中断的标记</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">         </span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt()) <span class="comment">// 线程中断的状态</span></span><br><span class="line">                <span class="comment">// ！！！只要被中断信号唤醒过一次，线程状态改为true ！！！</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">              <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 中断当前线程</span></span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下selfInterrupt的调用需要的前置条件，只有acquireQueued返回true，acquireQueued成立的条件是线程<strong>节点获取锁成功且被中断过</strong>；也就是说如果<strong>中断唤醒后节点未获取到锁会继续被挂起</strong>，这也是响应中断锁和不响应中断锁的区别，后面再介绍。</p>
<p>总结下：</p>
<ol>
<li>当中断线程被唤醒时，并不知道被唤醒的原因，可能是当前线程在等待中被中断，也可能是释放了锁以后被唤醒。因此我们在parkAndCheckInterrupt通过Thread.interrupted()方法检查中断标记（该方法返回了当前线程的中断状态，并将当前线程的中断标识设置为False），并记录下来interrupted，<strong>如果发现该线程被中断过（interrupted改为true之后，不可能再被置为false）</strong>，就再通过selfInterrupt中断一次。</li>
<li>线程在等待资源的过程中被唤醒，唤醒后还是会不断地去尝试获取锁，直到抢到锁为止。也就是说，在整个流程中，并不响应中断，只是记录中断记录。最后抢到锁返回了，那么如果被中断过的话，就需要补充一次中断。</li>
</ol>
<p>到此，lock过程就全部介绍完了，下面介绍下unlock的流程。</p>
<h2 id="2-4、unlock过程"><a href="#2-4、unlock过程" class="headerlink" title="2.4、unlock过程"></a>2.4、unlock过程</h2><p>unlock的调用链如下：</p>
<p><img src="../../pics/image-20210331175233795.png" alt="image-20210331175233795"></p>
<h3 id="ReentrantLock-unlock"><a href="#ReentrantLock-unlock" class="headerlink" title="ReentrantLock.unlock"></a>ReentrantLock.unlock</h3><p>解锁时先unlock，调用到Aqs的release方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AQS-release"><a href="#AQS-release" class="headerlink" title="AQS.release"></a>AQS.release</h3><p>release的主要作用有2个：</p>
<ol>
<li>tryRelease，释放当前线程持有的锁</li>
<li>上一步成功后唤醒下一个节点</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;<span class="comment">// 1.释放当前线程持有的锁</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> <span class="comment">//</span></span><br><span class="line">            &amp;&amp; h.waitStatus != <span class="number">0</span>) <span class="comment">//waitStatus=0 说明当前head之后没有待唤醒的节点，联系入队时AQS.shouldParkAfterFailedAcquire方法理解</span></span><br><span class="line">            unparkSuccessor(h); <span class="comment">// 2.唤醒下一个节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ReentrantLock-Sync-tryRelease"><a href="#ReentrantLock-Sync-tryRelease" class="headerlink" title="ReentrantLock.Sync.tryRelease"></a>ReentrantLock.Sync.tryRelease</h3><p>tryRelease 释放当前线程的锁：</p>
<ol>
<li>独占锁，unlock 时必须是当前占用线程调用</li>
<li>考虑到锁重入的情况，每次unlock state值均减1，若减完后state值为0，说明当前线程占用的锁都释放完了，将占用线程置为空；否则将新的值赋给state。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread()) <span class="comment">// 当前线程是占用线程</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 锁完全释放完</span></span><br><span class="line">        free = <span class="keyword">true</span>; </span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>); <span class="comment">//将当前占用线程置为空</span></span><br><span class="line">    &#125;</span><br><span class="line">    setState(c); <span class="comment">// 更新state值</span></span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AQS-unparkSuccessor"><a href="#AQS-unparkSuccessor" class="headerlink" title="AQS.unparkSuccessor"></a>AQS.unparkSuccessor</h3><p>上一步释放锁成功后，unparkSuccessor中会找到<strong>距离当前node最近的状态&lt;=0的节点进行唤醒</strong>，唤醒之后再回到<code>acquireQueued</code>竞争锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>); <span class="comment">// 将释放的节点状态改为 0 </span></span><br><span class="line"></span><br><span class="line">    Node s = node.next; <span class="comment">// 找到node的下一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123; <span class="comment">// head-&gt;next 节点为空或者节点状态是取消状态</span></span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev) <span class="comment">// 从tail节点向前遍历</span></span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>) <span class="comment">// 找到距离当前node最近的状态&lt;=0的节点进行唤醒</span></span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread); <span class="comment">//唤醒下一个节点，让节点竞争，联系到acquireQueued方法中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-5、独占式响应中断的锁"><a href="#2-5、独占式响应中断的锁" class="headerlink" title="2.5、独占式响应中断的锁"></a>2.5、独占式响应中断的锁</h2><p>怎么理解响应中断?其实就是锁的线程发生中断后，锁内部抛出<code>InterruptedException</code>让调用方可以去处理。ReentrantLock里的<code>lockInterruptibly</code>就是支持响应中断的锁。</p>
<h3 id="ReentrantLock-lockInterruptibly"><a href="#ReentrantLock-lockInterruptibly" class="headerlink" title="ReentrantLock.lockInterruptibly"></a>ReentrantLock.lockInterruptibly</h3><p>调用到AQS.acquireInterruptibly</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AQS-acquireInterruptibly"><a href="#AQS-acquireInterruptibly" class="headerlink" title="AQS.acquireInterruptibly"></a>AQS.acquireInterruptibly</h3><p>主要步骤有：</p>
<ol>
<li>判断当前线程是否被中断，若被中断直接抛出异常</li>
<li>tryAcquire 加锁，和普通lock加锁逻辑基本一致，不再赘述；若加锁失败调用到<code>doAcquireInterruptibly</code>,</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted()) <span class="comment">// 若线程已经被中断</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg)) <span class="comment">// 加锁</span></span><br><span class="line">        doAcquireInterruptibly(arg); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AQS-doAcquireInterruptibly"><a href="#AQS-doAcquireInterruptibly" class="headerlink" title="AQS.doAcquireInterruptibly"></a>AQS.doAcquireInterruptibly</h3><p>doAcquireInterruptibly 响应中断方式加锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE); <span class="comment">// 构造线程节点加入到同步队列</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException(); <span class="comment">// 区别：线程中断后抛出异常，让上层处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed) <span class="comment">// 抛出异常后 failed 变为 true，走到下面逻辑里</span></span><br><span class="line">            cancelAcquire(node); <span class="comment">// 注意</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// -------对比下 acquireQueued</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>; <span class="comment">// 中断唤醒后仅设置interrupted，继续自旋竞争锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到doAcquireInterruptibly和AQS.acquireQueued基本一致，主要的区别是：</p>
<p>doAcquireInterruptibly线程通过中断唤醒节点后，<strong>会抛出<code>InterruptedException</code>异常，走入到cancelAcquire逻辑里</strong>，cancleAcquire后面再介绍。</p>
<h2 id="2-6、独占式响应中断和超时的锁"><a href="#2-6、独占式响应中断和超时的锁" class="headerlink" title="2.6、独占式响应中断和超时的锁"></a>2.6、独占式响应中断和超时的锁</h2><h3 id="AQS-tryLock"><a href="#AQS-tryLock" class="headerlink" title="AQS.tryLock"></a>AQS.tryLock</h3><p>调用到aqs.tryAcquireNanos</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AQS-tryAcquireNanos"><a href="#AQS-tryAcquireNanos" class="headerlink" title="AQS.tryAcquireNanos"></a>AQS.tryAcquireNanos</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是和上面 <code>acquireInterruptibly</code> 方法长相很详细了，继续查看来 doAcquireNanos 方法。</p>
<h3 id="AQS-doAcquireNanos"><a href="#AQS-doAcquireNanos" class="headerlink" title="AQS.doAcquireNanos"></a>AQS.doAcquireNanos</h3><p>该方法也是 throws InterruptedException，我们在中断文章中说过，方法标记上有 <code>throws InterruptedException</code> 说明该方法也是可以响应中断的，所以你可以理解超时限制是 <code>acquireInterruptibly</code> 方法的加强版，具有超时和非阻塞控制的双保险。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  	<span class="comment">// 超时时间内，未获取到同步状态，直接返回false</span></span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  	<span class="comment">// 计算超时截止时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">  	<span class="comment">// 以独占方式加入到同步队列中</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// 自旋</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="comment">// 计算新的超时时间</span></span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">          	<span class="comment">// 如果超时，直接返回 false</span></span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">            		<span class="comment">// 判断是最新超时时间是否大于阈值 1000    </span></span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">              	<span class="comment">// 挂起线程 nanosTimeout 长时间，时间到，自动返回</span></span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的方法应该不是很难懂，但是又同学可能对这个判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nanosTimeout &gt; spinForTimeoutThreshold</span><br></pre></td></tr></table></figure>

<p>为什么 nanosTimeout 和 自旋超时阈值1000进行比较？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of nanoseconds for which it is faster to spin</span></span><br><span class="line"><span class="comment"> * rather than to use timed park. A rough estimate suffices</span></span><br><span class="line"><span class="comment"> * to improve responsiveness with very short timeouts.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> spinForTimeoutThreshold = <span class="number">1000L</span>;</span><br></pre></td></tr></table></figure>

<p>其实 doc 说的很清楚，说白了，1000 nanoseconds 时间已经非常短暂了，没必要再执行挂起和唤醒操作了，不如直接让线程进入下一次循环。</p>
<p>在上面介绍中，响应中断的锁被中断后，都会抛出<code>InterruptedException</code>异常，走入到cancelAcquire逻辑里，下面就来看下cancelAcquire。</p>
<h2 id="2-7、AQS-cancelAcquire"><a href="#2-7、AQS-cancelAcquire" class="headerlink" title="2.7、AQS.cancelAcquire"></a>2.7、AQS.cancelAcquire</h2><p>cancelAcquire 本质上就是为了中断而设计。那cancle节点是什么时候生成的？就是在cancelAcquire中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 忽略无效节点</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">	  <span class="comment">// 将关联的线程信息清空</span></span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// pred 代表前驱有效节点</span></span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>) <span class="comment">// 从当前节点从后往前遍历，找到有效（非cancle）节点</span></span><br><span class="line">        node.prev = pred = pred.prev;<span class="comment">//遍历过程中移除取消状态的前驱节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取该有效节点的后继</span></span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line">    <span class="comment">// 将当前节点的状态置为 CANCELLED</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 第一种情况</span></span><br><span class="line">    <span class="comment">// 1.1、如果当前节点的前驱节点是头节点，或者上述其他条件不满足，就唤醒当前节点的后继节点</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        <span class="comment">// tail更新成功，将tail的后继节点设置为null</span></span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="comment">// 第二种情况</span></span><br><span class="line">        <span class="comment">// 2.1、如果前驱节点pred不是head，也就是说当前节点不是头节点的后继节点</span></span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            <span class="comment">// 2.2、有效前驱节点的状态是否为 SIGNAL</span></span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             <span class="comment">// 2.3、如果不是SIGNAL，尝试将前驱节点的状态置为 SIGNAL, </span></span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = node.next;</span><br><span class="line">            <span class="comment">//将当前节点的有效节点的前驱的后继 指向 当前节点的后继节点，删除当前节点</span></span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 3、第三种情况</span></span><br><span class="line">            <span class="comment">// 3.1、如果当前节点的前驱节点是头节点，或者上述其他条件不满足，就唤醒当前节点的后继节点</span></span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要步骤有：</p>
<ol>
<li><p> 从当前节点从后往前遍历，找到有效（非cancle）节点，遍历过程中移除取消状态的前驱节点。</p>
</li>
<li><p>移除当前节点是，要重新关联链表，有三种情况：</p>
<ul>
<li><p>第一种情况，如果当前节点的前驱pred是头节点，或者上述其他条件不满足，就唤醒当前节点的后继节点</p>
<img src="../../pics/image-20210331235150892.png" alt="image-20210331235150892" style="zoom:50%;" /></li>
<li><p>第二种情况，如果前驱节点的前驱pred不是head，也就是说当前节点不是头节点的后继节点，将pred-&gt;next = node.next，就是删除当前节点</p>
<img src="../../pics/image-20210331235234168.png" alt="image-20210331235234168" style="zoom:50%;" /></li>
<li><p>第三种情况，如果当前节点的前驱节点是头节点，或者上述其他条件不满足，就唤醒当前节点的后继节点。这里要补充说明下和上面情况的区别；下一个唤醒的节点是通过<code>unparkSuccessor</code>从tail向前查找到的距离当前节点最近的可唤醒的节点Node1；再进入<code>shouldParkAfterFailedAcquire</code>中将head节点唤醒。</p>
<img src="../../pics/image-20210401103926746.png" alt="image-20210401103926746" style="zoom:67%;" />



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev) <span class="comment">// 从tail向前</span></span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>) <span class="comment">// 距离当前节点最近的可唤醒的节点</span></span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">	  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的流程，我们对于CANCELLED节点状态的产生和变化已经有了大致的了解，但是<strong>为什么<code>cancelAcquire</code>所有的变化都是对Next指针进行了操作，而没有对Prev指针进行操作呢？什么情况下会对Prev指针进行操作？</strong></p>
<p>执行cancelAcquire的时候，当前节点的前置节点可能已经从队列中出去了<code>shouldParkAfterFailedAcquire</code>，如果此时修改Prev指针，有可能会导致Prev指向另一个已经移除队列的Node，因此这块变化Prev指针不安全。 shouldParkAfterFailedAcquire方法中，会执行下面的代码，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> do &#123;</span><br><span class="line">	node.prev = pred = pred.prev;</span><br><span class="line">&#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">	pred.next = node;</span><br></pre></td></tr></table></figure>

<p>其实就是在处理Prev指针。shouldParkAfterFailedAcquire是获取锁失败的情况下才会执行，进入该方法后，<strong>说明共享资源已被获取，当前节点之前的节点都不会出现变化，因此这个时候变更Prev指针比较安全</strong>。   </p>
</li>
</ul>
</li>
</ol>
<p>以上ReentrantLock 的加锁和解锁基本都介绍完了。下面介绍下常用的awit和notify的原理。</p>
<h1 id="三、Condition"><a href="#三、Condition" class="headerlink" title="三、Condition"></a>三、Condition</h1><h2 id="3-1、Condition原理初探"><a href="#3-1、Condition原理初探" class="headerlink" title="3.1、Condition原理初探"></a>3.1、Condition原理初探</h2><p>ReentrantLock中锁的等待唤醒机制是通过内部的Condition组件实现的，通过一个简单的例子了解下Condition的使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 等待</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                conditionWait();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 唤醒</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                conditionSignal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">conditionWait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;conditionWait&quot;</span>);</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;await finally&quot;</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">conditionSignal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;conditionSignal&quot;</span>);</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;signal finally&quot;</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标准的锁等待唤醒的范式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// step1: 先获取锁</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// step2: 等待或唤醒, await或notify时已经获取到锁了</span></span><br><span class="line">	condition.await();</span><br><span class="line">    <span class="comment">//condition.signal();</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// step3: 解锁</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>condition从何而来呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Condition condition = lock.newCondition();</span><br></pre></td></tr></table></figure>

<h3 id="ReentrantLock-newCondition"><a href="#ReentrantLock-newCondition" class="headerlink" title="ReentrantLock.newCondition"></a>ReentrantLock.newCondition</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AQS-ConditionObject"><a href="#AQS-ConditionObject" class="headerlink" title="AQS.ConditionObject"></a>AQS.ConditionObject</h3><p> <code>ConditionObject</code> 中实现了 <code>Condition</code> 中的方法，主要对外提供 <code>awaite(Object.wait())</code> 和 <code>signal(Object.notify())</code>调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter; <span class="comment">// 头</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter; <span class="comment">// 尾</span></span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外类中还有两个成员变量，通过名字我们也可猜到，condition中维护了一个单向链表，这个队列称为<strong>条件等待队列</strong>（下称条件队列），注意这里的Node和之前介绍的锁原理时候的Node是一样的。那条件等待队列和AQS中的同步队列是什么关系呢？我们通过下面这张图来理解下。</p>
<img src="../../pics/image-20210401114927577.png" alt="image-20210401114927577" style="zoom:75%;" />



<p>为什么会有多个条件等待队列？</p>
<p>因为在 Lock 中可以定义多个条件，每个条件都会对应一 条件等待队列。其实await和notify的原理就是基于锁同步队列和条件等待队列的，我们先给出基本原理。</p>
<p><strong>首先记住，await或notify时线程已经获取到锁了</strong>。</p>
<ul>
<li><p>await：释放Node节点的锁，挂起节点线程（当前线程），创建<strong>新节点</strong>加入到条件队列中</p>
</li>
<li><p>notify：将条件队列中的节点移动到同步队列中，唤醒节点线程竞争锁</p>
</li>
</ul>
<h2 id="3-2、ConditionObject-await"><a href="#3-2、ConditionObject-await" class="headerlink" title="3.2、ConditionObject.await"></a>3.2、ConditionObject.await</h2><p>await的需要分成2部分讲，因为await中不仅有await的逻辑，还包含了唤醒之后的逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.节点加入到条件队列</span></span><br><span class="line">    Node node = addConditionWaiter(); </span><br><span class="line">    <span class="comment">// 2.释放锁</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.判断节点是否加入到同步队列</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>); <span class="comment">// 若节点未加入到阻塞队列，则挂起，等待signal唤醒</span></span><br><span class="line">        <span class="comment">// interruptMode == THROW_IE 成立，说明node在条件队列内发生过中断</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4.signal后开始再次竞争，且node在条件队列内发生过中断</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        <span class="comment">//说明当前node在条件队列内 未发生过中断,设置interruptMode = REINTERRUPT</span></span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="comment">// 5.移除条件队列中的cancle节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="comment">// 6.线程挂起期间，发生过中断，这里进行处理中断</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>await主要步骤是：</p>
<ol>
<li>addConditionWaiter，将节点加入到条件队列</li>
<li>fullyRelease，释放锁，返回释放前的state值</li>
<li>判断节点是否在同步队列中，否则挂起当前线程。</li>
</ol>
<p>后面的逻辑是被signal唤醒后才执行的逻辑</p>
<ol start="4">
<li>唤醒后再次开始竞争</li>
<li>移除条件队列中的cancle节点</li>
<li>线程挂起期间，发生过中断，这里进行处理中断，唤醒后识别过发生的中断情况：<ol>
<li>interruptMode == THROW_IE 成立，说明node在条件队列内发生过中断</li>
<li>interruptMode == REINTERRUPT 成立，说明node在条件队列外发生过中断</li>
</ol>
</li>
</ol>
<h2 id="3-3、await的上半场"><a href="#3-3、await的上半场" class="headerlink" title="3.3、await的上半场"></a>3.3、await的上半场</h2><p>将节点加入到条件队列并挂起当前线程，主要步骤有：</p>
<ol>
<li>addConditionWaiter，<strong>将当前线程构造成一个新节点</strong>加入到 <code>条件队列</code>？</li>
<li>fullyRelease，释放锁，返回释放前的state值</li>
<li>判断节点是否在同步队列中，否则挂起当前线程。</li>
</ol>
<h3 id="AQS-addConditionWaiter"><a href="#AQS-addConditionWaiter" class="headerlink" title="AQS.addConditionWaiter"></a>AQS.addConditionWaiter</h3><p>主要步骤有：</p>
<ol>
<li>队尾元素状态不是等待时，清理队列中的无效节点</li>
<li>创建新节点，加入到条件队列，尾插法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    <span class="comment">// 1.队尾元素状态不是等待时，清理队列中的无效节点</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        <span class="comment">// 清理队列中的非 CONDITION 状态的节点，后面讲</span></span><br><span class="line">        unlinkCancelledWaiters(); </span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.创建新节点，加入到条件队列，尾插法</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AQS-fullyRelease"><a href="#AQS-fullyRelease" class="headerlink" title="AQS.fullyRelease"></a>AQS.fullyRelease</h3><p>释放当前节点的锁，唤醒后继节点，并返回线程释放前的state值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> savedState = getState();</span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123; <span class="comment">// 1.释放锁</span></span><br><span class="line">            failed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> savedState; <span class="comment">// 返回当前线程释放的state值</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();<span class="comment">// 2. 当failed失败时，说明当前线程是未lock后就调用await方法的线程..</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            node.waitStatus = Node.CANCELLED; <span class="comment">//释放失败，节点标记为cancel</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为何要返回线程释放前的state值呢？因为在节点被唤醒后，需要再次通过<code>acquireQueued</code>获取到锁，同时考虑到锁重入，所以需要将state设置为savedState。</p>
<h3 id="挂起"><a href="#挂起" class="headerlink" title="挂起"></a>挂起</h3><p>若当前节点不在同步队列中则挂起线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>); <span class="comment">//若节点未加入到阻塞队列，则挂起，等待signal唤醒</span></span><br><span class="line">	<span class="comment">// 其他后面讲</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-4、ConditionObject-signal"><a href="#3-4、ConditionObject-signal" class="headerlink" title="3.4、ConditionObject.signal"></a>3.4、ConditionObject.signal</h2><p>signal会调用到doSignal唤醒条件队列中的节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.判断调用signal方法的线程是否是独占锁持有线程</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignal(first);<span class="comment">//条件队列的不为空尝试唤醒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ConditionObject-doSignal"><a href="#ConditionObject-doSignal" class="headerlink" title="ConditionObject.doSignal"></a>ConditionObject.doSignal</h3><p>doSignal，通过循环判断，从条件队列中找到第一个可以出队的节点进行唤醒。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>) <span class="comment">// 只有一个节点</span></span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>; <span class="comment">// /当前first节点 出 条件队列，断开和下一个节点的关系</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp; </span><br><span class="line">             <span class="comment">// 当前first迁移失败，则将first更新为 first.next 继续尝试迁移</span></span><br><span class="line">             <span class="comment">// 直至迁移某个节点成功，或者 条件队列为null为止。</span></span><br><span class="line">             (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AQS-transferForSignal"><a href="#AQS-transferForSignal" class="headerlink" title="AQS.transferForSignal"></a>AQS.transferForSignal</h3><p>transferForSignal主要步骤是：</p>
<ol>
<li>cas修改当前节点状态为 0</li>
<li>将节点加入的同步队列中，注意 <strong>enq 返回的是当前节点的前驱节点</strong></li>
<li>有2情况可唤醒当前节点：<ul>
<li>前驱状态是CANCELED</li>
<li>设置前驱节点状态为SIGNAl失败，什么情况下会失败呢?<br>前驱对应的线程是<code>lockInterrupt</code>加锁时，是会响应中断的；执行完ws &gt; 0 之后，在这段时间，前驱的线程发生了中断，节点状态修改为 CANCELED，并且执行出队逻辑。</li>
</ul>
</li>
<li> LockSupport.unpark，唤醒await。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.cas修改当前节点状态为0，</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="comment">// 2.将节点加入的同步队列中，！！！返回当前节点的前驱节点！！！</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 判断的是前驱的状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="comment">// 3.是否要唤醒当前节点</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> ||  <span class="comment">// 3.1、若前驱是取消状态 </span></span><br><span class="line">        !compareAndSetWaitStatus(p, ws, Node.SIGNAL)) <span class="comment">//3.2、设置前驱节点状态为SIGNAl状态失败</span></span><br><span class="line">        LockSupport.unpark(node.thread); <span class="comment">//4.唤醒await</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止signal就结束了，signal后会唤醒线程，继续走await中剩下的逻辑。</p>
<h2 id="3-5、await的下半场"><a href="#3-5、await的下半场" class="headerlink" title="3.5、await的下半场"></a>3.5、await的下半场</h2><p>线程被唤醒后await的主要逻辑是 让节点开始竞争锁；如果线程再等待队列中发生过中断后再执行中断的一些处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.判断节点是否加入到同步队列</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>); <span class="comment">// 若节点未加入到阻塞队列，则挂起，等待signal唤醒</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// interruptMode == THROW_IE 成立，说明node在条件队列内发生过中断，跳出</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4.signal后开始再次竞争，且node在条件队列内未发生过中断</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) </span><br><span class="line">        &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        <span class="comment">// acquireQueued false 时 不会走到这里，说明节点竞争锁成功了</span></span><br><span class="line">        <span class="comment">// 说明当前node在条件队列内 未发生过中断,设置interruptMode = REINTERRUPT</span></span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="comment">// 5.移除条件队列中的cancle节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="comment">// 6.线程挂起期间，发生过中断，这里进行处理中断</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AQS-isOnSyncQueue"><a href="#AQS-isOnSyncQueue" class="headerlink" title="AQS.isOnSyncQueue"></a>AQS.isOnSyncQueue</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 唤醒后执行</span></span><br><span class="line">    <span class="comment">// interruptMode == THROW_IE 成立，说明node在条件队列内发生过中断，跳出</span></span><br><span class="line">    <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>isOnSyncQueue 是否在同步队列中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// node.waitStatus == Node.CONDITION 条件成立，说明当前node一定是在条件队列，因为signal方法迁移节点到同步队列前，会将node的状态设置为 0</span></span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || </span><br><span class="line">        <span class="comment">// 即使同步队列是刚初始化的，至少会有个虚头节点存在，所以节点的前驱如果为null，那么节点也肯定不在同步队列中</span></span><br><span class="line">        node.prev == <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 条件队列的下一个节点属性是nextWaiter </span></span><br><span class="line">    <span class="comment">// 同步队列下一个节点属性是 next，next！=null 说明是在同步队列中</span></span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从队尾始向前遍历，如果查找到，返回true,查找不到返回false, 线程挂起</span></span><br><span class="line">	<span class="keyword">return</span> findNodeFromTail(node); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">findNodeFromTail</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    Node t = tail;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t == node)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        t = t.prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ConditionObject-checkInterruptWhileWaiting"><a href="#ConditionObject-checkInterruptWhileWaiting" class="headerlink" title="ConditionObject.checkInterruptWhileWaiting"></a>ConditionObject.checkInterruptWhileWaiting</h3><p>判断在await时，线程是不是被中断唤醒的：</p>
<ol>
<li><p>如果是，再判断下是否是在 条件队列 中发生了中断</p>
</li>
<li><p>否则返回0，继续判断是否在同步队列中</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted() <span class="comment">// 说明是线程是被中断唤醒，返回当前线程中断标记位，并且重置当前标记位 为 false 。</span></span><br><span class="line">        ? (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) <span class="comment">// 中断唤醒时走到这里</span></span><br><span class="line">        : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AQS-transferAfterCancelledWait"><a href="#AQS-transferAfterCancelledWait" class="headerlink" title="AQS.transferAfterCancelledWait"></a>AQS.transferAfterCancelledWait</h4><p>线程被中断唤醒时，将条件队列中的节点 迁移到 <code>同步队列</code>中，并且返回节点是是否是在 <code>条件队列</code> 中被中断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferAfterCancelledWait</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先将节点状态改为0</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// 再将节点从 条件队列 迁移到 同步队列 中</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 走到这里说明节点正在 向同步队列 迁移中</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node))</span><br><span class="line">        <span class="comment">// yield 缓一下再check，等同步队列迁移完后再判断</span></span><br><span class="line">        Thread.yield();</span><br><span class="line">    <span class="comment">// false:表示当前节点被中断唤醒时 不在 条件队列了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="加入竞争"><a href="#加入竞争" class="headerlink" title="加入竞争"></a>加入竞争</h3><p>acquireQueued 让被唤醒的线程开始竞争锁。</p>
<p>注意此时 acquireQueued 正常是获取不到锁的，会再次挂起；acquireQueued的主要功能是让线程重新竞争锁，<strong>需要等前一个线程执行完成unlock，才能在acquireQueued中重新获取到了锁，再往下执行</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4.signal后开始再次竞争，且node在条件队列内未发生过中断</span></span><br><span class="line"><span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; </span><br><span class="line">    <span class="comment">// acquireQueued false 时 不会走到这里，说明节点竞争锁成功了</span></span><br><span class="line">    interruptMode != THROW_IE) </span><br><span class="line">    <span class="comment">// acquireQueued 返回true，说明在同步队列中竞争锁时又发生了中断，需要再最后设置线程状态为 中断</span></span><br><span class="line">    <span class="comment">// interruptMode 设置为 REINTERRUPT</span></span><br><span class="line">    interruptMode = REINTERRUPT;</span><br></pre></td></tr></table></figure>

<h3 id="ConditionObject-unlinkCancelledWaiters"><a href="#ConditionObject-unlinkCancelledWaiters" class="headerlink" title="ConditionObject.unlinkCancelledWaiters"></a>ConditionObject.unlinkCancelledWaiters</h3><p>移除条件队列中非CONDITION状态的节点，非CONDITION有2种情况：</p>
<ol>
<li>一种是cancel ，线程发生了中断</li>
<li>状态是 0 ，说明节点已经被迁移到 同步队列中了，注意 Signal唤醒迁移时，并没有把节点从<code>条件队列</code>中移除，<strong>移除是在这里执行的</strong>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = firstWaiter;<span class="comment">// 从头开始循环</span></span><br><span class="line">    Node trail = <span class="keyword">null</span>; <span class="comment">// 上一个正常节点</span></span><br><span class="line">    <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node next = t.nextWaiter; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123; <span class="comment">// 当前节点状态为CANCELED</span></span><br><span class="line">            t.nextWaiter = <span class="keyword">null</span>; <span class="comment">// 节点出队</span></span><br><span class="line">            <span class="keyword">if</span> (trail == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">// 更新firstWaiter指针为下个节点就可以</span></span><br><span class="line">                firstWaiter = next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                trail.nextWaiter = next;<span class="comment">// 上一个 CONDITION 指向 非Condition的 下一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>) <span class="comment">// 当前节点为队尾节点了，更新lastWaiter 指向最后一个正常节点</span></span><br><span class="line">                lastWaiter = trail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            trail = t; <span class="comment">// 指向队列中的上一个 CONDITION 节点</span></span><br><span class="line">        </span><br><span class="line">        t = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ConditionObject-reportInterruptAfterWait"><a href="#ConditionObject-reportInterruptAfterWait" class="headerlink" title="ConditionObject.reportInterruptAfterWait"></a>ConditionObject.reportInterruptAfterWait</h3><p>有2种情况：</p>
<ol>
<li>在条件队列内发生过中断，此时await方法抛出中断异常，这也是await响应中断的原理。</li>
<li>在条件队列外发生的中断，此时设置当前线程的中断标记位 为true</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportInterruptAfterWait</span><span class="params">(<span class="keyword">int</span> interruptMode)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (interruptMode == THROW_IE) <span class="comment">// 在条件队列内发生过中断，此时await方法抛出中断异常；</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (interruptMode == REINTERRUPT) <span class="comment">// 在条件队列外发生的中断，此时设置当前线程的中断标记位 为true</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此， await和signal都介绍完了。我们再回顾下await和signal时，节点在同步队列中的条件队列中的变化情况。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过一张图来理解下await和signal过程。</p>
<p><img src="../../pics/image-20210402161954926.png" alt="image-20210402161954926"></p>
<ol>
<li><p>await时，会使用当前节点的线程构造一个CONDITION 状态的<strong>新节点加入到条件队列</strong>中，<strong>并且挂起当前线程。</strong></p>
<p>那么原来同步队列中的节点什么时候出队的呢？这里有2种情况</p>
<ol>
<li>await时，锁没有竞争，那么在await时，<code>同步队列</code>中不存在任何节点，自然就不用出队</li>
<li>await时，存在竞争，那么此时的head虚节点节点就是当前线程对应的节点；执行完fullyRelease后，第二个线程在唤醒后再acquireQueued中获取到锁时会将前一次的head出队。</li>
</ol>
<p>await的线程挂起后要需要等signal唤醒之后再执行，先走到signal的流程中。</p>
</li>
<li><p>signal时，将条件队列中的节点状态从 CONDITION 改为 0， 并加入<code>同步队列</code>中，此时该节点也没有从<code>条件队列</code>中移除。什么时候移除呢？</p>
<p>在<code>unlinkCancelledWaiters</code>中会将非 CONDITION 状态节点移出条件队列。</p>
<p>执行完signal后，await的线程被唤醒继续执行，首先判断下是不是被中断唤醒的，如果是，再判断下：</p>
<ol>
<li>在<code>条件队列</code>被中断唤醒，后续会抛出中断异常</li>
<li>在signal <strong>转移迁移节点到<code>同步队列</code>过程中</strong> 被中断的，后续会设置线程为中断</li>
</ol>
</li>
</ol>
<p>最后 acquireQueued 让节点开始竞争锁，移除条件队列中的非 CONDITION 节点，识别并设置线程的中断状态。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们从AQS开始介绍到ReentrantLock的lock和unlock，Condition的await和notify的原理。理解AQS 中的 同步队列 和 条件等待 队列的作用。剩余的知识，trylock 和 lock区别，共享锁（ReentrantReadWriteLock），后面的文章再介绍。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="http://www.starfish.ink/java/JUC/AQS.html#%E6%98%AF%E4%BB%80%E4%B9%88">http://www.starfish.ink/java/JUC/AQS.html#%E6%98%AF%E4%BB%80%E4%B9%88</a></p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html">https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/09/Notes/Java/JUC/JUC03_Volatile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/09/Notes/Java/JUC/JUC03_Volatile/" class="post-title-link" itemprop="url">JUC_03_volatile</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-09 23:52:52" itemprop="dateCreated datePublished" datetime="2021-04-09T23:52:52+08:00">2021-04-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/JUC/" itemprop="url" rel="index"><span itemprop="name">JUC</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JUC-03-volatile"><a href="#JUC-03-volatile" class="headerlink" title="JUC_03_volatile"></a>JUC_03_volatile</h1><p>被volatile修饰的共享变量，具有了以下特性：</p>
<ul>
<li>线程间可见性</li>
<li>禁止指令重排序 – 有序性</li>
<li>不保证原子性</li>
</ul>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>被volatile修饰的变量，如果在工作内存中发生了变化，回立刻写入到主内存中，同时使得其他工作内存中的变量无效。</p>
<p>写入过程中操作如下： <strong>lock + storge + write +  unlock</strong> 。</p>
<img src="../../pics/image-20210320170110425.png" alt="image-20210320170110425" style="zoom:50%;" />



<h3 id="lock-指令"><a href="#lock-指令" class="headerlink" title="lock 指令"></a>lock 指令</h3><p>volatile的底层实现是汇编的lock指令，<strong>它会锁定这块内存区域的缓存（缓存行锁定）</strong>。lock 前缀的指令在多核处理器下会引发两件事情：</p>
<ul>
<li>将当前处理器<strong>缓存行的数据写回到系统内存</strong></li>
<li><strong>使其他 CPU 里缓存了该内存地址的数据失效（MESI）</strong></li>
</ul>
<h3 id="不保证原子性"><a href="#不保证原子性" class="headerlink" title="不保证原子性"></a>不保证原子性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPlusPlus</span><span class="params">()</span></span>&#123;</span><br><span class="line">        number ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAtomic</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  MyData myData = <span class="keyword">new</span> MyData();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">        myData.add();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;addPlusThread:&quot;</span>+ i).start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//等待上边20个线程结束后(预计5秒肯定结束了)，在main线程中获取最后的number</span></span><br><span class="line">  TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>)&#123;</span><br><span class="line">    Thread.yield();</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(<span class="string">&quot;final value：&quot;</span>+myData.number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行 <code>testAtomic</code> 发现最后的输出值 &lt;= 10000 。</p>
<p>为什么会这样呢? 假设有2个线程同时执行 i ++，执行完工作内存值都是1，执行assgin回写时。此时出现线程竞争的话，<strong>线程1先会lock写入，线程2中的值会被置为无效</strong>，需要重新去主存中读取再继续执行，相当于丢失了一次值。</p>
<img src="../../pics/image-20210320162753252.png" alt="image-20210320162753252" style="zoom:50%;" />



<p>volatile的底层是使用内存屏障来保证有序性的。写volatile变量时，可以确保volatile写之前的操作不会被编译器重排序到volatile写之后。读volatile变量时，可以确保volatile读之后的操作不会被编译器重排序到volatile读之前。</p>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>禁止指令重排序 .从而避免了多线程环境下程序出现乱序执行的现象。</p>
<p>最常见的多线程环境中 <code>DCL(double-checked locking)</code> 版本的单例模式中，就是使用了 volatile 禁止指令重排的特性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123; <span class="comment">// 线程B</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">              	<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;<span class="comment">// 线程A</span></span><br><span class="line">                      instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为有指令重排序的存在，双端检索机制也不一定是线程安全的。</p>
<p><code>instance = new Singleton();</code> </p>
<p>初始化对象的过程其实并不是一个原子的操作，它会分为三部分执行：</p>
<ol>
<li>给 instance 分配内存</li>
<li>调用 instance 的构造函数来初始化对象</li>
<li>将 instance 对象指向分配的内存空间</li>
</ol>
<p>步骤 2 和 3 不存在数据依赖(as-if-serial)关系，如果虚拟机存在指令重排序优化，则步骤 2 和 3 的顺序是无法确定的。</p>
<p>如果 A 线程率先进入同步代码块并先执行了步骤3 而没有执行 2，也就是先给赋值给引用，但未进行初始化。</p>
<p>这时候线程 B 在第一次检查的时候，会发现 instance 已经是 非null 了，就将其返回使用，但是此时 instance 实际上还未初始化，自然就会出错。所以我们要限制实例对象的指令重排，用 volatile 修饰（JDK 5 之前使用了 volatile 的双检锁是有问题的）。</p>
<p>通过 hsdis 工具获取 JIT 编译器生成的汇编指令来看看对 volatile 进行写操作 CPU 会做什么事情，还是用上边的单例模式，可以看到</p>
<img src="../../pics/image-20210320214507422.png" alt="image-20210320214507422" style="zoom:50%;" />

<p>有 volatile 修饰的共享变量进行写操作时会多出第二行汇编代码，该句代码的意思是<strong>对原值加零</strong>，其中相加指令addl 前有 <strong>lock</strong> 修饰。</p>
<p>lock指令除了前面所讲的2个作用外，还有一个作用是<strong>提供内存屏障的作用</strong>，即</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br></pre></td></tr></table></figure>

<p>赋值操作的3条指令不可重排序。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/54chensongxia/p/12120117.html">https://www.cnblogs.com/54chensongxia/p/12120117.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/09/Notes/Java/JUC/JUC02_CAS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/09/Notes/Java/JUC/JUC02_CAS/" class="post-title-link" itemprop="url">JUC_02_CAS</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-09 23:52:52" itemprop="dateCreated datePublished" datetime="2021-04-09T23:52:52+08:00">2021-04-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/JUC/" itemprop="url" rel="index"><span itemprop="name">JUC</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JUC-02-CAS"><a href="#JUC-02-CAS" class="headerlink" title="JUC_02_CAS"></a>JUC_02_CAS</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/09/Notes/Java/JUC/JUC01_Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/09/Notes/Java/JUC/JUC01_Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">JUC_01_JMM</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-09 23:52:52" itemprop="dateCreated datePublished" datetime="2021-04-09T23:52:52+08:00">2021-04-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/JUC/" itemprop="url" rel="index"><span itemprop="name">JUC</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JUC-01-JMM"><a href="#JUC-01-JMM" class="headerlink" title="JUC_01_JMM"></a>JUC_01_JMM</h1><p>介绍 Java 内存模型之前，先温习下计算机硬件内存模型。</p>
<p>计算机在执行程序的时候，每条指令都是在 CPU 中执行的，而执行的时候，又免不了要和数据打交道。而计算机上面的数据，是存放在主存当中的，也就是计算机的物理内存。</p>
<p>计算机硬件架构简易图：</p>
<img src="/pics/image-20210318234901621.png" alt="image-20210318234901621" style="zoom:50%;" />

<p>我们以多核 CPU 为例，每个CPU 核都包含<strong>一组 「CPU 寄存器」</strong>，这些寄存器本质上是在 CPU 内存中。CPU 在这些寄存器上执行操作的速度要比在主内存(RAM)中执行的速度快得多。</p>
<p>因为<strong>CPU速率高， 内存速率慢，为了让存储体系可以跟上CPU的速度，所以中间又加上 Cache 层，就是我们说的 「CPU 高速缓存」</strong>。</p>
<h3 id="CPU多级缓存"><a href="#CPU多级缓存" class="headerlink" title="CPU多级缓存"></a>CPU多级缓存</h3><p>由于CPU的运算速度远远超越了1级缓存的数据IO能力，CPU厂商又引入了多级的缓存结构。通常L1、L2 是每个CPU 核有一个，L3 是多个核共用一个。</p>
<h3 id="Cache-Line"><a href="#Cache-Line" class="headerlink" title="Cache Line"></a>Cache Line</h3><p>Cache又是由很多个<strong>「缓存行」</strong>(Cache line) 组成的。Cache line 是 Cache 和 RAM 交换数据的最小单位。</p>
<p>Cache 存储数据是固定大小为单位的，称为一个<strong>Cache entry</strong>，这个单位称为<strong>Cache line</strong>或<strong>Cache block</strong>。给定Cache 容量大小和 Cache line size 的情况下，它能存储的条目个数(number of cache entries)就是固定的。因为Cache 是固定大小的，所以它从主内存获取数据也是固定大小。对于X86来讲，是 64Bytes。对于ARM来讲，较旧的架构的Cache line是32Bytes，但一次内存访存只访问一半的数据也不太合适，所以它经常是一次填两个 Cache line，叫做 double fill。</p>
<h3 id="缓存的工作原理"><a href="#缓存的工作原理" class="headerlink" title="缓存的工作原理"></a>缓存的工作原理</h3><p>这里的缓存的工作原理和我们项目中用 memcached、redis 做常用数据的缓存层是一个道理。</p>
<p>当 CPU 要读取一个数据时，首先从缓存中查找，如果找到就立即读取并送给CPU处理；如果没有找到，就去内存中读取并送给 CPU 处理，同时把这个数据所在的<strong>数据块</strong>（就是我们上边说的 Cache block）调入缓存中，即把临近的共 64 Byte 的数据也一同载入，因为临近的数据在将来被访问的可能性更大，可以使得以后对整块数据的读取都从缓存中进行，<strong>不必再调用内存</strong>。</p>
<p>这就增加了CPU读取缓存的<strong>命中率</strong>（Cache hit）了。</p>
<h3 id="计算机层级存储"><a href="#计算机层级存储" class="headerlink" title="计算机层级存储"></a>计算机层级存储</h3><p>计算机存储系统是有层次结构的，类似一个金字塔，顶层的寄存器读写速度较高，但是空间较小。底层的读写速度较低，但是空间较大。</p>
<img src="/pics/image-20210318235811049.png" alt="image-20210318235811049" style="zoom:50%;" />

<h3 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h3><p>既然每个核中都有单独的缓存，那我的 4 核 8 线程 CPU 处理主内存数据的时候，不就会出现数据不一致问题了吗？</p>
<p>为了解决这个问题，先后有过两种方法：<strong>总线锁机制</strong>和<strong>缓存锁机制</strong>。</p>
<p>总线锁就是使用 CPU 提供的一个<code>LOCK#</code>信号，当一个处理器在总线上输出此信号，其他处理器的请求将被阻塞，那么该处理器就可以独占共享锁。这样就保证了数据一致性。</p>
<p>但是总线锁开销太大，我们需要控制锁的粒度，所以又有了缓存锁，核心就是“<strong>缓存一致性协议</strong>”，不同的 CPU 硬件厂商实现方式稍有不同，有MSI、MESI、MOSI等。</p>
<h3 id="代码乱序执行优化"><a href="#代码乱序执行优化" class="headerlink" title="代码乱序执行优化"></a>代码乱序执行优化</h3><p>为了使得处理器内部的运算单元尽量被充分利用，提高运算效率，处理器可能会对输入的代码进行「乱序执行」**(Out-Of-Order Execution)，处理器会在计算之后将乱序执行的结果重组，**乱序优化可以保证在单线程下该执行结果与顺序执行的结果是一致的，但不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致。</p>
<p><strong>乱序执行技术是处理器为提高运算速度而做出违背代码原有顺序的优化</strong>。在单核时代，处理器保证做出的优化不会导致执行结果远离预期目标，但在多核环境下却并非如此。</p>
<p>多核环境下， 如果存在一个核的计算任务依赖另一个核的计算任务的中间结果，而且对相关数据读写没做任何防护措施，那么其顺序性并不能靠代码的先后顺序来保证，处理器最终得出的结果和我们逻辑得到的结果可能会大不相同。</p>
<h4 id="编译器指令重排"><a href="#编译器指令重排" class="headerlink" title="编译器指令重排"></a>编译器指令重排</h4><p>除了上述由处理器和缓存引起的乱序之外，现代编译器同样提供了乱序优化。之所以出现编译器乱序优化其根本原因在于处理器每次只能分析一小块指令，但编译器却能在很大范围内进行代码分析，从而做出更优的策略，充分利用处理器的乱序执行功能。</p>
<h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><p>尽管我们看到乱序执行初始目的是为了提高效率，但是它看来其好像在这多核时代不尽人意，其中的某些”自作聪明”的优化导致多线程程序产生各种各样的意外。因此有必要存在一种机制来消除乱序执行带来的坏影响，也就是说应该允许程序员显式的告诉处理器对某些地方禁止乱序执行。这种机制就是所谓内存屏障。不同架构的处理器在其指令集中提供了不同的指令来发起内存屏障，对应在编程语言当中就是提供特殊的关键字来调用处理器相关的指令，JMM里我们再探讨。</p>
<h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><p>Java 内存模型即 <code>Java Memory Model</code>，简称 <strong>JMM</strong>。</p>
<p>这里的内存模型可不是 JVM 里的运行时数据区。</p>
<p>「内存模型」可以理解为<strong>在特定操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象</strong>。</p>
<p>不同架构的物理计算机可以有不一样的内存模型，Java虚拟机也有自己的内存模型。</p>
<p>Java虚拟机规范中试图定义一种「 <strong>Java 内存模型</strong>」来<strong>屏蔽掉各种硬件和操作系统的内存访问差异</strong>，以实现<strong>让 Java 程序在各种平台下都能达到一致的内存访问效果</strong>，不必因为不同平台上的物理机的内存模型的差异，对各平台定制化开发程序。</p>
<p>Java 内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。这里的变量与我们写 Java 代码中的变量不同，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量和方法参数，因为他们是线程私有的，不会被共享。</p>
<h3 id="JMM-组成"><a href="#JMM-组成" class="headerlink" title="JMM 组成"></a>JMM 组成</h3><ul>
<li><p><strong>主内存</strong>：Java 内存模型规定了所有变量都存储在主内存(Main Memory)中（此处的主内存与物理硬件的主内存RAM 名字一样，两者可以互相类比，但此处仅是虚拟机内存的一部分）。</p>
</li>
<li><p><strong>工作内存</strong>：每条线程都有自己的工作内存(Working Memory，又称本地内存，可与CPU高速缓存类比)，线程的工作内存中保存了该线程使用到的主内存中的共享变量的副本拷贝。<strong>线程对变量的所有操作都必须在工作内存进行，而不能直接读写主内存中的变量</strong>。<strong>工作内存是 JMM 的一个抽象概念，并不真实存在</strong>。</p>
<img src="/pics/image-20210318234012867.png" alt="image-20210318234012867" style="zoom:50%;" /></li>
</ul>
<h3 id="JMM-与-JVM-内存结构"><a href="#JMM-与-JVM-内存结构" class="headerlink" title="JMM 与 JVM 内存结构"></a>JMM 与 JVM 内存结构</h3><p>JMM 与 Java 内存区域中的堆、栈、方法区等并不是同一个层次的内存划分，两者基本没有关系。如果一定要勉强对应，那从变量、主内存、工作内存的定义看，<strong>主内存主要对应 Java 堆中的对象实例数据部分，工作内存则对应虚拟机栈的部分区域</strong>（与上图对应着看哈）。</p>
<img src="/pics/image-20210319000613709.png" alt="image-20210319000613709" style="zoom:50%;" />

<h3 id="JMM-与计算机内存结构"><a href="#JMM-与计算机内存结构" class="headerlink" title="JMM 与计算机内存结构"></a>JMM 与计算机内存结构</h3><p>Java 内存模型和硬件内存体系结构也没有什么关系。硬件内存体系结构不区分栈和堆。在硬件上，线程栈和堆都位于主内存中。线程栈和堆的一部分有时可能出现在高速缓存和CPU寄存器中。如下图所示:</p>
<img src="/pics/image-20210319000711299.png" alt="image-20210319000711299" style="zoom:50%;" />

<p>当对象和变量可以存储在计算机中不同的内存区域时，这就可能会出现某些问题。两个主要问题是:</p>
<ul>
<li><strong>线程更新(写)到共享变量的可见性</strong></li>
<li><strong>读取、检查和写入共享变量时的竞争条件</strong></li>
</ul>
<h4 id="可见性问题（Visibility-of-Shared-Objects）"><a href="#可见性问题（Visibility-of-Shared-Objects）" class="headerlink" title="可见性问题（Visibility of Shared Objects）"></a>可见性问题（Visibility of Shared Objects）</h4><p>如果两个或多个线程共享一个对象，则一个线程对共享对象的更新可能对其他线程不可见（当然可以用 Java 提供的关键字 volatile）。 假设共享对象最初存储在主内存中。在 CPU 1上运行的线程将共享对象读入它的CPU缓存后修改，但是还没来得及即刷新回主内存，这时其他 CPU 上运行的线程就不会看到共享对象的更改。这样，每个线程都可能以自己的线程结束，就出现了可见性问题，如下</p>
<img src="/pics/image-20210319004455084.png" alt="image-20210319004455084" style="zoom:50%;" />

<h4 id="竞争条件（Race-Conditions）"><a href="#竞争条件（Race-Conditions）" class="headerlink" title="竞争条件（Race Conditions）"></a>竞争条件（Race Conditions）</h4><p>这个其实就是我们常说的原子问题。</p>
<p>如果两个或多个线程共享一个对象，并且多个线程更新该共享对象中的变量，则可能出现竞争条件。</p>
<p>想象一下，如果线程 A 将一个共享对象的变量读入到它的 CPU 缓存中。此时，线程 B 执行相同的操作，但是进入不同的 CPU 缓存。现在线程A执行 +1 操作，线程B也这样做。现在该变量增加了两次，在每个 CPU 缓存中一次。</p>
<p>如果这些增量是按顺序执行的，则变量结果会是 3，并将原始值 +2 写回主内存。但是，这两个增量是同时执行的，没有适当的同步。不管将哪个线程的结构写回主内存，更新后的值只比原始值高1，显然是有问题的。如下（当然可以用 Java 提供的关键字 Synchronized）</p>
<img src="/pics/image-20210319004553218.png" alt="image-20210319004553218" style="zoom:50%;" />

<h3 id="JMM-特性"><a href="#JMM-特性" class="headerlink" title="JMM 特性"></a>JMM 特性</h3><p>JMM 就是用来解决如上问题的。 <strong>JMM是围绕着并发过程中如何处理可见性、原子性和有序性这 3 个 特征建立起来的</strong></p>
<ul>
<li><p><strong>可见性</strong>：<strong>可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改</strong>。Java 中的 volatile、synchronzied、final 都可以实现可见性</p>
</li>
<li><p><strong>原子性</strong>：即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。<strong>即使在多个线程一起执行的时候</strong>，一个操作一旦开始，就不会被其他线程所干扰。</p>
</li>
<li><p><strong>有序性</strong>：计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排，一般分为以下 3 种：</p>
<p><img src="/pics/image-20210319001149455.png" alt="image-20210319001149455">单线程环境里确保程序最终执行结果和代码顺序执行的结果一致；</p>
<p>处理器在进行重排序时必须要考虑指令之间的<strong>数据依赖性</strong>；</p>
<p>多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。</p>
</li>
</ul>
<h3 id="内存之间的交互操作"><a href="#内存之间的交互操作" class="headerlink" title="内存之间的交互操作"></a>内存之间的交互操作</h3><p>关于主内存和工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java 内存模型中定义了 8 种 操作来完成，<strong>虚拟机实现必须保证每一种操作都是原子的、不可再拆分的</strong>（double和long类型例外）</p>
<ul>
<li><strong>lock</strong>（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</li>
<li><strong>unlock</strong>（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li><strong>read</strong>（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li>
<li><strong>load</strong>（载入）：作用于工作内存的变量，它把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li><strong>use</strong>（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</li>
<li><strong>assign</strong>（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li><strong>store</strong>（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的 write操作使用。</li>
<li><strong>write</strong>（写入）：作用于主内存的变量，它把 store 操作从工作内存中得到的变量的值放入主内存的变量中。</li>
</ul>
<p>如果需要把一个变量从主内存复制到工作内存，那就要顺序地执行 <strong>read 和 load 操作</strong>，如果要把变量从工作内存同步回主内存，就要顺序地执行 <strong>store 和 write 操作</strong>。注意，<strong>Java 内存模型只要求上述两个操作必须按顺序执行，而没有保证是连续执行</strong>。也就是说 read 与 load 之间、store 与write 之间是可插入其他指令的，如对主内存中的变量 a、b 进行访问时，一种可能出现顺序是 read a、read b、load b、load a。</p>
<img src="/pics/image-20210319001848007.png" alt="image-20210319001848007" style="zoom:50%;" />

<p>除此之外，Java 内存模型还规定了在执行上述 8 种基本操作时必须满足如下规则</p>
<ul>
<li>不允许 read 和 load、store 和 write 操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。</li>
<li>不允许一个线程丢弃它的最近的 assign 操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li>
<li>不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从线程的工作内存同步回主内存。</li>
<li>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load 或 assign）的变量，换句话说，就是对一个变量实施 use、store 操作之前，必须先执行过了 assign 和 load 操作。</li>
<li>一个变量在同一时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。</li>
<li>如果对一个变量执行 lock 操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值。</li>
<li>如果一个变量事先没有被 lock 操作锁定，那就不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定住的变量。</li>
<li>对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中（执行 store、write 操作）。</li>
</ul>
<h4 id="long-和-double-型变量的特殊规则"><a href="#long-和-double-型变量的特殊规则" class="headerlink" title="long 和 double 型变量的特殊规则"></a>long 和 double 型变量的特殊规则</h4><p>Java 内存模型要求 lock，unlock，read，load，assign，use，store，write 这 8 个操作都具有原子性，但对于64 位的数据类型（ long 或 double），在模型中定义了一条相对宽松的规定，允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作划分为两次 32 位的操作来进行，即允许虚拟机实现选择可以不保证 64 位数据类型的load，store，read，write 这 4 个操作的原子性，即 <strong>long 和 double 的非原子性协定</strong>。</p>
<p>如果多线程的情况下double 或 long 类型并未声明为 volatile，可能会出现“半个变量”的数值，也就是既非原值，也非修改后的值。</p>
<p>虽然 Java 规范允许上面的实现，但商用虚拟机中基本都采用了原子性的操作，因此在日常使用中几乎不会出现读取到“半个变量”的情况，so，这个了解下就行。</p>
<h3 id="先行发生原则（这8种情况不可以重排序，必须加屏障）"><a href="#先行发生原则（这8种情况不可以重排序，必须加屏障）" class="headerlink" title="先行发生原则（这8种情况不可以重排序，必须加屏障）"></a>先行发生原则（这8种情况不可以重排序，必须加屏障）</h3><p>先行发生（happens-before）是 Java 内存模型中定义的两项操作之间的偏序关系，<strong>如果操作A 先行发生于操作B，那么A的结果对B可见</strong>。happens-before关系的分析需要分为<strong>单线程和多线程</strong>的情况：</p>
<ul>
<li><strong>单线程下的 happens-before</strong> 字节码的先后顺序天然包含 happens-before 关系：因为单线程内共享一份工作内存，不存在数据一致性的问题。 在程序控制流路径中靠前的字节码 happens-before 靠后的字节码，即靠前的字节码执行完之后操作结果对靠后的字节码可见。然而，这并不意味着前者一定在后者之前执行。实际上，如果后者不依赖前者的运行结果，那么它们可能会被重排序。</li>
<li><strong>多线程下的 happens-before</strong> 多线程由于每个线程有共享变量的副本，如果没有对共享变量做同步处理，线程 1 更新执行操作 A 共享变量的值之后，线程 2 开始执行操作 B，此时操作 A 产生的结果对操作 B 不一定可见。</li>
</ul>
<p>为了方便程序开发，Java 内存模型实现了下述的先行发生关系（“天然的”先行发生关系，无需任何同步器协助就存在）：</p>
<ul>
<li><strong>程序次序规则：</strong> 一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作。</li>
<li><strong>管程锁定规则：</strong> 一个 unLock 操作先行发生于后面对同一个锁的 lock 操作。</li>
<li><strong>volatile变量规则：</strong> 对一个变量的写操作先行发生于后面对这个变量的读操作。</li>
<li><strong>传递规则：</strong> 如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出操作 A 先行发生于操作 C。</li>
<li><strong>线程启动规则：</strong> Thread对象的 <code>start()</code> 方法先行发生于此线程的每一个动作。</li>
<li><strong>线程中断规则：</strong> 对线程 <code>interrupt()</code> 方法的调用先行发生于被中断线程的代码检测到中断事件的发生。</li>
<li><strong>线程终结规则：</strong> 线程中所有的操作都先行发生于线程的终止检测，我们可以通过<code>Thread.join()</code>方法结束、<code>Thread.isAlive()</code>的返回值手段检测到线程已经终止执行。</li>
<li><strong>对象终结规则：</strong> 一个对象的初始化完成先行发生于它的 <code>finalize()</code>方法的开始</li>
</ul>
<h3 id="内存屏障-1"><a href="#内存屏障-1" class="headerlink" title="内存屏障"></a>内存屏障</h3><p>上边的一系列操作保证了数据一致性，Java 中如何保证底层操作的有序性和可见性？可以通过内存屏障。</p>
<p>内存屏障是被插入两个 CPU 指令之间的一种指令，用来禁止处理器指令发生重排序（像屏障一样），从而保障<strong>有序性</strong>的。另外，为了达到屏障的效果，它也会使处理器写入、读取值之前，将主内存的值写入高速缓存，清空无效队列，从而保障<strong>可见性</strong>。eg:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Store1; </span><br><span class="line">Store2;   </span><br><span class="line">Load1;   </span><br><span class="line">StoreLoad;  //内存屏障</span><br><span class="line">Store3;   </span><br><span class="line">Load2;   </span><br><span class="line">Load3;</span><br></pre></td></tr></table></figure>

<p>StoreLoad 屏障之前的 Store 指令无法与 StoreLoad 屏障之后的 Load 指令进行交换位置，即<strong>重排序</strong>。但是 StoreLoad 屏障之前和之后的指令是可以互换位置的，即 Store1 可以和 Store2 互换，Load2 可以和 Load3 互换。</p>
<p>常见的 4 种屏障：<strong>注意这些不是cpu的指令，而是JVM的规范要求，</strong>不同的CPU有不同的实现。 </p>
<ul>
<li><p><strong>LoadLoad</strong> 屏障： 对于这样的语句 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Load1; LoadLoad; Load2</span><br></pre></td></tr></table></figure>

<p>在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</p>
</li>
<li><p><strong>StoreStore</strong> 屏障： 对于这样的语句 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Store1; StoreStore; Store2</span><br></pre></td></tr></table></figure>

<p>在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</p>
</li>
<li><p><strong>LoadStore</strong> 屏障： 对于这样的语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Load1; LoadStore; Store2</span><br></pre></td></tr></table></figure>

<p>在Store2及后续写入操作被执行前，保证Load1要读取的数据被读取完毕。</p>
</li>
<li><p><strong>StoreLoad</strong> 屏障： 对于这样的语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Store1; StoreLoad; Load2</span><br></pre></td></tr></table></figure>

<p>在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的（冲刷写缓冲器，清空无效化队列）。在大多数处理器的实现中，这个屏障也被称为<strong>全能屏障</strong>，兼具其它三种内存屏障的功能。</p>
</li>
</ul>
<p>Java 中对内存屏障的使用在一般的代码中不太容易见到，常见的有 volatile 和 synchronized 关键字修饰的代码块，还可以通过 Unsafe 这个类来使用内存屏障。（下一章扯扯这些）</p>
<p>Java 内存模型就是通过定义的这些来解决可见性、原子性和有序性的。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="JMM-是什么？"><a href="#JMM-是什么？" class="headerlink" title="JMM 是什么？"></a>JMM 是什么？</h3><p>JMM，java内存模型，定义了内存中变量的访问规范（JVM和RAM交互规则），是一种抽象的概念。目的是为了让<strong>java程序在各种平台下都能达到一致的并发效果</strong>，屏蔽掉各种硬件和操作系统的差异。</p>
<p>JMM规定了内存主要划分为<strong>主内存</strong>和<strong>工作内存</strong>两种。</p>
<ul>
<li>主内存(Main Memory)：JMM规定<strong>所有的变量都存储在主内存</strong>中。</li>
<li>工作内存：线程私有的，每条线程都有自己的工作内存。保存了该线程使用到的主内存中的共享变量的副本。<strong>线程对变量的所有操作都必须在工作内存进行，而不能直接读写主内存中的变量</strong>。</li>
</ul>
<h3 id="JMM解决什么问题？"><a href="#JMM解决什么问题？" class="headerlink" title="JMM解决什么问题？"></a>JMM解决什么问题？</h3><p>JMM主要是为了解决并发过程中<strong>可见性问题和竞争问题</strong>，围绕着并发过程中如何处理可见性、原子性和有序性这3个特性建立起来的。</p>
<ul>
<li><p>原子性</p>
<p>一个操作是不可分割、不可中断的，<strong>一个线程在执行时不会被其他线程干扰</strong>。synchronized + lock + cas</p>
</li>
<li><p>可见性</p>
<p>当一个线程修改共享变量的值，其他线程能够立即知道。 volatile  + synchronized + lock</p>
</li>
<li><p>有序性</p>
<p>程序执行的顺序按照代码的先后顺序执行。程序执行过程中，编译器和处理器对指令进行的重排序优化，使得<strong>并发过程中代码的执行顺序和代码的先后顺序不一致</strong>，导致最终的结果无法预测。synchronized + happensbefore + lock</p>
</li>
</ul>
<h3 id="JMM中的8种内存交互操作？"><a href="#JMM中的8种内存交互操作？" class="headerlink" title="JMM中的8种内存交互操作？"></a>JMM中的8种内存交互操作？</h3><ul>
<li>lock + unlock : 作用于主内存中的变量；lock，加锁，表示线程独占；unlock ，释放锁，允许其他线程再锁定</li>
<li>read +  write ：作用于主内存变量，read把变量从主内存传输到工作线程；load把变量从工作线程写入到主内存</li>
<li>load + store  ：作用于工作内存的变量，load把read 操作从主内存中得到的变量放入工作内存的变量副本中；store 把工作内存中一个变量的值传送到主内存中，以便随后的 write操作使用</li>
<li>use + assign ：作用于工作内存的变量，use把工作内存中一个变量的值传递给执行引擎；assgin把一个从执行引擎接收到的值赋给工作内存的变量</li>
</ul>
<h3 id="内存屏障？"><a href="#内存屏障？" class="headerlink" title="内存屏障？"></a>内存屏障？</h3><p>保证底层操作的有序性和可见性</p>
<ul>
<li>就像一套栅栏分割前后的代码，阻止栅栏前后的没有数据依赖性的代码进行指令重排序，保证程序在一定程度上的<strong>有序性</strong>。</li>
<li>强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效，保证数据的<strong>可见性</strong>。</li>
</ul>
<h3 id="happens-before原则理解？"><a href="#happens-before原则理解？" class="headerlink" title="happens-before原则理解？"></a>happens-before原则理解？</h3><p>先行发生（happens-before）是 Java 内存模型中定义的两项操作之间的偏序关系，<strong>如果操作A 先行发生于操作B，那么A的结果对B可见</strong>。共定义了8种规则，单线程是天然有序的，对于多线程来说，多个并发线程间必需要符合这个规则中的任一条，否则就不能保证有序。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://yq.aliyun.com/articles/750655">https://yq.aliyun.com/articles/750655</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/54chensongxia/p/12120117.html">https://www.cnblogs.com/54chensongxia/p/12120117.html</a></p>
<p>《深入理解 Java 虚拟机》第二版</p>
<p><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/java-memory-model.html">http://tutorials.jenkov.com/java-concurrency/java-memory-model.html</a> <a target="_blank" rel="noopener" href="https://juejin.im/post/5bf2977751882505d840321d#heading-5">https://juejin.im/post/5bf2977751882505d840321d#heading-5</a> <a target="_blank" rel="noopener" href="http://rsim.cs.uiuc.edu/Pubs/popl05.pdf">http://rsim.cs.uiuc.edu/Pubs/popl05.pdf</a> <a target="_blank" rel="noopener" href="http://ifeve.com/wp-content/uploads/2014/03/JSR133%E4%B8%AD%E6%96%87%E7%89%88.pdf">http://ifeve.com/wp-content/uploads/2014/03/JSR133中文版.pdf</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/20/Notes/Android/Framework/APK%E7%AD%BE%E5%90%8D%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/20/Notes/Android/Framework/APK%E7%AD%BE%E5%90%8D%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">APK签名机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-20 10:15:14" itemprop="dateCreated datePublished" datetime="2021-03-20T10:15:14+08:00">2021-03-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="APK签名机制"><a href="#APK签名机制" class="headerlink" title="APK签名机制"></a>APK签名机制</h1><h1 id="1、什么是apk签名"><a href="#1、什么是apk签名" class="headerlink" title="1、什么是apk签名"></a>1、什么是apk签名</h1><p>android应用在安装过程中会对apk进行签名校验，主要用于验证apk的可靠性、安全性以及唯一性，保证apk是有可信性的发布者发布，防止发布后被篡改；另外在apk升级时除了包名一致，签名也要一致。要了解签名和验签过程需要先了解以下几个基本概念。</p>
<h2 id="1-1、基本概念"><a href="#1-1、基本概念" class="headerlink" title="1.1、基本概念"></a>1.1、基本概念</h2><h3 id="1-1-1、数字摘要"><a href="#1-1-1、数字摘要" class="headerlink" title="1.1.1、数字摘要"></a>1.1.1、数字摘要</h3><p>数字摘要就是采用单向Hash函数将需要加密的明文“摘要”成一串固定长度（128位）的密文这一串密文又称为数字指纹，它有固定的长度，而且不同的明文摘要成密文，其结果总是不同的，而同样的明文其摘要必定一致。常用的数字摘要技术（Digital Digest）也称作为安全HASH编码法（SHA：Secure Hash Algorithm）。对所要传输的数据进行运算生成信息摘要，它并不是一种加密机制，但却能产生信息的数字”指纹”，它的目的是为了确保数据没有被修改或变化，保证信息的完整性不被破坏。</p>
<h3 id="1-1-2、数字签名"><a href="#1-1-2、数字签名" class="headerlink" title="1.1.2、数字签名"></a>1.1.2、数字签名</h3><p>数字签名的作用就是保证信息传输的完整性、发送者的身份认证、防止交易中的抵赖发生。<strong>数字签名技术是将摘要信息用发送者的私钥加密</strong>，与原文一起传送给接收者。接收者只有<strong>用发送者的公钥才能解密被加密的摘要信息然后用HASH函数对收到的原文产生一个摘要信息，与解密的摘要信息对比</strong>。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。</p>
<h3 id="1-1-3、数字证书"><a href="#1-1-3、数字证书" class="headerlink" title="1.1.3、数字证书"></a>1.1.3、数字证书</h3><p>数字证书是由权威公证的第三方认证机构（即CA，Certificate Authority）负责签发和管理的、个人或企业的网络数字身份证明。A的数字签名可以类比为现实世界中的签名，用来证明一个文件或者消息是A签署的，通常是使用A的私钥对消息摘要加密而得到，其他人可以使用A的公钥对数字签名进行验证。但是怎么才能信任A的公钥呢？让A自己证明自己是一件很难的事情，因此就需要第三方来证明，这就是数字证书的意义所在。</p>
<h2 id="1-2、apk签名和验签原理"><a href="#1-2、apk签名和验签原理" class="headerlink" title="1.2、apk签名和验签原理"></a>1.2、apk签名和验签原理</h2><p><img src="/pics/image-20201216113655542.png" alt="image-20201216113655542"></p>
<h3 id="1-2-1、APK签名"><a href="#1-2-1、APK签名" class="headerlink" title="1.2.1、APK签名"></a>1.2.1、APK签名</h3><ol>
<li>计算摘要：使用数字摘要算法计算出apk的摘要；</li>
<li>签名：通过私钥对摘要进行加密，加密后的信息就是签名；</li>
<li>写入签名：将签名信息、证书以及公钥写入到文件中。</li>
</ol>
<h3 id="1-2-2、APK验签"><a href="#1-2-2、APK验签" class="headerlink" title="1.2.2、APK验签"></a>1.2.2、APK验签</h3><ol>
<li>解密签名：通过公钥解密签名信息获得摘要；</li>
<li>计算摘要：使用摘要算法从接收的数据中计算摘要；</li>
<li>比较摘要：比较解密出的摘要和通过文件计算的摘要，若一致，则校验通过。</li>
</ol>
<p>接下来介绍下现有的4种apk签名的方式。</p>
<h1 id="2、v1-签名"><a href="#2、v1-签名" class="headerlink" title="2、v1 签名"></a>2、v1 签名</h1><p>V1签名又称为JAR签名，是对jar包进行签名的一种机制，由于jar包apk本质上都是zip包，所以可以应用到对apk的签名。解压apk后，META-INF目录中存放的就是签名相关的文件。</p>
<h2 id="2-1-v1签名过程"><a href="#2-1-v1签名过程" class="headerlink" title="2.1 v1签名过程"></a>2.1 v1签名过程</h2><p><img src="/pics/image-20201221200634926.png" alt="image-20201221200634926"></p>
<p>MANIFEST.MF、CERT.SF、CERT.RSA是签名过程中生成的文件（<a target="_blank" rel="noopener" href="https://android.googlesource.com/platform/build/+/7e447ed/tools/signapk/SignApk.java">apksigner源码</a>），作用如下：</p>
<h3 id="2-1-1、MANIFEST-MF"><a href="#2-1-1、MANIFEST-MF" class="headerlink" title="2.1.1、MANIFEST.MF"></a>2.1.1、MANIFEST.MF</h3><p>对APK中所有文件计算摘要保存到该文件中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: <span class="number">1.0</span></span><br><span class="line">Created-By: <span class="number">1.8</span><span class="number">.0_212</span> (Oracle Corporation)</span><br><span class="line"></span><br><span class="line">Name: AndroidManifest.xml <span class="comment">//apk各个文件的摘要</span></span><br><span class="line">SHA1-Digest: GpiU1HOPO9rxpTPh43kG1XVG8iw=</span><br><span class="line"></span><br><span class="line">Name: META-INF/BdTuringSdk_cnRelease.kotlin_module</span><br><span class="line">SHA1-Digest: PVHPdoZ9+09Zq0PF+eJz0yRVf10=</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="2-1-2、CERT-SF"><a href="#2-1-2、CERT-SF" class="headerlink" title="2.1.2、CERT.SF"></a>2.1.2、CERT.SF</h3><ul>
<li>SHA1-Digest-Manifest-Main-Attributes：MANIFEST.MF主属性的数据摘要。</li>
<li>SHA1-Digest-Manifest： MANIFEST.MF 文件计算摘要。</li>
<li>SHA1-Digest：MANIFEST.MF 的各个条目摘要。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Signature-Version: <span class="number">1.0</span></span><br><span class="line">SHA1-Digest-Manifest-Main-Attributes: TN5zBsqBLAij6alOeMWe+Ejwd4g= <span class="comment">//主属性记录了MANIFEST.MF文件所有主属性的数据摘要</span></span><br><span class="line">SHA1-Digest-Manifest: PBUX5Kag9TIOJy4jZ57vwuAur1Y= <span class="comment">//整个MANIFEST.MF文件的数据摘要</span></span><br><span class="line">Created-By: <span class="number">1.8</span><span class="number">.0_45</span>-internal (Oracle Corporation)</span><br><span class="line"></span><br><span class="line">Name: res/layout/ac.xml</span><br><span class="line">SHA1-Digest: mYQig54fsd3pTRQTmTwMD2oO5CM= <span class="comment">//MANIFEST.MF 各个条目的摘要</span></span><br></pre></td></tr></table></figure>

<h3 id="2-1-3、CERT-RSA"><a href="#2-1-3、CERT-RSA" class="headerlink" title="2.1.3、CERT.RSA"></a>2.1.3、CERT.RSA</h3><p><strong>对CERT.SF 文件的摘要通过私钥加密生成校验串</strong>, 然后和<strong>数字签名、公钥、数字证书</strong>一同写入 CERT.RSA 中保存。很多文章将校验串描述成签名，这样的理解是不准确的。可以比较2个同一个公司出品的apk的RSA文件，你会发现可能除了结尾部分不太一样外，其他部分基本相同，原因其实就是同一个公司出品的apk，它的签名，证书，公钥通常都是相同的，只有通过私钥加密的CERT.SF的摘要不同。 如下图：</p>
<p><img src="/pics/image-20201217160514944.png" alt="image-20201217160514944"></p>
<h4 id="1、查看证书与公钥"><a href="#1、查看证书与公钥" class="headerlink" title="1、查看证书与公钥"></a>1、查看证书与公钥</h4><p>1、将.rsa 后缀改为.p7b文件，双击直接打开</p>
<p>2、openssl 命令查看证书信息（公钥在证书信息中）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 查看.RSA文件中证书信息</span><br><span class="line">openssl pkcs7 -inform DER -in XXX.RSA -noout -print_certs -text</span><br><span class="line"></span><br><span class="line">// 查看本地证书的公钥和私钥</span><br><span class="line">keytool -list -rfc --keystore test.jks | openssl x509 -inform pem -pubkey</span><br></pre></td></tr></table></figure>

<p>通过一个实例去理解一下这两种方式的区别和联系。</p>
<ol>
<li>使用AS或keytool生成一个.jks签名文件； <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b28a5be05029">Android studio 如何生成jks签名文件</a></li>
<li>使用签名文件对apk进行签名；</li>
<li>通过相关命令查看.jks文件以及解压apk中的.rsa 文件。</li>
</ol>
<p><img src="/pics/image-20201217162850396.png" alt="image-20201217162850396"></p>
<h4 id="2、查看签名"><a href="#2、查看签名" class="headerlink" title="2、查看签名"></a>2、查看签名</h4><p>其实能看到也是签名的摘要，不是真正的签名。</p>
<ol>
<li>将.rsa 后缀改为.p7b文件，双击直接打开</li>
<li>使用keytool的命令查看.RSA文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -printcert -file xxx.RSA</span><br></pre></td></tr></table></figure>

<p><strong>证书信息：</strong></p>
<p><img src="/pics/image-20201217163225037.png" alt="image-20201217163225037"></p>
<h2 id="2-2、v1验签过程"><a href="#2-2、v1验签过程" class="headerlink" title="2.2、v1验签过程"></a>2.2、<a target="_blank" rel="noopener" href="https://android.googlesource.com/platform/frameworks/base/+/android-5.1.1_r38/services/core/java/com/android/server/pm/PackageManagerService.java">v1验签过程</a></h2><ol>
<li><p><strong>首先校验cert.sf文件的签名</strong></p>
<p>计算cert.sf文件的摘要，与通过签名者公钥解密CERT.RSA文件得到的摘要进行对比，如果一致则进入下一步；</p>
</li>
<li><p><strong>校验manifest.mf文件的完整性</strong></p>
<p>计算manifest.mf文件的摘要，与cert.sf主属性中记录的摘要进行对比，如一致则逐一校验mf文件各个条目的完整性；</p>
</li>
<li><p><strong>校验apk中每个文件的完整性</strong></p>
<p>逐一计算apk中每个文件（META-INF目录除外）的摘要，与mf中的记录进行对比，如全部一致，刚校验通过；</p>
</li>
<li><p><strong>校验签名的一致性</strong></p>
<p>如果是升级安装，还需校验证书签名是否与已安装app一致。</p>
</li>
</ol>
<h2 id="2-3、v1签名的劣势"><a href="#2-3、v1签名的劣势" class="headerlink" title="2.3、v1签名的劣势"></a>2.3、v1签名的劣势</h2><ol>
<li><p>签名校验速度慢</p>
<p>校验过程中需要对apk中所有文件进行摘要计算，在apk资源很多、性能较差的机器上签名校验会花费较长时间，导致安装速度慢；</p>
</li>
<li><p>完整性保障不够</p>
<p>META-INF目录用来存放签名，自然此目录本身是不计入签名校验过程的，可以随意在这个目录中添加文件，比如一些快速批量打包方案就选择在这个目录中添加渠道文件。</p>
<p>为了解决这两个问题，Android 7.0推出了全新的签名方案V2，下面介绍下v2签名。</p>
</li>
</ol>
<h1 id="2、v2签名"><a href="#2、v2签名" class="headerlink" title="2、v2签名"></a>2、v2签名</h1><h2 id="2-1、ZIP文件结构"><a href="#2-1、ZIP文件结构" class="headerlink" title="2.1、ZIP文件结构"></a>2.1、ZIP文件结构</h2><p>我们先来了解下v1签名文件的apk结构，也就是zip文件的结构。</p>
<p><img src="/pics/image-20201217175101791.png" alt="image-20201217175101791"></p>
<p>zip文件分为3部分：</p>
<ol>
<li><p><strong>数据区</strong></p>
<p>主要存放压缩的文件数据</p>
</li>
<li><p><strong>中央目录</strong></p>
<p>存放数据区压缩文件的索引</p>
</li>
<li><p><strong>中央目录结尾记录</strong></p>
<p>存放中央目录的文件索引</p>
</li>
</ol>
<p>查找压缩文件中数据可以先中央目录起始偏移量和size即可定位到中央目录，再遍历中央目录条目，根据本地文件头的起始偏移量即可在数据区中找到相应数据。</p>
<h2 id="2-2、v2签名原理"><a href="#2-2、v2签名原理" class="headerlink" title="2.2、v2签名原理"></a>2.2、v2签名原理</h2><p>JAR签名是在apk文件中添加META-INF目录，即需要修改数据区、中央目录，此外，添加文件后会导致中央目录大小和偏移量发生变化，还需要修改中央目录结尾记录。</p>
<p>v2方案为加强数据完整性保证，不在数据区和中央目录中插入数据，选择在 数据区和中央目录之间插入一个APK签名分块，从而保证了原始数据的完整性。</p>
<img src="/pics/image-20201217174414400.png" alt="image-20201217174414400" style="zoom:150%;" />

<p>APK 签名方案 v2 负责保护第 1、3、4 部分的完整性，以及第 2 部分包含的“APK 签名方案 v2 分块”中的 <code>signed data</code> 分块的完整性。第 1、3 和 4 部分的完整性通过其内容的一个或多个摘要来保护，这些摘要存储在 <code>signed data</code> 分块中，而这些分块则通过一个或多个签名来保护。</p>
<h3 id="2-2-1、APK摘要计算"><a href="#2-2-1、APK摘要计算" class="headerlink" title="2.2.1、APK摘要计算"></a>2.2.1、APK摘要计算</h3><p><img src="/pics/image-20201217202801891.png" alt="image-20201217202801891"></p>
<p>第 1、3 和 4 部分的摘要采用以下计算方式：</p>
<ol>
<li>将APK拆分成多个大小为 1 MB大小的连续块，最后一个块可能小于1M。之所以分块，是为了可以通过并行计算摘要以加快计算速度；</li>
<li>计算块的摘要，以字节 0xa5 + 块的长度（字节数） + 块的内容 进行计算；</li>
<li>计算整体摘要，字节 0x5a + 块数 + 块的摘要的连接（按块在 APK 中的顺序）进行计算。</li>
</ol>
<h2 id="2-3、签名过程"><a href="#2-3、签名过程" class="headerlink" title="2.3、签名过程"></a>2.3、签名过程</h2><p>介绍APK签名过程前，需要先了解下使用apk签名块的结构和v2签名块的结构。</p>
<h3 id="2-3-1、APKSigning-Block"><a href="#2-3-1、APKSigning-Block" class="headerlink" title="2.3.1、APKSigning Block"></a>2.3.1、APKSigning Block</h3><p>APK签名分块包含了4部分：分块长度、ID-VALUE序列、分块长度、固定magic值。其中APK 签名方案 <strong>v2分块</strong>存放在ID为<strong>0x7109871a</strong>的ID-VALUE区中。</p>
<p><img src="/pics/image-20201217212653708.png" alt="image-20201217212653708"></p>
<h3 id="2-3-2、v2-Block"><a href="#2-3-2、v2-Block" class="headerlink" title="2.3.2、v2 Block"></a>2.3.2、v2 Block</h3><p>v2分块主要由签名数据，数字签名以及公钥组成，具体结构如下。</p>
<p><img src="/pics/image-20201219104001970.png" alt="image-20201219104001970"></p>
<h3 id="2-3-3、签名过程"><a href="#2-3-3、签名过程" class="headerlink" title="2.3.3、签名过程"></a>2.3.3、签名过程</h3><p>V2签名块的生成可参考<a target="_blank" rel="noopener" href="https://android.googlesource.com/platform/build/+/dd910c5/tools/signapk/src/com/android/signapk/ApkSignerV2.java">ApkSignerV2</a>，整体结构和流程如下图所示：</p>
<p><img src="/pics/image-20201219153651713.png" alt="image-20201219153651713"></p>
<h2 id="2-4、v2验签过程"><a href="#2-4、v2验签过程" class="headerlink" title="2.4、v2验签过程"></a>2.4、v2验签过程</h2><p>在 Android 7.0 及更高版本中，可以根据 APK 签名方案 v2+ 或 JAR 签名（v1 方案）验证 APK。更低版本的平台会忽略 v2 签名，仅验证 v1 签名。</p>
<p><img src="/pics/image-20201221204054757.png" alt="image-20201221204054757"></p>
<h3 id="2-4-1、v2签名块定位"><a href="#2-4-1、v2签名块定位" class="headerlink" title="2.4.1、v2签名块定位"></a>2.4.1、v2签名块定位</h3><p>APK签名分块包含了4部分：分块长度、ID-VALUE序列、分块长度、固定magic值。其中APK 签名方案 v2分块存放在ID为0x7109871a的键值对中。</p>
<p>在进行签名校验时，先找到zip中央目录结尾记录，从该记录中找到中央目录起始偏移量，再通过magic值（APK Sig Block 42）即可确定前方可能是APK签名分块，再通过前后两个分块长度字段，即可确定APK签名分块的位置，最后通过ID（0x7109871a）定位APK 签名方案 v2分块位置。</p>
<h3 id="2-4-2、v2-验证过程"><a href="#2-4-2、v2-验证过程" class="headerlink" title="2.4.2、v2 验证过程"></a>2.4.2、v2 验证过程</h3><p><img src="/pics/image-20210319101806758.png" alt="image-20210319101806758"></p>
<h3 id="2-4-3、防回滚保护"><a href="#2-4-3、防回滚保护" class="headerlink" title="2.4.3、防回滚保护"></a>2.4.3、防回滚保护</h3><p><img src="/pics/image-20210319102400692.png" alt="image-20210319102400692"></p>
<h1 id="3、v3签名"><a href="#3、v3签名" class="headerlink" title="3、v3签名"></a>3、<a target="_blank" rel="noopener" href="https://source.android.com/security/apksigning/v3.html">v3签名</a></h1><p>v3和v2一样签名块存储在中央目录区之前，v3 签名会存储的ID为<strong>0xf05368c0</strong>，新增了 ID为<strong>0x3ba06f8c</strong> 的proof-of-rotation 结构中用来支持应用替换签名证书。在 Android 9 及更高版本中，可以根据 APK 签名方案 v3、v2 或 v1 验证 APK。较旧的平台会忽略 v3 签名而尝试验证 v2 签名，然后尝试验证 v1 签名。</p>
<p><img src="/pics/image-20201222203051481.png" alt="image-20201222203051481"></p>
<h1 id="4、v4签名"><a href="#4、v4签名" class="headerlink" title="4、v4签名"></a>4、v4签名</h1><p>Android 11 通过 APK 签名方案 v4 支持与流式传输兼容的签名方案（来支持增量安装APK）。v4 签名基于根据 APK 的所有字节计算得出的 Merkle 哈希树。</p>
<p><a target="_blank" rel="noopener" href="https://source.android.google.cn/security/apksigning/v4">https://</a><a target="_blank" rel="noopener" href="https://source.android.google.cn/security/apksigning/v4">source.android.google.cn/security/apksigning/v4</a> </p>
<h1 id="5、多渠道打包原理"><a href="#5、多渠道打包原理" class="headerlink" title="5、多渠道打包原理"></a>5、多渠道打包原理</h1><p>同一个app，需要上线各种平台，比如：小米，华为，百度等，我们多数称之为渠道，如果发的渠道多，可能有上百个渠道。</p>
<p>针对每个渠道，我们希望可以获取各个渠道的一些独立的统计信息，比如：下载量等。</p>
<p><strong>那么，如何区分各个渠道呢？</strong></p>
<p>Gradle Plugin为我们提供了一个自动化的方案，我们可以利用占位符，然后在build.gradle中去配置多个渠道信息，这样就可以将枯燥重复的任务自动化了。</p>
<p>这样的方式最大的问题，就是效率问题，每个渠道包，都要执行一遍构建流程，打包效率太低，目前市面比较出名的方案有美团<a target="_blank" rel="noopener" href="https://tech.meituan.com/2017/01/13/android-apk-v2-signature-scheme.html">Walle</a>，腾讯的<a target="_blank" rel="noopener" href="https://github.com/Tencent/VasDolly">VasDolly</a>所谓万变不离其宗，下面就介绍下市面上多渠道打包方案的基本原理。</p>
<h2 id="5-1、v1方案"><a href="#5-1、v1方案" class="headerlink" title="5.1、v1方案"></a>5.1、v1方案</h2><h3 id="5-1-1、EOCD"><a href="#5-1-1、EOCD" class="headerlink" title="5.1.1、EOCD"></a>5.1.1、EOCD</h3><p>我们知道要在apk中定位某个文件的位置必须要先解析出EOCD的结果，根据EOCD的结构推断出中央目录区，再根据中央目录区定位到v2签名块或者文件的情况。下面是EOCD的结构，主要包括几部分：</p>
<ol>
<li>魔数 0x06054B50，标记EOCD</li>
<li>中央目录信息（起始位置，记录数，长度）</li>
<li>注释区长度n（前2个字节）以及注释内容（Comment）</li>
</ol>
<p><img src="/pics/image-20201219155013207.png" alt="image-20201219155013207"></p>
<h3 id="5-1-2、v1方案"><a href="#5-1-2、v1方案" class="headerlink" title="5.1.2、v1方案"></a>5.1.2、v1方案</h3><p>根据之前的V1签名和校验机制可知，v1签名只会检验第一部分的所有压缩文件，而不理会后两部分内容。因此，我们可以向注释区中写入渠道。写入过程如下：</p>
<p><img src="/pics/image-20201222201238671.png" alt="image-20201222201238671"></p>
<p>这里添加魔数的好处是方便从后向前读取数据，定位渠道信息。因此，读取渠道信息包括以下几步：</p>
<ol>
<li>定位到魔数（8字节）</li>
<li>向前读两个字节，确定渠道信息的长度LEN（2字节）</li>
<li>继续向前读LEN字节，就是渠道信息了。</li>
</ol>
<h2 id="5-2、v2方案"><a href="#5-2、v2方案" class="headerlink" title="5.2、v2方案"></a>5.2、v2方案</h2><p>对于v2签名，Android系统只会关注ID为<strong>0x7109871a</strong>的v2签名块，并且忽略其他的ID-Value，同时v2签名只会保护APK本身，不包含签名块。所以可以将渠道写入到ID-Value键值对区。写入过程如下：</p>
<ol>
<li>从apk文件结尾，通过ID <strong>0x06054B50定</strong>位到<strong>EOCD</strong></li>
<li>通过EOCD找到<strong>中央目录结尾起始偏移</strong></li>
<li>定位APKSigning Block，</li>
<li>定位v2block</li>
<li>获取已有的ID-Value Pair</li>
<li><strong>添加包含渠道信息的ID-Value</strong></li>
<li>基于所有的ID-Value生成新的签名</li>
<li>修改EOCD的中央目录的偏移量(修改EOCD的中央目录偏移量，不会导致数据摘要校验失败）</li>
</ol>
<p>读取过程和写入过程基本相同，忽略。</p>
<h2 id="5-3、v3-方案"><a href="#5-3、v3-方案" class="headerlink" title="5.3、v3 方案"></a>5.3、v3 方案</h2><p>v3和v2的方案基本相同，但是v3签名<strong>限制了签名块大小是4096的倍数</strong>（<a target="_blank" rel="noopener" href="https://www.cnblogs.com/yrstudy/p/11884996.html">参考</a>）在不写入渠道时读取下APK Singing Block，其大小刚好是4096。若写入渠道后不满足该条件，如果不是的话，就会去生成一个ByteBuffer来填充签名块，其ID为0x42726577。所以写入渠道后，<strong>可以通过修改0x42726577的value的大小保证签名块长度是4096的倍数即可</strong>。源码：</p>
<p><a target="_blank" rel="noopener" href="https://android.googlesource.com/platform/tools/apksig/+/master/src/main/java/com/android/apksig/internal/apk/ApkSigningBlockUtils.java">generateApkSigningBlock</a></p>
<p><img src="/pics/image-20201222211918992.png" alt="image-20201222211918992"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/286d2b372334">https://www.jianshu.com/p/286d2b372334</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903473310334984">https://juejin.cn/post/6844903473310334984</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/108036144">https://zhuanlan.zhihu.com/p/108036144</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/709mXKfEzSuLrd0WCqrmbghttps://github.com/Meituan-Dianping/walle">https://mp.weixin.qq.com/s/709mXKfEzSuLrd0WCqrmbghttps://github.com/Meituan-Dianping/walle</a>)</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yrstudy/p/11884996.html">https://www.cnblogs.com/yrstudy/p/11884996.html</a></p>
<p><a target="_blank" rel="noopener" href="https://source.android.google.cn/security/apksigning/v2?hl=zh-cn">https://source.android.google.cn/security/apksigning/v2?hl=zh-cn</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/27/Notes/Android/Framework/FrameWork_00_Handler%20%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/27/Notes/Android/Framework/FrameWork_00_Handler%20%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6md/" class="post-title-link" itemprop="url">Android Handler消息机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-27 23:52:26" itemprop="dateCreated datePublished" datetime="2021-02-27T23:52:26+08:00">2021-02-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Android-Handler消息机制"><a href="#Android-Handler消息机制" class="headerlink" title="Android Handler消息机制"></a>Android Handler消息机制</h1><p>Handler是Android中一种线程间传递消息的机制。主要应用的场景，将子线程中待更新的UI信息传递到主线程。本文将从以下几个方面介绍Handler：</p>
<ol>
<li>Handler的消息发送和分发过程</li>
<li>Looper，Message 以及和Handler的关系</li>
<li>Message组成和类型以及复用机制</li>
<li>IdleHandler等一些不常见的知识</li>
</ol>
<p>下面正式开始，故事从sendMessage开始讲起。</p>
<h1 id="一、消息分发过程"><a href="#一、消息分发过程" class="headerlink" title="一、消息分发过程"></a>一、消息分发过程</h1><h2 id="1-1、从sendMessage开始"><a href="#1-1、从sendMessage开始" class="headerlink" title="1.1、从sendMessage开始"></a>1.1、从sendMessage开始</h2><p>Handler常见的用法如下，主线程中创建Handler，子线程中使用sendMessage发送消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Handler mHandler;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        mHandler = <span class="keyword">new</span> Handler()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//收到消息后，更新 ui</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//发送消息</span></span><br><span class="line">                    mHandler.sendMessage();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了上面这种写法外，常见的写法还有post这种：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mHandler = <span class="keyword">new</span> Handler();</span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//ui操作</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;); </span><br><span class="line">       &#125;</span><br><span class="line">   &#125;).start();</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>以上2种方式最终都是殊途同归，最终调用的都是Handler的<strong>sendMessageAtTime</strong>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    MessageQueue queue = mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="keyword">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">        Log.w(<span class="string">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不同地方在于post 将Runnable赋值给msg.callback，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    Message m = Message.obtain();</span><br><span class="line">    m.callback = r;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后在dispatchMessage处理消息时，post方式msg.callback不为空，会执行handleCalback，最终回调Runnable的run方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// post的执行</span></span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleCalback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// sendMessage的执行</span></span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    message.callback.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>细心的读者可能会问mCallback又是什么呢？其实mCallback就是你在new Handler时可以传的一个参数，如果你像下面这样在Handler.Callback中返回true，就可以拦截消息不让消息在Handler的handler的handleMessage中处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Handler handler1 = <span class="keyword">new</span> Handler(<span class="keyword">new</span> Handler.Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="1-2、发送消息"><a href="#1-2、发送消息" class="headerlink" title="1.2、发送消息"></a>1.2、发送消息</h2><p>sendMessageAtTime后发生了什么？继续分析sendMessageAtTime方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    MessageQueue queue = mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="keyword">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">        Log.w(<span class="string">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(<span class="meta">@NonNull</span> MessageQueue queue, <span class="meta">@NonNull</span> Message msg,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将Handler赋值给msg.target,消息分发的时候会用到</span></span><br><span class="line">        msg.target = <span class="keyword">this</span>;</span><br><span class="line">        msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>经过一系列的调用sendMessageAtTime最终调用到了MessagQueue.enqueueMessage。</p>
<p>enqueueMessage将所有收到的消息按发送时间进行排序，加入到MessageQueue（消息队列）中，MessageQueue更多的细节后面再讲。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Message must have a target.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">&quot; This message is already in use.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">            IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    msg.target + <span class="string">&quot; sending message to a Handler on a dead thread&quot;</span>);</span><br><span class="line">            Log.w(TAG, e.getMessage(), e);</span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        <span class="comment">//1、拿到队列头部消息</span></span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="comment">//2、如果消息不需要延时，或者消息的执行时间比头部消息早，插到队列头部</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span></span><br><span class="line">            <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">            <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="comment">// 3、根据时间，将消息插到队列中合适的位置</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="comment">// 4、唤醒机制</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>22 - 24行：对收到的消息按发送时间进行排序，如果当前消息不需要延时，放到头部；若是延时消息，则根据发送时间放到队列合适位置。</p>
<p><strong>总结一下：sendMessage就是讲消息加到MessageQueue的队列中。</strong></p>
<p>至此，消息的发送过程全部结束了，什么！那消息是怎么分发的呢？我们先给出答案，是通过Looper.loop。</p>
<h2 id="1-3、消息分发"><a href="#1-3、消息分发" class="headerlink" title="1.3、消息分发"></a>1.3、消息分发</h2><p>刚才说了Handler的消息分发是通过Looper.loop，接下来看下代码，上车！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">     <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 1、从Looper中消息队列</span></span><br><span class="line">     <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">         <span class="comment">// 2、从消息队列中取出消息</span></span><br><span class="line">         Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">         <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"><span class="comment">// 省略 ...</span></span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">// 3、调用handler.dispatchMessage</span></span><br><span class="line">             msg.target.dispatchMessage(msg);</span><br><span class="line">             end = (slowDispatchThresholdMs == <span class="number">0</span>) ? <span class="number">0</span> : SystemClock.uptimeMillis();</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                 Trace.traceEnd(traceTag);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     </span><br><span class="line"><span class="comment">//省略 ...</span></span><br><span class="line">         msg.recycleUnchecked();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>主要步骤如下：</p>
<p>6行：从Looper中取出消息队列</p>
<p>9行：开启死循环，然后不断地调用的MessageQueue的next()方法，这个next()方法就是消息队列的出队方法。如果当前MessageQueue中存在待处理的消息，就将这个消息出队，否则就进入一个阻塞状态，一直等到有新的消息入队。</p>
<p>19行：消息分发msg.target的dispatchMessage()方法中，那这里msg.target又是什么呢？其实就是handler，回头看下enqueueMessage。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Handle system messages here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>28行：消息回收过程，这里涉及到Message的回收和复用，后面再讲。</p>
<p><strong>总结一下：Handler通过sendMessage将消息加入到消息队列中，最后在通过Looper.loop从消息队列中逐个取出消息执行。</strong>整体原理如下图所示：</p>
<p><img src="../../pics/image-20210226151751578.png" alt="image-20210226151751578"></p>
<p>好了，Handler的消息分发机制就介绍完了。如果只是想简单了解下Handler机制，到这里就可以了。</p>
<p>就这？当然不！上述介绍过程中涉及到几个概念Looper，MessageQueue，还没详细说呢？我们先来看下Looper。</p>
<h1 id="二、Looper"><a href="#二、Looper" class="headerlink" title="二、Looper"></a>二、Looper</h1><p>通过以上的介绍我们知道Looper是handler中消息分发的核心，那它是怎么来的？我们先来看下Handler的构造函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="meta">@Nullable</span> Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// loop赋值</span></span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()</span><br><span class="line">                    + <span class="string">&quot; that has not called Looper.prepare()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Looper的赋值是通过looper.myLooper()，最终调到了sThreadLocal.get()。这个sThreadLocal又是什么？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sThreadLocal.get() will return null unless you&#x27;ve called prepare().</span></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br></pre></td></tr></table></figure>

<p>这个sThreadLocal是一个ThreadLocal对象，存的是Looper对象。什么？ThreadLocal也不懂？来来来，先记住个概念，后面再解释：ThreadLocal提供了线程的局部变量，每个线程都可以通过set()和get()来对这个局部变量进行操作，但不会和其他线程的局部变量进行冲突，实现了线程的数据隔离。也就说通<strong>过ThreadLocal可以存取当前线程的Looper对象</strong>。</p>
<p>仔细看sThreadLocal的注释，除非您已调用prepare()，否则sThreadLocal.get()将返回null。那就看下loop.prepare吧。</p>
<h2 id="2-1、loop-prepare"><a href="#2-1、loop-prepare" class="headerlink" title="2.1、loop.prepare"></a>2.1、loop.prepare</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 每个线程只能初始化一次looper</span></span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 注意，这是messageQueue初始化的地方</span></span><br><span class="line">   mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">   mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>10行：新建一个Looper对象并存到sThreadLocal中。</p>
<p>14行：注意这里，handler中的MessageQuee就是Looper初始化时构造出来的。</p>
<p>也就是说，new Hanlder 之前必须要调用 Looper.prepare方法，那为何在主线程中使用是不需要呢？其实Android在程序启动的时候，通过ActivityThread帮我们创建主线程时已经初始化好了，代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line">    <span class="comment">// 1、 主线程Looper.parpare!</span></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">    thread.attach(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">        Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                LogPrinter(Log.DEBUG, <span class="string">&quot;ActivityThread&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2、看这里looper.loop</span></span><br><span class="line">    Looper.loop();</span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3行：调用了 Looper.prepareMainLooper()，再调用到Looper的prepare。</p>
<p>14行：<strong>Looper.looper，开启循环，不停取出消息。主线程中其实先开启循环不停取消息，再才是发送消息。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the current thread as a looper, marking it as an</span></span><br><span class="line"><span class="comment"> * application&#x27;s main looper. See also: &#123;<span class="doctag">@link</span> #prepare()&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@deprecated</span> The main looper for your application is created by the Android environment,</span></span><br><span class="line"><span class="comment"> *   so you should never need to call this function yourself.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The main Looper has already been prepared.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意prepareMainLooper的注释，prepare只能调用一次，ActivityThread中已经调用过了，再调用到这里会报异常（12行）。到这里我们已经搞明白主线程中的looper是怎么来的。刚才遗留了一个问题ThreadLocal是怎么存取Loope，下面就来介绍下ThreadLocal。</p>
<h2 id="2-2、ThreadLocal"><a href="#2-2、ThreadLocal" class="headerlink" title="2.2、ThreadLocal"></a>2.2、ThreadLocal</h2><p>先来看下ThreadLocal的set过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1、获取当前线程</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">// 2、获取当前线程的ThreadMap对象</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 2.1、map不为空存value到map中</span></span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 2.2、map为空则创建map并value存进去</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">                              </span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ThreadLocalMap存储的值是弱引用</span></span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要步骤有2点：</p>
<ol>
<li>获取当前线程的ThreadMap对象 , ThreadMap其实是Thread的一个成员变量，但是是通过ThreadLocal来维护的。Thread.threadLocals为空时先创建。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/* ThreadLocal values pertaining to this thread. This map is maintained</span><br><span class="line"> * by the ThreadLocal class. */</span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = null;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>将value值存到ThreadMap中，key是当前threadLocal对象，也就是说一个Thread可以存多个不同ThreadLocal的值，一个ThreadLocal只能存一个值。</li>
</ol>
<p>我们再理解下Looper.myLooper对应的get过程，先获取线程的threadLocals（ThreadMap对象），再通过get（key是当前ThreadLocal对象）获取到looper。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                T result = (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结一下：Looper通过prepare会初始化一个Looper对象，通过ThreadLocal将Thread和Looper对象绑定在一起。Looper.loop会从MessageQueue中不断取出消息，进行分发。</strong></p>
<h1 id="三、MessageQueue"><a href="#三、MessageQueue" class="headerlink" title="三、MessageQueue"></a>三、MessageQueue</h1><p>MessagQueue，顾名思义，消息队列，在Looper的介绍中，我们提到了MessageQueue其实是在Looper构造创建生成的，Handler中的mQueue其实就是Looper.mQueue，Looper和MessageQueue是一一对应的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="meta">@Nullable</span> Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()</span><br><span class="line">                    + <span class="string">&quot; that has not called Looper.prepare()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 看这里</span></span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在前面章节我们讲了sengMessage最终会调用到MessageQueue.enqueueMessage，下面具体分析enqueueMessage的代码。</p>
<h2 id="3-1、消息入队"><a href="#3-1、消息入队" class="headerlink" title="3.1、消息入队"></a>3.1、消息入队</h2><p>关于enqueueMessage消息入队逻辑在1.2节已经介绍过了；除此之外，消息加入队列时，两种情况会唤醒looper.loop，为什么要唤醒，后面再说：</p>
<ol>
<li>（队列为空，消息无需延时或消息执行时间比队列头部消息早) &amp;&amp; (线程处于挂起状态时（mBlocked = true）)</li>
<li>【线程挂起（mBlocked = true）&amp;&amp; 消息循环处于同步屏障状态】，这时如果插入的是一个异步消息，则需要唤醒。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">          <span class="keyword">boolean</span> needWake;</span><br><span class="line">         <span class="comment">//1、队列为空，消息无需延时或消息执行时间比队列头部消息早) &amp;&amp; (线程处于挂起状态时（mBlocked = true）)</span></span><br><span class="line">          <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">              <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">              msg.next = p;</span><br><span class="line">              mMessages = msg;</span><br><span class="line">              needWake = mBlocked;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span></span><br><span class="line">              <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">              <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">              <span class="comment">// 2、线程挂起（mBlocked = true）&amp;&amp; 消息循环处于同步屏障状态】，这时如果插入的是一个异步消息，则需要唤醒。</span></span><br><span class="line">              needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">              Message prev;</span><br><span class="line">              <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                  prev = p;</span><br><span class="line">                  p = p.next;</span><br><span class="line">                  <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                      needWake = <span class="keyword">false</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">              prev.next = msg;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">          <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">              nativeWake(mPtr);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2、消息出队"><a href="#3-2、消息出队" class="headerlink" title="3.2、消息出队"></a>3.2、消息出队</h2><p>在1.3节我们介绍过Looper.Looper负责消息出队，其实是通过Queue.next()取队列中的消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">    <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">    <span class="comment">// which is not supported.</span></span><br><span class="line">    <span class="comment">// 1、通过Looper.quit调用到Message.quit后会执行到这里</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2、nextPollTimeoutMillis = -1 阻塞</span></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">            Message msg = mMessages;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 3、屏障消息</span></span><br><span class="line">                <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// 4、时间没到，设定下次唤醒的时间</span></span><br><span class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Got a message.</span></span><br><span class="line">                    mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">           <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">           <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">          	<span class="comment">// 第一次执行时，确定IdleHandler的数目</span></span><br><span class="line">           <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                   &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">               pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">               mBlocked = <span class="keyword">true</span>;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">               mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">           &#125;</span><br><span class="line">           mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run the idle handlers.</span></span><br><span class="line">        <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">        <span class="comment">// 遍历执行idleHandler</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="comment">// 非keep的执行完后移除掉</span></span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">        <span class="comment">// idleHandler</span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line">        <span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要的步骤：</p>
<ol>
<li><p>判断MessageQueue是不是退出了，如果退出，整个Looper.loop都退出，通常是通过调用Looper.quit退出。</p>
</li>
<li><p>nativePollOnce，我们知道Looper.looper是一个死循环，如果没有消息，还会继续执行吗？显然不可能，在消息队列为空的时候，Looper实际上处于休眠状态，当nextPollTimeoutMillis =-1 时阻塞，CPU进入休眠；对于deleyMessage，nextPollTimeoutMillis&gt;0，时间到了后唤醒。Message Queue共有2种情况唤醒：1.加入消息新消息时唤醒（上一节介绍过） ；2.delayMsg时间到了唤醒。</p>
<p>那么是怎么实现的呢？这里涉及到linux的epoll机制，handler这里就不展开讲了，参考（<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/H8mHoYHyTe6oOaUwfYh6_g%EF%BC%89%E3%80%82">https://mp.weixin.qq.com/s/H8mHoYHyTe6oOaUwfYh6_g）。</a></p>
</li>
<li><p>屏障消息和idleHandler相关，后面介绍。</p>
</li>
</ol>
<p><strong>总结一下：MessageQueue负责消息的存取，Looper的looper并不会一直执行，当nativePollOnce的参数nextPollTimeoutMillis=-1时会休眠，唤醒有2种方式一种是队列有新消息入队时；另一种是delayMsg时刻到了。</strong></p>
<h1 id="四、Message"><a href="#四、Message" class="headerlink" title="四、Message"></a>四、Message</h1><p>先看下Message的数据结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> what;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> arg1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> arg2;</span><br><span class="line">    <span class="keyword">public</span> Object obj;</span><br><span class="line">    <span class="keyword">public</span> Messenger replyTo; <span class="comment">// Messager对象</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">long</span> when; <span class="comment">//消息发送时间</span></span><br><span class="line">    <span class="comment">/*package*/</span> <span class="keyword">int</span> flags; <span class="comment">// 标记消息消息类型是否是异步</span></span><br><span class="line">    <span class="comment">/*package*/</span> Handler target; <span class="comment">//指向接收消息的handler</span></span><br><span class="line">    <span class="comment">/*package*/</span> Message next; <span class="comment">//指向下一个消息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Message sPool; <span class="comment">// Message内部复用队列的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Message对象都有一个同类型的next字段，这个next字段指向的就是下一个可用的Message，最后Message的next为空，组成Message链表，sPool 永远指向的是整个链表的第一个元素。</p>
<h2 id="4-1、Message的复用机制"><a href="#4-1、Message的复用机制" class="headerlink" title="4.1、Message的复用机制"></a>4.1、Message的复用机制</h2><p>通常我们获取一个Message都是通过Message的obtain方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// sometimes we store linked lists of these things</span></span><br><span class="line">    <span class="comment">/*package*/</span> Message next;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object sPoolSync = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Message sPool;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sPoolSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * Return a new Message instance from the global pool. Allows us to</span></span><br><span class="line"><span class="comment">      * avoid allocating new objects in many cases.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Message m = sPool;</span><br><span class="line">                sPool = m.next;</span><br><span class="line">                m.next = <span class="keyword">null</span>;</span><br><span class="line">                m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">                sPoolSize--;</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Message();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>17 - 18行，当使用obtain方法获取一个Message对象时，其实获取的就是链表中的第一个元素，同时将sPool在指向下一个Message。</p>
<p>那么这些Message对象是在什么时候被放到链表中的呢，在Message类的说明中有这样一句话：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">While the constructor of Message is public, the best way to getone of these is to call &#123;@link #obtain Message.obtain()&#125; or one of the methods, which will pull them from a pool of recycled objects。</span><br></pre></td></tr></table></figure>

<p>原来在创建Message时不会将Message放入队列而是在recycle时才会加入到队列，让我们先来看下recylce方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isInUse()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (gCheckRecycle) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;This message cannot be recycled because it &quot;</span></span><br><span class="line">                    + <span class="string">&quot;is still in use.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    recycleUnchecked();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recycles a Message that may be in-use.</span></span><br><span class="line"><span class="comment"> * Used internally by the MessageQueue and Looper when disposing of queued Messages.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Mark the message as in use while it remains in the recycled object pool.</span></span><br><span class="line">    <span class="comment">// Clear out all other details.</span></span><br><span class="line">    flags = FLAG_IN_USE;</span><br><span class="line">    what = <span class="number">0</span>;</span><br><span class="line">    arg1 = <span class="number">0</span>;</span><br><span class="line">    arg2 = <span class="number">0</span>;</span><br><span class="line">    obj = <span class="keyword">null</span>;</span><br><span class="line">    replyTo = <span class="keyword">null</span>;</span><br><span class="line">    sendingUid = -<span class="number">1</span>;</span><br><span class="line">    when = <span class="number">0</span>;</span><br><span class="line">    target = <span class="keyword">null</span>;</span><br><span class="line">    callback = <span class="keyword">null</span>;</span><br><span class="line">    data = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">            next = sPool;</span><br><span class="line">            sPool = <span class="keyword">this</span>;</span><br><span class="line">            sPoolSize++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>12- 8行：判断Message是否在被使用中，如果没有，则执行回收操作。</p>
<p>19-35行：回收先清空Message的各字段，并将flag置为FLAG_IN_USE，这个flag在obtain时会被置为0。然后继续判断是否要将该消息放17到回收池中，如果池的大小小于MAX_POOL_SIZE（50），那么就进行链表操作，将这个Message放到链表的表头。</p>
<p>总结一下：Message 通过在内部构建一个链表维护一个被回收的Message对象的对象池，当用户调用obtain函数时优先从池中获取，如果池中没有可以复用的对象则创建一个新的Message对象。这些新创建的Message对象再被使用完之后会被回收到这个对象池中，当下次再调用obtain函数时，他们就会被复用。<br>结合的Looper.loop方法，在使用完一个Message对象后就将会将它回收，避免系统中创建太多Message对象。</p>
<h2 id="4-2、同步消息、屏障消息和异步消息"><a href="#4-2、同步消息、屏障消息和异步消息" class="headerlink" title="4.2、同步消息、屏障消息和异步消息"></a>4.2、同步消息、屏障消息和异步消息</h2><p>在Handler构造函数，如果看到的足够仔细的话</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="meta">@Nullable</span> Callback callback, <span class="keyword">boolean</span> async)</span> </span></span><br></pre></td></tr></table></figure>

<p>我们会发现构造参数里有个async，异步？这个参数代表什么意思？</p>
<p>其实在MessageQueue中消息有三种类型：同步消息，异步消息以及屏障消息。</p>
<h3 id="4-1-1、同步消息"><a href="#4-1-1、同步消息" class="headerlink" title="4.1.1、同步消息"></a>4.1.1、同步消息</h3><p>默认的消息类型，同步消息在MessageQueue里的存和取完全就是按照时间（msg.when）排序的。</p>
<h3 id="4-1-2、异步消息"><a href="#4-1-2、异步消息" class="headerlink" title="4.1.2、异步消息"></a>4.1.2、异步消息</h3><p>异步消息有2种构造方式：</p>
<ol>
<li>handler构造参数指定 async =true</li>
<li>Message构造时，指定setAsynchronous（true）</li>
</ol>
<p>在sendMessage中，我们可以看到这2者的关系</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(<span class="meta">@NonNull</span> MessageQueue queue, <span class="meta">@NonNull</span> Message msg,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    msg.target = <span class="keyword">this</span>;</span><br><span class="line">    msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line">	<span class="comment">// mAsynchronous 就是构造参数中的 async </span></span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若Handler的构造参数中的async设置为true，该Handler所有的消息都会被设置为异步消息。</p>
<h3 id="4-1-3、屏障消息"><a href="#4-1-3、屏障消息" class="headerlink" title="4.1.3、屏障消息"></a>4.1.3、屏障消息</h3><p>屏障(Barrier) 是一种特殊的Message，它最大的特征就是target为null(只有屏障的target可以为null，如果我们自己设置Message的target为null的话会报异常)，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Message must have a target.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且arg1属性被用作屏障的标识符来区别不同的屏障。屏障的作用是用于拦截队列中同步消息，放行异步消息。</p>
<p>那么屏障消息是怎么被添加和删除的呢？ 我们可以看到在MessageQueue里有添加和删除屏障消息的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">(<span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Enqueue a new sync barrier token.</span></span><br><span class="line">    <span class="comment">// We don&#x27;t need to wake the queue because the purpose of a barrier is to stall it.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> token = mNextBarrierToken++;</span><br><span class="line">        <span class="keyword">final</span> Message msg = Message.obtain();</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        msg.arg1 = token;</span><br><span class="line"></span><br><span class="line">        Message prev = <span class="keyword">null</span>;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">         <span class="comment">// 根据时间找到第一个比屏障消息晚的消息，将屏障消息插入到该消息之前；</span></span><br><span class="line">         <span class="comment">// 屏障只会影响到队列中它之后的消息</span></span><br><span class="line">        <span class="keyword">if</span> (when != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.when &lt;= when) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果prev是null,屏障消息插入到消息队列的头部</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeSyncBarrier</span><span class="params">(<span class="keyword">int</span> token)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Remove a sync barrier token from the queue.</span></span><br><span class="line">        <span class="comment">// If the queue is no longer stalled by a barrier then wake it.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            Message prev = <span class="keyword">null</span>;</span><br><span class="line">            Message p = mMessages;</span><br><span class="line">        <span class="comment">// 前面在插入屏障消息后会生成一个token，这个token就是用来删除该屏障消息用的。</span></span><br><span class="line">        <span class="comment">// 所以这里通过判断target和token来找到该屏障消息，从而进行删除操作</span></span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; (p.target != <span class="keyword">null</span> || p.arg1 != token)) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The specified message queue synchronization &quot;</span></span><br><span class="line">                        + <span class="string">&quot; barrier token has not been posted or has already been removed.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> needWake;</span><br><span class="line">            <span class="comment">// 删除屏障消息，原理是链表的删除</span></span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                prev.next = p.next;</span><br><span class="line">                needWake = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mMessages = p.next;</span><br><span class="line">                needWake = mMessages == <span class="keyword">null</span> || mMessages.target != <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p.recycleUnchecked();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the loop is quitting then it is already awake.</span></span><br><span class="line">            <span class="comment">// We can assume mPtr != 0 when mQuitting is false.</span></span><br><span class="line">            <span class="comment">// 屏障消息删除后可再次之前的同步消息</span></span><br><span class="line">            <span class="keyword">if</span> (needWake &amp;&amp; !mQuitting) &#123;</span><br><span class="line">                nativeWake(mPtr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>介绍完屏障消息的插入和删除，那么屏障消息的作用是什么？和同步及异步消息有何关系呢？ 我们可以看到MessageQueue的next方法里有这么一段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前消息是屏障消息时（msg.target==null）, 如果存在屏障消息，那么在它之后进来的消息中，只放行异步消息</span></span><br><span class="line"><span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prevMsg = msg;</span><br><span class="line">        msg = msg.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入屏障消息后，只放行队列中的异步消息，在Android系统里面为了更快响应UI刷新在<strong>ViewRootImpl.scheduleTraversals</strong>也有应用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 1、为主线程的MessageQueue设置了个消息屏障</span></span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        <span class="comment">// 2、这里发送了个异步消息mTraversalRunnable，这个mTraversalRunnable最终会执行doTraversal(),也就是会触发View的绘制流程</span></span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line"> 		</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// postCallback 经过层层调用到这里Choreographer.postCallbackDelayedInternal</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postCallbackDelayedInternal</span><span class="params">(<span class="keyword">int</span> callbackType,</span></span></span><br><span class="line"><span class="params"><span class="function">        Object action, Object token, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">  		<span class="comment">// 省略...</span></span><br><span class="line">        <span class="keyword">if</span> (dueTime &lt;= now) &#123;</span><br><span class="line">            scheduleFrameLocked(now);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">            msg.arg1 = callbackType;</span><br><span class="line">            <span class="comment">// 设置为异步消息</span></span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">            mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>scheduleTraversals时通过设置屏障消息，会把主线程的同步消息先阻塞，优先执行View绘制这个异步消息进行界面绘制。让界面绘制的任务优先执行，避免出现界面卡顿。</p>
<p>另外App层如果发送同步屏障postSyncBarrier需要反射才能使用，Android不建议使用，主线程中滥用的话就是和界面绘制抢资源了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postSyncBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Method method = MessageQueue.class.getDeclaredMethod(<span class="string">&quot;postSyncBarrier&quot;</span>);</span><br><span class="line">  token = (<span class="keyword">int</span>) method.invoke(Looper.getMainLooper().getQueue());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeSyncBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Method method = MessageQueue.class.getDeclaredMethod(<span class="string">&quot;removeSyncBarrier&quot;</span>, <span class="keyword">int</span>.class);</span><br><span class="line">   method.invoke(Looper.getMainLooper().getQueue(), token);&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="五、IdleHandler"><a href="#五、IdleHandler" class="headerlink" title="五、IdleHandler"></a>五、IdleHandler</h1><p>IdleHandler，空闲的处理器（就是说我是在消息队列空闲的时候才会执行的，如果消息队列里有其他非IdleHandler消息在执行，则我先不执行），它其实就是一个接口，我们就认为它是空闲消息吧，只不过它不是存在MessageQueue里，而是以数组的形式保存的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Callback interface for discovering when a thread is going to block</span><br><span class="line"> * waiting for more messages.</span><br><span class="line"> */</span><br><span class="line">public static interface IdleHandler &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Called when the message queue has run out of messages and will now</span><br><span class="line">     * wait for more.  Return true to keep your idle handler active, false</span><br><span class="line">     * to have it removed.  This may be called if there are still messages</span><br><span class="line">     * pending in the queue, but they are all scheduled to be dispatched</span><br><span class="line">     * after the current time.</span><br><span class="line">     */</span><br><span class="line">    boolean queueIdle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MessageQueue有添加和删除IdleHandler的方法，IdleHandler被保存在一个ArrayList里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;IdleHandler&gt; mIdleHandlers = <span class="keyword">new</span> ArrayList&lt;IdleHandler&gt;();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addIdleHandler</span><span class="params">(<span class="meta">@NonNull</span> IdleHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;Can&#x27;t add a null IdleHandler&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        mIdleHandlers.add(handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeIdleHandler</span><span class="params">(<span class="meta">@NonNull</span> IdleHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        mIdleHandlers.remove(handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，它是怎么实现在消息队列空闲的间隙得到执行的呢？细心的同学应该注意到了，也是在MessageQueue.next()方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">    <span class="comment">// 1、这个参数很重要，控制</span></span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">          	<span class="comment">// 省略...</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">            <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">            <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">            <span class="comment">// 首次for循环 &amp;&amp; 消息队列处于空闲 当前消息队列没有消息或者要执行的消息晚于当前时间</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                <span class="comment">// 赋值</span></span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run the idle handlers.</span></span><br><span class="line">        <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果queueIdle返回true，则该空闲消息不会被自动删除，在下次执行next的时候，如果还出现队列空闲，会再次执行。</span></span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果返回false，则该空闲消息会在执行完后，被自动删除掉。</span></span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">        <span class="comment">// 这里把空闲消息标志置为0，而不置为-1，防止一直执行；一直到下一次调用 MessageQueue.next() 方法.</span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当执行了 IdleHander 之后, 会消耗一段时间, 这时候消息队列里可能已经有消息到达可执行时间, 所以重置 nextPollTimeoutMillis 回去重新检查消息队列.</span></span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下：IdleHandler是在MessageQueuer队列空闲时执行的且只会执行一次，但如果将queueIdle的返回值改为true，会在每一次MessageQueue.next方法执行时在执行一次，也就是说如果队列中有新的消息到达就会再次执行。</p>
<h1 id="六、常见问题"><a href="#六、常见问题" class="headerlink" title="六、常见问题"></a>六、常见问题</h1><h2 id="6-1、子线程中更新UI的方法"><a href="#6-1、子线程中更新UI的方法" class="headerlink" title="6.1、子线程中更新UI的方法"></a>6.1、子线程中更新UI的方法</h2><p>除了Handler的sendMessage和post之外，我们还有以下2种方法可以在子线程中进行UI操作，一句话解释完，请看注释！！！</p>
<h3 id="6-1-1、View的post-方法"><a href="#6-1-1、View的post-方法" class="headerlink" title="6.1.1、View的post()方法"></a>6.1.1、View的post()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Causes the Runnable to be added to the message queue.</span></span><br><span class="line"><span class="comment"> * The runnable will be run on the user interface thread.&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class="line">    <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> attachInfo.mHandler.post(action);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Postpone the runnable until we know on which thread it needs to run.</span></span><br><span class="line">    <span class="comment">// Assume that the runnable will be successfully placed after attach.</span></span><br><span class="line">    getRunQueue().post(action);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-1-2、Activity的runOnUiThread-方法"><a href="#6-1-2、Activity的runOnUiThread-方法" class="headerlink" title="6.1.2、Activity的runOnUiThread()方法"></a>6.1.2、Activity的runOnUiThread()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Runs the specified action on the UI thread. If the current thread is the UI</span></span><br><span class="line"><span class="comment">* thread, then the action is executed immediately. If the current thread is</span></span><br><span class="line"><span class="comment">* not the UI thread, the action is posted to the event queue of the UI thread.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> action the action to run on the UI thread</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runOnUiThread</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (Thread.currentThread() != mUiThread) &#123;</span><br><span class="line">           mHandler.post(action);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           action.run();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-2、主线程中Looper-Loop的不会卡死？"><a href="#6-2、主线程中Looper-Loop的不会卡死？" class="headerlink" title="6.2、主线程中Looper.Loop的不会卡死？"></a>6.2、主线程中Looper.Loop的不会卡死？</h2><p>1、Looper.Loop会调用到MessageQueue.next()方法，没有消息时会阻塞在nativePollOnce，此时主线程会释放CPU进入休眠状态，并不会消耗CPU资源。直到有下个消息到达，这里依赖的是Linux pipe/epoll机制。</p>
<p>2、ANR的原理，任务再特定时间内没有执行完。以Service ANR原理为例，首先startService之后，经过一系列的调用，最终会调用到AMS的startService相关方法，发送一个SERVICE_TIMEOUT_MSG的延时消息；紧接着再通过消息机制调用到ActivityThread.H.handleMessag中先执行Service的onCreate，再回到AMS找中，执行serviceDoneExecuting，移除SERVICE_TIMEOUT_MSG消息。也就是说如果onCreate执行时间过长导致SERVICE_TIMEOUT_MSG消息没有被及时移除，就会触发ANR。这里涉及到2个handler，一个ActivityThread，一个是AMS的，ActivityThread的Handler是和应用主线程绑定的；而AMS.MainHandler是SystemServer的ServerThread绑定的，用于处理service、process、provider的超时问题。另外input的超时处理过程并非发生在ActivityManager线程，而是inputDispatcher线程发生的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>Looper 作为消息循环的核心，其内部包含了一个消息队列 MessageQueue ，用于记录所有待处理的消息；Handler通过sendMessage添加消息，通过Looper.loop()不断地从MessageQueue中抽取Message，按分发机制将消息分发给目标处理者，可以看成是消息泵。注意，线程切换就是在这一步完成的。</li>
<li>MessageQueue 则作为一个消息队列，则包含了一系列链接在一起的 Message ；不要被这个Queue的名字给迷惑了，就以为它是一个队列，但其实内部通过单链表的数据结构来维护消息列表，等待Looper的抽取。</li>
<li>Message 则是消息体，内部又包含了一个目标处理器 target ，这个 target 正是最终处理它的 Handler。</li>
<li><strong>Looper和Thread以及MessageQueue是一一对应的</strong>，<strong>而一个Handler只能关联一个Looper，一个Looper可以关联多个Handler</strong>, Handler的messagequeue就是Looper的messagequeue。  </li>
</ul>
<p><strong>参考资料：</strong><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/guolin_blog/article/details/9991569">http://blog.csdn.net/guolin_blog/article/details/9991569</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904068129751047">https://juejin.cn/post/6844904068129751047</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/H8mHoYHyTe6oOaUwfYh6_g">https://mp.weixin.qq.com/s/H8mHoYHyTe6oOaUwfYh6_g</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/71OV_K7YJas7pLtsPY-jeQ">https://mp.weixin.qq.com/s/71OV_K7YJas7pLtsPY-jeQ</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/26/Notes/Android/Framework/Android%20Service%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/26/Notes/Android/Framework/Android%20Service%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-26 18:49:09" itemprop="dateCreated datePublished" datetime="2021-02-26T18:49:09+08:00">2021-02-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p> 一、 startService 和 bindService的区别<br>    <img src="https://leanote.com/api/file/getImage?fileId=59341fcbab64415b02001748"></p>
<ul>
<li>执行startService时，Service会经历onCreate-&gt;onStartCommand。当执行stopService时，直接调用onDestroy方法。调用者如果没有stopService，Service会一直在后台运行，下次调用者再起来仍然可以stopService。</li>
<li>执行bindService时，Service会经历onCreate-&gt;onBind。这个时候调用者和Service绑定在一起。调用者调用unbindService方法或者调用者Context不存在了（如Activity被finish了），Service就会调用onUnbind-&gt;onDestroy。这里所谓的绑定在一起就是说两者共存亡了。</li>
<li>多次调用startService，该Service只能被创建一次，即该Service的onCreate方法只会被调用一次。但是每次调用startService，onStartCommand方法都会被调用。Service的onStart方法在API5时被废弃，替代它的是onStartCommand方法。</li>
<li>第一次执行bindService时，onCreate和onBind方法会被调用，但是多次执行bindService时，onCreate和onBind方法并不会被多次调用，即并不会多次创建服务和绑定服务。</li>
</ul>
<p>二、startService的过程<br><a target="_blank" rel="noopener" href="http://0.0.0.1/">http://www.jianshu.com/p/c0aadd5bf7a5</a><br><a target="_blank" rel="noopener" href="http://0.0.0.2/">http://wujingchao.com/2016/02/10/art-of-android-development-notes-startservice/</a></p>
<p>1.frameworks/base/core/java/android/content/ContextWrapper.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ComponentName <span class="title">startService</span><span class="params">(Intent service)</span> </span>&#123;</span><br><span class="line">        warnIfCallingFromSystemProcess();</span><br><span class="line">        <span class="keyword">return</span> startServiceCommon(service, mUser);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> ComponentName <span class="title">startServiceCommon</span><span class="params">(Intent service, UserHandle user)</span> </span>&#123;</span><br><span class="line">    ComponentName cn = ActivityManagerNative.getDefault().startService(</span><br><span class="line">        mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(</span><br><span class="line">                    getContentResolver()), getOpPackageName(), user.getIdentifier());    </span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.通过ActivityManagerNative.getDefault().startService的ActivityManagerNative-&gt;ActivityManagerService-&gt;ActiveServices.startServiceLocked</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ComponentName <span class="title">startServiceLocked</span><span class="params">(IApplicationThread caller, Intent service, String resolvedType,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid, String callingPackage, <span class="keyword">int</span> userId)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">…</span><br><span class="line"><span class="comment">//PackageManagerService解析出Intent得到要启动的ServiceRecord</span></span><br><span class="line">ServiceLookupResult res =</span><br><span class="line">retrieveServiceLocked(service, resolvedType, callingPackage,</span><br><span class="line">callingPid, callingUid, userId, <span class="keyword">true</span>, callerFg);</span><br><span class="line">    ServiceRecord r = res.record;            </span><br><span class="line">... </span><br><span class="line"><span class="keyword">return</span> startServiceInnerLocked(smap, service, r, callerFg, addToStarting);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ComponentName <span class="title">startServiceInnerLocked</span><span class="params">(ServiceMap smap, Intent service, ServiceRecord r,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">boolean</span> callerFg, <span class="keyword">boolean</span> addToStarting)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">…</span><br><span class="line">String error = bringUpServiceLocked(r, service.getFlags(), callerFg, <span class="keyword">false</span>);</span><br><span class="line">…</span><br><span class="line"><span class="keyword">return</span> r.name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> String <span class="title">bringUpServiceLocked</span><span class="params">(ServiceRecord r,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">int</span> intentFlags, <span class="keyword">boolean</span> execInFg, <span class="keyword">boolean</span> whileRestarting)</span> </span>&#123;</span><br><span class="line"><span class="comment">//如果进程已经存在的情况下就不是处理下面的流程，直接处理onStart的流程</span></span><br><span class="line"><span class="keyword">if</span> (r.app != <span class="keyword">null</span> &amp;&amp; r.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">sendServiceArgsLocked(r, execInFg, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处于restart的状态(在onStartCommand里面处理了服务被杀之后的行为)也不会处理</span></span><br><span class="line"><span class="keyword">if</span> (!whileRestarting &amp;&amp; r.restartDelay &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mRestartingServices.remove(r)) &#123;</span><br><span class="line">clearRestartingIfNeededLocked(r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (r.delayed) &#123;</span><br><span class="line">getServiceMap(r.userId).mDelayedStartList.remove(r);</span><br><span class="line">r.delayed = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//…</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> isolated = (r.serviceInfo.flags&amp;ServiceInfo.FLAG_ISOLATED_PROCESS) != <span class="number">0</span>;</span><br><span class="line"><span class="keyword">final</span> String procName = r.processName;</span><br><span class="line">ProcessRecord app;</span><br><span class="line"><span class="comment">//独立的进程运行isolated为true,</span></span><br><span class="line"><span class="keyword">if</span> (!isolated) &#123;</span><br><span class="line">app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">app.addPackage(r.appInfo.packageName, r.appInfo.versionCode, mAm.mProcessStats);</span><br><span class="line"><span class="comment">//直接启动服务，不用开启新的进程</span></span><br><span class="line">realStartServiceLocked(r, app, execInFg);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">Slog.w(TAG, “Exception when starting service ” + r.shortName, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">app = r.isolatedProc;</span><br><span class="line">&#125;</span><br><span class="line">第一次创建时，走到这里，先创建一个service的进程</span><br><span class="line"><span class="keyword">if</span> (app == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//开启新的进程 </span></span><br><span class="line">    <span class="keyword">if</span> ((app=mAm.startProcessLocked(procName, r.appInfo, <span class="keyword">true</span>, intentFlags,</span><br><span class="line">            <span class="string">&quot;service&quot;</span>, r.name, <span class="keyword">false</span>, isolated, <span class="keyword">false</span>))== <span class="keyword">null</span>) &#123;</span><br><span class="line">        bringDownServiceLocked(r);</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isolated) &#123;</span><br><span class="line">        r.isolatedProc = app;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将ServiceRecord加入即将启动mPendingServices列表里，后面进程启动成功后在启动Service</span></span><br><span class="line"><span class="keyword">if</span> (!mPendingServices.contains(r)) &#123;</span><br><span class="line">    mPendingServices.add(r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果进程已经存在的情况下就不是处理下面的流程，直接调用realStartServiceLocked处理onStart的流程。ActivityManagerService.startProcessLocked开启进程，procName为AndroidManifest中Service标签了process指定的进程名，默认是包名。</p>
<pre><code>final ProcessRecord startProcessLocked(String processName, ApplicationInfo info,
boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName,
boolean allowWhileBooting, boolean isolated, int isolatedUid, boolean keepIfLarge,
String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler) &#123;
    ProcessRecord app;
    if (!isolated) &#123;
    app = getProcessRecordLocked(processName, info.uid, keepIfLarge);
    &#125; else &#123;
        // If this is an isolated process, it can&#39;t re-use an existing process.
        app = null;
    &#125;
    //...
    String hostingNameStr = hostingName != null
            ? hostingName.flattenToShortString() : null;
   //...
   if (app == null) &#123;
        //构建一个新的的ProcessRecord
        app = newProcessRecordLocked(info, processName, isolated, isolatedUid);
        app.crashHandler = crashHandler;
        mProcessNames.put(processName, app.uid, app);
        if (isolated) &#123;
            mIsolatedProcesses.put(app.uid, app);
        &#125;
    &#125; 
    //...
    startProcessLocked(
            app, hostingType, hostingNameStr, abiOverride, entryPoint, entryPointArgs);
    return (app.pid != 0) ? app : null;
&#125;
</code></pre>
<p>构建新的ProcessRecord，startProcessLocked开启进程:</p>
<pre><code>private final void startProcessLocked(ProcessRecord app, String hostingType,
        String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) &#123;
    //...
    try &#123;
        int uid = app.uid;
        int[] gids = null;
        int mountExternal = Zygote.MOUNT_EXTERNAL_NONE;
        if (!app.isolated) &#123;
            //...
        &#125;
        int debugFlags = 0;
        //...
        boolean isActivityProcess = (entryPoint == null);
        if (entryPoint == null) entryPoint = &quot;android.app.ActivityThread&quot;;
        Process.ProcessStartResult startResult = Process.start(entryPoint,
                app.processName, uid, uid, gids, debugFlags, mountExternal,
                app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,
                app.info.dataDir, entryPointArgs);
        //...
&#125;
</code></pre>
<p>调用Process.start开启一个新的进程，新进程的入口点就是android.app.ActivityThread，执行里面的main方法。</p>
<pre><code> public final class ActivityThread &#123;
    final ApplicationThread mAppThread = new ApplicationThread();
    public static void main(String[] args) &#123;
        //...
        Looper.prepareMainLooper();
        ActivityThread thread = new ActivityThread();
        thread.attach(false);
        if (sMainThreadHandler == null) &#123;
            sMainThreadHandler = thread.getHandler();
        &#125;
        Looper.loop();
        throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);
    &#125;
     private void attach(boolean system) &#123;
        //...
        if (!system) &#123;
            //...
            final IActivityManager mgr = ActivityManagerNative.getDefault();
            try &#123;
                mgr.attachApplication(mAppThread);
            &#125; catch (RemoteException ex) &#123;
                // Ignore
            &#125;
            //...
        &#125; 
    &#125;
&#125;
</code></pre>
<p>准备主线程的Looper，调用attachApplication通知ActiviyManangerService主线程准备完毕，然后loop开始消息循环。<br>ApplicationThread通过IPC向ActivityManagerService调用attachApplication，并传递mAppThread给ActivityManagerService，mAppThread是一个Binder对象，用于ActivityManagerService向我们发起调用。注意从这里开始已经是在新进程里面执行了。<br>ApplicationThread对象继承自ApplicationThreadNative.java，在ActivityThread对象被创建时，它也被构造了，我前面已经提到过了，它继承了ApplicationThreadNative类，熟悉进程通信代理机制的朋友就清楚了，ApplicationThread就是一个通信代理存根实现类，我们可以看它的实现方法，都是调用queueOrSendMessage方法，派发消息交给ActivityThread的mH去处理，那么我们很清楚了，ActivityThread代理存根对象，它负责执行来自远程的调用，这些远程的调用大部分来自system_process，所以，system_process很容易通过ApplicationThread的客户端代理对象控制ActivityThread，事实就是如此，后面我们可以很好地看到这一点</p>
<pre><code>    base/core/java/android/app/ActivityManagerNative.java
    
    class ActivityManagerProxy implements IActivityManager&#123;
    public void attachApplication(IApplicationThread app) throws RemoteException
    &#123;
        Parcel data = Parcel.obtain();
        Parcel reply = Parcel.obtain();
        data.writeInterfaceToken(IActivityManager.descriptor);
        data.writeStrongBinder(app.asBinder());
        mRemote.transact(ATTACH_APPLICATION_TRANSACTION, data, reply, 0);
        reply.readException();
        data.recycle();
        reply.recycle();
    &#125;
&#125;
</code></pre>
<p>遂进入到ActivityManagerService:</p>
<pre><code>public final void attachApplication(IApplicationThread thread) &#123;
synchronized (this) &#123;
    int callingPid = Binder.getCallingPid();
    final long origId = Binder.clearCallingIdentity();
    attachApplicationLocked(thread, callingPid);
    Binder.restoreCallingIdentity(origId);
&#125;
</code></pre>
<p>attachApplicationLocked</p>
<pre><code>private final boolean attachApplicationLocked(IApplicationThread thread,
        int pid) &#123;
    ProcessRecord app;
    ...
    final String processName = app.processName;
    ...
    app.makeActive(thread, mProcessStats);
    app.curAdj = app.setAdj = -100;
    app.curSchedGroup = app.setSchedGroup = Process.THREAD_GROUP_DEFAULT;
    app.forcingToForeground = null;
    updateProcessForegroundLocked(app, false, false);
    app.hasShownUi = false;
    app.debugging = false;
    app.cached = false;
    app.killedByAm = false;
    ...
     //使用ApplicationThread发起IPC调用bindApplication -&gt;ActivityThread．bindApplication:
        thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,
                profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,
                app.instrumentationUiAutomationConnection, testMode, enableOpenGlTrace,
                isRestrictedBackupMode || !normalMode, app.persistent,
                new Configuration(mConfiguration), app.compat,
                getCommonServicesLocked(app.isolated),
                mCoreSettingsObserver.getCoreSettingsLocked());
    ...   
        
    boolean badApp = false;
    //...
    // Find any services that should be running in this process...
    if (!badApp) &#123;
        try &#123;
            //接着调用ActivieServices的attachApplicationLocked通知客户端启动Service:
            didSomething |= mServices.attachApplicationLocked(app, processName);
        &#125; catch (Exception e) &#123;
            Slog.wtf(TAG, &quot;Exception thrown starting services in &quot; + app, e);
            badApp = true;
        &#125;
    &#125;
   //...
    return true;
&#125;
</code></pre>
<p>使用ApplicationThread发起IPC调用bindApplication -&gt;ActivityThread.bindApplication:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bindApplication</span><span class="params">(String processName, ApplicationInfo appInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">                List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName,</span></span></span><br><span class="line"><span class="params"><span class="function">                ProfilerInfo profilerInfo, Bundle instrumentationArgs,</span></span></span><br><span class="line"><span class="params"><span class="function">                IInstrumentationWatcher instrumentationWatcher,</span></span></span><br><span class="line"><span class="params"><span class="function">                IUiAutomationConnection instrumentationUiConnection, <span class="keyword">int</span> debugMode,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">boolean</span> enableOpenGlTrace, <span class="keyword">boolean</span> isRestrictedBackupMode, <span class="keyword">boolean</span> persistent,</span></span></span><br><span class="line"><span class="params"><span class="function">                Configuration config, CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services,</span></span></span><br><span class="line"><span class="params"><span class="function">                Bundle coreSettings)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//... init</span></span><br><span class="line">            IPackageManager pm = getPackageManager();</span><br><span class="line">            android.content.pm.PackageInfo pi = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pi = pm.getPackageInfo(appInfo.packageName, <span class="number">0</span>, UserHandle.myUserId());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pi != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">//处理sharedUid的情况</span></span><br><span class="line">               <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">            AppBindData data = <span class="keyword">new</span> AppBindData();</span><br><span class="line">            data.processName = processName;</span><br><span class="line">            data.appInfo = appInfo;</span><br><span class="line">            data.providers = providers;</span><br><span class="line">            data.instrumentationName = instrumentationName;</span><br><span class="line">            data.instrumentationArgs = instrumentationArgs;</span><br><span class="line">            data.instrumentationWatcher = instrumentationWatcher;</span><br><span class="line">            data.instrumentationUiAutomationConnection = instrumentationUiConnection;</span><br><span class="line">            data.debugMode = debugMode;</span><br><span class="line">            data.enableOpenGlTrace = enableOpenGlTrace;</span><br><span class="line">            data.restrictedBackupMode = isRestrictedBackupMode;</span><br><span class="line">            data.persistent = persistent;</span><br><span class="line">            data.config = config;</span><br><span class="line">            data.compatInfo = compatInfo;</span><br><span class="line">            data.initProfilerInfo = profilerInfo;</span><br><span class="line">            sendMessage(H.BIND_APPLICATION, data);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">int</span> what, Object obj)</span> </span>&#123;</span><br><span class="line">        sendMessage(what, obj, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> H mH = <span class="keyword">new</span> H();</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">int</span> what, Object obj, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    Message msg = Message.obtain();</span><br><span class="line">    msg.what = what;</span><br><span class="line">    msg.obj = obj;</span><br><span class="line">    msg.arg1 = arg1;</span><br><span class="line">    msg.arg2 = arg2;</span><br><span class="line">    <span class="keyword">if</span> (async) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mH.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p> 主线程的Looper前面已经在ActivityThread主线程里面初始化了，然后向Handler发消息实现进程切换(因为bindApplication是在客户端Binder线程池里面调用的)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">case</span> BIND_APPLICATION:</span><br><span class="line">                       AppBindData data = (AppBindData)msg.obj;</span><br><span class="line">                       handleBindApplication(data);</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>接着调用ActivityThread的handleBindApplication，主要是然客户端初始化应用程序的一些状态比如时区地域，Instrumentation，LoadedApk等等。</p>
<pre><code>private void handleBindApplication(AppBindData data) &#123;
    mBoundApplication = data;
    mConfiguration = new Configuration(data.config);
    mCompatConfiguration = new Configuration(data.config);
    //...
    TimeZone.setDefault(null);
    //...
    Locale.setDefault(data.config.locale);
    //...
&#125;
</code></pre>
<p>再回到ActivityManagerService中的attachApplicationLocked，接着调用ActivieServices的attachApplicationLocked通知客户端启动Service</p>
<pre><code>    if (!badApp) &#123;
        try &#123;
            didSomething |= mServices.attachApplicationLocked(app, processName);
        &#125; catch (Exception e) &#123;
            Slog.wtf(TAG, &quot;Exception thrown starting services in &quot; + app, e);
            badApp = true;
        &#125;
    &#125;
</code></pre>
<p>attachApplicationLocked，mPendingServices就是前面加入列表的ServiceRecord，过滤要启动的ServiceRecord，调用realStartServiceLocked:   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(ProcessRecord proc, String processName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> didSomething = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// Collect any services that are waiting for this process to come up.</span></span><br><span class="line">    <span class="keyword">if</span> (mPendingServices.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ServiceRecord sr = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mPendingServices.size(); i++) &#123; sr = mPendingServices.get(i); <span class="comment">//过滤我们客户端当前的进程 </span></span><br><span class="line">                                                           <span class="keyword">if</span> (proc != sr.isolatedProc &amp;&amp; (proc.uid != sr.appInfo.uid || !processName.equals(sr.processName))) &#123; <span class="keyword">continue</span>; &#125; mPendingServices.remove(i); i--; proc.addPackage(sr.appInfo.packageName, sr.appInfo.versionCode, mAm.mProcessStats); realStartServiceLocked(sr, proc, sr.createdFromFg); didSomething = <span class="keyword">true</span>; &#125; &#125; <span class="keyword">catch</span> (RemoteException e) &#123; Slog.w(TAG, <span class="string">&quot;Exception in new application when starting service &quot;</span> - sr.shortName, e); <span class="keyword">throw</span> e; &#125; &#125; <span class="keyword">if</span> (mRestartingServices.size()&gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">//处理restart的状态</span></span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> didSomething;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>pendingStarts在放入要执行start操作的列表里面，在执行sendServiceArgsLocked告诉客户端执行onStart:</p>
<pre><code>private final void realStartServiceLocked(ServiceRecord r,
        ProcessRecord app, boolean execInFg) throws RemoteException &#123;
    //..
    r.app = app;
    r.restartTime = r.lastActivity = SystemClock.uptimeMillis();
    app.services.add(r);
    //将Service加入到正在执行的executingServices(ProcessRecord)列表里
    bumpServiceExecutingLocked(r, execInFg, &quot;create&quot;);
    mAm.updateLruProcessLocked(app, false, null);
    mAm.updateOomAdjLocked();
    boolean created = false;
    try &#123;
        //...
        app.thread.scheduleCreateService(r, r.serviceInfo,
                mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),
                app.repProcState);
        //前台进程显示Notification
        r.postNotification();
        created = true;
    &#125; catch (DeadObjectException e) &#123;
      //...
  &#125;
    // If the service is in the started state, and there are no
    // pending arguments, then fake up one so its onStartCommand() will
    // be called.
    if (r.startRequested &amp;&amp; r.callStart &amp;&amp; r.pendingStarts.size() == 0) &#123;
        r.pendingStarts.add(new ServiceRecord.StartItem(r, false, r.makeNextStartId(),
                null, null));
    &#125;
    sendServiceArgsLocked(r, execInFg, true);
    //...
&#125;
</code></pre>
<p> 先看ActivityThread的scheduleCreateService,这里对应的token就是ActivityManagerService创建的ServiceRecord，ServiceInfo是ActivityManagerService为我们解析AndroidManifest的Service标签:</p>
<pre><code>public final void scheduleCreateService(IBinder token,
        ServiceInfo info, CompatibilityInfo compatInfo, int processState) &#123;
    updateProcessState(processState, false);
    CreateServiceData s = new CreateServiceData();
    s.token = token;
    s.info = info;
    s.compatInfo = compatInfo;
    sendMessage(H.CREATE_SERVICE, s);
&#125;
</code></pre>
<p>同样是向Handler发送消息实现进程切换:</p>
<pre><code> private class H extends Handler &#123;
    public void handleMessage(Message msg) &#123;
        //...
         case CREATE_SERVICE:
            handleCreateService((CreateServiceData)msg.obj);
            break;
        //...
    &#125;
&#125;
</code></pre>
<p>执行ActivityThread的handleCreateService，实现创建服务并执行onCreate，调用ActivityManagerService的serviceDoneExecuting，onCreate更新下Service的一些状态</p>
<pre><code> private void handleCreateService(CreateServiceData data) &#123;
    ...
        Service service = null;
        ...
            java.lang.ClassLoader cl = packageInfo.getClassLoader();
            service = (Service) cl.loadClass(data.info.name).newInstance();
            ...
            service.attach(context, this, data.info.name, data.token, app,
                    ActivityManagerNative.getDefault());
            service.onCreate();
            mServices.put(data.token, service);
            ...
            //serviceDoneExecuting的主要工作是当service启动完成，则移除service Timeout消息。
                ActivityManagerNative.getDefault().serviceDoneExecuting(
                        data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);
            ...
    &#125;
</code></pre>
<p>再回到上面的ActivieServices的sendServiceArgsLocked告诉客户端要执行onStartCommand，将要执行的onStart的参数（例如startId）传回客户端:</p>
<pre><code>    private final void sendServiceArgsLocked(ServiceRecord r, boolean execInFg,
        boolean oomAdjusted) &#123;
    //...
    while (r.pendingStarts.size() &gt; 0) &#123;
        try &#123;
            ServiceRecord.StartItem si = r.pendingStarts.remove(0);
            //...
            si.deliveredTime = SystemClock.uptimeMillis();
            r.deliveredStarts.add(si);
            si.deliveryCount++;
            //更新正在执行的状态
            bumpServiceExecutingLocked(r, execInFg, &quot;start&quot;);
            int flags = 0;
            if (si.deliveryCount &gt; 1) &#123;
                flags |= Service.START_FLAG_RETRY;
            &#125;
            if (si.doneExecutingCount &gt; 0) &#123;
                flags |= Service.START_FLAG_REDELIVERY;
            &#125;
            //IPC过程 ApplicationThreadNative -&gt; ActivityThread
            r.app.thread.scheduleServiceArgs(r, si.taskRemoved, si.id, flags, si.intent);
        &#125; catch (RemoteException e) &#123;
            //...
        &#125; 
    &#125;
&#125;
</code></pre>
<p>接着执行ActivityThread里的scheduleServiceArgs:</p>
<pre><code>public final void scheduleServiceArgs(IBinder token, boolean taskRemoved, int startId,
            int flags ,Intent args) &#123;
            ServiceArgsData s = new ServiceArgsData();
            s.token = token;
            s.taskRemoved = taskRemoved;
            s.startId = startId;
            s.flags = flags;
            s.args = args;
            sendMessage(H.SERVICE_ARGS, s);
        &#125;
</code></pre>
<p>同样发送消息给主线程执行handleServiceArgs，mServices为客户端维护的Service列表:</p>
<pre><code>    private void handleServiceArgs(ServiceArgsData data) &#123;
    Service s = mServices.get(data.token);
    ...
            int res;
            if (!data.taskRemoved) &#123;
                res = s.onStartCommand(data.args, data.flags, data.startId);
           ...
           //通知AMSservice的状态
           ActivityManagerNative.getDefault().serviceDoneExecuting(
                    data.token, SERVICE_DONE_EXECUTING_START, data.startId, res);
           
&#125;
</code></pre>
<p>onStartCommand执行完后会返回一个参数，用于控制Service的一些行为，例如进程被杀死之后Service的行为。<br>随后调用serviceDoneExecuting告诉ActivityManagerService，onStart已经执行完了，ActivityManagerService再更新一些状态，就这样Service就运行起来了。</p>
<p>三、bindService的过程分析<br>    这个过程中Service所在的进程是已经别启动了的<br>    <a target="_blank" rel="noopener" href="http://0.0.0.1/">http://www.jianshu.com/p/37e0e66979a6</a><br>    <a target="_blank" rel="noopener" href="http://0.0.0.2/">http://blog.csdn.net/jelly_fang/article/details/50488915</a><br>    <a target="_blank" rel="noopener" href="http://0.0.0.3/">http://www.cnblogs.com/android-blogs/p/5718302.html</a></p>
<p>frameworks\base\core\java\android\app\ContextImpl.java</p>
<pre><code> public boolean bindService(Intent service, ServiceConnection conn,
            int flags) &#123;
        warnIfCallingFromSystemProcess();
        return bindServiceCommon(service, conn, flags, Process.myUserHandle());
    &#125;
    private boolean bindServiceCommon(Intent service, ServiceConnection conn, int flags,
            UserHandle user) &#123;
        IServiceConnection sd;
        ...
        1.onbind最终回调ServiceConnection的onServiceConnected方法
        if (mPackageInfo != null) &#123;
            sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(),
                    mMainThread.getHandler(), flags);
        &#125; 
        ...
        2.AMS中bind过程
        int res = ActivityManagerNative.getDefault().bindService(
                mMainThread.getApplicationThread(), getActivityToken(), service,
                service.resolveTypeIfNeeded(getContentResolver()),
                sd, flags, getOpPackageName(), user.getIdentifier());    
        ...
    &#125;
</code></pre>
<p>分析1过程：<br>sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(),<br>                mMainThread.getHandler(), flags);</p>
<pre><code>frameworks\base\core\java\android\app\LoadedApk.java

public final IServiceConnection getServiceDispatcher(ServiceConnection c,
        Context context, Handler handler, int flags) &#123;
    synchronized (mServices) &#123;
        //创建ServiceDispatcher
        LoadedApk.ServiceDispatcher sd = null;
        ...
        if (sd == null) &#123;
            sd = new ServiceDispatcher(c, context, handler, flags);
            ...
        &#125;
        ...
        //返回的是ServiceDispatcher的内部类InnerConnection
        return sd.getIServiceConnection();
    &#125;
&#125;
</code></pre>
<p>   ServiceDispatcher类中的方法</p>
<pre><code>static final class ServiceDispatcher &#123;
    private final ServiceDispatcher.InnerConnection mIServiceConnection;
    private final ServiceConnection mConnection;
    private final Context mContext;
    private final Handler mActivityThread;
    private final ServiceConnectionLeaked mLocation;
    private final int mFlags;
    ...
    //ServiceDispatcher的内部类
    private static class InnerConnection extends IServiceConnection.Stub &#123;
        final WeakReference&lt;LoadedApk.ServiceDispatcher&gt; mDispatcher;

        InnerConnection(LoadedApk.ServiceDispatcher sd) &#123;
            mDispatcher = new WeakReference&lt;LoadedApk.ServiceDispatcher&gt;(sd);
        &#125;
        //保存当前激活的Serviceconnection的Map
        private final ArrayMap&lt;ComponentName, ServiceDispatcher.ConnectionInfo&gt; mActiveConnections
        = new ArrayMap&lt;ComponentName, ServiceDispatcher.ConnectionInfo&gt;();
        
        public void connected(ComponentName name, IBinder service) throws RemoteException &#123;
            LoadedApk.ServiceDispatcher sd = mDispatcher.get();
            if (sd != null) &#123;
                //调用到了外部类ServiceDispatcher中的connected
                sd.connected(name, service);
            &#125;
        &#125;
    &#125;
    //ServiceDispatcher的connected方法
    public void connected(ComponentName name, IBinder service) &#123;
        if (mActivityThread != null) &#123;
            mActivityThread.post(new RunConnection(name, service, 0));
        &#125; else &#123;
        //调用到ServiceDispatcher的doConnected
            doConnected(name, service);
        &#125;
    &#125;
    
    public void doConnected(ComponentName name, IBinder service) &#123;
        ...
        if (service != null) &#123;
                // A new service is being connected... set it all up.
                mDied = false;
                info = new ConnectionInfo();
                info.binder = service;
                info.deathMonitor = new DeathMonitor(name, service);
                ...
        &#125;   
        ...
        // If there is a new service, it is now connected.
        if (service != null) &#123;
            //调用了 mConnection.onServiceConnected(name, service)这个方法,后面会通过InnerConnection实例来远程回调这个方法。
            //这个mConnection其实就是一开始ServiceDispatcher 的构造函数中传进来的ServiceConnection实例。
            mConnection.onServiceConnected(name, service);
        &#125;
    &#125;
</code></pre>
<p> 分析2过程：<br>    int res = ActivityManagerNative.getDefault().bindService(<br>            mMainThread.getApplicationThread(), getActivityToken(), service,<br>            service.resolveTypeIfNeeded(getContentResolver()),<br>            sd, flags, getOpPackageName(), user.getIdentifier());</p>
<p>   ActivityManagerNative.getDefault() 最终都会调用ActiveServices.bindServiceLocked方法,细致的不去跟踪<br>   frameworks\base\services\core\java\com\android\server\am\ActiveServices.java<br>   s（ServiceRecord ）、b（AppBindRecord ）、c（ConnectionRecord ）、callerApp （ProcessRecord） 这四个类型的一些保存之类的操作，方便以后调用</p>
<pre><code>    int bindServiceLocked(IApplicationThread caller, IBinder token, Intent service,
        String resolvedType, IServiceConnection connection, int flags,
        String callingPackage, int userId) throws TransactionTooLargeException &#123;
    ...
  
    final ProcessRecord callerApp = mAm.getRecordForAppLocked(caller);
    ...
    ServiceLookupResult res =
        retrieveServiceLocked(service, resolvedType, callingPackage,
                Binder.getCallingPid(), Binder.getCallingUid(), userId, true, callerFg);
    if (res == null) &#123;
        return 0;
    &#125;
    if (res.record == null) &#123;
        return -1;
    &#125;
    ServiceRecord s = res.record;
    ...
    try &#123;
        mAm.startAssociationLocked(callerApp.uid, callerApp.processName,
                s.appInfo.uid, s.name, s.processName);
        //获取一个ServiceRecord对象，如果不存在就创建        
        AppBindRecord b = s.retrieveAppBindingLocked(service, callerApp);
        ConnectionRecord c = new ConnectionRecord(b, activity,connection, flags, clientLabel, clientIntent);
        
        //这个binder其实可以简单的看做成IServiceConnection ，后面可以通过它asInterface方法获取binder驱动来远程调用IServiceConnection （其实就是IServiceConnection–&gt;InnerConnection –&gt;ServiceDispatcher ）里面的方法。然后把这个binder放到了s（ServiceRecord ）的connections的集合中,clist就是一个connectionRecord的集合，应为可能不止一个activity或者组件需要绑定这个service。
        IBinder binder = connection.asBinder();
        
        ArrayList&lt;ConnectionRecord&gt; clist = s.connections.get(binder);
        if (clist == null) &#123;
            clist = new ArrayList&lt;ConnectionRecord&gt;();
            s.connections.put(binder, clist);
        &#125;
        clist.add(c);
        ...
        if ((flags&amp;Context.BIND_AUTO_CREATE) != 0) &#123;
            s.lastActivity = SystemClock.uptimeMillis();
            //执行bringUpServiceLocked,bringUpServiceLocked调用到realStartServiceLocked;
            if (bringUpServiceLocked(s, service.getFlags(), callerFg, false) != null) &#123;
                return 0;
            &#125;
        &#125;
</code></pre>
<p>​<br>​            if (s.app != null &amp;&amp; b.intent.received) {<br>​                // Service is already running, so we can immediately<br>​                // publish the connection.<br>​                …<br>​                    //重复bind时会走这里，直接调用requestServiceBindingLocked<br>​                    c.conn.connected(s.name, b.intent.binder);<br>​                …<br>​                // If this is the first app connected back to this binding,<br>​                // and the service had previously asked to be told when<br>​                // rebound, then do so.<br>​                if (b.intent.apps.size() == 1 &amp;&amp; b.intent.doRebind) {<br>​                    requestServiceBindingLocked(s, b.intent, callerFg, true);<br>​                }<br>​            } else if (!b.intent.requested) {<br>​                requestServiceBindingLocked(s, b.intent, callerFg, false);<br>​<br>            }<br>        …<br>        return 1;<br>    }</p>
<p>bringUpServiceLocked</p>
<pre><code> private final String bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean execInFg, boolean whileRestarting) throws TransactionTooLargeException &#123;
        ...
        if (!isolated) &#123;
            app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, false);
            if (DEBUG_MU) Slog.v(TAG_MU, &quot;bringUpServiceLocked: appInfo.uid=&quot; + r.appInfo.uid
                        + &quot; app=&quot; + app);
            if (app != null &amp;&amp; app.thread != null) &#123;
                try &#123;
                    app.addPackage(r.appInfo.packageName, r.appInfo.versionCode, mAm.mProcessStats);
                    realStartServiceLocked(r, app, execInFg);
                    return null;
                &#125; catch (TransactionTooLargeException e) &#123;
                    throw e;
                &#125; catch (RemoteException e) &#123;
                    Slog.w(TAG, &quot;Exception when starting service &quot; + r.shortName, e);
                &#125;
            &#125;
        &#125;
        ...
        return null;
    &#125;
</code></pre>
<p> realStartServiceLocked</p>
<pre><code>private final void realStartServiceLocked(ServiceRecord r,
            ProcessRecord app, boolean execInFg) throws RemoteException &#123;

        r.app = app;
       ...
        //3.调用ActivityThread的scheduleCreateService,创建一个Service
            app.thread.scheduleCreateService(r, r.serviceInfo,
                    mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),
                    app.repProcState);
            r.postNotification();
     ...
        //4. 等待3的service被创建完成bindService
        requestServiceBindingsLocked(r, execInFg);
        updateServiceClientActivitiesLocked(app, null, true);
    &#125;
</code></pre>
<p>分析3过程<br>app.thread.scheduleCreateService(r, r.serviceInfo,<br>                    mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),<br>                    app.repProcState);</p>
<pre><code>//scheduleCreateService 发送一个消息
public final void scheduleCreateService(IBinder token,
            ServiceInfo info, CompatibilityInfo compatInfo, int processState) &#123;
        updateProcessState(processState, false);
        CreateServiceData s = new CreateServiceData();
        s.token = token;
        s.info = info;
        s.compatInfo = compatInfo;

        sendMessage(H.CREATE_SERVICE, s);
&#125;
//handleCreateService
private void handleCreateService(CreateServiceData data) &#123;
...
    初始化一个service ，并执行回调
    Service service = null;
    ...
        java.lang.ClassLoader cl = packageInfo.getClassLoader();
        service = (Service) cl.loadClass(data.info.name).newInstance();
        ...
        service.attach(context, this, data.info.name, data.token, app,
                ActivityManagerNative.getDefault());
        service.onCreate();
        mServices.put(data.token, service);
        ...
        //serviceDoneExecuting的主要工作是当service启动完成，则移除service Timeout消息。
        ActivityManagerNative.getDefault().serviceDoneExecuting(
                    data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);
        ...
&#125;
</code></pre>
<p>分析4过程：<br>requestServiceBindingsLocked(r, execInFg);</p>
<pre><code>private final boolean requestServiceBindingLocked(ServiceRecord r, IntentBindRecord i,
        boolean execInFg, boolean rebind) throws TransactionTooLargeException &#123;
        ...
        //调用ActivityThread的scheduleBindService
        r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,
                    r.app.repProcState);
        ...
&#125;
</code></pre>
<p>接下来的过程类似于 onCreate 的过程scheduleBindService -&gt; handleMessage -&gt; handleBindService 调用到ActiveServices.publishServiceLocked</p>
<pre><code>private void handleBindService(BindServiceData data) &#123;
    Service s = mServices.get(data.token);
    ...
    //类似于之前的过程 最终调用到 ActiveServices 的 publishServiceLocked
        ActivityManagerNative.getDefault().publishService(
                            data.token, data.intent, binder);
    ...
&#125;
</code></pre>
<p>//取出在bindServiceLock中放到ServiceRecord中的ConnectionRecord </p>
<pre><code>void publishServiceLocked(ServiceRecord r, Intent intent, IBinder service) &#123;
    for (int conni=r.connections.size()-1; conni&gt;=0; conni--) &#123;
         ArrayList&lt;ConnectionRecord&gt; clist = r.connections.valueAt(conni);
             for (int i=0; i&lt;clist.size(); i++) &#123; ConnectionRecord c = clist.get(i); ... //回调到onServiceConnected，bindService结束 即是方法ConnectionRecord.ServiceDispatcher.InnerConnection.connected c.conn.connected(r.name, service); ... &#125; &#125; &#125; 四、startService和bindService的流程的区别在于： 4.1在bringUpServiceLocked 中开启新的进程后，绕一圈再调用到realStartServiceLocked ActivityManagerService.startProcessLocked-&gt;ActivityThread.main-&gt;ActivityManagerNative.getDefault().attachApplicationLocked-&gt; 
</code></pre>
<p>ActivityManagerService.attachApplicationLocked-&gt;ActiveServices.attachApplicationLocked-&gt;ActiveServices.realStartServiceLocked<br>4.2当realStartServiceLocked 中执行时，bindService会调用requestServiceBindingsLocked做绑定服务的下一步处理，这里创建的Service并不会回调onStartCommand，在realStartServiceLocked中对start和bind的操作做了区分<br>    //bringUpServiceLocked</p>
<pre><code> private final String bringUpServiceLocked(ServiceRecord r,int intentFlags, boolean execInFg, boolean whileRestarting) &#123;
         if (app == null) &#123;
                if ((app=mAm.startProcessLocked(procName, r.appInfo, true, intentFlags,
                        &quot;service&quot;, r.name, false, isolated, false)) == null) &#123;
                   //...
            &#125;  
        &#125;
</code></pre>
<p>//开启新的进程</p>
<pre><code>public final class ActivityThread &#123;
            public static void main(String[] args) &#123;
                Looper.prepareMainLooper();
                ActivityThread thread = new ActivityThread();
                thread.attach(false);
                Looper.loop();
                throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);
            &#125;
            private void attach(boolean system) &#123;
                ...
                 mgr.attachApplication(mAppThread);
                ...
        &#125;
</code></pre>
<p>   ActivityManagerService.attachApplicationLocked</p>
<pre><code> private final boolean attachApplicationLocked(IApplicationThread thread,
            int pid) &#123;
          //...
            thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,
                    profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,
                    app.instrumentationUiAutomationConnection, testMode, enableOpenGlTrace,
                    isRestrictedBackupMode || !normalMode, app.persistent,
                    new Configuration(mConfiguration), app.compat,
                    getCommonServicesLocked(app.isolated),
                    mCoreSettingsObserver.getCoreSettingsLocked());
        ...
        // Find any services that should be running in this process...
        //这里继续调用到ActiveService.attachApplicationLocked
             didSomething |= mServices.attachApplicationLocked(app, processName);
      //...
        return true;
    &#125;
</code></pre>
<p> ActiveServices.attachApplicationLocked   </p>
<pre><code> boolean attachApplicationLocked(ProcessRecord proc, String processName)
        throws RemoteException &#123;
        ...
        realStartServiceLocked(sr, proc, sr.createdFromFg);
        didSomething = true;
        ...
    return didSomething;
&#125;
</code></pre>
<p>ActiveServices.realStartServiceLocked</p>
<pre><code>    private final void realStartServiceLocked(ServiceRecord r,
        ProcessRecord app, boolean execInFg) throws RemoteException &#123;
    //...
    r.app = app;
    r.restartTime = r.lastActivity = SystemClock.uptimeMillis();
    app.services.add(r);
    bumpServiceExecutingLocked(r, execInFg, &quot;create&quot;);
    mAm.updateLruProcessLocked(app, false, null);
    mAm.updateOomAdjLocked();
    boolean created = false;
    try &#123;
        //通知创建Service并执行onCreate
        app.thread.scheduleCreateService(r, r.serviceInfo,
                mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),
                app.repProcState);
        r.postNotification();
        created = true;
    &#125; catch (DeadObjectException e) &#123;
      //...
    &#125; finally &#123;
        //...
    &#125;
    //bindService 会执行这里,最终回调到方法onServiceConnected
      scheduleBindService -&gt; handleMessage -&gt; handleBindService 调用到ActiveServices.publishServiceLocked
    requestServiceBindingsLocked(r, execInFg);
    updateServiceClientActivitiesLocked(app, null, true);
    //这里不会加入到pendingStarts里面，所以不会执行onStartCommand
    if (r.startRequested &amp;&amp; r.callStart &amp;&amp; r.pendingStarts.size() == 0) &#123;
        r.pendingStarts.add(new ServiceRecord.StartItem(r, false, r.makeNextStartId(),
                null, null));
    &#125;
    //startService 过程继续执行这里
    sendServiceArgsLocked(r, execInFg, true);
    //...
&#125;
</code></pre>
<p>ActiveServices.requestServiceBindingsLocked,bindService 会执行这里,最终回调到方法onServiceConnected<br>          scheduleBindService -&gt; handleMessage -&gt; handleBindService,调用到ActiveServices.publishServiceLocked     </p>
<pre><code>private final void requestServiceBindingsLocked(ServiceRecord r, boolean execInFg)
        throws TransactionTooLargeException &#123;
    for (int i=r.bindings.size()-1; i&gt;=0; i--) &#123;
        IntentBindRecord ibr = r.bindings.valueAt(i);
        if (!requestServiceBindingLocked(r, ibr, execInFg, false)) &#123;
            break;
        &#125;
    &#125;
&#125; 
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/24/Notes/Android/other/other/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/24/Notes/Android/other/other/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-24 23:08:49" itemprop="dateCreated datePublished" datetime="2021-02-24T23:08:49+08:00">2021-02-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="http://blog.leanote.com/post/svenpaper/Android-SharePreference-%E6%80%BB%E7%BB%93">http://blog.leanote.com/post/svenpaper/Android-SharePreference-%E6%80%BB%E7%BB%93</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.leanote.com/post/svenpaper/Android-O-%E7%89%88%E6%9C%AC%E5%AE%89%E8%A3%85%E5%8C%85%E5%A4%A7%E5%B0%8F%E8%8E%B7%E5%8F%96%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E5%8F%8A%E8%A7%A3%E5%86%B3">http://blog.leanote.com/post/svenpaper/Android-O-%E7%89%88%E6%9C%AC%E5%AE%89%E8%A3%85%E5%8C%85%E5%A4%A7%E5%B0%8F%E8%8E%B7%E5%8F%96%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E5%8F%8A%E8%A7%A3%E5%86%B3</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.leanote.com/post/svenpaper/JobService-%E5%92%8C-Jobschedule">http://blog.leanote.com/post/svenpaper/JobService-%E5%92%8C-Jobschedule</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/24/Notes/Android/Framework/FrameWork_07_SharePreference%20%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/24/Notes/Android/Framework/FrameWork_07_SharePreference%20%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">FrameWork_08_SharedPreferences</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-24 23:08:49" itemprop="dateCreated datePublished" datetime="2021-02-24T23:08:49+08:00">2021-02-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="FrameWork-08-SharedPreference"><a href="#FrameWork-08-SharedPreference" class="headerlink" title="FrameWork_08_SharedPreference"></a>FrameWork_08_SharedPreference</h1><p>SharePreferences是一个轻量级的存储类，特别适合用于保存软件配置参数。使用SharedPreferences保存数据，其背后是用xml文件存放数据，文件存放在/data/data/ &lt; package name &gt; /shared_prefs目录下，本文主要介绍下sp的用法并且从源码的角度分析下sp的写入过程。</p>
<h2 id="1-获取sp的三种方式"><a href="#1-获取sp的三种方式" class="headerlink" title="1.获取sp的三种方式"></a>1.获取sp的三种方式</h2><p>1.this.getPreferences (int mode)<br>    通过Activity对象获取，获取的是本Activity私有的Preference，保存在系统中的xml形式的文件的名称为这个Activity的名字，因此一个Activity只能有一个，属于这个Activity。</p>
<p>2.context.getSharedPreferences (String name, int mode)<br>    因为Activity继承了ContextWrapper，因此也是通过Activity对象获取，但是属于整个应用程序，可以有多个，以第一参数的name为文件名保存在系统中。</p>
<p>3.PreferenceManager.getDefaultSharedPreferences(this);<br>    PreferenceManager的静态函数，保存PreferenceActivity中的设置，属于整个应用程序，但是只有一个，命名为packagename_preferences。</p>
<h2 id="2-写入模式"><a href="#2-写入模式" class="headerlink" title="2. 写入模式"></a>2. 写入模式</h2><pre><code>Activity.MODE_PRIVATE,//默认操作模式，代表该文件是私有数据，只能被应用本身访问，在该模式下，写入的内容会覆盖原文件的内容，如果想把新写入的内容追加到原文件中，可以使用Activity.MODE_APPEND 
Activity.MODE_APPEND //该模式会检查文件是否存在，存在就往文件追加内容，否则就创建新文件
以下2种模式已废弃，不安全
Activity.MODE_WORLD_READABLE,//表示当前文件可以被其他应用读取，  
Activity.MODE_WORLD_WRITEABLE,//表示当前文件可以被其他应用写入；
</code></pre>
<h2 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3.源码分析"></a>3.源码分析</h2><h3 id="1-获取SharedPreferences对象"><a href="#1-获取SharedPreferences对象" class="headerlink" title="1.获取SharedPreferences对象"></a>1.获取SharedPreferences对象</h3><p>contextImpl.getSharedPreferences()，这里使用到了单例模式，涉及到的几个对象如下：</p>
<pre><code>ArrayMap&lt;String, File&gt; mSharedPrefsPaths ： 保存sp的路径和文件
ArrayMap&lt;String, ArrayMap&lt;File, SharedPreferencesImpl&gt;&gt; sSharedPrefsCache key 是packageName， vlaue是 file 和 对应的spImpl对象。
</code></pre>
<p>整个过程分为2步，先获取对应name的sp文件，如果没有就new一个文件放到 mSharedPrefsPaths 中，<br>再根据文件名获取对应的spImpl对象。</p>
<p>对于一个相同的SharedPreferences name，获取到的都是同一个SharedPreferences对象，也就是SharedPreferencesImpl对象。</p>
<pre><code>public SharedPreferences getSharedPreferences(String name, int mode) &#123;
    // At least one application in the world actually passes in a null
    // name.  This happened to work because when we generated the file name
    // we would stringify it to &quot;null.xml&quot;.  Nice.
    if (mPackageInfo.getApplicationInfo().targetSdkVersion &lt;
            Build.VERSION_CODES.KITKAT) &#123;
        if (name == null) &#123;
            name = &quot;null&quot;;
        &#125;
    &#125;
    
    File file;
    synchronized (ContextImpl.class) &#123;
        if (mSharedPrefsPaths == null) &#123;
            mSharedPrefsPaths = new ArrayMap&lt;&gt;();
        &#125;
        file = mSharedPrefsPaths.get(name);
        if (file == null) &#123;
            file = getSharedPreferencesPath(name);
            mSharedPrefsPaths.put(name, file);
        &#125;
    &#125;
    return getSharedPreferences(file, mode);
&#125;

 public SharedPreferences getSharedPreferences(File file, int mode) &#123;
    ...
    SharedPreferencesImpl sp;
    synchronized (ContextImpl.class) &#123;
        final ArrayMap&lt;File, SharedPreferencesImpl&gt; cache = getSharedPreferencesCacheLocked();
        sp = cache.get(file);
        if (sp == null) &#123;
            sp = new SharedPreferencesImpl(file, mode);
            cache.put(file, sp);
            return sp;
        &#125;
    &#125;
    if ((mode &amp; Context.MODE_MULTI_PROCESS) != 0 ||
        getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) &#123;
        // If somebody else (some other process) changed the prefs
        // file behind our back, we reload it.  This has been the
        // historical (if undocumented) behavior.
        sp.startReloadIfChangedUnexpectedly();
    &#125;
    return sp;
&#125;

private ArrayMap&lt;File, SharedPreferencesImpl&gt; getSharedPreferencesCacheLocked() &#123;
    if (sSharedPrefsCache == null) &#123;
        sSharedPrefsCache = new ArrayMap&lt;&gt;();
    &#125;

    final String packageName = getPackageName();
    ArrayMap&lt;File, SharedPreferencesImpl&gt; packagePrefs = sSharedPrefsCache.get(packageName);
    if (packagePrefs == null) &#123;
        packagePrefs = new ArrayMap&lt;&gt;();
        sSharedPrefsCache.put(packageName, packagePrefs);
    &#125;

    return packagePrefs;
&#125;
</code></pre>
<h3 id="2-sp-的初始化"><a href="#2-sp-的初始化" class="headerlink" title="2.sp 的初始化"></a>2.sp 的初始化</h3><p>对于一个SharedPreferences文件name，第一次调用getSharedPreferences时会去创建一个SharedPreferencesImpl对象，它会开启一个子线程，将所有的数据以Map的形式保存在内存中。</p>
<pre><code> SharedPreferencesImpl(File file, int mode) &#123;
    mFile = file;
    mBackupFile = makeBackupFile(file);
    mMode = mode;
    mLoaded = false;
    mMap = null;
    startLoadFromDisk();
&#125;

private void startLoadFromDisk() &#123;
    synchronized (mLock) &#123;
        mLoaded = false;
    &#125;
    new Thread(&quot;SharedPreferencesImpl-load&quot;) &#123;
        public void run() &#123;
            loadFromDisk();
        &#125;
    &#125;.start();
&#125;

private void loadFromDisk() &#123;
    synchronized (mLock) &#123;
        if (mLoaded) &#123;
            return;
        &#125;
        if (mBackupFile.exists()) &#123;
            mFile.delete();
            mBackupFile.renameTo(mFile);
        &#125;
    &#125;

    // Debugging
    if (mFile.exists() &amp;&amp; !mFile.canRead()) &#123;
        Log.w(TAG, &quot;Attempt to read preferences file &quot; + mFile + &quot; without permission&quot;);
    &#125;

    Map map = null;
    StructStat stat = null;
    try &#123;
        stat = Os.stat(mFile.getPath());
        if (mFile.canRead()) &#123;
            BufferedInputStream str = null;
            try &#123;
                str = new BufferedInputStream(
                        new FileInputStream(mFile), 16*1024);
                map = XmlUtils.readMapXml(str);
            &#125; catch (Exception e) &#123;
                Log.w(TAG, &quot;Cannot read &quot; + mFile.getAbsolutePath(), e);
            &#125; finally &#123;
                IoUtils.closeQuietly(str);
            &#125;
        &#125;
    &#125; catch (ErrnoException e) &#123;
        /* ignore */
    &#125;

    synchronized (mLock) &#123;
        mLoaded = true;
        if (map != null) &#123;
            mMap = map;
            mStatTimestamp = stat.st_mtime;
            mStatSize = stat.st_size;
        &#125; else &#123;
            mMap = new HashMap&lt;&gt;();
        &#125;
        mLock.notifyAll();
    &#125;
&#125;
</code></pre>
<h2 id="3-sp的读取"><a href="#3-sp的读取" class="headerlink" title="3. sp的读取"></a>3. sp的读取</h2><p>当我们在ui线程种这样调用时：</p>
<pre><code>SharedPreferences sp = getSharedPreferences(&quot;test&quot;, Context.MODE_PRIVATE);
String name = sp.getString(&quot;name&quot;, null)
</code></pre>
<p>调用getString时那个SharedPreferencesImpl构造方法开启的子线程可能还没执行完（比如文件比较大时全部读取会比较久），这时getString当然还不能获取到相应的值，必须阻塞到那个子线程读取完为止，getString方法：</p>
<pre><code>public String getString(String key, @Nullable String defValue) &#123;
    synchronized (this) &#123;
        awaitLoadedLocked();
        String v = (String)mMap.get(key);
        return v != null ? v : defValue;
    &#125;
&#125;
</code></pre>
<p>显然这个awaitLoadedLocked方法就是用来等this这个锁的，在loadFromDiskLocked方法的最后我们也可以看到它调用了notifyAll方法，这时如果getString之前阻塞了就会被唤醒。那么现在这里有一个问题，我们的getString是写在UI线程中，如果那个getString被阻塞太久了，比如60s，这时就会出现ANR，因此要根据具体情况考虑是否需要把SharedPreferences的读写放在子线程中。这里回答第二个 问题，在UI线程中调用getXXX可能会导致ANR。同时可以回答第三个问题，SharedPreferences只能用来存放少量数据，如果一个SharedPreferences对应的xml文件很大的话，在初始化时会把这个文件的所有数据都加载到内存中，这样就会占用大量的内存，有时我们只是想读取某个xml文件中一个key的value，结果它把整个文件都加载进来了，显然如果必要的话这里需要进行相关优化处理。</p>
<h2 id="4-sp的写入"><a href="#4-sp的写入" class="headerlink" title="4.sp的写入"></a>4.sp的写入</h2><pre><code>SharedPreferences.Editor editor = getSharedPreferences(&quot;test&quot;, Context.MODE_PRIVATE).edit();
editor.putString(&quot;name&quot;, &quot;test&quot;);
editor.commit();
</code></pre>
<p>首先写一个SharedPreferences文件都是先要调用edit方法获取到一个Editor对象：   </p>
<pre><code>public Editor edit() &#123;
    synchronized (this) &#123;
        awaitLoadedLocked();
    &#125;
    return new EditorImpl();
&#125;
</code></pre>
<p>这个Editor对象是SharedPreferencesImpl的一个内部类：</p>
<pre><code>public final class EditorImpl implements Editor &#123;
    private final Map&lt;String, Object&gt; mModified = Maps.newHashMap();
    private boolean mClear = false;
    public Editor putString(String key, @Nullable String value) &#123;
        synchronized (this) &#123;
            mModified.put(key, value);
            return this;
        &#125;
    &#125;
    ...
&#125;
</code></pre>
<p>可以看到它有一个Map对象mModified，用来保存修改的数据，也就是你每次put的时候其实是把那个键值对放到这个mModified 中，最后调用apply或者commit才会真正把数据写入文件中。调用commit 和 apply时都会调用到commitToMemory 和 enqueueDiskWrite这2个方法。这里我们以commit 为例先看下整个写入的过程。 </p>
<h3 id="4-1-commit"><a href="#4-1-commit" class="headerlink" title="4.1 commit"></a>4.1 commit</h3><pre><code>public boolean commit() &#123;
    MemoryCommitResult mcr = commitToMemory();
    SharedPreferencesImpl.this.enqueueDiskWrite(
        mcr, null /* sync write on this thread okay */);
    try &#123;
        mcr.writtenToDiskLatch.await();
    &#125; catch (InterruptedException e) &#123;
        return false;
    &#125;
    notifyListeners(mcr);
    return mcr.writeToDiskResult;
&#125;
</code></pre>
<h3 id="4-2-commitToMemory"><a href="#4-2-commitToMemory" class="headerlink" title="4.2 commitToMemory"></a>4.2 commitToMemory</h3><p>这个方法对应了editor的增删改查方法，这里涉及了2个对象，mMap 和mModified，一个保存当前sp中的键值对，一个保存了修改的键值对。遍历mModified键值对时可以看到这个方法中首先处理了clear标志，它调用的是mMap.clear()，然后再遍历mModified将新的键值对put进mMap，也就是说在一次commit事务中，如果同时put一些键值对和调用clear，那么clear掉的只是之前的键值对，这次put进去的键值对还是会被写入的。</p>
<pre><code>// Returns true if any changes were made
private MemoryCommitResult commitToMemory() &#123;
    MemoryCommitResult mcr = new MemoryCommitResult();
    ...
        synchronized (this) &#123;
            if (mClear) &#123;
                if (!mMap.isEmpty()) &#123;
                    mcr.changesMade = true;
                    mMap.clear();
                &#125;
                mClear = false;
            &#125;

            for (Map.Entry&lt;String, Object&gt; e : mModified.entrySet()) &#123;
                String k = e.getKey();
                Object v = e.getValue();
                // &quot;this&quot; is the magic value for a removal mutation. In addition,
                // setting a value to &quot;null&quot; for a given key is specified to be
                // equivalent to calling remove on that key.
                if (v == this || v == null) &#123;
                    if (!mMap.containsKey(k)) &#123;
                        continue;
                    &#125;
                    mMap.remove(k);
                &#125; else &#123;
                    if (mMap.containsKey(k)) &#123;
                        Object existingValue = mMap.get(k);
                        if (existingValue != null &amp;&amp; existingValue.equals(v)) &#123;
                            continue;
                        &#125;
                    &#125;
                    mMap.put(k, v);
                &#125;

                mcr.changesMade = true;
                if (hasListeners) &#123;
                    mcr.keysModified.add(k);
                &#125;
            &#125;

            mModified.clear();
        &#125;
    &#125;
    return mcr;
&#125;
</code></pre>
<p>遍历mModified时，需要处理一个特殊情况，就是如果一个键值对的value是this（SharedPreferencesImpl）或者是null那么表示将此键值对删除，这个在remove方法中可以看到： </p>
<pre><code>public Editor remove(String key) &#123;
    synchronized (this) &#123;
        mModified.put(key, this);
        return this;
    &#125;
&#125;
</code></pre>
<h2 id="4-3-enqueueDiskWrite"><a href="#4-3-enqueueDiskWrite" class="headerlink" title="4.3 enqueueDiskWrite"></a>4.3 enqueueDiskWrite</h2><p>先定义一个Runnable，注意实现Runnable与继承Thread的区别，Runnable表示一个任务，不一定要在子线程中执行，一般优先考虑使用Runnable。这个Runnable中先调用writeToFile进行写操作，写操作需要先获得mWritingToDiskLock，也就是写锁。然后执行mDiskWritesInFlight–，表示正在等待写的操作减少1。最后判断postWriteRunnable是否为null，调用commit时它为null，而调用apply时它不为null。<br>Runnable定义完，就判断这次是commit还是apply，如果是commit，即isFromSyncCommit为true，而且有1个写操作需要执行，那么就调用writeToDiskRunnable.run()，注意这个调用是在当前线程中进行的。如果不是commit，那就是apply，这时调用QueuedWork.singleThreadExecutor().execute(writeToDiskRunnable)，这个QueuedWork类其实很简单，里面有一个SingleThreadExecutor，用于异步执行这个writeToDiskRunnable。 </p>
<pre><code>private void enqueueDiskWrite(final MemoryCommitResult mcr,
                              final Runnable postWriteRunnable) &#123;
    final Runnable writeToDiskRunnable = new Runnable() &#123;
            public void run() &#123;
                synchronized (mWritingToDiskLock) &#123;
                    writeToFile(mcr);
                &#125;
                synchronized (SharedPreferencesImpl.this) &#123;
                    mDiskWritesInFlight--;
                &#125;
                if (postWriteRunnable != null) &#123;
                    postWriteRunnable.run();
                &#125;
            &#125;
        &#125;;

    final boolean isFromSyncCommit = (postWriteRunnable == null);

    // Typical #commit() path with fewer allocations, doing a write on
    // the current thread.
    if (isFromSyncCommit) &#123;
        boolean wasEmpty = false;
        synchronized (SharedPreferencesImpl.this) &#123;
            wasEmpty = mDiskWritesInFlight == 1;
        &#125;
        if (wasEmpty) &#123;
            writeToDiskRunnable.run();
            return;
        &#125;
    &#125;

    QueuedWork.singleThreadExecutor().execute(writeToDiskRunnable);
&#125;
</code></pre>
<h3 id="4-4-writeToFile"><a href="#4-4-writeToFile" class="headerlink" title="4.4 writeToFile"></a>4.4 writeToFile</h3><p>SharedPreferences在写入时会先把之前的xml文件改成名成一个备份文件mBackupFile，然后再将要写入的数据写到一个新的文件中，如果这个过程执行成功的话，就会把备份文件删除。由此可见每次即使只是添加一个键值对，也会重新写入整个文件的数据，这也说明SharedPreferences只适合保存少量数据，文件太大会有性能问题。</p>
<pre><code>private void writeToFile(MemoryCommitResult mcr) &#123;
    // Rename the current file so it may be used as a backup during the next read
    if (mFile.exists()) &#123;
        if (!mcr.changesMade) &#123;
            // If the file already exists, but no changes were
            // made to the underlying map, it&#39;s wasteful to
            // re-write the file.  Return as if we wrote it
            // out.
            mcr.setDiskWriteResult(true);
            return;
        &#125;
        if (!mBackupFile.exists()) &#123;
            if (!mFile.renameTo(mBackupFile)) &#123;
                Log.e(TAG, &quot;Couldn&#39;t rename file &quot; + mFile
                      + &quot; to backup file &quot; + mBackupFile);
                mcr.setDiskWriteResult(false);
                return;
            &#125;
        &#125; else &#123;
            mFile.delete();
        &#125;
    &#125;

    // Attempt to write the file, delete the backup and return true as atomically as
    // possible.  If any exception occurs, delete the new file; next time we will restore
    // from the backup.
    try &#123;
        FileOutputStream str = createFileOutputStream(mFile);
        if (str == null) &#123;
            mcr.setDiskWriteResult(false);
            return;
        &#125;
        XmlUtils.writeMapXml(mcr.mapToWriteToDisk, str);
        FileUtils.sync(str);
        str.close();
        ContextImpl.setFilePermissionsFromMode(mFile.getPath(), mMode, 0);
        try &#123;
            final StructStat stat = Os.stat(mFile.getPath());
            synchronized (this) &#123;
                mStatTimestamp = stat.st_mtime;
                mStatSize = stat.st_size;
            &#125;
        &#125; catch (ErrnoException e) &#123;
            // Do nothing
        &#125;
        // Writing was successful, delete the backup file if there is one.
        mBackupFile.delete();
        mcr.setDiskWriteResult(true);
        return;
    &#125; catch (XmlPullParserException e) &#123;
        Log.w(TAG, &quot;writeToFile: Got exception:&quot;, e);
    &#125; catch (IOException e) &#123;
        Log.w(TAG, &quot;writeToFile: Got exception:&quot;, e);
    &#125;
    // Clean up an unsuccessfully written file
    if (mFile.exists()) &#123;
        if (!mFile.delete()) &#123;
            Log.e(TAG, &quot;Couldn&#39;t clean up partially-written file &quot; + mFile);
        &#125;
    &#125;
    mcr.setDiskWriteResult(false);
&#125;
</code></pre>
<h3 id="5-使用apply导致的anr"><a href="#5-使用apply导致的anr" class="headerlink" title="5.使用apply导致的anr"></a>5.使用apply导致的anr</h3><p>其实无节制的使用apply方法也时会造成anr的，在主线程中无节制的使用apply其实也会造成anr，在调用apply时，会将等待写入到文件系统的任务awaitCommit放在QueuedWork的等待完成队列里。</p>
<pre><code>public void apply() &#123;
    final MemoryCommitResult mcr = commitToMemory();
    final Runnable awaitCommit = new Runnable() &#123;
            public void run() &#123;
                try &#123;
                    mcr.writtenToDiskLatch.await();
                &#125; catch (InterruptedException ignored) &#123;
                &#125;
            &#125;
        &#125;;

    QueuedWork.add(awaitCommit);

    Runnable postWriteRunnable = new Runnable() &#123;
            public void run() &#123;
                awaitCommit.run();
                QueuedWork.remove(awaitCommit);
            &#125;
        &#125;;

    SharedPreferencesImpl.this.enqueueDiskWrite(mcr, postWriteRunnable);

    // Okay to notify the listeners before it&#39;s hit disk
    // because the listeners should always get the same
    // SharedPreferences instance back, which has the
    // changes reflected in memory.
    notifyListeners(mcr);
&#125;
</code></pre>
<p>所以如果我们使用SharedPreference的apply方法,虽然该方法可以很快返回， 并在其它线程里将键值对写入到文件系统， 但是当Activity的onPause等方法被调用时，会调用等待写入到文件系统的任务完成，</p>
<pre><code>/**
 * Finishes or waits for async operations to complete.
 * (e.g. SharedPreferences$Editor#startCommit writes)
 *
 * Is called from the Activity base class&#39;s onPause(), after
 * BroadcastReceiver&#39;s onReceive, after Service command handling,
 * etc.  (so async work is never lost)
 */
public static void waitToFinish() &#123;
    Runnable toFinish;
    while ((toFinish = sPendingWorkFinishers.poll()) != null) &#123;
        toFinish.run();
    &#125;
&#125;
</code></pre>
<p>在执行任务writeToDiskRunnable时，会先等待postrunable执行完成，也就是awaitCommit执行完成，</p>
<pre><code>final Runnable awaitCommit = new Runnable() &#123;
            public void run() &#123;
                try &#123;
                    mcr.writtenToDiskLatch.await();
                &#125; catch (InterruptedException ignored) &#123;
                &#125;
            &#125;
        &#125;;
</code></pre>
<p>所以如果写入比较慢，主线程就会出现ANR问题。</p>
<p><a target="_blank" rel="noopener" href="http://www.cloudchou.com/android/post-988.html">http://www.cloudchou.com/android/post-988.html</a></p>
<p>结论：<br>1.对于一个相同的SharedPreferences name，获取到的都是同一个SharedPreferences对象，它其实是SharedPreferencesImpl对象。<br>2.在UI线程中调用getXXX可能会导致ANR。<br>3.SharedPreferences只能用来存放少量数据，如果一个SharedPreferences对应的xml文件很大的话，在初始化时会把这个文件的所有数据都加载到内存中，这样就会占用大量的内存，有时我们只是想读取某个xml文件中一个key的value，结果它把整个文件都加载进来了，显然如果必要的话这里需要进行相关优化处理。<br>4.commit的写操作是在调用线程中执行的，而apply内部是用一个单线程的线程池实现的，因此写操作是在子线程中执行的。<br>5.SharedPreferences每次写入都是整个文件重新写入，不是增量写入。<br>6.apply也会造成anr。<br>参考：<br><a target="_blank" rel="noopener" href="http://blog.csdn.net/u012619640/article/details/50940074">http://blog.csdn.net/u012619640/article/details/50940074</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="sven"
      src="/images/sven.jpeg">
  <p class="site-author-name" itemprop="name">sven</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">58</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhaoxiaowen-sven" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhaoxiaowen-sven" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhaoxiaowen-sven@gmail.com" title="E-Mail → mailto:zhaoxiaowen-sven@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sven</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
