<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Sven&#39;s blog">
<meta property="og:url" content="http://example.com/page/6/index.html">
<meta property="og:site_name" content="Sven&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="sven">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Sven's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
      <a target="_blank" rel="noopener" href="https://github.com/zhaoxiaowen-sven" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Sven's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/24/Notes/Android/Framework/Android%E7%B3%BB%E7%BB%9F%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/24/Notes/Android/Framework/Android%E7%B3%BB%E7%BB%9F%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-24 23:08:49" itemprop="dateCreated datePublished" datetime="2021-02-24T23:08:49+08:00">2021-02-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="http://参考博客/">http://gityuan.com/2016/06/04/broadcast-receiver/</a><br><a target="_blank" rel="noopener" href="http://流程图/">https://rawgit.com/prife/VirtualAppDoc/master/pngs/Broadcast.svg</a></p>
<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>广播(Broadcast)机制用于进程/线程间通信，广播分为广播发送和广播接收两个过程，其中广播接收者BroadcastReceiver便是Android四大组件之一。</p>
<p>BroadcastReceiver分为两类：</p>
<pre><code>静态广播接收者：通过AndroidManifest.xml的标签来申明的BroadcastReceiver。
动态广播接收者：通过AMS.registerReceiver()方式注册的BroadcastReceiver，动态注册更为灵活，可在不需要时通过unregisterReceiver()取消注册。
</code></pre>
<p>从广播发送方式可分为三类：</p>
<pre><code>普通广播：通过Context.sendBroadcast()发送，可并行处理
有序广播：通过Context.sendOrderedBroadcast()发送，串行处理
Sticky广播：通过Context.sendStickyBroadcast()发送
</code></pre>
<h1 id="二、广播的注册过程"><a href="#二、广播的注册过程" class="headerlink" title="二、广播的注册过程"></a>二、广播的注册过程</h1><h1 id="2-1-registerReceiver-BroadcastReceiver-receiver-IntentFilter-filter"><a href="#2-1-registerReceiver-BroadcastReceiver-receiver-IntentFilter-filter" class="headerlink" title="2.1 registerReceiver(BroadcastReceiver receiver, IntentFilter filter)"></a>2.1 registerReceiver(BroadcastReceiver receiver, IntentFilter filter)</h1><h1 id="2-2-ContextWrapper-registerReceiver-receiver-filter"><a href="#2-2-ContextWrapper-registerReceiver-receiver-filter" class="headerlink" title="2.2 ContextWrapper.registerReceiver(receiver,filter)"></a>2.2 ContextWrapper.registerReceiver(receiver,filter)</h1><h1 id="2-3-ContextImpl-registerReceiver-receiver-filter"><a href="#2-3-ContextImpl-registerReceiver-receiver-filter" class="headerlink" title="2.3 ContextImpl.registerReceiver(receiver,filter)"></a>2.3 ContextImpl.registerReceiver(receiver,filter)</h1><pre><code>public Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter,
        String broadcastPermission, Handler scheduler) &#123;
    return registerReceiverInternal(receiver, getUserId(),
            filter, broadcastPermission, scheduler, getOuterContext());
&#125;

private Intent registerReceiverInternal(BroadcastReceiver receiver, int userId,
        IntentFilter filter, String broadcastPermission,
        Handler scheduler, Context context) &#123;
    //rd 的类型是LoadApk.ReceiverDispatcher.InnerReceiver的一个对象
    IIntentReceiver rd = null;
    if (receiver != null) &#123;
        if (mPackageInfo != null &amp;&amp; context != null) &#123;
            if (scheduler == null) &#123;
                scheduler = mMainThread.getHandler();
            &#125;
            rd = mPackageInfo.getReceiverDispatcher(
                receiver, context, scheduler,
                mMainThread.getInstrumentation(), true);
        &#125; else &#123;
            if (scheduler == null) &#123;
                scheduler = mMainThread.getHandler();
            &#125;
            rd = new LoadedApk.ReceiverDispatcher(
                    receiver, context, scheduler, null, true).getIIntentReceiver();
        &#125;
    &#125;
    try &#123;
        //调用到AMS的registerReceiver方法
        return ActivityManagerNative.getDefault().registerReceiver(
                mMainThread.getApplicationThread(), mBasePackageName,
                rd, filter, broadcastPermission, userId);
    &#125; catch (RemoteException e) &#123;
        return null;
    &#125;
&#125;
</code></pre>
<h1 id="step1：-rd-的创建过程"><a href="#step1：-rd-的创建过程" class="headerlink" title="step1： rd 的创建过程"></a>step1： rd 的创建过程</h1><p>ReceiverDispatcher(广播分发者)有一个内部类InnerReceiver，该类继承于IIntentReceiver.Stub。显然，这是一个Binder服务端，广播分发者通过rd.getIIntentReceiver()可获取该Binder服务端对象InnerReceiver，用于Binder IPC通信。</p>
<pre><code>frameworks/base/core/java/android/app/LoadedApk.java

static final class ReceiverDispatcher &#123;

    final static class InnerReceiver extends IIntentReceiver.Stub &#123;
        final WeakReference&lt;LoadedApk.ReceiverDispatcher&gt; mDispatcher;
        final LoadedApk.ReceiverDispatcher mStrongRef;

        InnerReceiver(LoadedApk.ReceiverDispatcher rd, boolean strong) &#123;
            mDispatcher = new WeakReference&lt;LoadedApk.ReceiverDispatcher&gt;(rd);
            mStrongRef = strong ? rd : null;
        &#125;
       ...
    &#125;

    final IIntentReceiver.Stub mIIntentReceiver;
    final BroadcastReceiver mReceiver;
    ...

     ReceiverDispatcher(BroadcastReceiver receiver, Context context,
            Handler activityThread, Instrumentation instrumentation,
            boolean registered) &#123;
        if (activityThread == null) &#123;
            throw new NullPointerException(&quot;Handler must not be null&quot;);
        &#125;

        mIIntentReceiver = new InnerReceiver(this, !registered);
        mReceiver = receiver;
        mContext = context;
        mActivityThread = activityThread;
        mInstrumentation = instrumentation;
        mRegistered = registered;
        mLocation = new IntentReceiverLeaked(null);
        mLocation.fillInStackTrace();
    &#125;
    ...
    IIntentReceiver getIIntentReceiver() &#123;
        return mIIntentReceiver;
    &#125;
</code></pre>
<h1 id="2-4-在AMS中注册"><a href="#2-4-在AMS中注册" class="headerlink" title="2.4 在AMS中注册"></a>2.4 在AMS中注册</h1><p>其中mRegisteredReceivers记录着所有已注册的广播，以receiver IBinder为key, ReceiverList为value为HashMap。另外，这个过程涉及对象ReceiverList，BroadcastFilter，BroadcastRecord的创建。</p>
<p>在BroadcastQueue中有两个广播队列mParallelBroadcasts,mOrderedBroadcasts，数据类型都为ArrayList：</p>
<pre><code>mParallelBroadcasts:并行广播队列，可以立刻执行，而无需等待另一个广播运行完成，该队列只允许动态已注册的广播，从而避免发生同时拉起大量进程来执行广播，前台的和后台的广播分别位于独立的队列。
mOrderedBroadcasts：有序广播队列，同一时间只允许执行一个广播，该队列顶部的广播便是活动广播，其他广播必须等待该广播结束才能运行，也是独立区别前台的和后台的广播。

public Intent registerReceiver(IApplicationThread caller, String callerPackage,
            IIntentReceiver receiver, IntentFilter filter, String permission, int userId) &#123;
        synchronized (this) &#123;
            if (callerApp != null &amp;&amp; (callerApp.thread == null
                    || callerApp.thread.asBinder() != caller.asBinder())) &#123;
                return null;
            &#125;
            //ReceiverList rl保存了相同InnerReceiver注册的广播接收者BroadcastFilter
            //mRegisteredReceivers的 final HashMap&lt;IBinder, ReceiverList&gt; mRegisteredReceivers
            //通过不同的InnerReceiver来区分不同的广播
            ReceiverList rl = mRegisteredReceivers.get(receiver.asBinder());
            if (rl == null) &#123;
                rl = new ReceiverList(this, callerApp, callingPid, callingUid,
                        userId, receiver);
                if (rl.app != null) &#123;
                    rl.app.receivers.add(rl);
                &#125; else &#123;
                    try &#123;
                        receiver.asBinder().linkToDeath(rl, 0);
                    &#125; catch (RemoteException e) &#123;
                        return sticky;
                    &#125;
                    rl.linkedToDeath = true;
                &#125;
                mRegisteredReceivers.put(receiver.asBinder(), rl);
            &#125; 
            //描述正在注册的广播接收者
            BroadcastFilter bf = new BroadcastFilter(filter, rl, callerPackage,
                    permission, callingUid, userId);
            //将注册的广播接收者BroadcastFilter 加入到ReceiverList中
            rl.add(bf);
            if (!bf.debugCheck()) &#123;
                Slog.w(TAG, &quot;==&gt; For Dynamic broadcast&quot;);
            &#125;
            //将广播接收者保存到内部的类成员变量mReceiverResolver中，所以BroadcastReceiver和InnerReceiver是成对存在的
            //final IntentResolver&lt;BroadcastFilter, BroadcastFilter&gt; mReceiverResolver
            mReceiverResolver.addFilter(bf);

            if (allSticky != null) &#123;
                ArrayList receivers = new ArrayList();
                receivers.add(bf);

                final int stickyCount = allSticky.size();
                for (int i = 0; i &lt; stickyCount; i++) &#123;
                    Intent intent = allSticky.get(i);
                    BroadcastQueue queue = broadcastQueueForIntent(intent);
                    BroadcastRecord r = new BroadcastRecord(queue, intent, null,
                            null, -1, -1, null, null, AppOpsManager.OP_NONE, null, receivers,
                            null, 0, null, null, false, true, true, -1);
                    queue.enqueueParallelBroadcastLocked(r);
                    queue.scheduleBroadcastsLocked();
                &#125;
            &#125;

            return sticky;
        &#125;
    &#125;
</code></pre>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>注册广播的过程，主要功能：<br>创建ReceiverList(接收者队列)，并添加到AMS.mRegisteredReceivers(已注册广播队列)；<br>创建BroadcastFilter(广播过滤者)，并添加到AMS.mReceiverResolver(接收者的解析人)；<br>当注册的是Sticky广播，则创建BroadcastRecord，并添加到BroadcastQueue的mParallelBroadcasts(并行广播队列)，注册后调用AMS来尽快处理该广播。</p>
<p>三、广播的发送过程</p>
<h1 id="3-1-sendBroadcast-intent"><a href="#3-1-sendBroadcast-intent" class="headerlink" title="3.1 sendBroadcast(intent)"></a>3.1 sendBroadcast(intent)</h1><h1 id="3-2-ContextWrapper-sendBroadcast-intent"><a href="#3-2-ContextWrapper-sendBroadcast-intent" class="headerlink" title="3.2 ContextWrapper.sendBroadcast(intent)"></a>3.2 ContextWrapper.sendBroadcast(intent)</h1><pre><code>frameworks/base/core/java/android/content/ContextWrapper.java

public void sendBroadcast(Intent intent) &#123;
        mBase.sendBroadcast(intent);
&#125;
</code></pre>
<h1 id="3-3-ContextImpl-sendBroadcast"><a href="#3-3-ContextImpl-sendBroadcast" class="headerlink" title="3.3 ContextImpl.sendBroadcast"></a>3.3 ContextImpl.sendBroadcast</h1><pre><code>frameworks/base/core/java/android/app/ContextImpl.java

public void sendBroadcast(Intent intent) &#123;
        warnIfCallingFromSystemProcess();
        String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
        try &#123;
            intent.prepareToLeaveProcess();
            ActivityManagerNative.getDefault().broadcastIntent(
                    mMainThread.getApplicationThread(), intent, resolvedType, null,
                    Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false,
                    getUserId());
        &#125; catch (RemoteException e) &#123;
            throw new RuntimeException(&quot;Failure from system&quot;, e);
        &#125;
    &#125;
</code></pre>
<h1 id="3-4-ActivityManagerProxy-broadcastIntent"><a href="#3-4-ActivityManagerProxy-broadcastIntent" class="headerlink" title="3.4 ActivityManagerProxy.broadcastIntent"></a>3.4 ActivityManagerProxy.broadcastIntent</h1><pre><code>frameworks/base/core/java/android/app/ActivityManagerNative.java

    public int broadcastIntent(IApplicationThread caller,
        Intent intent, String resolvedType, IIntentReceiver resultTo,
        int resultCode, String resultData, Bundle map,
        String[] requiredPermissions, int appOp, Bundle options, boolean serialized,
        boolean sticky, int userId) throws RemoteException
&#123;
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IActivityManager.descriptor);
    data.writeStrongBinder(caller != null ? caller.asBinder() : null);
    intent.writeToParcel(data, 0);
    data.writeString(resolvedType);
    data.writeStrongBinder(resultTo != null ? resultTo.asBinder() : null);
    data.writeInt(resultCode);
    data.writeString(resultData);
    data.writeBundle(map);
    data.writeStringArray(requiredPermissions);
    data.writeInt(appOp);
    data.writeBundle(options);
    data.writeInt(serialized ? 1 : 0);
    data.writeInt(sticky ? 1 : 0);
    data.writeInt(userId);
    mRemote.transact(BROADCAST_INTENT_TRANSACTION, data, reply, 0);
    reply.readException();
    int res = reply.readInt();
    reply.recycle();
    data.recycle();
    return res;
&#125;
</code></pre>
<h1 id="3-5-ActivityManagerService-broadcastIntent"><a href="#3-5-ActivityManagerService-broadcastIntent" class="headerlink" title="3.5 ActivityManagerService.broadcastIntent"></a>3.5 ActivityManagerService.broadcastIntent</h1><pre><code>frameworks/base/services/java/com/android/server/am/ActivityManagerService.java

public final int broadcastIntent(IApplicationThread caller,
        Intent intent, String resolvedType, IIntentReceiver resultTo,
        int resultCode, String resultData, Bundle resultExtras,
        String[] requiredPermissions, int appOp, Bundle options,
        boolean serialized, boolean sticky, int userId) &#123;
    enforceNotIsolatedCaller(&quot;broadcastIntent&quot;);
    synchronized(this) &#123;
        intent = verifyBroadcastLocked(intent);

        final ProcessRecord callerApp = getRecordForAppLocked(caller);
        final int callingPid = Binder.getCallingPid();
        final int callingUid = Binder.getCallingUid();
        final long origId = Binder.clearCallingIdentity();
        int res = broadcastIntentLocked(callerApp,
                callerApp != null ? callerApp.info.packageName : null,
                intent, resolvedType, resultTo, resultCode, resultData, resultExtras,
                requiredPermissions, appOp, null, serialized, sticky,
                callingPid, callingUid, userId);
        Binder.restoreCallingIdentity(origId);
        return res;
    &#125;
</code></pre>
<h1 id="3-6-ActivityManagerService-broadcastIntentLocked-分解为8个步骤解析"><a href="#3-6-ActivityManagerService-broadcastIntentLocked-分解为8个步骤解析" class="headerlink" title="3.6 ActivityManagerService.broadcastIntentLocked 分解为8个步骤解析"></a>3.6 ActivityManagerService.broadcastIntentLocked 分解为8个步骤解析</h1><h1 id="step1-设置广播flag"><a href="#step1-设置广播flag" class="headerlink" title="step1: 设置广播flag"></a>step1: 设置广播flag</h1><pre><code>添加flag=FLAG_EXCLUDE_STOPPED_PACKAGES，保证已停止app不会收到该广播；
当系统还没有启动完成，则不允许启动新进程，，即只有动态注册receiver才能接受广播
当非USER_ALL广播且当前用户并没有处于Running的情况下，除非是系统升级广播或者关机广播，否则直接返回。

BroadcastReceiver还有其他flag，位于Intent.java常量:
    FLAG_RECEIVER_REGISTERED_ONLY //只允许已注册receiver接收广播
    FLAG_RECEIVER_REPLACE_PENDING //新广播会替代相同广播
    FLAG_RECEIVER_FOREGROUND //只允许前台receiver接收广播
    FLAG_RECEIVER_NO_ABORT //对于有序广播，先接收到的receiver无权抛弃广播
    FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT //Boot完成之前，只允许已注册receiver接收广播
    FLAG_RECEIVER_BOOT_UPGRADE //升级模式下，允许系统准备就绪前可以发送广播

private final int broadcastIntentLocked(ProcessRecord callerApp,
        String callerPackage, Intent intent, String resolvedType,
        IIntentReceiver resultTo, int resultCode, String resultData,
        Bundle resultExtras, String[] requiredPermissions, int appOp, Bundle options,
        boolean ordered, boolean sticky, int callingPid, int callingUid, int userId) &#123;
    intent = new Intent(intent);

    // By default broadcasts do not go to stopped apps.
    intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
    
    // If we have not finished booting, don&#39;t allow this to launch new processes.
    if (!mProcessesReady &amp;&amp; (intent.getFlags()&amp;Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) &#123;
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
    &#125;
    
     // Make sure that the user who is receiving this broadcast is running.
    // If not, we will just skip it. Make an exception for shutdown broadcasts
    // and upgrade steps.

    if (userId != UserHandle.USER_ALL &amp;&amp; !isUserRunningLocked(userId, false)) &#123;
        if ((callingUid != Process.SYSTEM_UID
                || (intent.getFlags() &amp; Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0)
                &amp;&amp; !Intent.ACTION_SHUTDOWN.equals(intent.getAction())) &#123;
            Slog.w(TAG, &quot;Skipping broadcast of &quot; + intent
                    + &quot;: user &quot; + userId + &quot; is stopped&quot;);
            return ActivityManager.BROADCAST_FAILED_USER_STOPPED;
        &#125;
    &#125;
</code></pre>
<h1 id="step2-广播权限验证"><a href="#step2-广播权限验证" class="headerlink" title="step2: 广播权限验证"></a>step2: 广播权限验证</h1><p>对于callingAppId为SYSTEM_UID，PHONE_UID，SHELL_UID，BLUETOOTH_UID，NFC_UID之一或者callingUid == 0时都畅通无阻；<br>否则对于调用者进程为空并且不是persistent进程的情况下：<br>    1.当发送的是受保护广播mProtectedBroadcasts(只允许系统使用)，则抛出异常；<br>    2.当action为ACTION_APPWIDGET_CONFIGURE时，虽然不希望该应用发送这种广播，处于兼容性考虑，限制该广播只允许发送给自己，否则抛出异常。</p>
<pre><code>/*
     * Prevent non-system code (defined here to be non-persistent
     * processes) from sending protected broadcasts.
     */
    int callingAppId = UserHandle.getAppId(callingUid);
    if (callingAppId == Process.SYSTEM_UID || callingAppId == Process.PHONE_UID
        || callingAppId == Process.SHELL_UID || callingAppId == Process.BLUETOOTH_UID
        || callingAppId == Process.NFC_UID || callingUid == 0) &#123;
        // Always okay.
    &#125; else if (callerApp == null || !callerApp.persistent) &#123;
        try &#123;
            if (AppGlobals.getPackageManager().isProtectedBroadcast(
                    intent.getAction())) &#123;
                String msg = &quot;Permission Denial: not allowed to send broadcast &quot;
                        + intent.getAction() + &quot; from pid=&quot;
                        + callingPid + &quot;, uid=&quot; + callingUid;
                Slog.w(TAG, msg);
                throw new SecurityException(msg);
            &#125; else if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(intent.getAction())) &#123;
                // Special case for compatibility: we don&#39;t want apps to send this,
                // but historically it has not been protected and apps may be using it
                // to poke their own app widget.  So, instead of making it protected,
                // just limit it to the caller.
                if (callerApp == null) &#123;
                    String msg = &quot;Permission Denial: not allowed to send broadcast &quot;
                            + intent.getAction() + &quot; from unknown caller.&quot;;
                    Slog.w(TAG, msg);
                    throw new SecurityException(msg);
                &#125; else if (intent.getComponent() != null) &#123;
                    // They are good enough to send to an explicit component...  verify
                    // it is being sent to the calling app.
                    if (!intent.getComponent().getPackageName().equals(
                            callerApp.info.packageName)) &#123;
                        String msg = &quot;Permission Denial: not allowed to send broadcast &quot;
                                + intent.getAction() + &quot; to &quot;
                                + intent.getComponent().getPackageName() + &quot; from &quot;
                                + callerApp.info.packageName;
                        Slog.w(TAG, msg);
                        throw new SecurityException(msg);
                    &#125;
                &#125; else &#123;
                    // Limit broadcast to their own package.
                    intent.setPackage(callerApp.info.packageName);
                &#125;
            &#125;
        &#125; catch (RemoteException e) &#123;
            Slog.w(TAG, &quot;Remote exception&quot;, e);
            return ActivityManager.BROADCAST_SUCCESS;
        &#125;
    &#125;
</code></pre>
<h1 id="step3-处理系统相关广播"><a href="#step3-处理系统相关广播" class="headerlink" title="step3: 处理系统相关广播"></a>step3: 处理系统相关广播</h1><pre><code>这个过程代码较长，主要处于系统相关的广播，如下10个case：
case Intent.ACTION_UID_REMOVED: //uid移除
case Intent.ACTION_PACKAGE_REMOVED: //package移除，
case Intent.ACTION_PACKAGE_CHANGED: //package改变
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE: //外部设备不可用时，强制停止所有波及的应用并清空cache数据
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE: //外部设备可用
case Intent.ACTION_PACKAGE_ADDED: //增加package，处于兼容考虑

case Intent.ACTION_TIMEZONE_CHANGED: //时区改变，通知所有运行中的进程
case Intent.ACTION_TIME_CHANGED: //时间改变，通知所有运行中的进程
case Intent.ACTION_CLEAR_DNS_CACHE: //dns缓存清空
case Proxy.PROXY_CHANGE_ACTION: //网络代理改变

final String action = intent.getAction();
if (action != null) &#123;
    switch (action) &#123;
        case Intent.ACTION_UID_REMOVED:
            mBatteryStatsService.removeUid(uid);
            mAppOpsService.uidRemoved(uid);
            break;
        case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
            String list[] = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
            if (list != null &amp;&amp; list.length &gt; 0) &#123;
                for (int i = 0; i &lt; list.length; i++) &#123;
                    forceStopPackageLocked(list[i], -1, false, true, true,
                            false, false, userId, &quot;storage unmount&quot;);
                &#125;
                mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
                sendPackageBroadcastLocked(
                    IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE, list,userId);
            &#125;
            break;
        case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE
            mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
            break;
        case Intent.ACTION_PACKAGE_REMOVED:
        case Intent.ACTION_PACKAGE_CHANGED:
            Uri data = intent.getData();
            boolean removed = Intent.ACTION_PACKAGE_REMOVED.equals(action);
            boolean fullUninstall = removed &amp;&amp; !intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
            final boolean killProcess = !intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP, false);
            if (killProcess) &#123;
                forceStopPackageLocked(ssp, UserHandle.getAppId(
                        intent.getIntExtra(Intent.EXTRA_UID, -1)),
                        false, true, true, false, fullUninstall, userId,
                        removed ? &quot;pkg removed&quot; : &quot;pkg changed&quot;);
            &#125;
            if (removed) &#123;
                sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REMOVED,new String[] &#123;ssp&#125;, userId);
                if (fullUninstall) &#123;
                    mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID, -1), ssp);
                    removeUriPermissionsForPackageLocked(ssp, userId, true);
                    removeTasksByPackageNameLocked(ssp, userId);
                    mBatteryStatsService.notePackageUninstalled(ssp);
                &#125;
            &#125; else &#123;
                cleanupDisabledPackageComponentsLocked(ssp, userId, killProcess,
                        intent.getStringArrayExtra(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST));
            &#125;
            break;

        case Intent.ACTION_PACKAGE_ADDED:
            Uri data = intent.getData();
            final boolean replacing =intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
            mCompatModePackages.handlePackageAddedLocked(ssp, replacing);
            ApplicationInfo ai = AppGlobals.getPackageManager().getApplicationInfo(ssp, 0, 0);
            break;
        case Intent.ACTION_TIMEZONE_CHANGED:
            mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
            break;
        case Intent.ACTION_TIME_CHANGED:
            final int is24Hour = intent.getBooleanExtra(Intent.EXTRA_TIME_PREF_24_HOUR_FORMAT, false) ? 1: 0;
            mHandler.sendMessage(mHandler.obtainMessage(UPDATE_TIME, is24Hour, 0));
            BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();
            synchronized (stats) &#123;
                stats.noteCurrentTimeChangedLocked();
            &#125;
            break;
        case Intent.ACTION_CLEAR_DNS_CACHE:
            mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
            break;
        case Proxy.PROXY_CHANGE_ACTION:
            ProxyInfo proxy = intent.getParcelableExtra(Proxy.EXTRA_PROXY_INFO);
            mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG, proxy));
            break;
    &#125;
&#125;
</code></pre>
<h1 id="step4：增加sticky广播"><a href="#step4：增加sticky广播" class="headerlink" title="step4：增加sticky广播"></a>step4：增加sticky广播</h1><pre><code>这个过程主要是将sticky广播增加到list，并放入mStickyBroadcasts里面。

if (sticky) &#123;
    if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,
            callingPid, callingUid)
            != PackageManager.PERMISSION_GRANTED) &#123;
        throw new SecurityException(&quot;&quot;);
    &#125;
    if (requiredPermissions != null &amp;&amp; requiredPermissions.length &gt; 0) &#123;
        return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
    &#125;

    if (intent.getComponent() != null) &#123;
       //当sticky广播发送给指定组件，则throw Exception
    &#125;
    if (userId != UserHandle.USER_ALL) &#123;
       //当非USER_ALL广播跟USER_ALL广播出现冲突,则throw Exception
    &#125;

    ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt; stickies = mStickyBroadcasts.get(userId);
    if (stickies == null) &#123;
        stickies = new ArrayMap&lt;&gt;();
        mStickyBroadcasts.put(userId, stickies);
    &#125;
    ArrayList&lt;Intent&gt; list = stickies.get(intent.getAction());
    if (list == null) &#123;
        list = new ArrayList&lt;&gt;();
        stickies.put(intent.getAction(), list);
    &#125;
    final int stickiesCount = list.size();
    int i;
    for (i = 0; i &lt; stickiesCount; i++) &#123;
        if (intent.filterEquals(list.get(i))) &#123;
            //替换已存在的sticky intent
            list.set(i, new Intent(intent));
            break;
        &#125;
    &#125;
    //新的intent追加到list
    if (i &gt;= stickiesCount) &#123;
        list.add(new Intent(intent));
    &#125;
&#125;
</code></pre>
<h1 id="step5：查询receivers和registeredReceivers"><a href="#step5：查询receivers和registeredReceivers" class="headerlink" title="step5：查询receivers和registeredReceivers"></a>step5：查询receivers和registeredReceivers</h1><p>receivers：记录着匹配当前intent的所有静态注册广播接收者；<br>registeredReceivers：记录着匹配当前的所有动态注册的广播接收者。<br>其中，mReceiverResolver是AMS的成员变量，记录着已注册的广播接收者的resolver.</p>
<pre><code>int[] users;
if (userId == UserHandle.USER_ALL) &#123;
    users = mStartedUserArray; //广播给所有已启动用户
&#125; else &#123;
    users = new int[] &#123;userId&#125;; //广播给指定用户
&#125;

List receivers = null;
List&lt;BroadcastFilter&gt; registeredReceivers = null;
//找出所有能接收该广播的receivers
if ((intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) &#123;
    //根据intent查找相应的receivers,查询静态注册的广播
    receivers = collectReceiverComponents(intent, resolvedType, callingUid, users);
&#125;
if (intent.getComponent() == null) &#123;
    if (userId == UserHandle.USER_ALL &amp;&amp; callingUid == Process.SHELL_UID) &#123;
        UserManagerService ums = getUserManagerLocked();
        for (int i = 0; i &lt; users.length; i++) &#123;
            //shell用户是否开启允许debug功能
            if (ums.hasUserRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES, users[i])) &#123;
                continue;
            &#125;
            // 查询动态注册的广播
            List&lt;BroadcastFilter&gt; registeredReceiversForUser =
                    mReceiverResolver.queryIntent(intent,
                            resolvedType, false, users[i]);
            if (registeredReceivers == null) &#123;
                registeredReceivers = registeredReceiversForUser;
            &#125; else if (registeredReceiversForUser != null) &#123;
                registeredReceivers.addAll(registeredReceiversForUser);
            &#125;
        &#125;
    &#125; else &#123;
        // 查询动态注册的广播
        registeredReceivers = mReceiverResolver.queryIntent(intent,
                resolvedType, false, userId);
    &#125;
&#125;

AMS.collectReceiverComponents：

private List&lt;ResolveInfo&gt; collectReceiverComponents(Intent intent, String resolvedType,
    int callingUid, int[] users) &#123;
List&lt;ResolveInfo&gt; receivers = null;
for (int user : users) &#123;
    //调用PKMS.queryIntentReceivers，可获取AndroidManifest.xml声明的接收者信息
    List&lt;ResolveInfo&gt; newReceivers = AppGlobals.getPackageManager()
            .queryIntentReceivers(intent, resolvedType, STOCK_PM_FLAGS, user);
    if (receivers == null) &#123;
        receivers = newReceivers;
    &#125; else if (newReceivers != null) &#123;
        ...
        //将所用户的receiver整合到receivers
    &#125;
 &#125;
return receivers;
&#125;
</code></pre>
<h1 id="step6：处理并行广播"><a href="#step6：处理并行广播" class="headerlink" title="step6：处理并行广播"></a>step6：处理并行广播</h1><p>广播队列中有一个成员变量mParallelBroadcasts，类型为ArrayList，记录着所有的并行广播。</p>
<pre><code>//用于标识是否需要用新intent替换旧的intent。
final boolean replacePending = (intent.getFlags()&amp;Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
//处理并行广播
int NR = registeredReceivers != null ? registeredReceivers.size() : 0;
if (!ordered &amp;&amp; NR &gt; 0) &#123;
    final BroadcastQueue queue = broadcastQueueForIntent(intent);
    //创建BroadcastRecord对象
    BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp,
            callerPackage, callingPid, callingUid, resolvedType, requiredPermissions,
            appOp, brOptions, registeredReceivers, resultTo, resultCode, resultData,
            resultExtras, ordered, sticky, false, userId);

    final boolean replaced = replacePending &amp;&amp; queue.replaceParallelBroadcastLocked(r);
    if (!replaced) &#123;
        //将BroadcastRecord加入到并行广播队列
        queue.enqueueParallelBroadcastLocked(r);
        //处理广播【见小节4.1】
        queue.scheduleBroadcastsLocked();
    &#125;
    registeredReceivers = null;
    NR = 0;
&#125;
</code></pre>
<h1 id="step7：合并registeredReceivers到receivers"><a href="#step7：合并registeredReceivers到receivers" class="headerlink" title="step7：合并registeredReceivers到receivers"></a>step7：合并registeredReceivers到receivers</h1><pre><code>int ir = 0;
if (receivers != null) &#123;
    //防止应用监听该广播，在安装时直接运行。
    String skipPackages[] = null;
    if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction())
            || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction())
            || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) &#123;
        Uri data = intent.getData();
        if (data != null) &#123;
            String pkgName = data.getSchemeSpecificPart();
            if (pkgName != null) &#123;
                skipPackages = new String[] &#123; pkgName &#125;;
            &#125;
        &#125;
    &#125; else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) &#123;
        skipPackages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
    &#125;

    //将skipPackages相关的广播接收者从receivers列表中移除
    if (skipPackages != null &amp;&amp; (skipPackages.length &gt; 0)) &#123;
        for (String skipPackage : skipPackages) &#123;
            if (skipPackage != null) &#123;
                int NT = receivers.size();
                for (int it=0; it&lt;NT; it++) &#123; ResolveInfo curt = (ResolveInfo)receivers.get(it); if (curt.activityInfo.packageName.equals(skipPackage)) &#123; receivers.remove(it); it--; NT--; &#125; &#125; &#125; &#125; &#125; //前面part6有一个处理动态广播的过程，处理完后再执行将动态注册的registeredReceivers合并到receivers int NT = receivers != null ? receivers.size() : 0; int it = 0; ResolveInfo curt = null; BroadcastFilter curr = null; while (it &lt; NT &amp;&amp; ir &lt; NR) &#123; if (curt == null) &#123; curt = (ResolveInfo)receivers.get(it); &#125; if (curr == null) &#123; curr = registeredReceivers.get(ir); &#125; if (curr.getPriority()&gt;= curt.priority) &#123;
            receivers.add(it, curr);
            ir++;
            curr = null;
            it++;
            NT++;
        &#125; else &#123;
            it++;
            curt = null;
        &#125;
    &#125;
&#125;
while (ir &lt; NR) &#123;
    if (receivers == null) &#123;
        receivers = new ArrayList();
    &#125;
    receivers.add(registeredReceivers.get(ir));
    ir++;
&#125;
</code></pre>
<h1 id="step8-处理串行广播"><a href="#step8-处理串行广播" class="headerlink" title="step8: 处理串行广播"></a>step8: 处理串行广播</h1><p>广播队列中有一个成员变量mOrderedBroadcasts，类型为ArrayList，记录着所有的有序广播。</p>
<pre><code>    if ((receivers != null &amp;&amp; receivers.size() &gt; 0)
        || resultTo != null) &#123;
    BroadcastQueue queue = broadcastQueueForIntent(intent);
    //创建BroadcastRecord
    BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp,
            callerPackage, callingPid, callingUid, resolvedType,
            requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode,
            resultData, resultExtras, ordered, sticky, false, userId);

    boolean replaced = replacePending &amp;&amp; queue.replaceOrderedBroadcastLocked(r);
    if (!replaced) &#123;
        //将BroadcastRecord加入到有序广播队列
        queue.enqueueOrderedBroadcastLocked(r);
        //处理广播【见小节4.1】
        queue.scheduleBroadcastsLocked();
    &#125;
&#125;
</code></pre>
<h1 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h1><pre><code>注册广播的小节[2.4]阶段, 会处理Sticky广播;
发送广播的[step 6]阶段, 会处理并行广播;
发送广播的[step 8]阶段, 会处理串行广播;
</code></pre>
<p>上述3个处理过程都是通过调用scheduleBroadcastsLocked()方法来完成的,接下来再来看看这个方法.</p>
<h1 id="四、-处理广播"><a href="#四、-处理广播" class="headerlink" title="四、 处理广播"></a>四、 处理广播</h1><p>在发送广播过程中会执行scheduleBroadcastsLocked方法来处理相关的广播</p>
<pre><code>base/services/core/java/com/android/server/am/BroadcastQueue
</code></pre>
<h1 id="4-1-scheduleBroadcastsLocked"><a href="#4-1-scheduleBroadcastsLocked" class="headerlink" title="4.1 scheduleBroadcastsLocked"></a>4.1 scheduleBroadcastsLocked</h1><pre><code>public void scheduleBroadcastsLocked() &#123;
        if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;Schedule broadcasts [&quot;
                + mQueueName + &quot;]: current=&quot;
                + mBroadcastsScheduled);

        if (mBroadcastsScheduled) &#123;
            return;
        &#125;
        mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this));
        mBroadcastsScheduled = true;
    &#125;
</code></pre>
<h1 id="4-2-handleMessage"><a href="#4-2-handleMessage" class="headerlink" title="4.2 handleMessage"></a>4.2 handleMessage</h1><p>调用到processNextBroadcast</p>
<pre><code>private final class BroadcastHandler extends Handler &#123;
    public BroadcastHandler(Looper looper) &#123;
        super(looper, null, true);
    &#125;

    @Override
    public void handleMessage(Message msg) &#123;
        switch (msg.what) &#123;
            case BROADCAST_INTENT_MSG: &#123;
                if (DEBUG_BROADCAST) Slog.v(
                        TAG_BROADCAST, &quot;Received BROADCAST_INTENT_MSG&quot;);
                processNextBroadcast(true);
            &#125; break;
            ...
            &#125;
</code></pre>
<h1 id="4-3-processNextBroadcast"><a href="#4-3-processNextBroadcast" class="headerlink" title="4.3 processNextBroadcast"></a>4.3 processNextBroadcast</h1><p>此处mService为AMS，整个流程还是比较长的，全程持有AMS锁，所以广播效率低的情况下，直接会严重影响这个手机的性能与流畅度，这里应该考虑细化同步锁的粒度。</p>
<pre><code>final void processNextBroadcast(boolean fromMsg) &#123;
synchronized(mService) &#123;
    //step1: 处理并行广播
    //step2: 处理当前有序广播
    //step3: 获取下条有序广播
    //step4: 处理下条有序广播
    &#125;
&#125;
</code></pre>
<h1 id="step1-处理并行广播"><a href="#step1-处理并行广播" class="headerlink" title="step1: 处理并行广播"></a>step1: 处理并行广播</h1><pre><code>BroadcastRecord r;
mService.updateCpuStats(); //更新CPU统计信息
if (fromMsg)  mBroadcastsScheduled = false;

while (mParallelBroadcasts.size() &gt; 0) &#123;
    r = mParallelBroadcasts.remove(0);
    r.dispatchTime = SystemClock.uptimeMillis();
    r.dispatchClockTime = System.currentTimeMillis();
    final int N = r.receivers.size();
    for (int i=0; i&lt;N; i++) &#123; Object target = r.receivers.get(i); //分发广播给已注册的receiver 【见小节4.3】 deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, false); &#125; addBroadcastToHistoryLocked(r);//将广播添加历史统计 &#125; # step2: 处理当前有序广播 if (mPendingBroadcast != null) &#123; boolean isDead; synchronized (mService.mPidsSelfLocked) &#123; //从mPidsSelfLocked获取正在处理该广播进程，判断该进程是否死亡 ProcessRecord proc = mService.mPidsSelfLocked.get(mPendingBroadcast.curApp.pid); isDead = proc == null || proc.crashing; &#125; if (!isDead) &#123; //正在处理广播的进程保持活跃状态，则继续等待其执行完成 return; &#125; else &#123; mPendingBroadcast.state = BroadcastRecord.IDLE; mPendingBroadcast.nextReceiver = mPendingBroadcastRecvIndex; mPendingBroadcast = null; &#125; &#125; boolean looped = false; do &#123; if (mOrderedBroadcasts.size() == 0) &#123; //所有串行广播处理完成，则调度执行gc mService.scheduleAppGcsLocked(); if (looped) &#123; mService.updateOomAdjLocked(); &#125; return; &#125; r = mOrderedBroadcasts.get(0); boolean forceReceive = false; //获取所有该广播所有的接收者 int numReceivers = (r.receivers != null) ? r.receivers.size() : 0; if (mService.mProcessesReady &amp;&amp; r.dispatchTime&gt; 0) &#123;
        long now = SystemClock.uptimeMillis();
        if ((numReceivers &gt; 0) &amp;&amp;
                (now &gt; r.dispatchTime + (2*mTimeoutPeriod*numReceivers))) &#123;
            //当广播处理时间超时，则强制结束这条广播
            broadcastTimeoutLocked(false);
            forceReceive = true;
            r.state = BroadcastRecord.IDLE;
        &#125;
    &#125;

    if (r.state != BroadcastRecord.IDLE) &#123;
        return;
    &#125;

    if (r.receivers == null || r.nextReceiver &gt;= numReceivers
            || r.resultAbort || forceReceive) &#123;
        if (r.resultTo != null) &#123;
            //处理广播消息消息，调用到onReceive()
            performReceiveLocked(r.callerApp, r.resultTo,
                new Intent(r.intent), r.resultCode,
                r.resultData, r.resultExtras, false, false, r.userId);
            r.resultTo = null;
        &#125;
        //取消BROADCAST_TIMEOUT_MSG消息
        cancelBroadcastTimeoutLocked();

        addBroadcastToHistoryLocked(r);
        mOrderedBroadcasts.remove(0);
        r = null;
        looped = true;
        continue;
    &#125;
&#125; while (r == null);
</code></pre>
<h1 id="step3-获取下条有序广播"><a href="#step3-获取下条有序广播" class="headerlink" title="step3: 获取下条有序广播"></a>step3: 获取下条有序广播</h1><p>mTimeoutPeriod，对于前台广播则为10s，对于后台广播则为60s。广播超时为2<em>mTimeoutPeriod</em>numReceivers，接收者个数numReceivers越多则广播超时总时长越大。</p>
<pre><code>//获取下一个receiver的index
int recIdx = r.nextReceiver++;

r.receiverTime = SystemClock.uptimeMillis();
if (recIdx == 0) &#123;
    r.dispatchTime = r.receiverTime;
    r.dispatchClockTime = System.currentTimeMillis();
&#125;
if (!mPendingBroadcastTimeoutMessage) &#123;
    long timeoutTime = r.receiverTime + mTimeoutPeriod;
    //设置广播超时时间，发送BROADCAST_TIMEOUT_MSG
    setBroadcastTimeoutLocked(timeoutTime);
&#125;

final BroadcastOptions brOptions = r.options;
//获取下一个广播接收者
final Object nextReceiver = r.receivers.get(recIdx);

if (nextReceiver instanceof BroadcastFilter) &#123;
    //对于动态注册的广播接收者，deliverToRegisteredReceiverLocked处理广播
    BroadcastFilter filter = (BroadcastFilter)nextReceiver;
    deliverToRegisteredReceiverLocked(r, filter, r.ordered);
    if (r.receiver == null || !r.ordered) &#123;
        r.state = BroadcastRecord.IDLE;
        scheduleBroadcastsLocked();
    &#125; else &#123;
        ...
    &#125;
    return;
&#125;

//对于静态注册的广播接收者
ResolveInfo info = (ResolveInfo)nextReceiver;
ComponentName component = new ComponentName(
        info.activityInfo.applicationInfo.packageName,
        info.activityInfo.name);
...
//执行各种权限检测，此处省略，当权限不满足时skip=true

if (skip) &#123;
    r.receiver = null;
    r.curFilter = null;
    r.state = BroadcastRecord.IDLE;
    scheduleBroadcastsLocked();
    return;
&#125;

r.state = BroadcastRecord.APP_RECEIVE;
String targetProcess = info.activityInfo.processName;
r.curComponent = component;
final int receiverUid = info.activityInfo.applicationInfo.uid;
if (r.callingUid != Process.SYSTEM_UID &amp;&amp; isSingleton
        &amp;&amp; mService.isValidSingletonCall(r.callingUid, receiverUid)) &#123;
    info.activityInfo = mService.getActivityInfoForUser(info.activityInfo, 0);
&#125;
r.curReceiver = info.activityInfo;
...

//Broadcast正在执行中，stopped状态设置成false
AppGlobals.getPackageManager().setPackageStoppedState(
        r.curComponent.getPackageName(), false, UserHandle.getUserId(r.callingUid));
</code></pre>
<h1 id="step4-处理下条有序广播"><a href="#step4-处理下条有序广播" class="headerlink" title="step4: 处理下条有序广播"></a>step4: 处理下条有序广播</h1><p>如果是动态广播接收者，则调用deliverToRegisteredReceiverLocked处理；<br>如果是静态广播接收者，且对应进程已经创建，则调用processCurBroadcastLocked处理；<br>如果是静态广播接收者，且对应进程尚未创建，则调用startProcessLocked创建进程。</p>
<pre><code>//该receiver所对应的进程已经运行，则直接处理
    ProcessRecord app = mService.getProcessRecordLocked(targetProcess,
            info.activityInfo.applicationInfo.uid, false);
    if (app != null &amp;&amp; app.thread != null) &#123;
        try &#123;
            app.addPackage(info.activityInfo.packageName,
                    info.activityInfo.applicationInfo.versionCode, mService.mProcessStats);
            processCurBroadcastLocked(r, app);
            return;
        &#125; catch (RemoteException e) &#123;
        &#125; catch (RuntimeException e) &#123;
            finishReceiverLocked(r, r.resultCode, r.resultData, r.resultExtras, r.resultAbort, false);
            scheduleBroadcastsLocked();
            r.state = BroadcastRecord.IDLE; //启动receiver失败则重置状态
            return;
        &#125;
    &#125;
    
    //该receiver所对应的进程尚未启动，则创建该进程
    if ((r.curApp=mService.startProcessLocked(targetProcess,
            info.activityInfo.applicationInfo, true,
            r.intent.getFlags() | Intent.FLAG_FROM_BACKGROUND,
            &quot;broadcast&quot;, r.curComponent,
            (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_BOOT_UPGRADE) != 0, false, false))
                    == null) &#123;
        //创建失败，则结束该receiver
        finishReceiverLocked(r, r.resultCode, r.resultData,
                r.resultExtras, r.resultAbort, false);
        scheduleBroadcastsLocked();
        r.state = BroadcastRecord.IDLE;
        return;
    &#125;
    mPendingBroadcast = r;
    mPendingBroadcastRecvIndex = recIdx;
</code></pre>
<h1 id="4-3-deliverToRegisteredReceiverLocked"><a href="#4-3-deliverToRegisteredReceiverLocked" class="headerlink" title="4.3 deliverToRegisteredReceiverLocked"></a>4.3 deliverToRegisteredReceiverLocked</h1><pre><code>private void deliverToRegisteredReceiverLocked(BroadcastRecord r,
        BroadcastFilter filter, boolean ordered) &#123;
        ...
        //检查发送者是否有BroadcastFilter所需权限
        //以及接收者是否有发送者所需的权限等等
        //当权限不满足要求，则skip=true。
    
        if (!skip) &#123;
            //并行广播ordered = false，只有串行广播才进入该分支
            if (ordered) &#123;
                r.receiver = filter.receiverList.receiver.asBinder();
                r.curFilter = filter;
                filter.receiverList.curBroadcast = r;
                r.state = BroadcastRecord.CALL_IN_RECEIVE;
                if (filter.receiverList.app != null) &#123;
                    r.curApp = filter.receiverList.app;
                    filter.receiverList.app.curReceiver = r;
                    mService.updateOomAdjLocked(r.curApp);
                &#125;
            &#125;
            // 处理广播【见小节4.4】
            performReceiveLocked(filter.receiverList.app, filter.receiverList.receiver,
                    new Intent(r.intent), r.resultCode, r.resultData,
                    r.resultExtras, r.ordered, r.initialSticky, r.userId);
            if (ordered) &#123;
                r.state = BroadcastRecord.CALL_DONE_RECEIVE;
            &#125;
            ...
        &#125;
    &#125;
</code></pre>
<h1 id="4-4-performReceiveLocked"><a href="#4-4-performReceiveLocked" class="headerlink" title="4.4 performReceiveLocked"></a>4.4 performReceiveLocked</h1><pre><code>private static void performReceiveLocked(ProcessRecord app, IIntentReceiver receiver,
    Intent intent, int resultCode, String data, Bundle extras,
    boolean ordered, boolean sticky, int sendingUser) throws RemoteException &#123;
//通过binder异步机制，向receiver发送intent
if (app != null) &#123;
    if (app.thread != null) &#123;
        //调用ApplicationThreadProxy类对应的方法 【4.5】
        app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode,
                data, extras, ordered, sticky, sendingUser, app.repProcState);
    &#125; else &#123;
        //应用进程死亡，则Recevier并不存在
        throw new RemoteException(&quot;app.thread must not be null&quot;);
    &#125;
&#125; else &#123;
    //调用者进程为空，则执行该分支
    receiver.performReceive(intent, resultCode, data, extras, ordered,
            sticky, sendingUser);
&#125;
</code></pre>
<p>}</p>
<h1 id="4-5-ATP-scheduleRegisteredReceiver"><a href="#4-5-ATP-scheduleRegisteredReceiver" class="headerlink" title="4.5 ATP.scheduleRegisteredReceiver"></a>4.5 ATP.scheduleRegisteredReceiver</h1><p>ATP位于system_server进程，是Binder Bp端通过Binder驱动向Binder Bn端发送消息, ATP所对应的Bn端位于发送广播调用端所在进程的ApplicationThread，即进入AT.scheduleRegisteredReceiver， 接下来说明该方</p>
<pre><code>public void scheduleRegisteredReceiver(IIntentReceiver receiver, Intent intent,
        int resultCode, String dataStr, Bundle extras, boolean ordered,
        boolean sticky, int sendingUser, int processState) throws RemoteException &#123;
    Parcel data = Parcel.obtain();
    data.writeInterfaceToken(IApplicationThread.descriptor);
    data.writeStrongBinder(receiver.asBinder());
    intent.writeToParcel(data, 0);
    data.writeInt(resultCode);
    data.writeString(dataStr);
    data.writeBundle(extras);
    data.writeInt(ordered ? 1 : 0);
    data.writeInt(sticky ? 1 : 0);
    data.writeInt(sendingUser);
    data.writeInt(processState);

    //command=SCHEDULE_REGISTERED_RECEIVER_TRANSACTION
    mRemote.transact(SCHEDULE_REGISTERED_RECEIVER_TRANSACTION, data, null,
            IBinder.FLAG_ONEWAY);
    data.recycle();
&#125;
</code></pre>
<h1 id="4-6-scheduleRegisteredReceiver"><a href="#4-6-scheduleRegisteredReceiver" class="headerlink" title="4.6 scheduleRegisteredReceiver"></a>4.6 scheduleRegisteredReceiver</h1><p>IPC过程 最终调用到ActivityThread.scheduleRegisteredReceiver,此处receiver是注册广播时创建的，见小节[2.3]，可知该receiver=LoadedApk.ReceiverDispatcher.InnerReceiver。</p>
<pre><code>public void scheduleRegisteredReceiver(IIntentReceiver receiver, Intent intent,
        int resultCode, String dataStr, Bundle extras, boolean ordered,
        boolean sticky, int sendingUser, int processState) throws RemoteException &#123;
    //更新虚拟机进程状态
    updateProcessState(processState, false);
    //【见小节4.7】
    receiver.performReceive(intent, resultCode, dataStr, extras, ordered,
            sticky, sendingUser);
&#125;
</code></pre>
<h1 id="4-7-InnerReceiver-performReceive"><a href="#4-7-InnerReceiver-performReceive" class="headerlink" title="4.7 InnerReceiver.performReceive"></a>4.7 InnerReceiver.performReceive</h1><pre><code>base/core/java/android/app/LoadedApk.java
public void performReceive(Intent intent, int resultCode, String data,
        Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123;
    LoadedApk.ReceiverDispatcher rd = mDispatcher.get();
    if (rd != null) &#123;
        //【4.8】
        rd.performReceive(intent, resultCode, data, extras, ordered, sticky, sendingUser);
    &#125; else &#123;
       ...
    &#125;
&#125;
</code></pre>
<h1 id="4-8-ReceiverDispatcher-performReceive"><a href="#4-8-ReceiverDispatcher-performReceive" class="headerlink" title="4.8 ReceiverDispatcher.performReceive"></a>4.8 ReceiverDispatcher.performReceive</h1><p>其中Args继承于BroadcastReceiver.PendingResult，实现了接口Runnable。这里mActivityThread.post(args) 消息机制，关于Handler消息机制，见Android消息机制1-Handler(Java层)，把消息放入MessageQueue，再调用Args的run()方法。</p>
<pre><code>public void performReceive(Intent intent, int resultCode, String data,
        Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123;
    Args args = new Args(intent, resultCode, data, extras, ordered,
            sticky, sendingUser);
    //通过handler消息机制发送args.
    if (!mActivityThread.post(args)) &#123;
        if (mRegistered &amp;&amp; ordered) &#123;
            IActivityManager mgr = ActivityManagerNative.getDefault();
            args.sendFinished(mgr);
        &#125;
    &#125;
&#125;
</code></pre>
<h1 id="4-9-Args-run"><a href="#4-9-Args-run" class="headerlink" title="4.9 Args.run"></a>4.9 Args.run</h1><p>最终调用BroadcastReceiver具体实现类的onReceive()方法，至此广播的处理过程结束,后续是AMS的一些处理过程</p>
<pre><code>public final class LoadedApk &#123;
  static final class ReceiverDispatcher &#123;
    final class Args extends BroadcastReceiver.PendingResult implements Runnable &#123;
        public void run() &#123;
            final BroadcastReceiver receiver = mReceiver;
            final boolean ordered = mOrdered;

            final IActivityManager mgr = ActivityManagerNative.getDefault();
            final Intent intent = mCurIntent;
            mCurIntent = null;

            if (receiver == null || mForgotten) &#123;
                if (mRegistered &amp;&amp; ordered) &#123;
                    sendFinished(mgr);
                &#125;
                return;
            &#125;

            try &#123;
                //获取mReceiver的类加载器
                ClassLoader cl =  mReceiver.getClass().getClassLoader();
                intent.setExtrasClassLoader(cl);
                setExtrasClassLoader(cl);
                receiver.setPendingResult(this);
                //回调广播onReceive方法
                receiver.onReceive(mContext, intent);
            &#125; catch (Exception e) &#123;
                ...
            &#125;
            //调用到BroadcastReceiver.finishReceiver
            if (receiver.getPendingResult() != null) &#123;
                finish();
            &#125;
        &#125;
      &#125;
    &#125;
</code></pre>
<p>​        </p>
<h1 id="4-10-PendingResult-finish"><a href="#4-10-PendingResult-finish" class="headerlink" title="4.10 PendingResult.finish"></a>4.10 PendingResult.finish</h1><p>此处AMP.finishReceiver，经过binder调用，进入AMS.finishReceiver方法,</p>
<pre><code>base/core/java/android/content/BroadcastReceiver.java

public final void finish() &#123;
    final IActivityManager mgr = ActivityManagerNative.getDefault();
    sendFinished(mgr);
    ...
&#125;

public void sendFinished(IActivityManager am) &#123;
    synchronized (this) &#123;
        try &#123;
            if (mResultExtras != null) &#123;
                mResultExtras.setAllowFds(false);
            &#125;
            if (mOrderedHint) &#123;
                //串行广播
                am.finishReceiver(mToken, mResultCode, mResultData, mResultExtras,
                        mAbortBroadcast, mFlags);
            &#125; else &#123;
                //并行广播
                am.finishReceiver(mToken, 0, null, null, false, mFlags);
            &#125;
        &#125; catch (RemoteException ex) &#123;
        &#125;
    &#125;
&#125;
</code></pre>
<h1 id="4-11-AMS-finishReceiver"><a href="#4-11-AMS-finishReceiver" class="headerlink" title="4.11 AMS.finishReceiver"></a>4.11 AMS.finishReceiver</h1><pre><code>public void finishReceiver(IBinder who, int resultCode, String resultData,
        Bundle resultExtras, boolean resultAbort, int flags) &#123;
    ...
    final long origId = Binder.clearCallingIdentity();
    try &#123;
        boolean doNext = false;
        BroadcastRecord r;

        synchronized(this) &#123;
            BroadcastQueue queue = (flags &amp; Intent.FLAG_RECEIVER_FOREGROUND) != 0
                    ? mFgBroadcastQueue : mBgBroadcastQueue;
            r = queue.getMatchingOrderedReceiver(who);
            if (r != null) &#123;
                doNext = r.queue.finishReceiverLocked(r, resultCode,
                    resultData, resultExtras, resultAbort, true);
            &#125;
        &#125;

        if (doNext) &#123;
            //处理下一条广播
            r.queue.processNextBroadcast(false);
        &#125;
        trimApplications();
    &#125; finally &#123;
        Binder.restoreCallingIdentity(origId);
    &#125;
&#125;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/24/Notes/Android/IPC/2.%20IPC%E7%9A%84%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/24/Notes/Android/IPC/2.%20IPC%E7%9A%84%E6%96%B9%E5%BC%8F/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-24 23:08:49" itemprop="dateCreated datePublished" datetime="2021-02-24T23:08:49+08:00">2021-02-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Android中IPC的方式："><a href="#Android中IPC的方式：" class="headerlink" title="Android中IPC的方式："></a>Android中IPC的方式：</h1><pre><code>1.Bundle
2.文件共享：适合在对数据同步要求不高的进程中通信
3.Messenger 和 Message
4.AIDL
5.contentProvider 数据共享,数据库
6.Socket （未学习）
</code></pre>
<h1 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL:"></a>AIDL:</h1><h2 id="1-支持的数据类型："><a href="#1-支持的数据类型：" class="headerlink" title="1.支持的数据类型："></a>1.支持的数据类型：</h2><pre><code>1.基本数据类型（int、long、char、boolean、double等）
2.String和charSequence
3.List只支持ArrayList （CopyOnWriteArrayList支持并发）
4.Map 只支持 HashMap （ConcurrentHashMap 支持并发）
5.Parcelable 实现了Parcelable接口的对象
6.AIDL 接口本身
</code></pre>
<h2 id="2-RemoteCallbackList：监听者的注册与解注册"><a href="#2-RemoteCallbackList：监听者的注册与解注册" class="headerlink" title="2.RemoteCallbackList：监听者的注册与解注册"></a>2.RemoteCallbackList：监听者的注册与解注册</h2><pre><code>private RemoteCallbackList&lt;IOnNewBookArrivedListener&gt; mListenerList = new RemoteCallbackList&lt;IOnNewBookArrivedListener&gt;();
 
mListenerList.register(listener);

mListenerList.unregister(listener);

final int N = mListenerList.beginBroadcast();
for(int i = 0; i &lt;N ;i++)&#123; IOnNewBookArrivedListener l = mListenerList.getBroadcastItem(i); 
if (l != null)&#123; Log.i(TAG, &quot;real onNewBookArrived...&quot;); 
try &#123; l.onNewBookArrived(book); &#125;catch (RemoteException e)&#123; e.printStackTrace(); &#125; &#125; &#125; mListenerList.finishBroadcast(); 
</code></pre>
<h2 id="3-不要在UI线程中调用远程的耗时方法-例如：在onServiceConnected-和-onServiceDisconnected中调用"><a href="#3-不要在UI线程中调用远程的耗时方法-例如：在onServiceConnected-和-onServiceDisconnected中调用" class="headerlink" title="3.不要在UI线程中调用远程的耗时方法 例如：在onServiceConnected 和 onServiceDisconnected中调用"></a>3.不要在UI线程中调用远程的耗时方法 例如：在onServiceConnected 和 onServiceDisconnected中调用</h2><h2 id="4-监听Binder意外死亡的2中方式"><a href="#4-监听Binder意外死亡的2中方式" class="headerlink" title="4.监听Binder意外死亡的2中方式"></a>4.监听Binder意外死亡的2中方式</h2><pre><code>1.onServiceDisconnected 
2.给binder设置DeathRecipient private IBookManager iBookManager; 
privateServiceConnection mServiceConn = new ServiceConnection() &#123; 
    @Override public void onServiceConnected(ComponentName name, IBinderservice) &#123; 
        iBookManager = IBookManager.Stub.asInterface(service); 
        try &#123; service.linkToDeath(mDeathRecipient,0); ... 
    &#125; catch(RemoteException e) &#123; 
        e.printStackTrace(); 
        &#125; 
    &#125; 
    @Override public void onServiceDisconnected(ComponentName name) &#123;
    Log.i(TAG,&quot;onServiceDisconnected ...&quot;); 
        iBookManager = null; Intent intent = new Intent(MainActivity.this,BookManagerService.class); bindService(intent,mServiceConn, Context.BIND_AUTO_CREATE); &#125; 
    &#125;; 
    private IBinder.DeathRecipientmDeathRecipient = new IBinder.DeathRecipient()&#123; 
    @Override 
    public void binderDied() &#123;
        Log.i(TAG,&quot;binderDied ...&quot;);
        if(iBookManager == null) return; 
        iBookManager.asBinder().unlinkToDeath(mDeathRecipient, 0); 
        iBookManager = null; //rebindremote service &#125; 
    &#125;; 
&#125;
</code></pre>
<h2 id="5-连接服务时添加权限验证-1-onBind：验证不通过返回null，无法绑定服务2-onTransact：验证失败返回false，服务端不会执行AIDL中的方法-…"><a href="#5-连接服务时添加权限验证-1-onBind：验证不通过返回null，无法绑定服务2-onTransact：验证失败返回false，服务端不会执行AIDL中的方法-…" class="headerlink" title="5.连接服务时添加权限验证 1.onBind：验证不通过返回null，无法绑定服务2.onTransact：验证失败返回false，服务端不会执行AIDL中的方法 …"></a>5.连接服务时添加权限验证 1.onBind：验证不通过返回null，无法绑定服务2.onTransact：验证失败返回false，服务端不会执行AIDL中的方法 …</h2><p>1.服务端定义权限并且声明服务需要该权限<br>    <permission android:name="com.example.zxw.self.permission"/><br>    <service android:permission="com.example.zxw.self.permission" android:name=".BookManagerService" android:enabled="true" android:exported="true" android:process=":remote">    </p>
<p>2.客户端绑定时：</p>
<pre><code>&lt;uses-permission android:name=&quot;com.example.zxw.self.permission&quot;/&gt;
</code></pre>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>private Binder mBinder = new IBookManager.Stub()&#123;
    ...
    @Override
    public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;
        Log.i(TAG, &quot;onTransact ...&quot;);
            int check = checkCallingOrSelfPermission(&quot;com.example.zxw.self.permission&quot;);
            if(check == PackageManager.PERMISSION_DENIED)&#123;
                return false;
            &#125;
        return super.onTransact(code, data, reply, flags);
    &#125;
&#125;;

@Override
public IBinder onBind(Intent intent) &#123;
    Log.i(TAG,&quot;onBind ...&quot;);
    int check = checkCallingOrSelfPermission(&quot;com.example.zxw.self.permission&quot;);
    Log.i(TAG,&quot;check = &quot;+check);
    if(check == PackageManager.PERMISSION_DENIED)&#123;
        return null;
    &#125;
    return mBinder;
&#125;
</code></pre>
<h3 id="区别：都是无法调用aidl的方法"><a href="#区别：都是无法调用aidl的方法" class="headerlink" title="区别：都是无法调用aidl的方法"></a>区别：都是无法调用aidl的方法</h3><pre><code>      但是onbind 中校验不过根本没有连接
      onTransact 有连接，客户端能监听到连接的断开
</code></pre>
<h2 id="6-onDestroy中解绑"><a href="#6-onDestroy中解绑" class="headerlink" title="6.onDestroy中解绑"></a>6.onDestroy中解绑</h2><pre><code>protected void onDestroy() &#123;
    super.onDestroy();
    Log.i(TAG, &quot;onDestroy&quot;);
    if(iBookManager != null &amp;&amp; iBookManager.asBinder().isBinderAlive())&#123;
        try &#123;
            iBookManager.unregesterListener(mOnNewBookArrivedListener);
        &#125; catch (RemoteException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
    unbindService(mServiceConn);
    iBookManager = null;
&#125;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/22/Notes/Android/FourComponents/ContentProvider%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/22/Notes/Android/FourComponents/ContentProvider%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-22 23:45:13" itemprop="dateCreated datePublished" datetime="2021-02-22T23:45:13+08:00">2021-02-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ContentProvider-基础知识"><a href="#ContentProvider-基础知识" class="headerlink" title="ContentProvider 基础知识"></a>ContentProvider 基础知识</h1><p>ContentProvider 用户跨进程访问数据，通常和数据库以及ContentResolver配合使用，可以保证数据的安全性。</p>
<h2 id="一、ContentResolver"><a href="#一、ContentResolver" class="headerlink" title="一、ContentResolver"></a>一、ContentResolver</h2><p>对于每一个应用程序来说，如果想要访问内容提供器中共享的数据，就一定要借助ContentResolver类，可以通过Context中的getContentResolver()方法获取到该类的实例。 ContentResolver中提供了一系列的方法用于对数据进行CRUD操作，其中insert()方法用于添加数据，update()方法用于更新数据，delete()方法用于删除数据，query()方法用于查询数据。有没有似曾相识的感觉？没错，SQLiteDatabase中也是使用的这几个方法来进行 CRUD 操作的，只不过它们在方法参数上稍微有一些区别。不同于SQLiteDatabase，ContentResolver中的增删改查方法都是不接收表名参数的，而是使用一个 Uri参数代替，这个参数被称为内容 URI，下面会详细介绍它的格式定义。在得到了内容URI字符串之后，我们还需要将它解析成Uri对象才可以作为参数传入。 只需要调用 Uri.parse()方法，就可以将内容URI字符串解析成 Uri对象： </p>
<pre><code>Uri uri = Uri.parse(&quot;content://com.example.app.provider/table1&quot;) 
</code></pre>
<p>再调用contentResolver的CURD方法就可完成对应的操作。</p>
<pre><code>Cursor cursor = context.getContentResolver().query(uri, null, null, null, null);
</code></pre>
<h2 id="二、内容-URI"><a href="#二、内容-URI" class="headerlink" title="二、内容 URI"></a>二、内容 URI</h2><p>无论是通过ContentResolver访问数据，还是实现自定义的ContentProvider都需要内容URI才能够通信。URI给内容提供器中的数据建立了唯一标志符，基本格式如下：</p>
<pre><code>content://Authority/Path/Id
</code></pre>
<p>content:// 固定格式<br>Authority：权限，用于对不同的应用程序进行区分，一般为了避免冲突，都会采用包名.provider<br>Path: 路径，用于对同一个程序中的不同表做区分<br>Id: 数据Id，用于区分表中的不同数据<br>URI的格式主要有如下2种：</p>
<pre><code>   content://com.example.app.provider/table 
   content://com.example.app.provider/table1/1 
</code></pre>
<p>以路径结尾表示期望访问该表中所有的数据， 以 id结尾就表示期望访问该表中拥有相应 id的数据。我们可以使用通配符的方式来分别匹 配这两种格式的内容 URI，规则如下。</p>
<ol>
<li><p>*：表示匹配任意长度的任意字符 </p>
</li>
<li><p>#：表示匹配任意长度的数字<br>所以，一个能够匹配任意表的内容 URI格式就可以写成：</p>
<p> content://com.example.app.provider/* </p>
</li>
</ol>
<p>而一个能够匹配 table1表中任意一行数据的内容 URI格式就可以写成</p>
<pre><code>content://com.example.app.provider/table1/#
</code></pre>
<p>我们再借助UriMatcher这个类就可以轻松地实现匹配内容URI的功能。UriMatcher中提供了一个addURI()方法，这个方法接收三个参数，可以分别把权限、路径和一个自定义代码传进去。这样，当调用UriMatcher的match()方法时，就可以将一个 Uri对象传入，返回值是某个能够匹配这个Uri对象所对应的自定义代码，利用这个代码，我们就可以判断出调用方期望访问的是哪张表中的数据了。</p>
<h2 id="三、ContentProvider方法介绍"><a href="#三、ContentProvider方法介绍" class="headerlink" title="三、ContentProvider方法介绍"></a>三、ContentProvider方法介绍</h2><p>通过继承ContentProvider，并且实现抽象方法就可完成自定义的ContentProvider共享数据了。</p>
<h3 id="1-onCreate"><a href="#1-onCreate" class="headerlink" title="1.onCreate()"></a>1.onCreate()</h3><p>初始化内容提供器的时候调用。通常会在这里完成对数据库的创建和升级等操作，返回true表示内容提供器初始化成功，返回false 则表示失败。注意，只有当存在 ContentResolver尝试访问我们程序中的数据时，内容提供器才会被初始化。</p>
<h3 id="2-query"><a href="#2-query" class="headerlink" title="2.query()"></a>2.query()</h3><p>从内容提供器中查询数据。使用uri参数来确定查询哪张表，projection参数用于确定查询哪些列，selection和selectionArgs参数用于约束查询哪些行，sortOrder参数用于对结果进行排序，查询的结果存放在Cursor对象中返回。 </p>
<h3 id="3-insert"><a href="#3-insert" class="headerlink" title="3.insert()"></a>3.insert()</h3><p>向内容提供器中添加一条数据。使用uri参数来确定要添加到的表，待添加的数据保存在values参数中。添加完成后，返回一个用于表示这条新记录的 URI。</p>
<h3 id="4-update"><a href="#4-update" class="headerlink" title="4.update()"></a>4.update()</h3><p>更新内容提供器中已有的数据。使用uri参数来确定更新哪一张表中的数据，新数据保存在values参数中，selection和selectionArgs参数用于约束更新哪些行，受影响的 行数将作为返回值返回。</p>
<h3 id="5-delete"><a href="#5-delete" class="headerlink" title="5.delete()"></a>5.delete()</h3><p>从内容提供器中删除数据。使用uri参数来确定删除哪一张表中的数据，selection和selectionArgs参数用于约束删除哪些行，被删除的行数将作为返回值返回。</p>
<h3 id="6-getType"><a href="#6-getType" class="headerlink" title="6.getType()"></a>6.getType()</h3><p>根据传入的内容 URI来返回相应的 MIME类型。它是所有的内容提供器都必须提供的一个方法，用于获取Uri对象所对应的MIME类型。一个内容URI所对应的MIME字符串主要由三部分组分，Android对这三个部分做了如下格式规定。<br>    1. 必须以vnd开头。<br>    2. 如果内容URI以路径结尾，则后接android.cursor.dir/，如果内容URI以id结尾，则后接android.cursor.item/<br>    3. 最后接上 vnd.authority.path</p>
<p>所以，对于 content://com.example.app.provider/table1这个内容 URI，它所对应的 MIME 类型就可以写成：</p>
<pre><code>vnd.android.cursor.dir/vnd.com.example.app.provider.table1 
</code></pre>
<p>对于 content://com.example.app.provider/table1/1这个内容 URI，它所对应的 MIME类型 就可以写成：</p>
<pre><code> vnd.android.cursor.item/vnd.com.example.app.provider.table1
</code></pre>
<h2 id="四、call-方法"><a href="#四、call-方法" class="headerlink" title="四、call 方法"></a>四、call 方法</h2><p>上面的方法都是访问或修改数据库的，如果需要跨进程访问里一个应用其他数据，例如sharePreference数据，可以通过call方法来调用自定义的函数。</p>
<h3 id="1-provider中复写call-方法，并且添加自定义的方法"><a href="#1-provider中复写call-方法，并且添加自定义的方法" class="headerlink" title="1.provider中复写call 方法，并且添加自定义的方法"></a>1.provider中复写call 方法，并且添加自定义的方法</h3><pre><code>@Override
public Bundle call(@NonNull String method, @Nullable String arg, @Nullable Bundle extras) &#123;
    switch (method)&#123;
        case &quot;getData&quot;:
            return getData();
        default:
            break;
    &#125;
    return null;
&#125;

//自定义函数
public Bundle getData()&#123;
    Bundle b = new Bundle();
    b.putString(&quot;name&quot;,&quot;call getData&quot;);
    return b;
&#125;
</code></pre>
<h3 id="2-查询方传入要调用的provider的自定义方法名和参数"><a href="#2-查询方传入要调用的provider的自定义方法名和参数" class="headerlink" title="2.查询方传入要调用的provider的自定义方法名和参数"></a>2.查询方传入要调用的provider的自定义方法名和参数</h3><pre><code>// uri格式最后一定要带一个 /
Uri uriCall = Uri.parse(&quot;content://&quot; + AUTHORITY + &quot;/&quot;);
Bundle b = getContentResolver().call(uriCall, &quot;getData&quot;, null, null);
Log.i(TAG, &quot;&quot;+b.get(&quot;name&quot;));
</code></pre>
<h2 id="五、MatrixCursor"><a href="#五、MatrixCursor" class="headerlink" title="五、MatrixCursor"></a>五、MatrixCursor</h2><p>ContentProvider的Query方法返回的是一个cursor，如果要对cursor中的数据做处理后再返回给查询的一方，可以通过MatrixCursor 对现有数据封装后返回。</p>
<pre><code>Cursor cursor1 = db.query(&quot;users&quot;, null, &quot;id = ?&quot;, new String[]&#123;&quot;1&quot;&#125;,null, null, null);
MatrixCursor m = new MatrixCursor(new String[]&#123;&quot;c1&quot;, &quot;c2&quot;, &quot;c3&quot;&#125;);
while(cursor1.moveToNext()) &#123;
    String name = cursor1.getString(1);
    int age = cursor1.getInt(2);
    String address = cursor1.getString(3);
    Log.i(TAG, name + &quot;age = &quot;+age + &quot;address = &quot;+address);
    m.addRow(new Object[]&#123;name, age, address&#125;);
&#125;
return m
</code></pre>
<p>Demo：</p>
<p>参考资料：<br>第一行代码——Android 郭霖<br><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/17224766/what-is-getcontentresolver-call-and-how-to-use-it">https://stackoverflow.com/questions/17224766/what-is-getcontentresolver-call-and-how-to-use-it</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/22/Notes/Android/FourComponents/Android%20Service%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/22/Notes/Android/FourComponents/Android%20Service%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-22 23:09:43" itemprop="dateCreated datePublished" datetime="2021-02-22T23:09:43+08:00">2021-02-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Android-Service-基础知识"><a href="#Android-Service-基础知识" class="headerlink" title="Android Service 基础知识"></a>Android Service 基础知识</h1><p>Service 作为android 四大组件之一，主要用于再后台处理一些耗时的逻辑或者去执行一些长期运行的任务。</p>
<h1 id="一、startService-和-bindService"><a href="#一、startService-和-bindService" class="headerlink" title="一、startService 和 bindService"></a>一、startService 和 bindService</h1><h2 id="1-生命周期和启动方式："><a href="#1-生命周期和启动方式：" class="headerlink" title="1. 生命周期和启动方式："></a>1. 生命周期和启动方式：</h2><p><img src="https://leanote.com/api/file/getImage?fileId=595288b4ab6441560e001f51" alt="service_lifecircle"><br>1.1 启动<br>通过startService启动服务时，如果是第一次启动，会调用onCreate-&gt;onStartCommand，但是多次启动时不会再调用onCreate，只有onStartCommand会被调用多次。<br>通过bindService绑定服务时，如果服务还未启动，会调用onCreate-&gt;onBind，创建并且绑定服务，多次调用bindService并不会多次调用onBind()，除非是多个客户端来绑定服务。</p>
<p>1.2 销毁<br>如果组件通过调用 startService() 启动服务，则服务将一直运行，直到服务使用 stopSelf()自行停止运行，或由其他组件通过调用 stopService() 停止它为止。无论服务被启动了多少次，只要调用一次stopService，便可终止（不考虑被绑定过的情况）。</p>
<p>如果组件是通过调用 bindService()来创建服务（且未调用onStartCommand()），则服务只会在该组件与其绑定时运行。一旦该服务与所有客户端之间的绑定全部取消，系统便会销毁它。</p>
<h2 id="2-starService和bindService一起使用："><a href="#2-starService和bindService一起使用：" class="headerlink" title="2. starService和bindService一起使用："></a>2. starService和bindService一起使用：</h2><p>如果一个Service又被启动又被绑定，则该Service会一直在后台运行。首先不管如何调用，onCreate始终只会调用一次。startService调用多少次，Service的onStartCommand方法便会调用多少次。Service的终止，需要unbindService和stopService同时调用才行。不管startService与bindService的调用顺序，如果先调用unbindService，此时服务不会自动终止，再调用stopService之后，服务才会终止；如果先调用stopService，此时服务也不会终止，再次调用unbindService或者<strong>之前调用bindService的Context不存在了</strong>（如Activity被finish的时候）之后，服务才会停止。</p>
<h2 id="3-使用场景："><a href="#3-使用场景：" class="headerlink" title="3. 使用场景："></a>3. 使用场景：</h2><p>   startService 主要用于开启服务，例如后台下载和播放音乐<br>   bindService 主要为了使用服务中的一些功能或者与服务进行交互<br>   这2种模式不是完全分离的。你可以可以绑定到一个通过startService()启动的服务。如一个intent想要播放音乐，通过startService启动后台播放音乐的service。然后，也许用户想要操作播放器或者获取当前正在播放的乐曲的信息，一个activity就会通过bindService建立一个到此service的连接. 这种情况下 stopService() 在全部的连接关闭后才会真正停止service。</p>
<h3 id="Tips："><a href="#Tips：" class="headerlink" title="Tips："></a>Tips：</h3><ol>
<li>服务的onCreate和onDestroy在一个生命周期中只会执行一次</li>
<li>service的stopself方法的功能是，当完成所有功能之后，将service停掉</li>
<li>Service中onRebind方法被调用的时机，需要满足2个条件：<br>(1)服务中onUnBind方法返回值为true<br>(2)服务对象被解绑后没有被销毁，之后再次被绑定</li>
</ol>
<h2 id="2-onStartCommand的返回值："><a href="#2-onStartCommand的返回值：" class="headerlink" title="2. onStartCommand的返回值："></a>2. onStartCommand的返回值：</h2><p>请注意，onStartCommand() 方法必须返回整型数。整型数是一个值，用于描述系统应该如何在服务终止的情况下继续运行服务（如上所述，IntentService 的默认实现将为您处理这种情况，不过您可以对其进行修改）。从onStartCommand()返回的值必须是以下常量之一：</p>
<h2 id="1-START-NOT-STICKY"><a href="#1-START-NOT-STICKY" class="headerlink" title="1. START_NOT_STICKY"></a>1. START_NOT_STICKY</h2><p>如果系统在 onStartCommand() 返回后终止服务，则除非有挂起 Intent 要传递，否则系统不会重建服务。这是最安全的选项，可以避免在不必要时以及应用能够轻松重启所有未完成的作业时运行服务。</p>
<h2 id="2-START-STICKY"><a href="#2-START-STICKY" class="headerlink" title="2. START_STICKY"></a>2. START_STICKY</h2><p>如果系统在 onStartCommand() 返回后终止服务，则会重建服务并调用 onStartCommand()，但不会重新传递最后一个 Intent。相反，除非有挂起 Intent 要启动服务（在这种情况下，将传递这些 Intent ），否则系统会通过空 Intent 调用 onStartCommand()。这适用于不执行命令、但无限期运行并等待作业的媒体播放器（或类似服务）。</p>
<h2 id="3-START-REDELIVER-INTENT"><a href="#3-START-REDELIVER-INTENT" class="headerlink" title="3. START_REDELIVER_INTENT"></a>3. START_REDELIVER_INTENT</h2><p>如果系统在 onStartCommand() 返回后终止服务，则会重建服务，并通过传递给服务的最后一个 Intent 调用 onStartCommand()。任何挂起 Intent 均依次传递。这适用于主动执行应该立即恢复的作业（例如下载文件）的服务。</p>
<h1 id="二、前台服务"><a href="#二、前台服务" class="headerlink" title="二、前台服务"></a>二、前台服务</h1><p>Service几乎都是在后台运行的，一直以来它都是默默地做着辛苦的工作。但是Service的系统优先级还是比较低的，当系统出现内存不足情况时，就有可能会回收掉正在后台运行的Service。如果你希望Service可以一直保持运行状态，而不会由于系统内存不足的原因导致被回收，就可以考虑使用前台Service。前台Service和普通Service最大的区别就在于，它会一直有一个正在运行的图标在系统的状态栏显示，下拉状态栏后可以看到更加详细的信息，非常类似于通知的效果。当然有时候你也可能不仅仅是为了防止Service被回收才使用前台Service，有些项目由于特殊的需求会要求必须使用前台Service，比如说墨迹天气。</p>
<pre><code>    Intent intent = new Intent(this, MainActivity.class);
    //需要让Activity运行在新的任务栈中
    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    Notification.Builder builder = new Notification.Builder(this);
    Notification notification = builder.setSmallIcon(R.mipmap.ic_launcher)
            .setContentText(&quot;this is a notify&quot;)
            .setContentTitle(&quot;notify!!!&quot;).setTicker(&quot;notify&quot;)
            .setContentIntent(PendingIntent.
                    getActivity(ServiceB.this, 0, intent, PendingIntent.FLAG_CANCEL_CURRENT))
            .build();
    startForeground(1, notification);
</code></pre>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips:"></a>Tips:</h3><ol>
<li>startForeground让服务变成前台服务并显示通知，这时必须要setSmallIcon，否则会显示默认的通知，不显示自定义通知</li>
<li>如何让服务一直存活 <a target="_blank" rel="noopener" href="http://zhoujianghua.com/2015/07/28/black_technology_in_alipay/">http://zhoujianghua.com/2015/07/28/black_technology_in_alipay/</a></li>
</ol>
<h1 id="三、Service-和-Thread"><a href="#三、Service-和-Thread" class="headerlink" title="三、Service 和 Thread"></a>三、Service 和 Thread</h1><p>之所以有不少人会把它们联系起来，主要就是因为Service的后台概念。Thread我们大家都知道，是用于开启一个子线程，在这里去执行一些耗时操作就不会阻塞主线程的运行。而Service我们最初理解的时候，总会觉得它是用来处理一些后台任务的，一些比较耗时的操作也可以放在这里运行，这就会让人产生混淆了。但其实Service其实是运行在主线程里的，所以说service的主进程中不能执行耗时的任务，需要另外启动线程执行，例如IntentService的内部就是使用了HandlerThread的实现。</p>
<h1 id="四、IntentService"><a href="#四、IntentService" class="headerlink" title="四、IntentService"></a>四、IntentService</h1><p>IntentService是Service 的子类，它使用工作线程逐一处理所有启动请求。如果不要求服务同时处理多个请求，这是最好的选择。只需实现 onHandleIntent() 方法即可，该方法会接收每个启动请求的Intent，能够执行后台工作。由于大多数启动服务都不必同时处理多个请求，因此使用 IntentService 类实现服务也许是最好的选择。</p>
<p>IntentService的特点：</p>
<ol>
<li>IntentService 会创建一个线程，来处理所有传给onStartCommand()的Intent请求</li>
<li>创建一个请求队列，用于将 Intent 逐一传递给 onHandleIntent() 实现，不必担心多线程问题</li>
<li>在所有的请求执行完毕后结束Service</li>
<li>提供 onBind() 的默认实现（返回 null）</li>
<li>提供默认的 onStartCommand() 实现，将intent传入等待队列中，然后到onHandleIntent()的实现。所以如果需要重写onStartCommand() 方法一定要调用父类的实现。</li>
</ol>
<h3 id="Tips-1"><a href="#Tips-1" class="headerlink" title="Tips:"></a>Tips:</h3><ol>
<li>IntentService是针对StarteService设计的，由于它默认实现的onBind()方法返回值是null，所以不适合bindService()</li>
<li>多次startService请求执行耗时任务，不会并发执行onHandleIntent()方法，而是一个一个顺序执行。当所有的任务执行完成，IntentService会自动销毁</li>
</ol>
<p>问题：onStartCommand的返回值的具体应用场景？</p>
<p>Demo：</p>
<p>参考资料：<br><a target="_blank" rel="noopener" href="https://developer.android.com/guide/components/services.html">https://developer.android.com/guide/components/services.html</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/guolin_blog/article/details/11952435">http://blog.csdn.net/guolin_blog/article/details/11952435</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/22/Notes/Android/FourComponents/BroadcastReceiver%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/22/Notes/Android/FourComponents/BroadcastReceiver%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-22 23:06:56" itemprop="dateCreated datePublished" datetime="2021-02-22T23:06:56+08:00">2021-02-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="BroadcastReceiver-基础知识"><a href="#BroadcastReceiver-基础知识" class="headerlink" title="BroadcastReceiver 基础知识"></a>BroadcastReceiver 基础知识</h1><p>BroadcastReceiver 四大组件之一，主要用于监听手机状态的变以及不同组件和应用间的通信。</p>
<h2 id="一-注册广播"><a href="#一-注册广播" class="headerlink" title="一.注册广播"></a>一.注册广播</h2><h3 id="1-静态注册："><a href="#1-静态注册：" class="headerlink" title="1.静态注册："></a>1.静态注册：</h3><ol>
<li><p>在AndroidMainfest中添加receiver</p>
<pre><code> &lt;receiver android:name=&quot;.MyReceiver&quot;&gt;
     &lt;intent-filter&gt;
         &lt;action android:name=&quot;android.intent.action.myreceiver&quot; /&gt;
     &lt;/intent-filter&gt;
 &lt;/receiver&gt;
</code></pre>
</li>
<li><p>创建类继承BroadcastReceiver的，并且复写onReceive()方法</p>
<pre><code> public class MyReceiver extends BroadcastReceiver &#123;
     @Override
     public void onReceive(Context context, Intent intent) &#123;
         Log.i(TAG, &quot;receive action &quot;);
     &#125;
 &#125;
</code></pre>
</li>
</ol>
<h3 id="2-动态注册"><a href="#2-动态注册" class="headerlink" title="2. 动态注册"></a>2. 动态注册</h3><ol>
<li><p>创建广播类和实例</p>
</li>
<li><p>创建intentFilter并且添加需要接收的action</p>
</li>
<li><p>调用registerReceiver方法注册</p>
</li>
<li><p>可以通过unregisterReceiver取消</p>
<pre><code> public class MainActivity extends Activity &#123;
     private BroadcastReceiver mBroadcastReceiver;
 
     @Override
     protected void onCreate(Bundle savedInstanceState) &#123;
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_main);
 
         mBroadcastReceiver = new MyBroadcastReceiver();
         IntentFilter intentFilter = new IntentFilter();
         intentFilter.addAction(&quot;MyIntent&quot;);
         registerReceiver(mBroadcastReceiver, intentFilter);
     &#125;
     @Override
     protected void onDestroy() &#123;
         super.onDestroy();
         unregisterReceiver(mBroadcastReceiver);
     &#125;
 &#125;
</code></pre>
</li>
</ol>
<p>###Tips：</p>
<ol>
<li>action的注册和解注册成对出现在context对应的生命周期中，例如onCreate和onDestroy，以及onResume和onPause</li>
<li>同一个receiver可以同时接收动态注册和静态注册的广播</li>
<li>动态广播在应用没有启动时，是无法接收到的，即使加了Intent.FLAG_INCLUDE_STOPPED_PACKAGES（测试失败）</li>
</ol>
<h2 id="二、广播的类型"><a href="#二、广播的类型" class="headerlink" title="二、广播的类型"></a>二、广播的类型</h2><p>###1. 系统广播<br>   系统广播，当手机状态发生变化时，都会发出相应的系统广播。如：网络状态，解锁等。注意：有些系统广播必须态注册才有效：SCREEN_ON，SCREEN_OFF<br>###2. 普通广播<br>   自定义的广播，通常用于应用内或应用间通信。<br>###3. 有序广播</p>
<ol>
<li>多个具当前已经注册且有效的BroadcastReceiver接收有序广播时，是按照先后顺序接收的，先后顺序判定标准为：将当前系统中所有有效的动态注册和静态注册的BroadcastReceiver按照priority属性值从大到小排序，对于具有相同的priority的动态广播和静态广播，动态广播会排在前面。<pre><code> &lt;receiver android:name=&quot;.OrderedReceiver1&quot;&gt;
     &lt;intent-filter android:priority=&quot;100&quot;&gt;
         &lt;action android:name=&quot;com.sven.action.my.receiver.orderd.receiver&quot; /&gt;
     &lt;/intent-filter&gt;
 &lt;/receiver&gt;
 &lt;receiver android:name=&quot;.OrderedReceiver2&quot;&gt;
     &lt;intent-filter android:priority=&quot;1000&quot;&gt;
         &lt;action android:name=&quot;com.sven.action.my.receiver.orderd.receiver&quot; /&gt;
     &lt;/intent-filter&gt;
 &lt;/receiver&gt;
</code></pre>
</li>
</ol>
<p> 当然动态注册时也可以设置优先级：</p>
<pre><code>    intentFilter.setPriority(1000);
</code></pre>
<ol start="2">
<li><p>先接收的BroadcastReceiver可以对此有序广播进行截断，使后面的BroadcastReceiver不再接收到此广播，</p>
<pre><code> public class OrderedReceiver2 extends BroadcastReceiver &#123;
     private static final String TAG = &quot;OrderedReceiver2&quot;;
     @Override
     public void onReceive(Context context, Intent intent) &#123;
         Log.i(TAG, &quot;action = &quot;+intent.getAction());
         abortBroadcast();
     &#125;
 &#125;
</code></pre>
</li>
<li><p>receiver之间的通信<br>优先接收到Broadcast的Receiver可通过setResultExtras(Bundle)方法将处理结果存入Broadcast中，下一个Receiver 可通过getResultExtras(true)方法获取上一个 Receiver传来的数据。</p>
<pre><code> //修改
 public class OrderedReceiver2 extends BroadcastReceiver &#123;
     private static final String TAG = &quot;OrderedReceiver2&quot;;
     @Override
     public void onReceive(Context context, Intent intent) &#123;
         Log.i(TAG, &quot;action = &quot;+intent.getAction());
         Bundle b = new Bundle();
         b.putInt(&quot;value&quot;, 101);
         setResultExtras(b);
     &#125;
 &#125;
 
 //接收    
 public class OrderedReceiver1 extends BroadcastReceiver &#123;
     private static final String TAG = &quot;OrderedReceiver1&quot;;
     @Override
     public void onReceive(Context context, Intent intent) &#123;
         Log.i(TAG, &quot;action = &quot;+intent.getAction());
         Bundle b = getResultExtras(true);
         Log.i(TAG,&quot;value = &quot;+b.get(&quot;value&quot;));
     &#125;
 &#125;
</code></pre>
</li>
</ol>
<p>##三、广播和权限</p>
<h3 id="1-谁有权限接收-和安装的顺序有关-需要先装发送者"><a href="#1-谁有权限接收-和安装的顺序有关-需要先装发送者" class="headerlink" title="1. 谁有权限接收 (和安装的顺序有关 需要先装发送者)"></a>1. 谁有权限接收 (和安装的顺序有关 需要先装发送者)</h3><ol>
<li>发送者的manifest声明权限<pre><code> &lt;permission android:name=&quot;com.sven.permission.my.receiver.RECEIVE&quot;/&gt;
</code></pre>
</li>
<li>发送时添加权限<pre><code> public void sendBroadcast(View view) &#123;
     sendBroadcast(new Intent(&quot;com.sven.action.my.receiver&quot;),
             &quot;com.sven.permission.my.receiver.RECEIVE&quot;);
 &#125;
</code></pre>
</li>
<li>接收app的manifest要添加对应的权限<pre><code> &lt;uses-permission android:name=&quot;com.sven.permission.my.receiver.RECEIVE&quot;/&gt;
</code></pre>
</li>
</ol>
<h3 id="2-谁有权限发送-（和安装顺序有关，先安装接收者）"><a href="#2-谁有权限发送-（和安装顺序有关，先安装接收者）" class="headerlink" title="2. 谁有权限发送 （和安装顺序有关，先安装接收者）"></a>2. 谁有权限发送 （和安装顺序有关，先安装接收者）</h3><ol>
<li><p>接收者的manifest文件中声明权限</p>
<pre><code>    &lt;permission android:name=&quot;com.sven.permission.my.receiver.SEND&quot;/&gt;
</code></pre>
</li>
<li><p>接收者的receiver节点中添加</p>
<pre><code>     &lt;receiver
         android:name=&quot;.MyReceiverWithPermission&quot;
         android:permission=&quot;com.sven.permission.my.receiver.SEND&quot;&gt;
         &lt;intent-filter&gt;
         ....
         &lt;/intent-filter&gt;
     &lt;/receiver&gt;
</code></pre>
</li>
<li><p>发送者的manifest文件中使用</p>
<pre><code> &lt;uses-permission android:name=&quot;com.sven.permission.my.receiver.SEND&quot;/&gt;
</code></pre>
</li>
</ol>
<h3 id="Tips："><a href="#Tips：" class="headerlink" title="Tips："></a>Tips：</h3><p>自定义的权限最好在2个app中同时声明，（测试出现了比较奇怪的情况，声明权限的app，必须先安装，否则还是会报权限问题），使用系统权限不会不存在以上问题</p>
<h3 id="四、安全高效地使用广播的一些原则："><a href="#四、安全高效地使用广播的一些原则：" class="headerlink" title="四、安全高效地使用广播的一些原则："></a>四、安全高效地使用广播的一些原则：</h3><ol>
<li><p>如果不需要发送到应用外，同一个应用内的广播尽量使用LocalBroadcastManager</p>
</li>
<li><p>尽量使用动态注册的广播，而且有些系统广播，比如说 CONNECTIVITY_ACTION 在7.0之后只能通过动态注册接收</p>
</li>
<li><p>发送广播时明确广播的接受者：<br> (1)发送时添加权限<br> (2)通过setPackage 指定应用<br> (3)使用LocalBroadcastManager</p>
</li>
<li><p>广播的命名尽量保证唯一</p>
</li>
<li><p>注册一个广播时，限制广播的接收者：</p>
<p> (1)添加一个权限, mainfest 中指定，动态注册可以使用该接口添加权限</p>
<pre><code> public abstract Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler);
</code></pre>
<p> (2)仅仅只是应用内使用时，可以使用设置 android:exported=”false”。这样就不会接收应用外的广播了<br> (3)使用LocalBroadcastManager</p>
</li>
<li><p>onReceive方法运行在主线程中，所以不能执行耗时任务</p>
</li>
<li><p>不要通过广播启动activity，可以使用通知替代</p>
</li>
</ol>
<p>五、onReceive<br>系统执行onReceive方法时，receiver会被当成前台进程，不会被杀，但是当onReceive()方法返回后，会被当成一个低优先级的程序，很容易被系统杀掉，在onReceive执行耗时异步任务时，最好通过goAsync防止执行过程中被系统杀掉。<br>onReceive 的context是Application的context？？？</p>
<pre><code>public class MyBroadcastReceiver extends BroadcastReceiver &#123;
    private static final String TAG = &quot;MyBroadcastReceiver&quot;;
    @Override
    public void onReceive(final Context context, final Intent intent) &#123;
        final PendingResult pendingResult = goAsync();
        AsyncTask&lt;String, Integer, String&gt; asyncTask = new AsyncTask&lt;String, Integer, String&gt;() &#123;
            @Override
            protected String doInBackground(String... params) &#123;
                StringBuilder sb = new StringBuilder();
                sb.append(&quot;Action: &quot; + intent.getAction() + &quot;\n&quot;);
                sb.append(&quot;URI: &quot; + intent.toUri(Intent.URI_INTENT_SCHEME).toString() + &quot;\n&quot;);
                Log.d(TAG, log);
                // Must call finish() so the BroadcastReceiver can be recycled.
                pendingResult.finish();
                return data;
            &#125;
        &#125;;
        asyncTask.execute(); 
&#125;
</code></pre>
<p>}<br>###Tips:<br>可以在通过一下这种方法让onReceive执行在handlerThread中。</p>
<pre><code>private Handler handler; // Handler for the separate Thread
HandlerThread handlerThread = new HandlerThread(&quot;MyNewThread&quot;);
handlerThread.start();
// Now get the Looper from the HandlerThread so that we can create a Handler that is  attached to the HandlerThread
// NOTE: This call will block until the HandlerThread gets control and initializes its Looper
Looper looper = handlerThread.getLooper();
// Create a handler for the service
handler = new Handler(looper);
// Register the broadcast receiver to run on the separate Thread
registerReceiver (myReceiver, intentFilter, broadcastPermission, handler);
</code></pre>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/10682241/register-a-broadcast-receiver-from-a-service-in-a-new-thread">https://stackoverflow.com/questions/10682241/register-a-broadcast-receiver-from-a-service-in-a-new-thread</a></p>
<h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><ol>
<li>有哪些静态广播可以启动进程，是否有其他要求？</li>
<li>上文提到的发送及接收时permission的问题？</li>
<li>BroadcastReceiver 耗时任务通过开启service执行和异步执行各有什么应用场景？</li>
</ol>
<p>参考资料：<br><a target="_blank" rel="noopener" href="https://developer.android.com/guide/components/broadcasts.html#security_considerations_and_best_practices">https://developer.android.com/guide/components/broadcasts.html#security_considerations_and_best_practices</a><br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/lwbqqyumidi/p/4168017.html">http://www.cnblogs.com/lwbqqyumidi/p/4168017.html</a></p>
<p>Demo：<br><a target="_blank" rel="noopener" href="http://download.csdn.net/detail/time_traveller14/9892205">http://download.csdn.net/detail/time_traveller14/9892205</a><br><a target="_blank" rel="noopener" href="http://download.csdn.net/detail/time_traveller14/9892207">http://download.csdn.net/detail/time_traveller14/9892207</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/22/Notes/Android/FourComponents/Fragment%E5%AD%A6%E4%B9%A0%E7%90%86%E8%A7%A3%E5%8F%8A%E7%AE%80%E5%8D%95%E5%AE%9E%E8%B7%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/22/Notes/Android/FourComponents/Fragment%E5%AD%A6%E4%B9%A0%E7%90%86%E8%A7%A3%E5%8F%8A%E7%AE%80%E5%8D%95%E5%AE%9E%E8%B7%B5/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-22 22:57:54" itemprop="dateCreated datePublished" datetime="2021-02-22T22:57:54+08:00">2021-02-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文主要介绍下Android Fragment的生命周期，相关的API以及和Activity通信的简单实践</p>
<h1 id="一、生命周期："><a href="#一、生命周期：" class="headerlink" title="一、生命周期："></a>一、生命周期：</h1><p><img src="https://leanote.com/api/file/getImage?fileId=5936c722ab64410e79001e16" alt="fragment生命周期"><br>Fragment创建销毁时，fragment和所依赖的activity生命周期的执行顺序，<strong>注意看log的TAG</strong></p>
<h2 id="1-创建时"><a href="#1-创建时" class="headerlink" title="1.创建时"></a>1.创建时</h2><pre><code>01-12 17:57:24.823 28028-28028/? I/ActivityLife: onCreate...
01-12 17:57:24.843 28028-28028/? I/FragmentLife: onAttach...
01-12 17:57:24.843 28028-28028/? I/FragmentLife: onCreate...
01-12 17:57:24.843 28028-28028/? I/FragmentLife: onCreateView...
01-12 17:57:24.843 28028-28028/? I/FragmentLife: onActivityCreated...
01-12 17:57:24.843 28028-28028/? I/ActivityLife: onStart...
01-12 17:57:24.843 28028-28028/? I/FragmentLife: onStart...
01-12 17:57:24.843 28028-28028/? I/ActivityLife: onResume...
01-12 17:57:24.843 28028-28028/? I/FragmentLife: onResume...
</code></pre>
<h2 id="2-销毁时"><a href="#2-销毁时" class="headerlink" title="2.销毁时"></a>2.销毁时</h2><pre><code>01-12 17:57:40.583 28028-28028/? I/FragmentLife: onPause...
01-12 17:57:40.583 28028-28028/? I/ActivityLife: onPause...
01-12 17:57:40.883 28028-28028/? I/FragmentLife: onStop...
01-12 17:57:40.883 28028-28028/? I/ActivityLife: onStop...
01-12 17:57:40.883 28028-28028/? I/FragmentLife: onDestroyView...
01-12 17:57:40.883 28028-28028/? I/FragmentLife: onDestroy...
01-12 17:57:40.883 28028-28028/? I/FragmentLife: onDetach...
01-12 17:57:40.883 28028-28028/? I/ActivityLife: onDestroy...
</code></pre>
<h1 id="二、Activity中，Fragment的2种加载方法"><a href="#二、Activity中，Fragment的2种加载方法" class="headerlink" title="二、Activity中，Fragment的2种加载方法"></a>二、Activity中，Fragment的2种加载方法</h1><h2 id="1-静态加载"><a href="#1-静态加载" class="headerlink" title="1.静态加载"></a>1.静态加载</h2><h3 id="（1）创建Fragment类和布局文件-fragment1-xml"><a href="#（1）创建Fragment类和布局文件-fragment1-xml" class="headerlink" title="（1）创建Fragment类和布局文件(fragment1.xml)"></a>（1）创建Fragment类和布局文件(fragment1.xml)</h3><pre><code>public class Fragment1 extends Fragment &#123;
    @Override
    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) &#123;
       return inflater.inflate(R.layout.fragment1, container, false);
    &#125;
&#125;

&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:background=&quot;#00ff00&quot; &gt;
    &lt;TextView
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;This is fragment 1&quot;
        android:textColor=&quot;#000000&quot;
        android:textSize=&quot;25sp&quot; /&gt;
&lt;/LinearLayout&gt; 
</code></pre>
<h3 id="（2）在activity布局文件（activity-main-xml）中添加fragment布局"><a href="#（2）在activity布局文件（activity-main-xml）中添加fragment布局" class="headerlink" title="（2）在activity布局文件（activity_main.xml）中添加fragment布局"></a>（2）在activity布局文件（activity_main.xml）中添加fragment布局</h3><pre><code>...
&lt;fragment
android:id=&quot;@+id/fragment1&quot;
android:name=&quot;com.example.sven.fragementdemo.Fragment1&quot;
android:layout_width=&quot;0dip&quot;
android:layout_height=&quot;match_parent&quot;
android:layout_weight=&quot;1&quot; /&gt;
...
</code></pre>
<h2 id="2-动态加载"><a href="#2-动态加载" class="headerlink" title="2.动态加载"></a>2.动态加载</h2><h3 id="1-在activity布局文件中添加FragmentLayout节点"><a href="#1-在activity布局文件中添加FragmentLayout节点" class="headerlink" title="(1) 在activity布局文件中添加FragmentLayout节点"></a>(1) 在activity布局文件中添加FragmentLayout节点</h3><pre><code>...
  &lt;FrameLayout
        android:id=&quot;@+id/fragment_container&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;&gt;
    &lt;/FrameLayout&gt;
...
</code></pre>
<h3 id="2-java代码中动态加载"><a href="#2-java代码中动态加载" class="headerlink" title="(2) java代码中动态加载"></a>(2) java代码中动态加载</h3><pre><code>...
  1.获取fragmentManager
FragmentManager fragmentManager = getFragmentManager();
  2.获取FragmentTransaction
FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();
  3.创建需要的Fragment
Fragment fragment = new Fragment1();
  4.动态添加fragment
    将创建的fragment添加到Activity布局文件中定义的占位符中（FrameLayout）
fragmentTransaction.add(R.id.fragment_container,fragment).commit();
...
</code></pre>
<h1 id="三、FragmentTransaction方法解析结合Fragment的生命周期"><a href="#三、FragmentTransaction方法解析结合Fragment的生命周期" class="headerlink" title="三、FragmentTransaction方法解析结合Fragment的生命周期"></a>三、FragmentTransaction方法解析结合Fragment的生命周期</h1><p>对Fragment的操作主要是通过调用FragmentTransaction类的方法进行的，FragmentTransaction的对象通常是通过getFragmentManager().beginTransaction()获取的</p>
<h2 id="1-add-amp-remove-replace"><a href="#1-add-amp-remove-replace" class="headerlink" title="1.add &amp; remove / replace"></a>1.add &amp; remove / replace</h2><h3 id="1-add-往Activity中添加一个Fragment，对应的fragment的生命周期如下："><a href="#1-add-往Activity中添加一个Fragment，对应的fragment的生命周期如下：" class="headerlink" title="(1) add 往Activity中添加一个Fragment，对应的fragment的生命周期如下："></a>(1) add 往Activity中添加一个Fragment，对应的fragment的生命周期如下：</h3><pre><code>06-13 12:01:43.406 1986-1986/? I/Fragment3: onAttach
06-13 12:01:43.406 1986-1986/? I/Fragment3: onCreate
06-13 12:01:43.406 1986-1986/? I/Fragment3: onCreateView
06-13 12:01:43.406 1986-1986/? I/Fragment3: onActivityCreated
06-13 12:01:43.406 1986-1986/? I/Fragment3: onStart
06-13 12:01:43.406 1986-1986/? I/Fragment3: onResume  
</code></pre>
<h3 id="2-remove-从Activity中移除一个Fragment，和add配对使用，通常是直接用replace"><a href="#2-remove-从Activity中移除一个Fragment，和add配对使用，通常是直接用replace" class="headerlink" title="(2) remove 从Activity中移除一个Fragment，和add配对使用，通常是直接用replace"></a>(2) remove 从Activity中移除一个Fragment，和add配对使用，通常是直接用replace</h3><pre><code>06-13 12:07:54.046 8765-8765/com.example.sven.fragementdemo I/Fragment3: onPause
06-13 12:07:54.046 8765-8765/com.example.sven.fragementdemo I/Fragment3: onStop
06-13 12:07:54.046 8765-8765/com.example.sven.fragementdemo I/Fragment3: onDestroyView
06-13 12:07:54.046 8765-8765/com.example.sven.fragementdemo I/Fragment3: onDestroy
06-13 12:07:54.046 8765-8765/com.example.sven.fragementdemo I/Fragment3: onDetach
</code></pre>
<h3 id="3-replace-使用另一个fragment替换当前的，先remove掉当前的再add新的，参考add和remove的过程"><a href="#3-replace-使用另一个fragment替换当前的，先remove掉当前的再add新的，参考add和remove的过程" class="headerlink" title="(3) replace 使用另一个fragment替换当前的，先remove掉当前的再add新的，参考add和remove的过程"></a>(3) replace 使用另一个fragment替换当前的，先remove掉当前的再add新的，参考add和remove的过程</h3><h2 id="2-attach-amp-detach"><a href="#2-attach-amp-detach" class="headerlink" title="2.attach &amp; detach"></a>2.attach &amp; detach</h2><h3 id="1-attach-重建view视图，添加到UI上并显示，和detach配合使用，显示一个被detach的fragment"><a href="#1-attach-重建view视图，添加到UI上并显示，和detach配合使用，显示一个被detach的fragment" class="headerlink" title="(1) attach 重建view视图，添加到UI上并显示，和detach配合使用，显示一个被detach的fragment"></a>(1) attach 重建view视图，添加到UI上并显示，和detach配合使用，显示一个被detach的fragment</h3><pre><code>06-13 11:57:46.376 29992-29992/com.example.sven.fragementdemo I/Fragment3: onCreateView
06-13 11:57:46.376 29992-29992/com.example.sven.fragementdemo I/Fragment3: onActivityCreated
06-13 11:57:46.376 29992-29992/com.example.sven.fragementdemo I/Fragment3: onStart
06-13 11:57:46.376 29992-29992/com.example.sven.fragementdemo I/Fragment3: onResume
</code></pre>
<h3 id="2-detach-会将view从UI中移除-和remove-不同-此时fragment的状态依然由FragmentManager维护，fragment的实例还存在，但是视图被销毁了"><a href="#2-detach-会将view从UI中移除-和remove-不同-此时fragment的状态依然由FragmentManager维护，fragment的实例还存在，但是视图被销毁了" class="headerlink" title="(2) detach 会将view从UI中移除,和remove()不同,此时fragment的状态依然由FragmentManager维护，fragment的实例还存在，但是视图被销毁了"></a>(2) detach 会将view从UI中移除,和remove()不同,此时fragment的状态依然由FragmentManager维护，fragment的实例还存在，但是视图被销毁了</h3><pre><code>06-13 11:58:13.486 29992-29992/com.example.sven.fragementdemo I/Fragment3: onPause
06-13 11:58:13.486 29992-29992/com.example.sven.fragementdemo I/Fragment3: onStop
06-13 11:58:13.486 29992-29992/com.example.sven.fragementdemo I/Fragment3: onDestroyView
</code></pre>
<h2 id="3-hide-amp-show"><a href="#3-hide-amp-show" class="headerlink" title="3.hide &amp; show"></a>3.hide &amp; show</h2><p>不涉及fragment生命周期，调试过程中没有看到想象中onPause、onStop、onResume函数的调用过程，hide时fragment的视图和实例都不会被销毁，只是视图可见与不可见的变化。账号登陆界面应该用的比较多，能够保存用户的输入，和detach区别就是detach不能够的保存界面的信息（例如EditText的输入），每次detach，attch时界面都会重绘</p>
<h2 id="4-commit"><a href="#4-commit" class="headerlink" title="4.commit"></a>4.commit</h2><p>提交对fragment的一系列操作。注意每一次对fragment的操作都要开一次事务，commit一次。commit和FragmentManager.beginTransaction()要配对使用。（很像数据库，暂时没深入研究）</p>
<h2 id="5-addToBackStack-String"><a href="#5-addToBackStack-String" class="headerlink" title="5.addToBackStack(String)"></a>5.addToBackStack(String)</h2><p>把当前事务的变化情况添加到回退栈,下节详细讲下</p>
<h2 id="tips："><a href="#tips：" class="headerlink" title="tips："></a>tips：</h2><h3 id="1-以上这些方法通常是在Activity中使用，依附于同一个Activity的多个fragment的各种切换"><a href="#1-以上这些方法通常是在Activity中使用，依附于同一个Activity的多个fragment的各种切换" class="headerlink" title="1.以上这些方法通常是在Activity中使用，依附于同一个Activity的多个fragment的各种切换"></a>1.以上这些方法通常是在Activity中使用，依附于同一个Activity的多个fragment的各种切换</h3><h3 id="2-fragment真正的实例其实是要通过FragmentTransaction-add，只有在add时才会执行onCreate，new的时候拿到只是一个引用-并没有执行生命周期函数"><a href="#2-fragment真正的实例其实是要通过FragmentTransaction-add，只有在add时才会执行onCreate，new的时候拿到只是一个引用-并没有执行生命周期函数" class="headerlink" title="2.fragment真正的实例其实是要通过FragmentTransaction.add，只有在add时才会执行onCreate，new的时候拿到只是一个引用 并没有执行生命周期函数"></a>2.fragment真正的实例其实是要通过FragmentTransaction.add，只有在add时才会执行onCreate，new的时候拿到只是一个引用 并没有执行生命周期函数</h3><h3 id="3-使用attach-detach-或者-hide-show-都需要new出对象，并且执行add"><a href="#3-使用attach-detach-或者-hide-show-都需要new出对象，并且执行add" class="headerlink" title="3.使用attach/detach 或者 hide/show 都需要new出对象，并且执行add"></a>3.使用attach/detach 或者 hide/show 都需要new出对象，并且执行add</h3><h3 id="4-add-remove-replace-hide-show后都要commit其效果才会在屏幕上显示出来"><a href="#4-add-remove-replace-hide-show后都要commit其效果才会在屏幕上显示出来" class="headerlink" title="4.add/remove/replace/hide/show后都要commit其效果才会在屏幕上显示出来"></a>4.add/remove/replace/hide/show后都要commit其效果才会在屏幕上显示出来</h3><h1 id="四、Fragment的回退栈"><a href="#四、Fragment的回退栈" class="headerlink" title="四、Fragment的回退栈"></a>四、Fragment的回退栈</h1><p>Fragment回退栈是用来保存每一次Fragment事务发生的变化，如果你将Fragment任务添加到回退栈，当点击back键时，将看到上一次的保存的Fragment，一旦Fragment完全从后退栈中弹出，用户再次点击后退键，则退出当前Activity，如果被移除的Fragment没有添加到回退栈，例如执行remove或者replace时，这个Fragment实例将会被销毁</p>
<p>理解以下3种情况 在同一个Actity中，fragment1 跳转到fragment2，然后按back退出时的不同情况</p>
<pre><code>public void jump2fragment2()&#123;
    FragmentTransaction fragmentTransaction = getFragmentManager().beginTransaction();
    fragment之间跳转时
    1.只采用replace 实例会被销毁 back键一次
    fragmentTransaction.replace(R.id.fragment_container,new Fragment2());
    fragmentTransaction.addToBackStack(null);

    2.把当前事务的变化情况添加到回退栈,视图会被销毁但是实例还在(back 2次)
    fragmentTransaction.replace(R.id.fragment_container,new Fragment2());
    fragmentTransaction.addToBackStack(null);

    3.采用hide方式 实例不会被销毁,视图也不会被销毁(back 2次)
    fragmentTransaction.hide(this);
    fragmentTransaction.add(R.id.fragment_container, new Fragment2());
    fragmentTransaction.addToBackStack(null);
    fragmentTransaction.commit();
&#125;
</code></pre>
<h1 id="五、Fragment与Activity之间的通信"><a href="#五、Fragment与Activity之间的通信" class="headerlink" title="五、Fragment与Activity之间的通信"></a>五、Fragment与Activity之间的通信</h1><h2 id="1-一般Fragment依附于Activity存在，因此与Activity之间的通信可以归纳为以下3点："><a href="#1-一般Fragment依附于Activity存在，因此与Activity之间的通信可以归纳为以下3点：" class="headerlink" title="1.一般Fragment依附于Activity存在，因此与Activity之间的通信可以归纳为以下3点："></a>1.一般Fragment依附于Activity存在，因此与Activity之间的通信可以归纳为以下3点：</h2><h3 id="（1）Fragment中可以通过getActivity得到当前绑定的Activity的实例，然后进行操作"><a href="#（1）Fragment中可以通过getActivity得到当前绑定的Activity的实例，然后进行操作" class="headerlink" title="（1）Fragment中可以通过getActivity得到当前绑定的Activity的实例，然后进行操作"></a>（1）Fragment中可以通过getActivity得到当前绑定的Activity的实例，然后进行操作</h3><p>例如你在想在某个fragment中通过activity拿到fragment1的数据可以这样做</p>
<pre><code>public void getfragment1text() &#123;
    getActivity().findViewById(R.id.fragment1_text)
&#125;
</code></pre>
<h3 id="2-如果你Activity中包含自己管理的Fragment的引用，可以通过引用直接访问所有的Fragment的public方法"><a href="#2-如果你Activity中包含自己管理的Fragment的引用，可以通过引用直接访问所有的Fragment的public方法" class="headerlink" title="(2) 如果你Activity中包含自己管理的Fragment的引用，可以通过引用直接访问所有的Fragment的public方法"></a>(2) 如果你Activity中包含自己管理的Fragment的引用，可以通过引用直接访问所有的Fragment的public方法</h3><h3 id="3-如果Activity中未保存任何Fragment的引用，那么没关系，每个Fragment都有一个唯一的TAG或者ID-可以通过getFragmentManager-findFragmentByTag-或者findFragmentById-获得任何Fragment实例，然后进行操作-fragment的id其实是无法设置的，add或replace时设置的id是其实要插入fragment所在ViewGroup的id，tag可以在add或replace时设置。https-stackoverflow-com-questions-9363072-android-set-fragment-id"><a href="#3-如果Activity中未保存任何Fragment的引用，那么没关系，每个Fragment都有一个唯一的TAG或者ID-可以通过getFragmentManager-findFragmentByTag-或者findFragmentById-获得任何Fragment实例，然后进行操作-fragment的id其实是无法设置的，add或replace时设置的id是其实要插入fragment所在ViewGroup的id，tag可以在add或replace时设置。https-stackoverflow-com-questions-9363072-android-set-fragment-id" class="headerlink" title="(3) 如果Activity中未保存任何Fragment的引用，那么没关系，每个Fragment都有一个唯一的TAG或者ID,可以通过getFragmentManager.findFragmentByTag()或者findFragmentById()获得任何Fragment实例，然后进行操作 fragment的id其实是无法设置的，add或replace时设置的id是其实要插入fragment所在ViewGroup的id，tag可以在add或replace时设置。https://stackoverflow.com/questions/9363072/android-set-fragment-id"></a>(3) 如果Activity中未保存任何Fragment的引用，那么没关系，每个Fragment都有一个唯一的TAG或者ID,可以通过getFragmentManager.findFragmentByTag()或者findFragmentById()获得任何Fragment实例，然后进行操作 fragment的id其实是无法设置的，add或replace时设置的id是其实要插入fragment所在ViewGroup的id，tag可以在add或replace时设置。<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/9363072/android-set-fragment-id">https://stackoverflow.com/questions/9363072/android-set-fragment-id</a></h3><pre><code>public class MainActivity extends AppCompatActivity &#123;
    private static final String TAG = &quot;ActivityLife&quot;;
    private Fragment1 fragment = new Fragment1();
    @Override
    protected void onCreate(Bundle savedInstanceState) &#123;
        super.onCreate(savedInstanceState);
        printLog(&quot;onCreate...&quot;);
        setContentView(R.layout.activity_main);

        // 1.获取fragmentManager
        FragmentManager fragmentManager = getFragmentManager();
        // 2.获取FragmentTransaction
        FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();
        // 3.创建需要的Fragment
        // Fragment fragment = new Fragment1();
        // 4.动态添加fragment
        // 将创建的fragment添加到Activity布局文件中定义的占位符中（FrameLayout）
        fragmentTransaction.add(R.id.fragment_container, fragment, &quot;fragment1&quot;).commit();
    &#125;

    public void getFragmentMessage(View view)&#123;
        //1.针对第2种情况
        fragment.printSth();
        //2.针对第3种情况
        Fragment fragment = getFragmentManager().findFragmentByTag(&quot;fragment1&quot;);
        printLog(fragment.toString());
        fragment.onResume();
    &#125;
&#125;

public class Fragment1 extends Fragment &#123;
    ...
    public void printSth() &#123;
        Log.i(TAG,&quot;fragment3 printSth&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="（4）更复杂的用法参考："><a href="#（4）更复杂的用法参考：" class="headerlink" title="（4）更复杂的用法参考："></a>（4）更复杂的用法参考：</h3><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/lmj623565791/article/details/37992017">http://blog.csdn.net/lmj623565791/article/details/37992017</a></p>
<h2 id="2-应用场景主要就是通过Activity去管理多个Fragment的状态"><a href="#2-应用场景主要就是通过Activity去管理多个Fragment的状态" class="headerlink" title="2.应用场景主要就是通过Activity去管理多个Fragment的状态"></a>2.应用场景主要就是通过Activity去管理多个Fragment的状态</h2><h2 id="思路如下："><a href="#思路如下：" class="headerlink" title="思路如下："></a>思路如下：</h2><h3 id="1-让各个Fragment注册一个监听接口，让Activity去implements这个监听接口"><a href="#1-让各个Fragment注册一个监听接口，让Activity去implements这个监听接口" class="headerlink" title="(1) 让各个Fragment注册一个监听接口，让Activity去implements这个监听接口"></a>(1) 让各个Fragment注册一个监听接口，让Activity去implements这个监听接口</h3><h3 id="2-在Activity中new出各个Fragment的对象，获取引用"><a href="#2-在Activity中new出各个Fragment的对象，获取引用" class="headerlink" title="(2) 在Activity中new出各个Fragment的对象，获取引用"></a>(2) 在Activity中new出各个Fragment的对象，获取引用</h3><h3 id="3-将Fragment中的事件通过listener传递到Activity中，在Fragment中通过getActivity去调用监听方法"><a href="#3-将Fragment中的事件通过listener传递到Activity中，在Fragment中通过getActivity去调用监听方法" class="headerlink" title="(3) 将Fragment中的事件通过listener传递到Activity中，在Fragment中通过getActivity去调用监听方法"></a>(3) 将Fragment中的事件通过listener传递到Activity中，在Fragment中通过getActivity去调用监听方法</h3><h2 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h2><h3 id="Fragment中的按钮的事件响应时不能通过在配置文件中加onClick属性找到的，必须注册onClickListenr-有2种方式"><a href="#Fragment中的按钮的事件响应时不能通过在配置文件中加onClick属性找到的，必须注册onClickListenr-有2种方式" class="headerlink" title="Fragment中的按钮的事件响应时不能通过在配置文件中加onClick属性找到的，必须注册onClickListenr(有2种方式)"></a>Fragment中的按钮的事件响应时不能通过在配置文件中加onClick属性找到的，必须注册onClickListenr(有2种方式)</h3><p>原因参考：<a target="_blank" rel="noopener" href="http://blog.csdn.net/Zafir6453/article/details/51383915">http://blog.csdn.net/Zafir6453/article/details/51383915</a></p>
<h2 id="3-以上这些自己写了个Demo，方便大家调试和学习"><a href="#3-以上这些自己写了个Demo，方便大家调试和学习" class="headerlink" title="3.以上这些自己写了个Demo，方便大家调试和学习"></a>3.以上这些自己写了个Demo，方便大家调试和学习</h2><p><a target="_blank" rel="noopener" href="http://download.csdn.net/detail/time_traveller14/9870932">http://download.csdn.net/detail/time_traveller14/9870932</a></p>
<h3 id="1-生命周期，回退栈，参考fragment1-fragment2-MainActivity"><a href="#1-生命周期，回退栈，参考fragment1-fragment2-MainActivity" class="headerlink" title="1.生命周期，回退栈，参考fragment1,fragment2,MainActivity"></a>1.生命周期，回退栈，参考fragment1,fragment2,MainActivity</h3><h3 id="2-FragmentTransaction及和Activity通信（fragment中不同的按钮事件响应）-参考fragment3-fragment4-Main2Activity"><a href="#2-FragmentTransaction及和Activity通信（fragment中不同的按钮事件响应）-参考fragment3-fragment4-Main2Activity" class="headerlink" title="2.FragmentTransaction及和Activity通信（fragment中不同的按钮事件响应） 参考fragment3,fragment4, Main2Activity"></a>2.FragmentTransaction及和Activity通信（fragment中不同的按钮事件响应） 参考fragment3,fragment4, Main2Activity</h3><h1 id="六-还未理解问题："><a href="#六-还未理解问题：" class="headerlink" title="六.还未理解问题："></a>六.还未理解问题：</h1><h3 id="1-回退栈的使用场景，有了hide和detach为何还要加这个，仅仅是为了多按一次back键？"><a href="#1-回退栈的使用场景，有了hide和detach为何还要加这个，仅仅是为了多按一次back键？" class="headerlink" title="1.回退栈的使用场景，有了hide和detach为何还要加这个，仅仅是为了多按一次back键？"></a>1.回退栈的使用场景，有了hide和detach为何还要加这个，仅仅是为了多按一次back键？</h3><h3 id="2-hide和show为何没有onPause和onResume的过程，hide为何不执行onPause，onStop呢？"><a href="#2-hide和show为何没有onPause和onResume的过程，hide为何不执行onPause，onStop呢？" class="headerlink" title="2.hide和show为何没有onPause和onResume的过程，hide为何不执行onPause，onStop呢？"></a>2.hide和show为何没有onPause和onResume的过程，hide为何不执行onPause，onStop呢？</h3><h3 id="3-remove-的真正含义销毁还是出栈，看许多资料解释是销毁掉，但为何remove掉，commit完fragment-null，还能够通过tag获取到，但是去寻找fragment的视图元素会报错？"><a href="#3-remove-的真正含义销毁还是出栈，看许多资料解释是销毁掉，但为何remove掉，commit完fragment-null，还能够通过tag获取到，但是去寻找fragment的视图元素会报错？" class="headerlink" title="3.remove 的真正含义销毁还是出栈，看许多资料解释是销毁掉，但为何remove掉，commit完fragment!=null，还能够通过tag获取到，但是去寻找fragment的视图元素会报错？"></a>3.remove 的真正含义销毁还是出栈，看许多资料解释是销毁掉，但为何remove掉，commit完fragment!=null，还能够通过tag获取到，但是去寻找fragment的视图元素会报错？</h3><h3 id="4-屏幕旋转时，已经判断了onSavedInstance-null，为何还会继续，log中-onCreate-onCreateView会执行，要结合activity？"><a href="#4-屏幕旋转时，已经判断了onSavedInstance-null，为何还会继续，log中-onCreate-onCreateView会执行，要结合activity？" class="headerlink" title="4.屏幕旋转时，已经判断了onSavedInstance==null，为何还会继续，log中 onCreate onCreateView会执行，要结合activity？"></a>4.屏幕旋转时，已经判断了onSavedInstance==null，为何还会继续，log中 onCreate onCreateView会执行，要结合activity？</h3><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a target="_blank" rel="noopener" href="https://developer.android.com/guide/components/fragments.html">https://developer.android.com/guide/components/fragments.html</a><br>郭霖大神 <a target="_blank" rel="noopener" href="http://blog.csdn.net/guolin_blog/article/details/8881711">http://blog.csdn.net/guolin_blog/article/details/8881711</a><br>鸿洋大神 <a target="_blank" rel="noopener" href="http://blog.csdn.net/lmj623565791/article/details/37970961">http://blog.csdn.net/lmj623565791/article/details/37970961</a></p>
<h3 id="自己的第一篇技术博客，请大家多多指教，最后不理解的问题，欢迎讨论！"><a href="#自己的第一篇技术博客，请大家多多指教，最后不理解的问题，欢迎讨论！" class="headerlink" title="自己的第一篇技术博客，请大家多多指教，最后不理解的问题，欢迎讨论！"></a>自己的第一篇技术博客，请大家多多指教，最后不理解的问题，欢迎讨论！</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/18/Notes/Design/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/18/Notes/Design/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/" class="post-title-link" itemprop="url">Design01_设计模式之美</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-18 22:51:10" itemprop="dateCreated datePublished" datetime="2021-02-18T22:51:10+08:00">2021-02-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/design/" itemprop="url" rel="index"><span itemprop="name">design</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="设计模式之美"><a href="#设计模式之美" class="headerlink" title="设计模式之美"></a>设计模式之美</h1><p><img src="/pics/image-20200417165625730.png" alt="image-20200417165625730"></p>
<h2 id="一、面向对象"><a href="#一、面向对象" class="headerlink" title="一、面向对象"></a>一、面向对象</h2><h2 id="1-1-什么是面向对象"><a href="#1-1-什么是面向对象" class="headerlink" title="1.1 什么是面向对象"></a>1.1 什么是面向对象</h2><p><strong>面向对象编程是一种编程范式或编程风格</strong>。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。</p>
<p><strong>面向对象编程语言是支持类或对象的语法机制</strong>，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。</p>
<h4 id="1-面向对象分析（OOA）-amp-面向对象设计（OOD）-amp-面向对象编程（OOP）"><a href="#1-面向对象分析（OOA）-amp-面向对象设计（OOD）-amp-面向对象编程（OOP）" class="headerlink" title="1. 面向对象分析（OOA）&amp; 面向对象设计（OOD）&amp; 面向对象编程（OOP）"></a>1. 面向对象分析（OOA）&amp; 面向对象设计（OOD）&amp; 面向对象编程（OOP）</h4><p>面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做，面向对象编程就是将分析和设计的的结果翻译成代码的过程。</p>
<h4 id="2-如何进行面向对象设计？"><a href="#2-如何进行面向对象设计？" class="headerlink" title="2. 如何进行面向对象设计？"></a>2. 如何进行面向对象设计？</h4><ul>
<li>划分职责进而识别出有哪些类；</li>
<li>定义类及其属性和方法；</li>
<li>定义类与类之间的交互关系；</li>
<li>将类组装起来并提供执行入口。</li>
</ul>
<h4 id="3-类与类之间的交互关系"><a href="#3-类与类之间的交互关系" class="headerlink" title="3. 类与类之间的交互关系"></a>3. 类与类之间的交互关系</h4><p>类与类之间都哪些交互关系呢？UML 统一建模语言中定义了六种类之间的关系。它们分别是：泛化、实现、关联、聚合、组合、依赖。关系比较多，而且有些还比较相近，比如聚合和组合，接下来我就逐一讲解一下。</p>
<p>泛化（Generalization）可以简单理解为继承关系。具体到 Java 代码就是下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class A &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">public class B extends A &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>实现（Realization）一般是指接口和实现类之间的关系。具体到 Java 代码就是下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface A &#123;...&#125;</span><br><span class="line"></span><br><span class="line">public class B implements A &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>聚合（Aggregation）是一种包含关系，A 类对象包含 B 类对象，B 类对象的生命周期可以不依赖 A 类对象的生命周期，也就是说可以单独销毁 A 类对象而不影响 B 对象，比如课程与学生之间的关系。具体到 Java 代码就是下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class A &#123; </span><br><span class="line">	private B b; </span><br><span class="line">	public A(B b) &#123;</span><br><span class="line">    	this.b = b; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组合（Composition）也是一种包含关系。A 类对象包含 B 类对象，B 类对象的生命周期跟依赖 A 类对象的生命周期，B 类对象不可单独存在，比如鸟与翅膀之间的关系。具体到 Java 代码就是下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class A &#123; </span><br><span class="line">    private B b; </span><br><span class="line">    public A() &#123; </span><br><span class="line">    	this.b = new B(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关联（Association）是一种非常弱的关系，包含聚合、组合两种关系。具体到代码层面，如果 B 类对象是 A 类的成员变量，那 B 类和 A 类就是关联关系。具体到 Java 代码就是下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class A &#123; </span><br><span class="line">    private B b; </span><br><span class="line">    public A(B b) &#123;</span><br><span class="line">    	this.b = b; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">public class A &#123; </span><br><span class="line">    private B b;</span><br><span class="line">    public A() &#123;</span><br><span class="line">    	this.b = new B(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依赖（Dependency）是一种比关联关系更加弱的关系，包含关联关系。不管是 B 类对象是 A 类对象的成员变量，还是 A 类的方法使用 B 类对象作为参数或者返回值、局部变量，只要 B 类对象和 A 类对象有任何使用关系，我们都称它们有依赖关系。具体到 Java 代码就是下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class A &#123; </span><br><span class="line">    private B b; </span><br><span class="line">    public A(B b) &#123;</span><br><span class="line">    	this.b = b; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line">public class A &#123;</span><br><span class="line">    private B b; </span><br><span class="line">    public A() &#123; </span><br><span class="line">    	this.b = new B(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line">public class A &#123;</span><br><span class="line">	public void func(B b) &#123;</span><br><span class="line">		... </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-面向对象的四大特性"><a href="#1-2-面向对象的四大特性" class="headerlink" title="1.2 面向对象的四大特性"></a>1.2 面向对象的四大特性</h2><ul>
<li><p>封装：封装特性存在的意义，一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用性。</p>
</li>
<li><p>抽象：抽象存在的意义，一方面是提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围；另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。</p>
</li>
<li><p>继承：继承主要是用来解决代码复用的问题。</p>
</li>
<li><p>多态：多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础</p>
</li>
</ul>
<h2 id="1-3-面向对象编程-vs-面向过程编程（OPP）"><a href="#1-3-面向对象编程-vs-面向过程编程（OPP）" class="headerlink" title="1.3 面向对象编程 vs 面向过程编程（OPP）"></a>1.3 面向对象编程 vs 面向过程编程（OPP）</h2><h4 id="1-OOP-更加能够应对大规模复杂程序的开发"><a href="#1-OOP-更加能够应对大规模复杂程序的开发" class="headerlink" title="1. OOP 更加能够应对大规模复杂程序的开发"></a>1. OOP 更加能够应对大规模复杂程序的开发</h4><p>面向对象编程是以类为思考对象。在进行面向对象编程的时候，我们并不是一上来就去思考，如何将复杂的流程拆解为一个一个方法，而是采用曲线救国的策略，<strong>先去思考如何给业务建模，如何将需求翻译为类，如何给类之间建立交互关系，而完成这些工作完全不需要考虑错综复杂的处理流程</strong>。当我们有了类的设计之后，然后再像搭积木一样，按照处理流程，将类组装起来形成整个程序。</p>
<h4 id="2-OOP-风格的代码更易复用、易扩展、易维护"><a href="#2-OOP-风格的代码更易复用、易扩展、易维护" class="headerlink" title="2. OOP 风格的代码更易复用、易扩展、易维护"></a>2. OOP 风格的代码更易复用、易扩展、易维护</h4><p>面向对象编程提供的封装、抽象、继承、多态这些特性，能极大地满足复杂的编程需求，能方便我们写出更易 复用、易扩展、易维护的代码。</p>
<h4 id="3-OOP-语言更加人性化、更加高级、更加智能"><a href="#3-OOP-语言更加人性化、更加高级、更加智能" class="headerlink" title="3. OOP 语言更加人性化、更加高级、更加智能"></a>3. OOP 语言更加人性化、更加高级、更加智能</h4><p>跟二进制指令、汇编语言、面向过程编程语言相比，面向对象编程语言的编程套路、思考问题的方式，是完全 不一样的。前三者是一种计算机思维方式，而面向对象是一种人类的思维方式。我们在用前面三种语言编程的时候，我们是在思考，如何设计一组指令，告诉机器去执行这组指令，操作某些数据，帮我们完成某个任务。而<strong>在进行面向对象编程时候，我们是在思考，如何给业务建模，如何将真实的世界映射为类或者对象，这让我们更加能聚焦到业务本身，而不是思考如何跟机器打交道。</strong>可以这么说，越高级的编程语言离机器越“远”，离我们人类越“近”，越“智能”。</p>
<h2 id="1-4-面向对象误区"><a href="#1-4-面向对象误区" class="headerlink" title="1.4 面向对象误区"></a>1.4 面向对象误区</h2><h4 id="1-哪些代码设计看似是面向对象，实际是面向过程的？"><a href="#1-哪些代码设计看似是面向对象，实际是面向过程的？" class="headerlink" title="1. 哪些代码设计看似是面向对象，实际是面向过程的？"></a>1. 哪些代码设计看似是面向对象，实际是面向过程的？</h4><ol>
<li><p>滥用 getter、setter 方法</p>
<p>在设计实现类的时候，除非真的需要，否则尽量不要给属性定义 setter 方法。除此之外，尽管 getter 方法相对 setter 方法要安全些，但是如果返回的是集合容器，那也要防范集合内部数据被修改的风险。</p>
</li>
<li><p>Constants 类、Utils 类的设计问题</p>
<p>对于这两种类的设计，我们尽量能做到职责单一，定义一些细化的小类，比如 RedisConstants、FileUtils，而不是定义一个大而全的 Constants 类、Utils 类。除此之外，如果能将这些类中的属性和方法，划分归并到其他业务类中，那是最好不过的了，能极大地提高类的内聚性和代码的可复用性。</p>
</li>
</ol>
<h4 id="2-在面向对象编程中，为什么容易写出面向过程风格的代码？"><a href="#2-在面向对象编程中，为什么容易写出面向过程风格的代码？" class="headerlink" title="2. 在面向对象编程中，为什么容易写出面向过程风格的代码？"></a>2. 在面向对象编程中，为什么容易写出面向过程风格的代码？</h4><ol>
<li><p>面向过程更符合人类的思考习惯。</p>
<p>你可以联想一下，在生活中，你去完成一个任务，你一般都会思考，应该先做什么、后做什么，如何一步一步地顺序执行一系列操作，最后完成整个任务。面向过程编程风格恰恰符合人的这种流程化思维方式。而面向对象编程风格正好相反。它是一种自底向上的思考方式。它不是先去按照执行流程来分解任务，而是将任务翻译成一个一个的小的模块（也就是类），设计类之间的交互，最后按照流程将类组装起来，完成整个任务。</p>
</li>
<li><p>面向对象编程要比面向过程编程难一些。</p>
<p>在面向对象编程中，类的设计还是挺需要技巧，挺需要一定设计经验的。你要去思考如何封装合适的数据和方法到一个类里，如何设计类之间的关系，如何设计类之间的交互等等诸多设计问题。</p>
</li>
</ol>
<h4 id="3-面向过程编程及面向过程编程语言就真的无用武之地了吗？"><a href="#3-面向过程编程及面向过程编程语言就真的无用武之地了吗？" class="headerlink" title="3. 面向过程编程及面向过程编程语言就真的无用武之地了吗？"></a>3. 面向过程编程及面向过程编程语言就真的无用武之地了吗？</h4><p>实际上，面向过程编程是面向对象编程的基础，面向对象编程离不开基础的面向过程编程。为什么这么说？我们仔细想想，类中每个方法的实现逻辑，不就是面向过程风格的代码吗？</p>
<p>不管使用面向过程还是面向对象哪种风格来写代码，我们最终的目的还是写出易维护、易读、易复用、易扩展的高质量代码。只要我们能避免面向过程编程风格的一些弊端，控制好它的副作用，在掌控范围内为我们所用，我们就大可不用避讳在面向对象编程中写面向过程风格的代码。重点回顾</p>
<h2 id="1-5-接口-vs-抽象类"><a href="#1-5-接口-vs-抽象类" class="headerlink" title="1.5 接口 vs 抽象类"></a>1.5 接口 vs 抽象类</h2><h4 id="1-接口和抽象类的区别"><a href="#1-接口和抽象类的区别" class="headerlink" title="1. 接口和抽象类的区别"></a>1. 接口和抽象类的区别</h4><p>抽象类特性：</p>
<ul>
<li>抽象类不允许被实例化，只能被继承。也就是说，你不能 new 一个抽象类的对象出来。</li>
<li>抽象类可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的方法叫作抽象方法。</li>
<li>子类继承抽象类，必须实现抽象类中的所有抽象方法。</li>
</ul>
<p>相比于普通类，抽象类具有多态的特性，同时明确标记需要子类复写的方法，避免出错。</p>
<p>接口的特性：</p>
<ul>
<li><p>接口不能包含属性（也就是成员变量）。</p>
</li>
<li><p>接口只能声明方法，方法不能包含代码实现。</p>
</li>
<li><p>类实现接口的时候，必须实现接口中声明的所有方法。</p>
</li>
</ul>
<p>抽象类更多的是为了代码复用，而接口就更侧重于解耦。接口是对行为的一种抽象，相当于一组协议或者契约，你可以联想类比一下 API 接口。调用者只需要关注抽象的接口，不需要了解具体的实现，具体的实现代码对调用者透明。接口实现了约定和实现相分离，可以降低代码间的耦合性，提高代码的可扩展性。</p>
<h4 id="2-如何决定该用抽象类还是接口？"><a href="#2-如何决定该用抽象类还是接口？" class="headerlink" title="2. 如何决定该用抽象类还是接口？"></a>2. 如何决定该用抽象类还是接口？</h4><p>实际上，判断的标准很简单。<strong>如果我们要表示一种 is-a 的关系，并且是为了解决代码复用的问题</strong>，我们就用抽象类；<strong>如果我们要表示一种 has-a 关系，并且是为了解决抽象而非代码复用的问题</strong>，那我们就可以使用接口。</p>
<p>从类的继承层次上来看，<strong>抽象类是一种自下而上的设计思路</strong>，先有子类的代码重复，然后再抽象成上层的父类（也就是抽象类）。而接口正好相反，<strong>它是一种自上而下的设计思路</strong>。我们在编程的时候，一般都是先设计接口，再去考虑具体的实现。</p>
<h2 id="1-6-基于接口编程"><a href="#1-6-基于接口编程" class="headerlink" title="1.6 基于接口编程"></a>1.6 基于接口编程</h2><h4 id="1-基于接口而非实现编程"><a href="#1-基于接口而非实现编程" class="headerlink" title="1. 基于接口而非实现编程"></a>1. 基于接口而非实现编程</h4><p>应用这条原则，可以将接口和实现相分离，<strong>封装不稳定的实现，暴露稳定的接口</strong>。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低耦合性，提高扩展性。</p>
<p>“基于接口而非实现编程”这条原则的另一个表述方式，是“基于抽象而非实现编程”。后者的表述方式其实更能体现这条原则的设计初衷。在软件开发中，最大的挑战之一就是需求的不断变化，这也是考验代码设计好坏的一个标准。<strong>越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。</strong>而抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。</p>
<p>“基于接口而非实现编程”的原则，具体来讲，我们需要做到下面这 3 点。</p>
<ol>
<li>函数的命名不能暴露任何实现细节，使用更加抽象的命名方式。与特定实现有关的方法不要定义在接口中。</li>
<li>封装具体的实现细节。</li>
<li>具体的实现类都依赖统一的接口定义，遵从一致的上传功能协议。使用者依赖接口，而不是具体的实现类来编程</li>
</ol>
<h4 id="2-有必要为每个类都定义接口吗？"><a href="#2-有必要为每个类都定义接口吗？" class="headerlink" title="2. 有必要为每个类都定义接口吗？"></a>2. 有必要为每个类都定义接口吗？</h4><p>从这个设计初衷上来看，如果在我们的业务场景中<strong>，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口</strong>，也没有必要基于接口编程，直接使用实现类就可以了。</p>
<h2 id="1-7-组合-vs-继承"><a href="#1-7-组合-vs-继承" class="headerlink" title="1.7 组合 vs 继承"></a>1.7 组合 vs 继承</h2><h4 id="1-为什么不推荐使用继承？"><a href="#1-为什么不推荐使用继承？" class="headerlink" title="1. 为什么不推荐使用继承？"></a>1. 为什么不推荐使用继承？</h4><p>继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。在这种情况下，我们应该尽量少用，甚至不用继承。</p>
<h4 id="2-组合相比继承有哪些优势？"><a href="#2-组合相比继承有哪些优势？" class="headerlink" title="2. 组合相比继承有哪些优势？"></a>2. 组合相比继承有哪些优势？</h4><p>继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用。而这三个作用都可以通过组合、接口、委托三个技术手段来达成。除此之外，利用组合还能解决层次过深、过复杂的继承关系影响代码可维护性的问题。</p>
<h4 id="3-如何判断该用组合还是继承？"><a href="#3-如何判断该用组合还是继承？" class="headerlink" title="3. 如何判断该用组合还是继承？"></a>3. 如何判断该用组合还是继承？</h4><p>尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。在实际的项目开发中，我们还是要根据具体的情况，来选择该用继承还是组合。如果类之间的继承结构稳定，层次比较浅，关系不复杂，我们就可以大胆地使用继承。反之，我们就尽量使用组合来替代继承。除此之外，还有一些设计模式、特殊的应用场景，会固定使用继承或者组合。</p>
<h2 id="二、设计原则与思想"><a href="#二、设计原则与思想" class="headerlink" title="二、设计原则与思想"></a>二、设计原则与思想</h2><p>我们开始学习一些经典的设计原则，其中包括，SOLID、KISS、YAGNI、DRY、LOD 等。 这些设计原则，从字面上理解，都不难。你一看就感觉懂了，一看就感觉掌握了，但真的用到项目中的时候，你会发现，“看懂”和“会用”是两回事，而“用好”更是难上加难。</p>
<h2 id="2-1-SOLID-原则"><a href="#2-1-SOLID-原则" class="headerlink" title="2.1 SOLID 原则"></a>2.1 SOLID 原则</h2><p>实际上，SOLID 原则并非单纯的 1 个原则，而是由 5 个设计原则组成的，它们分别是：单一职责原则、开闭原则、里式替换原则、接口隔离原则和依赖反转原则，依次对应 SOLID 中的 S、O、L、I、D 这 5 个英文字母。</p>
<h3 id="2-1-1-单一职责原则（SRP）"><a href="#2-1-1-单一职责原则（SRP）" class="headerlink" title="2.1.1 单一职责原则（SRP）"></a>2.1.1 单一职责原则（SRP）</h3><p>一个类或者模块只负责完成一个职责（或者功能）。从类的角度来讲，不要设计大而全的类，要设计粒度小、功能单一的类。换个角度来讲就是，一个类包含了两个或者两个以上业务不相干的功能，那我们就说它职责不够单一，应该将它拆分成多个功能更加单一、粒度更细的类。</p>
<h4 id="1-如何理解单一职责原则（SRP-–-Single-Responsibility-Principle）？"><a href="#1-如何理解单一职责原则（SRP-–-Single-Responsibility-Principle）？" class="headerlink" title="1.如何理解单一职责原则（SRP – Single Responsibility Principle）？"></a>1.如何理解单一职责原则（SRP – Single Responsibility Principle）？</h4><p>一个类只负责完成一个职责或者功能。不要设计大而全的类，要设计粒度小、功能单一的类。单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。</p>
<h4 id="2-如何判断类的职责是否足够单一？"><a href="#2-如何判断类的职责是否足够单一？" class="headerlink" title="2.如何判断类的职责是否足够单一？"></a>2.如何判断类的职责是否足够单一？</h4><p>不同的应用场景、不同阶段的需求背景、不同的业务层面，对同一个类的职责是否单一，可能会有不同的判定结果。实际上，一些侧面的判断指标更具有指导意义和可执行性，比如，出现下面这些情况就有可能说明这类的设计不满足单一职责原则：</p>
<ul>
<li><p>类中的代码行数、函数或者属性过多；</p>
</li>
<li><p>类依赖的其他类过多，或者依赖类的其他类过多；</p>
</li>
<li><p>私有方法过多；</p>
</li>
<li><p>比较难给类起一个合适的名字；</p>
</li>
<li><p>类中大量的方法都是集中操作类中的某几个属性。</p>
</li>
</ul>
<h4 id="3-类的职责是否设计得越单一越好？"><a href="#3-类的职责是否设计得越单一越好？" class="headerlink" title="3.类的职责是否设计得越单一越好？"></a>3.类的职责是否设计得越单一越好？</h4><p>单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、低耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。</p>
<h3 id="2-1-2-开闭原则（OCP）"><a href="#2-1-2-开闭原则（OCP）" class="headerlink" title="2.1.2 开闭原则（OCP）"></a>2.1.2 开闭原则（OCP）</h3><p>软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。</p>
<p>这个描述比较简略，如果我们详细表述一下，那就是，添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。</p>
<h4 id="1-如何理解“对扩展开放、对修改关闭”？"><a href="#1-如何理解“对扩展开放、对修改关闭”？" class="headerlink" title="1.如何理解“对扩展开放、对修改关闭”？"></a>1.如何理解“对扩展开放、对修改关闭”？</h4><p>添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。关于定义，我们有两点要注意。</p>
<p>第一点是，开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。</p>
<p>第二点是，同样的代码改动，在粗代码粒度下，可能被认定为“修改”；在细代码粒度下，可能又被认定为“扩展”。</p>
<h4 id="2-如何做到“对扩展开放、修改关闭”？"><a href="#2-如何做到“对扩展开放、修改关闭”？" class="headerlink" title="2.如何做到“对扩展开放、修改关闭”？"></a>2.如何做到“对扩展开放、修改关闭”？</h4><p>我们要时刻具备扩展意识、抽象意识、封装意识。在写代码的时候，我们要多花点时间思考一下，这段代码未来可能有哪些需求变更，如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，在不改动代码整体结构、做到最小代码改动的情况下，将新的代码灵活地插入到扩展点上。</p>
<p>很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的。特别是 23 种经典设计模式，大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的。最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态）。</p>
<h3 id="2-1-3-里式替换（LSP）"><a href="#2-1-3-里式替换（LSP）" class="headerlink" title="2.1.3 里式替换（LSP）"></a>2.1.3 里式替换（LSP）</h3><p>子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且<strong>保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。</strong></p>
<h4 id="1-如何理解“里式替换原则”？"><a href="#1-如何理解“里式替换原则”？" class="headerlink" title="1.如何理解“里式替换原则”？"></a>1.如何理解“里式替换原则”？</h4><p>理解里式替换原则，最核心的就是理解“design by contract，<strong>按照协议来设计</strong>”这几个字。父类定义了函数的“约定”（或者叫协议），那子类可以改变函数的内部实现逻辑，但不能改变函数原有的“约定”。这里的约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。</p>
<h4 id="2-里式替换-vs-多态"><a href="#2-里式替换-vs-多态" class="headerlink" title="2.里式替换 vs 多态"></a>2.里式替换 vs 多态</h4><p>理解这个原则，我们还要弄明白里式替换原则跟多态的区别。虽然从定义描述和代码实现上来看，多态和里式替换有点类似，但它们关注的角度是不一样的。<strong>多态是面向对象编程的一大特性</strong>，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而<strong>里式替换是一种设计原则</strong>，用来指导继承关系中子类该如何设计<strong>，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性</strong>。</p>
<h4 id="3-哪些代码明显违背了-LSP？"><a href="#3-哪些代码明显违背了-LSP？" class="headerlink" title="3.哪些代码明显违背了 LSP？"></a>3.哪些代码明显违背了 LSP？</h4><ol>
<li>子类违背父类声明要实现的功能父类中提供的 sortOrdersByAmount() 订单排序函数，是按照金额从小到大来给订单排序的，而子类重写这个 sortOrdersByAmount() 订单排序函数之后，是按照创建日期来给订单排序的。那子类的设计就违背里式替换原则。</li>
<li>子类违背父类对输入、输出、异常的约定在父类中，某个函数约定：运行出错的时候返回 null；获取数据为空的时候返回空集合（empty collection）。而子类重载函数之后，实现变了，运行出错返回异常（exception），获取不到数据返回 null。那子类的设计就违背里式替换原则。在父类中，某个函数约定，输入数据可以是任意整数，但子类实现的时候，只允许输入数据是正整数，负数就抛出，也就是说，子类对输入的数据的校验比父类更加严格，那子类的设计就违背了里式替换原则。在父类中，某个函数约定，只会抛出 ArgumentNullException 异常，那子类的设计实现中只允许抛出 ArgumentNullException 异常，任何其他异常的抛出，都会导致子类违背里式替换原则。</li>
<li>子类违背父类注释中所罗列的任何特殊说明父类中定义的 withdraw() 提现函数的注释是这么写的：“用户的提现金额不得超过账户余额……”，而子类重写 withdraw() 函数之后，针对 VIP 账号实现了透支提现的功能，也就是提现金额可以大于账户余额，那这个子类的设计也是不符合里式替换原则的。</li>
</ol>
<h3 id="2-1-4-接口隔离原则（ISP）"><a href="#2-1-4-接口隔离原则（ISP）" class="headerlink" title="2.1.4 接口隔离原则（ISP）"></a>2.1.4 接口隔离原则（ISP）</h3><p>客户端不应该被强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者。</p>
<h4 id="1-如何理解“接口隔离原则”？"><a href="#1-如何理解“接口隔离原则”？" class="headerlink" title="1.如何理解“接口隔离原则”？"></a>1.如何理解“接口隔离原则”？</h4><p>理解“接口隔离原则”的重点是理解其中的“接口”二字。这里有三种不同的理解。</p>
<p>如果把“接口”理解为一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口等。<strong>如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。</strong></p>
<p>如果把“接口”理解为单个 API 接口或函数，<strong>部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数</strong>。</p>
<p>如果把“接口”理解为 OOP 中的接口，也可以理解为面向对象编程语言中的接口语法。<strong>那接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数</strong>。</p>
<h4 id="2-接口隔离原则与单一职责原则的区别？"><a href="#2-接口隔离原则与单一职责原则的区别？" class="headerlink" title="2.接口隔离原则与单一职责原则的区别？"></a>2.接口隔离原则与单一职责原则的区别？</h4><p>单一职责原则针对的是模块、类、接口的设计。接口隔离原则相对于单一职责原则，一方面更侧重于接口的设计，另一方面它的思考角度也是不同的。<strong>接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定</strong>。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。</p>
<h3 id="2-1-5-依赖反转原则（DIP）"><a href="#2-1-5-依赖反转原则（DIP）" class="headerlink" title="2.1.5 依赖反转原则（DIP）"></a>2.1.5 依赖反转原则（DIP）</h3><p>高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。</p>
<h4 id="1-控制反转（IOC）"><a href="#1-控制反转（IOC）" class="headerlink" title="1.控制反转（IOC）"></a>1.控制反转（IOC）</h4><p><strong>控制反转并不是一种具体的实现技巧，而是一个比较笼统的设计思想</strong>，一般用来指导框架层面的设计。框架提供了一个可扩展的代码骨架，用来组装对象、管理整个执行流程。程序员利用框架进行开发的时候，只需要往预留的扩展点上，添加跟自己业务相关的代码，就可以利用框架来驱动整个程序流程的执行，比如模板设计模式。</p>
<p>这里的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。<strong>在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员“反转”到了框架。</strong></p>
<h4 id="2-依赖注入（DI）"><a href="#2-依赖注入（DI）" class="headerlink" title="2.依赖注入（DI）"></a>2.依赖注入（DI）</h4><p>依赖注入跟控制反转恰恰相反，它是一种具体的编码技巧。不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。</p>
<p>通过依赖注入的方式来将依赖的类对象传递进来，这样就提高了代码的扩展性，我们可以灵活地替换依赖的类。</p>
<h4 id="3-依赖反转原则"><a href="#3-依赖反转原则" class="headerlink" title="3. 依赖反转原则"></a>3. 依赖反转原则</h4><p>依赖反转原则也叫作依赖倒置原则。这条原则跟控制反转有点类似，<strong>主要用来指导框架层面的设计。高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不要依赖具体实现细节，具体实现细节依赖抽象。</strong></p>
<p>所谓高层模块和低层模块的划分，简单来说就是，在调用链上，调用者属于高层，被调用者属于低层。在平时的业务代码开发中，高层模块依赖底层模块是没有任何问题的。实际上，这条原则主要还是用来指导框架层面的设计，跟前面讲到的控制反转类似。</p>
<p>高层次模块不依赖于低层次模块。看似在要求高层次模块，实际上是在规范低层次模块的设计。低层次模块提供的接口要足够的抽象、通用，在设计时需要考虑高层次模块的使用种类和场景。</p>
<p><strong>明明是高层次模块要使用低层次模块，对低层次模块有依赖性。现在反而低层次模块需要根据高层次模块来设计，出现了「倒置」的显现。</strong></p>
<h2 id="2-2-KISS原则"><a href="#2-2-KISS原则" class="headerlink" title="2.2 KISS原则"></a>2.2 KISS原则</h2><p>Keep It Short and Simple——尽量保持简单。</p>
<p>KISS 原则是保持代码可读和可维护的重要手段。KISS 原则中的“简单”并不是以代码行数来考量的。代码行数越少并不代表代码越简单，我们还要考虑逻辑复杂度、实现难度、代码的可读性等。而且，本身就复杂的问题，用复杂的方法解决，并不违背 KISS 原则。除此之外，同样的代码，在某个业务场景下满足 KISS 原则，换一个应用场景可能就不满足了。</p>
<p>如何写出满足 KISS 原则的代码？</p>
<ol>
<li>不要使用同事可能不懂的技术来实现代码；</li>
<li>不要重复造轮子，要善于使用已经有的工具类库；</li>
<li>不要过度优化。</li>
</ol>
<h2 id="2-3-YAGNI原则"><a href="#2-3-YAGNI原则" class="headerlink" title="2.3 YAGNI原则"></a>2.3 YAGNI原则</h2><p>You Ain’t Gonna Need It ——你不会需要它。</p>
<p>不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：不要做过度设计。</p>
<h2 id="2-4-DRY-原则"><a href="#2-4-DRY-原则" class="headerlink" title="2.4 DRY 原则"></a>2.4 DRY 原则</h2><p>Don’t Repeat Yourself ——不要重复自己。将它应用在编程中，可以理解为：不要写重复的代码。</p>
<h4 id="1-三种代码重复的情况？"><a href="#1-三种代码重复的情况？" class="headerlink" title="1. 三种代码重复的情况？"></a>1. 三种代码重复的情况？</h4><p>实现逻辑重复、功能语义重复、代码执行重复。<strong>实现逻辑重复，但功能语义不重复的代码，并不违反 DRY 原则</strong>。对于包含重复代码的问题，我们可以通过抽象成更细粒度函数的方式来解决。<strong>实现逻辑不重复，但功能语义重复的代码</strong>，也算是违反 DRY 原则。除此之外，代码执行重复也算是违反 DRY 原则。</p>
<h4 id="2-代码的复用性？"><a href="#2-代码的复用性？" class="headerlink" title="2.代码的复用性？"></a>2.代码的复用性？</h4><p>我们首先来区分三个概念：代码复用性（Code Reusability）、代码复用（Code Resue）和 DRY 原则。代码复用表示一种行为：我们在开发新功能的时候，尽量复用已经存在的代码。代码的可复用性表示一段代码可被复用的特性或能力：我们在编写代码的时候，让代码尽量可复用。DRY 原则是一条原则：不要写重复的代码。从定义描述上，它们好像有点类似，但深究起来，三者的区别还是蛮大的。</p>
<p>首先，“不重复”并不代表“可复用”。在一个项目代码中，可能不存在任何重复的代码，但也并不表示里面有可复用的代码，不重复和可复用完全是两个概念。所以，从这个角度来说，DRY 原则跟代码的可复用性讲的是两回事。</p>
<p>其次，“复用”和“可复用性”关注角度不同。<strong>代码“可复用性”是从代码开发者的角度来讲的，“复用”是从代码使用者的角度来讲的</strong>。比如，A 同事编写了一个 UrlUtils 类，代码的“可复用性”很好。B 同事在开发新功能的时候，直接“复用”A 同事编写的 UrlUtils 类。</p>
<h4 id="3-怎么提高代码复用性？"><a href="#3-怎么提高代码复用性？" class="headerlink" title="3.怎么提高代码复用性？"></a>3.怎么提高代码复用性？</h4><ul>
<li>减少代码耦合</li>
<li>满足单一职责原则</li>
<li>模块化业务</li>
<li>与非业务逻辑分离</li>
<li>通用代码下沉</li>
<li>继承、多态、抽象、封装</li>
<li>应用模板等设计模式</li>
</ul>
<h4 id="4-“Rule-of-Three”原则"><a href="#4-“Rule-of-Three”原则" class="headerlink" title="4.“Rule of Three”原则"></a>4.“Rule of Three”原则</h4><p>第一次编写代码的时候，我们不考虑复用性；第二次遇到复用场景的时候，再进行重构使其复用。需要注意的是，“Rule of Three”中的“Three”并不是真的就指确切的“三”，这里就是指“二”。</p>
<h2 id="2-5-迪米特法则（LOD）"><a href="#2-5-迪米特法则（LOD）" class="headerlink" title="2.5 迪米特法则（LOD）"></a>2.5 迪米特法则（LOD）</h2><p>不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口（也就是定义中的“有限知识”）</p>
<h4 id="1-如何理解“高内聚、松耦合”？"><a href="#1-如何理解“高内聚、松耦合”？" class="headerlink" title="1.如何理解“高内聚、松耦合”？"></a>1.如何理解“高内聚、松耦合”？</h4><p>“高内聚、松耦合”是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。</p>
<p>所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中。所谓松耦合指的是，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动也不会或者很少导致依赖类的代码改动。</p>
<h4 id="2-如何理解“迪米特法则”？"><a href="#2-如何理解“迪米特法则”？" class="headerlink" title="2.如何理解“迪米特法则”？"></a>2.如何理解“迪米特法则”？</h4><p><strong>不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。</strong>迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。</p>
<h2 id="2-6-如何做需求分析和设计？"><a href="#2-6-如何做需求分析和设计？" class="headerlink" title="2.6 如何做需求分析和设计？"></a>2.6 如何做需求分析和设计？</h2><h4 id="1-如何做系统设计？"><a href="#1-如何做系统设计？" class="headerlink" title="1.如何做系统设计？"></a>1.如何做系统设计？</h4><ol>
<li>合理地将功能划分到不同模块</li>
<li>设计模块与模块之间的交互关系</li>
<li>设计模块的接口、数据库、业务模型</li>
</ol>
<h4 id="2-为什么要分-MVC-三层开发？"><a href="#2-为什么要分-MVC-三层开发？" class="headerlink" title="2.为什么要分 MVC 三层开发？"></a>2.为什么要分 MVC 三层开发？</h4><p>对于这个问题，我总结了以下 5 点原因。</p>
<ul>
<li>分层能起到代码复用的作用</li>
<li>分层能起到隔离变化的作用</li>
<li>分层能起到隔离关注点的作用</li>
<li>分层能提高代码的可测试性</li>
<li>分层能应对系统的复杂性</li>
</ul>
<h2 id="三、重构"><a href="#三、重构" class="headerlink" title="三、重构"></a>三、重构</h2><h2 id="3-1-什么情况下要重构？到底重构什么？又该如何重构？"><a href="#3-1-什么情况下要重构？到底重构什么？又该如何重构？" class="headerlink" title="3.1 什么情况下要重构？到底重构什么？又该如何重构？"></a>3.1 什么情况下要重构？到底重构什么？又该如何重构？</h2><h4 id="1-重构的目的：为什么重构（why）？"><a href="#1-重构的目的：为什么重构（why）？" class="headerlink" title="1.重构的目的：为什么重构（why）？"></a>1.重构的目的：为什么重构（why）？</h4><p>对于项目来言，重构可以保持代码质量持续处于一个可控状态，不至于腐化到无可救药的地步。对于个人而言，重构非常锻炼一个人的代码能力，并且是一件非常有成就感的事情。它是我们学习的经典设计思想、原则、模式、编程规范等理论知识的练兵场。</p>
<h4 id="2-重构的对象：重构什么（what）？"><a href="#2-重构的对象：重构什么（what）？" class="headerlink" title="2.重构的对象：重构什么（what）？"></a>2.重构的对象：重构什么（what）？</h4><p>按照重构的规模，我们可以将重构大致分为大规模高层次的重构和小规模低层次的重构。</p>
<p>大规模高层次重构包括对代码分层、模块化、解耦、梳理类之间的交互关系、抽象复用组件等等。这部分工作利用的更多的是比较抽象、比较顶层的设计思想、原则、模式。</p>
<p>小规模低层次的重构包括规范命名、注释、修正函数参数过多、消除超大类、提取重复代码等等编程细节问题，主要是针对类、函数级别的重构。小规模低层次的重构更多的是利用编码规范这一理论知识。</p>
<h4 id="3-重构的时机：什么时候重构（when）？"><a href="#3-重构的时机：什么时候重构（when）？" class="headerlink" title="3.重构的时机：什么时候重构（when）？"></a>3.重构的时机：什么时候重构（when）？</h4><p>建立持续重构意识，把重构作为开发必不可少的部分，融入到日常开发中，而不是等到代码出现很大问题的时候，再大刀阔斧地重构。</p>
<h4 id="4-重构的方法：如何重构（how）？"><a href="#4-重构的方法：如何重构（how）？" class="headerlink" title="4.重构的方法：如何重构（how）？"></a>4.重构的方法：如何重构（how）？</h4><p>大规模高层次的重构难度比较大，需要组织、有计划地进行，分阶段地小步快跑，时刻让代码处于一个可运行的状态。而小规模低层次的重构，因为影响范围小，改动耗时短，所以，只要你愿意并且有时间，随时随地都可以去做。</p>
<h2 id="3-2-保证重构质量"><a href="#3-2-保证重构质量" class="headerlink" title="3.2 保证重构质量"></a>3.2 保证重构质量</h2><p><a target="_blank" rel="noopener" href="https://juejin.im/entry/5acad0806fb9a028cd456236">Java服务端单元测试指南</a></p>
<h4 id="1-什么是单元测试？"><a href="#1-什么是单元测试？" class="headerlink" title="1.什么是单元测试？"></a>1.什么是单元测试？</h4><p>单元测试是代码层面的测试，由研发自己来编写，用于测试“自己”编写的代码的逻辑的正确性。单元测试顾名思义是测试一个“单元”，有别于集成测试，这个“单元”一般是类或函数，而不是模块或者系统。</p>
<h4 id="2-为什么要写单元测试？"><a href="#2-为什么要写单元测试？" class="headerlink" title="2.为什么要写单元测试？"></a>2.为什么要写单元测试？</h4><p>写单元测试的过程本身就是代码 Code Review 和重构的过程，能有效地发现代码中的 bug 和代码设计上的问题。除此之外，单元测试还是对集成测试的有力补充，还能帮助我们快速熟悉代码，是 TDD 可落地执行的改进方案。</p>
<h4 id="3-如何编写单元测试？"><a href="#3-如何编写单元测试？" class="headerlink" title="3.如何编写单元测试？"></a>3.如何编写单元测试？</h4><p>写单元测试就是针对代码设计各种测试用例，以覆盖各种输入、异常、边界情况，并将其翻译成代码。我们可以利用一些测试框架来简化单元测试的编写。除此之外，对于单元测试，我们需要建立以下正确的认知：编写单元测试尽管繁琐，但并不是太耗时；我们可以稍微放低对单元测试代码质量的要求；覆盖率作为衡量单元测试质量的唯一标准是不合理的；单元测试不要依赖被测代码的具体实现逻辑；单元测试框架无法测试，多半是因为代码的可测试性不好。</p>
<h4 id="4-单元测试为何难落地执行？"><a href="#4-单元测试为何难落地执行？" class="headerlink" title="4.单元测试为何难落地执行？"></a>4.单元测试为何难落地执行？</h4><p>一方面，写单元测试本身比较繁琐，技术挑战不大，很多程序员不愿意去写；另一方面，国内研发比较偏向“快、糙、猛”，容易因为开发进度紧，导致单元测试的执行虎头蛇尾。最后，关键问题还是团队没有建立对单元测试正确的认识，觉得可有可无，单靠督促很难执行得很好。</p>
<h2 id="3-3-重构-解耦"><a href="#3-3-重构-解耦" class="headerlink" title="3.3 重构-解耦"></a>3.3 重构-解耦</h2><h4 id="1-“解耦”为何如此重要？"><a href="#1-“解耦”为何如此重要？" class="headerlink" title="1.“解耦”为何如此重要？"></a>1.“解耦”为何如此重要？</h4><p>过于复杂的代码往往在可读性、可维护性上都不友好。解耦保证代码松耦合、高内聚，是控制代码复杂度的有效手段。代码高内聚、松耦合，也就是意味着，代码结构清晰、分层模块化合理、依赖关系简单、模块或类之间的耦合小，那代码整体的质量就不会差。</p>
<h4 id="2-代码是否需要“解耦”？"><a href="#2-代码是否需要“解耦”？" class="headerlink" title="2. 代码是否需要“解耦”？"></a>2. 代码是否需要“解耦”？</h4><p>间接的衡量标准有很多，比如，看修改代码是否牵一发而动全身。直接的衡量标准是把模块与模块、类与类之间的依赖关系画出来，根据依赖关系图的复杂性来判断是否需要解耦重构。</p>
<h4 id="3-如何给代码“解耦”？"><a href="#3-如何给代码“解耦”？" class="headerlink" title="3. 如何给代码“解耦”？"></a>3. 如何给代码“解耦”？</h4><p>封装与抽象、中间层、模块化，以及一些其他的设计思想与原则，比如：单一职责原则、基于接口而非实现编程、依赖注入、多用组合少用继承、迪米特法则等。当然，还有一些设计模式，比如观察者模式。</p>
<h2 id="3-4-编码规范"><a href="#3-4-编码规范" class="headerlink" title="3.4 编码规范"></a>3.4 编码规范</h2><p>1.关于命名命名的关键是能准确达意。</p>
<ul>
<li>对于不同作用域的命名，我们可以适当地选择不同的长度。</li>
<li>我们可以借助类的信息来简化属性、函数的命名，利用函数的信息来简化函数参数的命名。</li>
<li>命名要可读、可搜索。</li>
<li>不要使用生僻的、不好读的英文单词来命名。命</li>
<li>名要符合项目的统一规范，也不要用些反直觉的命名。</li>
<li>接口有两种命名方式：一种是在接口中带前缀“I”；另一种是在接口的实现类中带后缀“Impl”。</li>
<li>对于抽象类的命名，也有两种方式，一种是带上前缀“Abstract”，一种是不带前缀。这两种命名方式都可以，关键是要在项目中统一。</li>
</ul>
<p>2.关于注释</p>
<ul>
<li>注释的内容主要包含这样三个方面：做什么、为什么、怎么做。对于一些复杂的类和接口，我们可能还需要写明“如何用”。</li>
<li>类和函数一定要写注释，而且要写得尽可能全面详细。函数内部的注释要相对少一些，一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码可读性。</li>
</ul>
<p>3.关于代码风格函数、类多大才合适？</p>
<ul>
<li>函数的代码行数不要超过一屏幕的大小，比如 50 行。类的大小限制比较难确定。</li>
<li>一行代码多长最合适？最好不要超过 IDE 的显示宽度。当然，也不能太小，否则会导致很多稍微长点的语句被折成两行，也会影响到代码的整洁，不利于阅读。</li>
<li>善用空行分割单元块。对于比较长的函数，为了让逻辑更加清晰，可以使用空行来分割各个代码块。</li>
<li>四格缩进还是两格缩进？我个人比较推荐使用两格缩进，这样可以节省空间，尤其是在代码嵌套层次比较深的情况下。不管是用两格缩进还是四格缩进，一定不要用 tab 键缩进。</li>
<li>大括号是否要另起一行？将大括号放到跟上一条语句同一行，可以节省代码行数。但是将大括号另起新的一行的方式，左右括号可以垂直对齐，哪些代码属于哪一个代码块，更加一目了然。</li>
<li>类中成员怎么排列？在 Google Java 编程规范中，依赖类按照字母序从小到大排列。类中先写成员变量后写函数。成员变量之间或函数之间，先写静态成员变量或函数，后写普通变量或函数，并且按照作用域大小依次排列。</li>
</ul>
<p>4.关于编码技巧</p>
<ul>
<li>将复杂的逻辑提炼拆分成函数和类。</li>
<li>通过拆分成多个函数或将参数封装为对象的方式，来处理参数过多的情况。</li>
<li>函数中不要使用参数来做代码执行逻辑的控制。</li>
<li>函数设计要职责单一。</li>
<li>移除过深的嵌套层次，方法包括：去掉多余的 if 或 else 语句，使用 continue、break、return 关键字提前退出嵌套，调整执行顺序来减少嵌套，将部分嵌套逻辑抽象成函数。</li>
<li>用字面常量取代魔法数。</li>
<li>用解释性变量来解释复杂表达式，以此提高代码可读性。</li>
</ul>
<h2 id="3-5-总结"><a href="#3-5-总结" class="headerlink" title="3.5 总结"></a>3.5 总结</h2><p><img src="/pics/34c51d1eb44ffc099d448ad10bcda82b.jpg" alt="34c51d1eb44ffc099d448ad10bcda82b"></p>
<p><img src="/pics/f4ce06502a9782d200e8e10a90bf2ce7.jpg" alt="f4ce06502a9782d200e8e10a90bf2ce7"></p>
<p><img src="/pics/fbf1ae0ce08d4ea890b80944c2b8309f-1593607047324.jpg" alt="fbf1ae0ce08d4ea890b80944c2b8309f"></p>
<p><img src="/pics/fc56f7c2b348d324c93a09dd0dee538a.jpg" alt="fc56f7c2b348d324c93a09dd0dee538a"></p>
<h2 id="3-6-实战课"><a href="#3-6-实战课" class="headerlink" title="3.6 实战课"></a>3.6 实战课</h2><p><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/179644">https://time.geekbang.org/column/article/179644</a></p>
<p><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/179673">https://time.geekbang.org/column/article/179673</a></p>
<p><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/193221">https://time.geekbang.org/column/article/193221</a></p>
<p><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/193555">https://time.geekbang.org/column/article/193555</a></p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>跟进用途设计模式可分为3种：</p>
<ul>
<li>创建型模式主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。其中，单例模式用来创建全局唯一的对象。工厂模式用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。原型模式针对创建成本比较大的对象，利用对已有对象进行复制的方式进行创建，以达到节省创建时间的目的。</li>
<li>结构型模式主要总结了一些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。结构型模式包括：代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式。</li>
<li>行为型设计模式主要解决的是“类或对象之间的交互”问题。行为型设计模式比较多，有 11 个，几乎占了 23 种经典设计模式的一半。它们分别是：观察者模式、模板模式、策略模式、职责链模式、状态模式、迭代器模式、访问者模式、备忘录模式、命令模式、解释器模式、中介模式。</li>
</ul>
<h2 id="四、创建型设计模式"><a href="#四、创建型设计模式" class="headerlink" title="四、创建型设计模式"></a>四、创建型设计模式</h2><h2 id="4-1-单例设计模式"><a href="#4-1-单例设计模式" class="headerlink" title="4.1 单例设计模式"></a>4.1 单例设计模式</h2><p>一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</p>
<h3 id="1-为什么使用单例？"><a href="#1-为什么使用单例？" class="headerlink" title="1.为什么使用单例？"></a>1.为什么使用单例？</h3><ol>
<li><p>处理资源访问冲突</p>
</li>
<li><p>表示全局唯一类</p>
</li>
</ol>
<h3 id="2-单例的5种写法？"><a href="#2-单例的5种写法？" class="headerlink" title="2.单例的5种写法？"></a>2.单例的5种写法？</h3><h4 id="1-饿汉式"><a href="#1-饿汉式" class="headerlink" title="1.饿汉式"></a>1.饿汉式</h4><p>饿汉式的实现方式，在类加载的期间，就已经将 instance 静态实例初始化好了，所以，instance 实例的创建是线程安全的。不过，这样的实现方式不支持延迟加载实例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class IdGenerator &#123;</span><br><span class="line">    private static final IdGenerator Instance = new IdGenerator();</span><br><span class="line"></span><br><span class="line">    private IdGenerator() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static IdGenerator getInstance() &#123;</span><br><span class="line">        return Instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-懒汉式"><a href="#2-懒汉式" class="headerlink" title="2.懒汉式"></a>2.懒汉式</h4><p>懒汉式相对于饿汉式的优势是支持延迟加载，不过懒汉式的缺点也很明显，我们给 getInstance() 这个方法加了一把大锁（synchronzed），导致性能降低。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class IdGenerator &#123; </span><br><span class="line">  private static IdGenerator instance;</span><br><span class="line">  private IdGenerator() &#123;&#125;</span><br><span class="line">  public static synchronized IdGenerator getInstance() &#123;</span><br><span class="line">    if (instance == null) &#123;</span><br><span class="line">      instance = new IdGenerator();</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-双重检测机制"><a href="#3-双重检测机制" class="headerlink" title="3.双重检测机制"></a>3.双重检测机制</h4><p>假如在某一瞬间线程A和线程B都在调用getInstance()方法，此时instance对象为null值，均能通 过instance == null的判断。由于实现了synchronized加锁机制，线程A进入synchronized锁定的代 码中执行实例创建代码，线程B处于排队等待状态，必须等待线程A执行完毕后才可以进入 synchronized锁定代码。但当A执行完毕时，线程B并不知道实例已经创建，将继续创建新的实例，导致产生多个单例对象，违背单例模式的设计思想，因此需要进行进一步改进，在 synchronized中再进行一次(instance == null)判断，这种方式称为双重检查锁定(Double-Check Locking)。</p>
<p>因为指令重排序，可能会导致 IdGenerator 对象被 new 出来，并且赋值给 instance 之后，还没来得及初始化，就被另一个线程使用了。我们需要给 instance 成员变量加上 volatile 关键字，禁止指令重排序才行。实际上，只有很低版本的 Java 才会有这个问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span>&#123; </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> IdGenerator instance;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">IdGenerator</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(IdGenerator.class) &#123; <span class="comment">// 此处为类级别的锁</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">          instance = <span class="keyword">new</span> IdGenerator();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-静态内部类"><a href="#4-静态内部类" class="headerlink" title="4.静态内部类"></a>4.静态内部类</h4><p>SingletonHolder 是一个静态内部类，当外部类 IdGenerator 被加载的时候，并不会创建 SingletonHolder 实例对象。只有当调用 getInstance() 方法时，SingletonHolder 才会被加载，这个时候才会创建 instance。instance 的唯一性、创建过程的线程安全性，都由 JVM 来保证。所以，这种实现方法既保证了线程安全，又能做到延迟加载。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class IdGenerator &#123; </span><br><span class="line">  private IdGenerator() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  private static class SingletonHolder&#123;</span><br><span class="line">    private static final IdGenerator instance = new IdGenerator();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static IdGenerator getInstance() &#123;</span><br><span class="line">    return SingletonHolder.instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-枚举"><a href="#5-枚举" class="headerlink" title="5.枚举"></a>5.枚举</h4><p>最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public enum IdGenerator &#123;</span><br><span class="line">  INSTANCE;</span><br><span class="line">  private AtomicLong id = new AtomicLong(0);</span><br><span class="line"></span><br><span class="line">  public long getId() &#123; </span><br><span class="line">    return id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-懒汉式比饿汉式更好吗？"><a href="#3-懒汉式比饿汉式更好吗？" class="headerlink" title="3. 懒汉式比饿汉式更好吗？"></a>3. 懒汉式比饿汉式更好吗？</h3><p>有人认为饿汉式的实现方式不好，因为不支持延迟加载，如果实例占用资源多（比如占用内存多）或初始化耗时长（比如需要加载各种配置文件），提前初始化实例是一种浪费资源的行为。最好的方法应该在用到的时候再去初始化。不过，我个人并不认同这样的观点。</p>
<p><strong>如果初始化耗时长，那我们最好不要等到真正要用它的时候，才去执行这个耗时长的初始化过程，这会影响到系统的性能</strong>（比如，在响应客户端接口请求的时候，做这个初始化操作，会导致此请求的响应时间变长，甚至超时）。采用饿汉式实现方式，将耗时的初始化操作，提前到程序启动的时候完成，这样就能避免在程序运行的时候，再去初始化导致的性能问题。</p>
<p><strong>如果实例占用资源多，按照 fail-fast 的设计原则（有问题及早暴露），那我们也希望在程序启动时就将这个实例初始化好</strong>。如果资源不够，就会在程序启动的时候触发报错（比如 Java 中的 PermGen Space OOM），我们可以立即去修复。这样也能避免在程序运行一段时间后，突然因为初始化这个实例占用资源过多，导致系统崩溃，影响系统的可用性。</p>
<h3 id="4-如何理解单例的模式的全局唯一性？"><a href="#4-如何理解单例的模式的全局唯一性？" class="headerlink" title="4. 如何理解单例的模式的全局唯一性？"></a>4. 如何理解单例的模式的全局唯一性？</h3><p>单例模式创建的对象是进程唯一的。“进程唯一”指的是进程内唯一，进程间不唯一；“线程唯一”指的是线程内唯一，线程间可以不唯一。实际上，“进程唯一”就意味着线程内、线程间都唯一，这也是“进程唯一”和“线程唯一”的区别之处。“集群唯一”指的是进程内唯一、进程间也唯一。</p>
<h3 id="5-如何实现线程唯一的单例？"><a href="#5-如何实现线程唯一的单例？" class="headerlink" title="5.如何实现线程唯一的单例？"></a>5.如何实现线程唯一的单例？</h3><p>我们通过一个 HashMap 来存储对象，其中 key 是线程 ID，value 是对象。这样我们就可以做到，不同的线程对应不同的对象，同一个线程只能对应一个对象。实际上，Java 语言本身提供了 <strong>ThreadLocal</strong> 并发工具类，可以更加轻松地实现线程唯一单例。</p>
<h2 id="4-2-工厂模式"><a href="#4-2-工厂模式" class="headerlink" title="4.2 工厂模式"></a>4.2 工厂模式</h2><p>当创建逻辑比较复杂，是一个“大工程”的时候，我们就考虑使用工厂模式。</p>
<h3 id="1-工厂模式的分类？"><a href="#1-工厂模式的分类？" class="headerlink" title="1.工厂模式的分类？"></a>1.工厂模式的分类？</h3><h4 id="1-简单工厂"><a href="#1-简单工厂" class="headerlink" title="1.简单工厂"></a>1.简单工厂</h4><p>又叫静态工厂方法，因为在简单工厂模式中用于创建实例的方法是静态方法。</p>
<p><img src="/pics/image-20200529101403310.png" alt="image-20200529101403310"></p>
<h4 id="2-工厂方法"><a href="#2-工厂方法" class="headerlink" title="2.工厂方法"></a>2.工厂方法</h4><p>简单工厂模式最大的 缺点是当有新产品要加入到系统中时，必须修改工厂类，需要在其中加入必要的业务逻辑， 这违背了“开闭原则”。</p>
<p>当对象的创建逻辑比较复杂，<strong>不只是简单的 new 一下就可以，而是要组合其他类对象，做各种初始化操作的时候，</strong>我们推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。典型UML图如下：</p>
<p><img src="/pics/image-20200506180721332.png" alt="image-20200506180721332"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Client &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        LoggerFactory factory;</span><br><span class="line">        Logger logger;</span><br><span class="line">        factory = new FileLoggerFactory(); //可引入配置文件实现</span><br><span class="line">        logger = factory.createLogger();</span><br><span class="line">        logger.writeLog();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-抽象工厂"><a href="#3-抽象工厂" class="headerlink" title="3.抽象工厂"></a>3.抽象工厂</h4><p>与工厂方法模式相比，抽象工厂模式中的具体工厂不只是创建一种产品，它负责创建一族产品。</p>
<p><img src="/pics/image-20200506201358048.png" alt="image-20200506201358048"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Factory vivoFactory = new VivoFactory();</span><br><span class="line">vivoFactory.createMobile().call();</span><br><span class="line">vivoFactory.createTv().play();</span><br></pre></td></tr></table></figure>

<h3 id="2-工厂模式使用的场景，何谓创建逻辑比较复杂呢？"><a href="#2-工厂模式使用的场景，何谓创建逻辑比较复杂呢？" class="headerlink" title="2.工厂模式使用的场景，何谓创建逻辑比较复杂呢？"></a>2.工厂模式使用的场景，何谓创建逻辑比较复杂呢？</h3><ul>
<li><p>类似规则配置解析的例子，<strong>代码中存在 if-else 分支判断，动态地根据不同的类型创建不同的对象</strong>。针对这种情况，我们就考虑使用工厂模式，将这一大坨 if-else 创建对象的代码抽离出来，放到工厂类中。还有一种情况，尽管我们不需要根据不同的类型创建不同的对象，但是，单个对象本身的创建过程比较复杂，比如前面提到的要组合其他类对象，做各种初始化操作。在这种情况下，我们也可以考虑使用工厂模式，将对象的创建过程封装到工厂类中。</p>
</li>
<li><p>尽管我们不需要根据不同的类型创建不同的对象，但是，<strong>单个对象本身的创建过程比较复杂</strong>，比如前面提到的要组合其他类对象，做各种初始化操作。在这种情况下，我们也可以考虑使用工厂模式，将对象的创建过程封装到工厂类中。</p>
</li>
</ul>
<h2 id="4-3-建造者模式"><a href="#4-3-建造者模式" class="headerlink" title="4.3 建造者模式"></a>4.3 建造者模式</h2><p>建造者模式是让建造者类来负责对象的创建工作。</p>
<h3 id="1-与工厂模式有何区别？"><a href="#1-与工厂模式有何区别？" class="headerlink" title="1. 与工厂模式有何区别？"></a>1. 与工厂模式有何区别？</h3><p>工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。<strong>建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象，同时可在创建时多传入参数进行验证。</strong></p>
<p>举例，顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。</p>
<h3 id="2-建造者模式的应用场景？"><a href="#2-建造者模式的应用场景？" class="headerlink" title="2.建造者模式的应用场景？"></a>2.建造者模式的应用场景？</h3><p>如果一个类中有很多属性，为了避免构造函数的参数列表过长，影响代码的可读性和易用性，我们可以通过构造函数配合 set() 方法来解决。但是，如果存在下面情况中的任意一种，我们就要考虑使用建造者模式了。</p>
<ul>
<li>我们把类的必填属性放到构造函数中，强制创建对象的时候就设置。如果必填的属性有很多，把这些必填属性都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填属性通过 set() 方法设置，那校验这些必填属性是否已经填写的逻辑就无处安放了。</li>
<li><strong>如果类的属性之间有一定的依赖关系或者约束条件，我们继续使用构造函数配合 set() 方法的设计思路，那这些依赖关系或约束条件的校验逻辑就无处安放了</strong>。比如创建一个长方形时同时需要长宽2个参数，否则就是无意义的。</li>
<li><strong>如果我们希望创建不可变对象</strong>，也就是说，对象在创建好之后，就不能再修改内部的属性值，要实现这个功能，我们就不能在类中暴露 set() 方法。构造函数配合 set() 方法来设置属性值的方式就不适用了。</li>
</ul>
<h2 id="4-4-原型模式"><a href="#4-4-原型模式" class="headerlink" title="4.4 原型模式"></a>4.4 原型模式</h2><p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大，在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。</p>
<p>在开发过程中，尽量避免浅拷贝共享对象，可能会导致共享数据被修改的情况，没有充分的理由，不要为了一点点的性能提升而使用浅拷贝。</p>
<h3 id="1-深拷贝vs浅拷贝？"><a href="#1-深拷贝vs浅拷贝？" class="headerlink" title="1.深拷贝vs浅拷贝？"></a>1.深拷贝vs浅拷贝？</h3><p>浅拷贝和深拷贝的区别在于，浅拷贝只会复制图中的索引，不会复制数据本身。相反，深拷贝不仅仅会复制索引，还会复制数据本身。浅拷贝得到的对象跟原始对象共享数据，而深拷贝得到的是一份完完全全独立的对象。</p>
<h3 id="2-深拷贝的2种方式？"><a href="#2-深拷贝的2种方式？" class="headerlink" title="2.深拷贝的2种方式？"></a>2.深拷贝的2种方式？</h3><ul>
<li>第一种方法：递归拷贝对象、对象的引用对象以及引用对象的引用对象，直到要拷贝的对象只包含基本数据类型数据，没有引用对象为止。参考Android Intent的clone方法。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Student implements Cloneable &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public Student(String s) &#123;</span><br><span class="line">        name = s;</span><br><span class="line">        subj = new Subject(sub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object clone() &#123;</span><br><span class="line">        // 深拷贝，创建拷贝类的一个新对象，这样就和原始对象相互独立</span><br><span class="line">        Student s = new Student(name);</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第二种方法：先将对象序列化，然后再反序列化成新的对象。具体的示例代码如下所示：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public Object deepCopy(Object object) &#123;</span><br><span class="line">  //将对象写入流中</span><br><span class="line">  ByteArrayOutputStream bo = new ByteArrayOutputStream();</span><br><span class="line">  ObjectOutputStream oo = new ObjectOutputStream(bo);</span><br><span class="line">  oo.writeObject(object);</span><br><span class="line"></span><br><span class="line">  //将对象从流中取出</span><br><span class="line">  ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());</span><br><span class="line">  ObjectInputStream oi = new ObjectInputStream(bi);</span><br><span class="line"></span><br><span class="line">  return oi.readObject();</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<h2 id="五、结构型设计模式"><a href="#五、结构型设计模式" class="headerlink" title="五、结构型设计模式"></a>五、结构型设计模式</h2><p>结构型模式主要总结了一些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。结构型模式包括：代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式。</p>
<h2 id="5-1-代理模式"><a href="#5-1-代理模式" class="headerlink" title="5.1 代理模式"></a>5.1 代理模式</h2><p>当无法直接访问某个对象或访问某个对象存在困难 时可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，所访问的真实对象与 代理对象需要实现相同的接口。</p>
<p>代理模式常用在业务系统中开发一些非功能性需求，比如：<strong>监控、统计</strong>、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类统一处理，让程序员只需要关注业务方面的开发。</p>
<p><img src="/pics/image-20200508201754929.png" alt="image-20200508201754929"></p>
<h3 id="1-静态代理的2种实现方式？"><a href="#1-静态代理的2种实现方式？" class="headerlink" title="1.静态代理的2种实现方式？"></a>1.静态代理的2种实现方式？</h3><ul>
<li>第一种，代理类和原始类实现相同的接口。</li>
<li>第二种，采用继承的方式进行扩展，适用场景：如果原始类并没有定义接口，或者没办法直接修改原始类。</li>
</ul>
<p>这2种方式，一种基于组合一种基于继承，组合模式的优点在于更加灵活，对于接口的所有子类都可以代理，缺点在于不需要扩展的方法也需要进行代理。<br>继承模式的优点在于只需要针对需要扩展的方法进行代理，缺点在于只能针对单一父类进行代理。</p>
<h3 id="2-动态代理？"><a href="#2-动态代理？" class="headerlink" title="2.动态代理？"></a>2.动态代理？</h3><p>动态代理的原理与实现静态代理需要针对每个类都创建一个代理类，<strong>并且每个代理类中的代码都有点像模板式的“重复”代码</strong>，增加了维护成本和开发成本。对于静态代理存在的问题，我们可以通过动态代理来解决。我们不事先为每个原始类编写代理类，而是在运行的时候动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/23d3f1a2b3c7">Java动态代理实现及原理分析</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">// 1.定义接口</span><br><span class="line">public interface UserService &#123;</span><br><span class="line">    void select();</span><br><span class="line"></span><br><span class="line">    void update();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserServiceImpl implements UserService&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void select() &#123;</span><br><span class="line">        System.out.println(&quot;查询 selectById&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void update() &#123;</span><br><span class="line">        System.out.println(&quot;更新 update&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2.动态代理对象调用目标对象的任何方法前，都会调用调用处理器类的invoke（）</span><br><span class="line">public class DynamicProxyHandler implements InvocationHandler &#123;</span><br><span class="line">    // 被代理的对象，实际的方法执行者</span><br><span class="line">    Object target;</span><br><span class="line"></span><br><span class="line">    public DynamicProxyHandler(Object target) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        before();</span><br><span class="line">        Object result = method.invoke(target, args);  // 调用 target 的 method 方法</span><br><span class="line">        after();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void before() &#123;</span><br><span class="line">        System.out.println(&quot;before ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void after() &#123;</span><br><span class="line">        System.out.println(&quot;after ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3.绑定代理和handler</span><br><span class="line">public class DynamicProxy &#123;</span><br><span class="line">    public static Object createProxy(Object proxyObject) &#123;</span><br><span class="line">        DynamicProxyHandler handler = new DynamicProxyHandler(proxyObject);</span><br><span class="line">        // 根据指定的类装载器、一组接口 &amp; 调用处理器 生成动态代理类实例，并最终返回</span><br><span class="line">        // 参数说明：</span><br><span class="line">        // 参数1：指定产生代理对象的类加载器，需要将其指定为和目标对象同一个类加载器</span><br><span class="line">        // 参数2：指定目标对象的实现接口</span><br><span class="line">        // 即要给目标对象提供一组什么接口。若提供了一组接口给它，那么该代理对象就默认实现了该接口，这样就能调用这组接口中的方法</span><br><span class="line">        // 参数3：指定InvocationHandler对象。即动态代理对象在调用方法时，会关联到哪个InvocationHandler对象</span><br><span class="line">        return Proxy.newProxyInstance(proxyObject.getClass().getClassLoader(), proxyObject.getClass().getInterfaces(), handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 4.代理类执行</span><br><span class="line">// 4.1 设置变量可以保存动态代理类，默认名称以 $Proxy0 格式命名</span><br><span class="line">System.getProperties().setProperty(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</span><br><span class="line"></span><br><span class="line">UserService proxy = (UserService) DynamicProxy.createProxy(new UserServiceImpl());</span><br><span class="line">proxy.select();</span><br><span class="line">proxy.update();</span><br></pre></td></tr></table></figure>

<h2 id="5-2-桥接模式"><a href="#5-2-桥接模式" class="headerlink" title="5.2  桥接模式"></a>5.2  桥接模式</h2><p>将抽象和实现解耦，让它们可以独立变化。还有另外一种理解方式：<strong>一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展</strong>。通过组合关系来替代继承关系，避免继承层次的指数级爆炸。这种理解方式非常类似于，我们之前讲过的“组合优于继承”设计原则，</p>
<p><img src="/pics/image-20200507195435427.png" alt="image-20200507195435427"></p>
<p>比如饮料有咖啡、茶，这2中饮料都存在苹果味、橘子味。如果顾客要一杯苹果味的咖啡、橘子味的茶；如果反之呢，该如何设计才能满足用户灵活的需求呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// 饮料</span><br><span class="line">public abstract class Drink &#123;</span><br><span class="line">    protected Flavor flavor;</span><br><span class="line"></span><br><span class="line">    public Drink(Flavor flavor) &#123;</span><br><span class="line">        this.flavor = flavor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    abstract void make();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 口味</span><br><span class="line">public interface Flavor &#123;</span><br><span class="line">    void make(String drink);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Coffee extends Drink &#123;</span><br><span class="line">    public Coffee(Flavor flavor) &#123;</span><br><span class="line">        super(flavor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void make() &#123;</span><br><span class="line">        flavor.add(&quot;coffee&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Tea extends Drink &#123;</span><br><span class="line">    public Tea(Flavor flavor) &#123;</span><br><span class="line">        super(flavor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void make() &#123;</span><br><span class="line">        flavor.add(&quot;tea&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class AppleFlavor implements Flavor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void add(String drink) &#123;</span><br><span class="line">        System.out.println(&quot;make apple flavor &quot; + drink );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class OrangeFlavor implements Flavor&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void add(String drink) &#123;</span><br><span class="line">        System.out.println(&quot;make orange flavor &quot; + drink );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Flavor flavor = new AppleFlavor();</span><br><span class="line">Drink drink = new Coffee(flavor);</span><br><span class="line">drink.make();</span><br></pre></td></tr></table></figure>

<h2 id="5-3-装饰器模式"><a href="#5-3-装饰器模式" class="headerlink" title="5.3 装饰器模式"></a>5.3 装饰器模式</h2><p><strong>装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承。</strong>它主要的作用是给原始类添加增强功能。</p>
<p>Java IO类就是典型的装饰器模式。</p>
<p><img src="/pics/image-20200507210406322.png" alt="image-20200507210406322"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = new FileInputStream(&quot;/user/wangzheng/test.txt&quot;);</span><br><span class="line">InputStream bin = new BufferedInputStream(in);</span><br><span class="line">byte[] data = new byte[128];</span><br><span class="line">while (bin.read(data) != -1) &#123;</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个特点：<strong>装饰器类和原始类继承同样的父类</strong>，这样我们可以对原始类“嵌套”多个装饰器类。</p>
<p>第二个特点：装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点。和代理模式相比，代理类附加的是跟原始类无关的功能，而在装饰器模式中，装饰器类附加的是跟<strong>原始类相关的增强功能</strong>。</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 父类</span><br><span class="line">public abstract class Person &#123;</span><br><span class="line">    public abstract void dressed();</span><br><span class="line">&#125;</span><br><span class="line">// 原始类，待增强</span><br><span class="line">public class Boy extends Person &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void dressed() &#123;</span><br><span class="line">        System.out.println(&quot;boy dressed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 装饰类</span><br><span class="line">public class CheapPersonCloth extends Person &#123;</span><br><span class="line">    private Person person;</span><br><span class="line"></span><br><span class="line">    public CheapPersonCloth(Person p)&#123;</span><br><span class="line">        this.person = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void dressed() &#123;</span><br><span class="line">        super.dressed();</span><br><span class="line">        dressCheap();// 增强</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void dressCheap() &#123;</span><br><span class="line">        System.out.println(&quot;dress Cheap&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 装饰模式</span><br><span class="line">Person person = new Boy();</span><br><span class="line">CheapPersonCloth cheapCloth = new CheapPersonCloth(person);</span><br><span class="line">cheapCloth.dressed();</span><br></pre></td></tr></table></figure>

<h2 id="5-4-适配器模式"><a href="#5-4-适配器模式" class="headerlink" title="5.4 适配器模式"></a>5.4 适配器模式</h2><p>将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。客户端需要的是A接口，但是现在可提供是b，那么要统一暴露给外部A。</p>
<p>适配器模式通常有2种常见形式，类适配器和对象适配器。</p>
<p><img src="/pics/image-20200507211617343.png" alt="image-20200507211617343"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 类适配器: 基于继承</span><br><span class="line"></span><br><span class="line">public interface ITarget &#123; // 目标抽象类</span><br><span class="line">  void f1();</span><br><span class="line">  void f2();</span><br><span class="line">  void fc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Adaptee &#123; // 适配者类,定义了一个已经存在的接口，这个接口需要适配 </span><br><span class="line">  public void fa() &#123; //... &#125;</span><br><span class="line">  public void fb() &#123; //... &#125;</span><br><span class="line">  public void fc() &#123; //... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Adaptor extends Adaptee implements ITarget &#123;//适配器类</span><br><span class="line">  public void f1() &#123;</span><br><span class="line">    super.fa();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void f2() &#123;</span><br><span class="line">    //...重新实现f2()...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/pics/image-20200507211926651.png" alt="image-20200507211926651"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 对象适配器：基于组合</span><br><span class="line">public interface ITarget &#123;</span><br><span class="line">  void f1();</span><br><span class="line">  void f2();</span><br><span class="line">  void fc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Adaptee &#123;</span><br><span class="line">  public void fa() &#123; //... &#125;</span><br><span class="line">  public void fb() &#123; //... &#125;</span><br><span class="line">  public void fc() &#123; //... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Adaptor implements ITarget &#123;</span><br><span class="line">  private Adaptee adaptee;</span><br><span class="line"></span><br><span class="line">  public Adaptor(Adaptee adaptee) &#123;</span><br><span class="line">    this.adaptee = adaptee;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void f1() &#123;</span><br><span class="line">    adaptee.fa(); //委托给Adaptee</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void f2() &#123;</span><br><span class="line">    //...重新实现f2()...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void fc() &#123;</span><br><span class="line">    adaptee.fc();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-类适配器-vs-对象适配器？"><a href="#1-类适配器-vs-对象适配器？" class="headerlink" title="1. 类适配器 vs 对象适配器？"></a>1. 类适配器 vs 对象适配器？</h3><ul>
<li>如果 Adaptee 接口并不多，那两种实现方式都可以。</li>
<li><strong>如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都相同，</strong>那我们推荐使用类适配器，因为 Adaptor 复用父类 Adaptee 的接口，比起对象适配器的实现方式，Adaptor 的代码量要少一些。</li>
<li>如果 Adaptee 接口很多，而且 <strong>Adaptee 和 ITarget 接口定义大部分都不相同</strong>，那我们推荐使用对象适配器，因为组合结构相对于继承更加灵活。</li>
</ul>
<h3 id="2-那在实际的开发中，什么情况下才会出现接口不兼容呢？"><a href="#2-那在实际的开发中，什么情况下才会出现接口不兼容呢？" class="headerlink" title="2. 那在实际的开发中，什么情况下才会出现接口不兼容呢？"></a>2. 那在实际的开发中，什么情况下才会出现接口不兼容呢？</h3><ul>
<li>封装有缺陷的接口设计</li>
<li>统一多个类的接口设计</li>
<li>替换依赖的外部系统</li>
<li>兼容老版本接口</li>
<li>适配不同格式的数据</li>
</ul>
<h3 id="3-代理、桥接、装饰器、适配器-4-种设计模式的区别"><a href="#3-代理、桥接、装饰器、适配器-4-种设计模式的区别" class="headerlink" title="3. 代理、桥接、装饰器、适配器 4 种设计模式的区别"></a>3. 代理、桥接、装饰器、适配器 4 种设计模式的区别</h3><ul>
<li>代理模式：代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，<strong>主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同</strong>。</li>
<li>桥接模式：桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。</li>
<li>装饰器模式：装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。</li>
<li>适配器模式：适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。</li>
</ul>
<h2 id="5-5-门面（外观）模式"><a href="#5-5-门面（外观）模式" class="headerlink" title="5.5 门面（外观）模式"></a>5.5 门面（外观）模式</h2><p>为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。</p>
<p><img src="/pics/image-20200508204121839.png" alt="image-20200508204121839"></p>
<h3 id="1-门面模式的应用场景"><a href="#1-门面模式的应用场景" class="headerlink" title="1.门面模式的应用场景"></a>1.门面模式的应用场景</h3><ul>
<li><p>解决易用性问题。门面模式可以用来封装系统的底层实现，隐藏系统的复杂性，提供一组更加简单易用、更高层的接口。</p>
</li>
<li><p>解决性能问题。我们通过将多个接口调用替换为一个门面接口调用，减少网络通信成本，提高 App 客户端的响应速度。</p>
</li>
<li><p>解决分布式事务问题。要支持两个接口调用在一个事务中执行，是比较难实现的，这涉及分布式事务问题。虽然我们可以通过引入分布式事务框架或者事后补偿的机制来解决，但代码实现都比较复杂。而最简单的解决方案是，设计一个包裹这两个操作的新接口，让新接口在一个事务中执行两个 SQL 操作。</p>
</li>
</ul>
<h3 id="2-门面-vs-适配器？"><a href="#2-门面-vs-适配器？" class="headerlink" title="2.门面 vs 适配器？"></a>2.门面 vs 适配器？</h3><p>适配器模式注重的是兼容性，解决的是原接口和目标接口不匹配的问题。</p>
<p>而门面模式注重的是易用性，解决的是多接口调用带来的问题。</p>
<h2 id="5-6-组合模式"><a href="#5-6-组合模式" class="headerlink" title="5.6 组合模式"></a>5.6 组合模式</h2><p>将一组对象组织成树形结构，将单个对象和组合对象都看做树中的节点，<strong>以统一处理逻辑，并且它利用树形结构的特点，递归地处理每个子树，依次简化代码实现</strong>。使用组合模式的前提在于，你的业务场景必须能够表示成树形结构。所以，组合模式的应用场景也比较局限，它并不是一种很常用的设计模式。</p>
<p><img src="/pics/image-20200508210024521.png" alt="image-20200508210024521"></p>
<p>假设我们在开发一个 OA 系统（办公自动化系统）。公司的组织结构包含部门和员工两种数据类型。其中，部门又可以包含子部门和员工。在数据库中的表结构如下所示：<img src="/pics/image-20200508210435722.png" alt="image-20200508210435722"></p>
<p>我们希望在内存中构建整个公司的人员架构图（部门、子部门、员工的隶属关系），并且提供接口计算出部门的薪资成本（隶属于这个部门的所有员工的薪资和）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public interface HumanResource &#123;</span><br><span class="line">    double countSalary();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Department implements HumanResource &#123;</span><br><span class="line">    private List&lt;HumanResource&gt; humanResources = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public double countSalary() &#123;</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (HumanResource humanResource : humanResources) &#123;</span><br><span class="line">            count += humanResource.countSalary();</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void add(HumanResource humanResource) &#123;</span><br><span class="line">        humanResources.add(humanResource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Employee implements HumanResource &#123;</span><br><span class="line">    double salary;</span><br><span class="line"></span><br><span class="line">    public Employee(double salary) &#123;</span><br><span class="line">        this.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public double countSalary() &#123;</span><br><span class="line">        return salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 计算部门的薪资</span><br><span class="line">Department department = new Department();</span><br><span class="line">HumanResource humanResource = new Employee(1);</span><br><span class="line">HumanResource humanResource2 = new Employee(2);</span><br><span class="line">department.add(humanResource);</span><br><span class="line">System.out.println(department.countSalary());</span><br></pre></td></tr></table></figure>

<h2 id="5-7-享元模式"><a href="#5-7-享元模式" class="headerlink" title="5.7 享元模式"></a>5.7 享元模式</h2><p>所谓“享元”，顾名思义就是被共享的单元。<strong>享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象</strong>。</p>
<p>具体来讲，当一个系统中存在大量重复对象的时候，我们就可以利用享元模式，将对象设计成享元，在内存中只保留一份实例，供多处代码引用，这样可以减少内存中对象的数量，以起到节省内存的目的。实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段），提取出来设计成享元，让这些大量相似对象引用这些享元。</p>
<h3 id="1-享元模式的实现"><a href="#1-享元模式的实现" class="headerlink" title="1.享元模式的实现"></a>1.享元模式的实现</h3><p>享元模式的代码实现非常简单，主要是通过工厂模式，在工厂类中，通过一个 Map 或者 List 来缓存已经创建好的享元对象，以达到复用的目的。</p>
<p>假设我们在开发一个棋牌游戏（比如象棋）。一个游戏厅中有成千上万个“房间”，每个房间对应一个棋局。棋局要保存每个棋子的数据，比如：棋子类型（将、相、士、炮等）、棋子颜色（红方、黑方）、棋子在棋局中的位置。利用这些数据，我们就能显示一个完整的棋盘给玩家。具体的代码如下所示。其中，ChessPiece 类表示棋子，ChessBoard 类表示一个棋局，里面保存了象棋中 30 个棋子的信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">// 享元类</span><br><span class="line">public class ChessPieceUnit &#123;</span><br><span class="line">  private int id;</span><br><span class="line">  private String text;</span><br><span class="line">  private Color color;</span><br><span class="line"></span><br><span class="line">  public ChessPieceUnit(int id, String text, Color color) &#123;</span><br><span class="line">    this.id = id;</span><br><span class="line">    this.text = text;</span><br><span class="line">    this.color = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static enum Color &#123;</span><br><span class="line">    RED, BLACK</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // ...省略其他属性和getter方法...</span><br><span class="line">&#125;</span><br><span class="line">// 享元池</span><br><span class="line">public class ChessPieceUnitFactory &#123;</span><br><span class="line">  private static final Map&lt;Integer, ChessPieceUnit&gt; pieces = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  static &#123;</span><br><span class="line">    pieces.put(1, new ChessPieceUnit(1, &quot;車&quot;, ChessPieceUnit.Color.BLACK));</span><br><span class="line">    pieces.put(2, new ChessPieceUnit(2,&quot;馬&quot;, ChessPieceUnit.Color.BLACK));</span><br><span class="line">    //...省略摆放其他棋子的代码...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static ChessPieceUnit getChessPiece(int chessPieceId) &#123;</span><br><span class="line">    return pieces.get(chessPieceId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ChessPiece &#123;</span><br><span class="line">  private ChessPieceUnit chessPieceUnit;</span><br><span class="line">  private int positionX;</span><br><span class="line">  private int positionY;</span><br><span class="line"></span><br><span class="line">  public ChessPiece(ChessPieceUnit unit, int positionX, int positionY) &#123;</span><br><span class="line">    this.chessPieceUnit = unit;</span><br><span class="line">    this.positionX = positionX;</span><br><span class="line">    this.positionY = positionY;</span><br><span class="line">  &#125;</span><br><span class="line">  // 省略getter、setter方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ChessBoard &#123;</span><br><span class="line">  private Map&lt;Integer, ChessPiece&gt; chessPieces = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public ChessBoard() &#123;</span><br><span class="line">    init();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void init() &#123;</span><br><span class="line">    chessPieces.put(1, new ChessPiece(</span><br><span class="line">            ChessPieceUnitFactory.getChessPiece(1), 0,0));</span><br><span class="line">    chessPieces.put(1, new ChessPiece(</span><br><span class="line">            ChessPieceUnitFactory.getChessPiece(2), 1,0));</span><br><span class="line">    //...省略摆放其他棋子的代码...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void move(int chessPieceId, int toPositionX, int toPositionY) &#123;</span><br><span class="line">    //...省略...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码实现中，我们利用工厂类来缓存 ChessPieceUnit 信息。通过工厂类获取到的 ChessPieceUnit 就是享元。所有的 ChessBoard 对象共享这 30 个 ChessPieceUnit 对象（因为象棋中只有 30 个棋子）。注意：共享的单元是chessPieceUnit而不是ChessPiece（包含位置信息），<strong>享元模式要区分清楚可变和不可变的属性，不可变的属性是可以共享的，可变的不可以。</strong></p>
<h3 id="2-享元模式-VS-单例、缓存、对象池"><a href="#2-享元模式-VS-单例、缓存、对象池" class="headerlink" title="2.享元模式 VS 单例、缓存、对象池"></a>2.享元模式 VS 单例、缓存、对象池</h3><ul>
<li>应用单例模式是为了保证对象全局唯一。</li>
<li>应用享元模式是为了实现对象复用，节省内存。</li>
<li>缓存是为了提高访问效率，而非复用。</li>
<li>池化技术中的“复用”理解为“重复使用”，主要是为了节省时间。</li>
</ul>
<h3 id="3-剖析享元模式在Java-Integer、String中的应用"><a href="#3-剖析享元模式在Java-Integer、String中的应用" class="headerlink" title="3.剖析享元模式在Java Integer、String中的应用"></a><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/209343">3.剖析享元模式在Java Integer、String中的应用</a></h3><p>理解下面2段代码的输出，基本数据类型的对应包装类型的实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Integer i1 = 56;</span><br><span class="line">Integer i2 = 56;</span><br><span class="line">Integer i3 = 129;</span><br><span class="line">Integer i4 = 129;</span><br><span class="line">System.out.println(i1 == i2); // true </span><br><span class="line">System.out.println(i3 == i4); // false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String s1 = &quot;小争哥&quot;;</span><br><span class="line">String s2 = &quot;小争哥&quot;;</span><br><span class="line">String s3 = new String(&quot;小争哥&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2);//true</span><br><span class="line">System.out.println(s1 == s3);//false</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html">深入解析String#intern</a></p>
<p><code>String s = new String(&quot;1&quot;);</code> 第一句代码，生成了2个对象。常量池中的“1” 和 JAVA Heap 中的字符串对象。</p>
<p><code>String s2 = &quot;1&quot;;</code> 这句代码是生成一个 s2的引用指向常量池中的“1”对象。</p>
<ul>
<li>直接使用双引号声明出来的<code>String</code>对象会直接存储在常量池中。</li>
<li>如果不是用双引号声明的<code>String</code>对象，可以使用<code>String</code>提供的<code>intern</code>方法。intern 方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中</li>
</ul>
<p>小结：从上述的例子代码可以看出 jdk7 版本对 intern 操作和常量池都做了一定的修改。主要包括2点：</p>
<ul>
<li>将String常量池 从 Perm 区移动到了 Java Heap区</li>
<li><code>String#intern</code> 方法时，如果存在堆中的对象，会直接保存对象的引用，而不会重新创建对象。</li>
</ul>
<h2 id="六、行为型设计模式"><a href="#六、行为型设计模式" class="headerlink" title="六、行为型设计模式"></a>六、行为型设计模式</h2><h2 id="6-1-观察者模式"><a href="#6-1-观察者模式" class="headerlink" title="6.1 观察者模式"></a>6.1 观察者模式</h2><p>在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。</p>
<p><img src="/pics/image-20200520103154468.png" alt="image-20200520103154468"></p>
<h3 id="1-典型代码"><a href="#1-典型代码" class="headerlink" title="1.典型代码"></a>1.典型代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public interface Subject &#123;</span><br><span class="line">  void registerObserver(Observer observer);</span><br><span class="line">  void removeObserver(Observer observer);</span><br><span class="line">  void notifyObservers(Message message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Observer &#123;</span><br><span class="line">  void update(Message message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteSubject implements Subject &#123;</span><br><span class="line">  private List&lt;Observer&gt; observers = new ArrayList&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void registerObserver(Observer observer) &#123;</span><br><span class="line">    observers.add(observer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void removeObserver(Observer observer) &#123;</span><br><span class="line">    observers.remove(observer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void notifyObservers(Message message) &#123;</span><br><span class="line">    for (Observer observer : observers) &#123;</span><br><span class="line">      observer.update(message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteObserverOne implements Observer &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void update(Message message) &#123;</span><br><span class="line">    //TODO: 获取消息通知，执行自己的逻辑...</span><br><span class="line">    System.out.println(&quot;ConcreteObserverOne is notified.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteObserverTwo implements Observer &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void update(Message message) &#123;</span><br><span class="line">    //TODO: 获取消息通知，执行自己的逻辑...</span><br><span class="line">    System.out.println(&quot;ConcreteObserverTwo is notified.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    ConcreteSubject subject = new ConcreteSubject();</span><br><span class="line">    subject.registerObserver(new ConcreteObserverOne());</span><br><span class="line">    subject.registerObserver(new ConcreteObserverTwo());</span><br><span class="line">    subject.notifyObservers(new Message());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-EventBus"><a href="#2-EventBus" class="headerlink" title="2.EventBus"></a>2.EventBus</h3><p>观察者模式。根据应用场景的不同，观察者模式会对应不同的代码实现方式：有同步阻塞的实现方式，也有异步非阻塞的实现方式</p>
<h2 id="6-2-模板模式"><a href="#6-2-模板模式" class="headerlink" title="6.2 模板模式"></a>6.2 模板模式</h2><p>模板方法模式<strong>在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现</strong>。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。</p>
<p>在模板模式经典的实现中，模板方法定义为 final，可以避免被子类重写。需要子类重写的方法定义为 abstract，可以强迫子类去实现。</p>
<p><img src="/pics/image-20200520103312533.png" alt="image-20200520103312533"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractClass &#123;</span><br><span class="line">  public final void templateMethod() &#123;</span><br><span class="line">    //...</span><br><span class="line">    method1();</span><br><span class="line">    //...</span><br><span class="line">    method2();</span><br><span class="line">    //...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  protected abstract void method1();</span><br><span class="line">  protected abstract void method2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteClass1 extends AbstractClass &#123;</span><br><span class="line">  @Override</span><br><span class="line">  protected void method1() &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  protected void method2() &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteClass2 extends AbstractClass &#123;</span><br><span class="line">  @Override</span><br><span class="line">  protected void method1() &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  protected void method2() &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AbstractClass demo = ConcreteClass1();</span><br><span class="line">demo.templateMethod();</span><br></pre></td></tr></table></figure>

<h3 id="1-模板模式的两大作用"><a href="#1-模板模式的两大作用" class="headerlink" title="1.模板模式的两大作用"></a>1.模板模式的两大作用</h3><p>复用和扩展。其中，复用指的是，所有的子类可以复用父类中提供的模板方法的代码。扩展指的是，框架通过模板模式提供功能扩展点，让框架用户可以在不修改框架源码的情况下，基于扩展点定制化框架的功能。</p>
<h3 id="2-模板模式-VS-回调"><a href="#2-模板模式-VS-回调" class="headerlink" title="2.模板模式 VS 回调"></a>2.模板模式 VS 回调</h3><p>回调可以分为同步回调和异步回调（或者延迟回调）。同步回调指在函数返回之前执行回调函数；异步回调指的是在函数返回之后执行回调函数。同步回调相当于传入了一个方法，在调用者执行到这个方法时被调用，此时是调用者还未执行完毕。异步回调类似于注册监听者的方式，注册方法执行后，可能立刻会有回调，也可能方法执行完才有。</p>
<p>从应用场景上来看，同步回调跟模板模式几乎一致。它们都是在一个大的算法骨架中，自由替换其中的某个步骤，起到代码复用和扩展的目的。<strong>而异步回调跟模板模式有较大差别，更像是观察者模式</strong>。</p>
<p>从代码实现上来看，回调和模板模式完全不同。<strong>回调基于组合关系来实现，把一个对象传递给另一个对象，是一种对象之间的关系；模板模式基于继承关系来实现，子类重写父类的抽象方法，是一种类之间的关系</strong>。</p>
<h2 id="6-3-策略模式"><a href="#6-3-策略模式" class="headerlink" title="6.3  策略模式"></a>6.3  策略模式</h2><p>定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于调用者。</p>
<p><img src="/pics/image-20200521111434498.png" alt="image-20200521111434498"></p>
<h3 id="1-策略的定义"><a href="#1-策略的定义" class="headerlink" title="1.策略的定义"></a>1.策略的定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public interface Strategy &#123;</span><br><span class="line">  void algorithmInterface();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteStrategyA implements Strategy &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void  algorithmInterface() &#123;</span><br><span class="line">    //具体的算法...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteStrategyB implements Strategy &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void  algorithmInterface() &#123;</span><br><span class="line">    //具体的算法...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-策略的创建"><a href="#2-策略的创建" class="headerlink" title="2.策略的创建"></a>2.策略的创建</h3><p>因为策略模式会包含一组策略，在使用它们的时候，一般会通过类型（type）来判断创建哪个策略来使用。为了封装创建逻辑，我们需要对客户端代码屏蔽创建细节。我们可以把根据 type 创建策略的逻辑抽离出来，放到工厂类中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class StrategyFactory &#123;</span><br><span class="line">  private static final Map&lt;String, Strategy&gt; strategies = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  static &#123;</span><br><span class="line">    strategies.put(&quot;A&quot;, new ConcreteStrategyA());</span><br><span class="line">    strategies.put(&quot;B&quot;, new ConcreteStrategyB());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static Strategy getStrategy(String type) &#123;</span><br><span class="line">    if (type == null || type.isEmpty()) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;type should not be empty.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return strategies.get(type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>一般来讲，如果策略类是无状态的，不包含成员变量，只是纯粹的算法实现，这样的策略对象是可以被共享使用的，不需要在每次调用 getStrategy() 的时候，都创建一个新的策略对象。</strong>针对这种情况，我们可以使用上面这种工厂类的实现方式，事先创建好每个策略对象，缓存到工厂类中，用的时候直接返回。</p>
<p>相反，<strong>如果策略类是有状态的，根据业务场景的需要，我们希望每次从工厂方法中，获得的都是新创建的策略对象，</strong>而不是缓存好可共享的策略对象，那我们就需要按照如下方式来实现策略工厂类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class StrategyFactory &#123;</span><br><span class="line">  public static Strategy getStrategy(String type) &#123;</span><br><span class="line">    if (type == null || type.isEmpty()) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;type should not be empty.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (type.equals(&quot;A&quot;)) &#123;</span><br><span class="line">      return new ConcreteStrategyA();</span><br><span class="line">    &#125; else if (type.equals(&quot;B&quot;)) &#123;</span><br><span class="line">      return new ConcreteStrategyB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-策略的使用"><a href="#3-策略的使用" class="headerlink" title="3.策略的使用"></a>3.策略的使用</h3><p>策略模式包含一组可选策略，客户端代码一般如何确定使用哪个策略呢？最常见的是运行时动态确定使用哪种策略，这也是策略模式最典型的应用场景。<strong>这里的“运行时动态”指的是，我们事先并不知道会使用哪个策略，而是在程序运行期间，根据配置、用户输入、计算结果等这些不确定因素，动态决定使用哪种策略</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 策略接口：EvictionStrategy</span></span><br><span class="line"><span class="comment">// 策略类：LruEvictionStrategy、FifoEvictionStrategy、LfuEvictionStrategy...</span></span><br><span class="line"><span class="comment">// 策略工厂：EvictionStrategyFactory</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserCache</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, User&gt; cacheData = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> EvictionStrategy eviction;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UserCache</span><span class="params">(EvictionStrategy eviction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.eviction = eviction;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行时动态确定，根据配置文件的配置决定使用哪种策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    EvictionStrategy evictionStrategy = <span class="keyword">null</span>;</span><br><span class="line">    Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">    props.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;./config.properties&quot;</span>));</span><br><span class="line">    String type = props.getProperty(<span class="string">&quot;eviction_type&quot;</span>);</span><br><span class="line">    evictionStrategy = EvictionStrategyFactory.getEvictionStrategy(type);</span><br><span class="line">    UserCache userCache = <span class="keyword">new</span> UserCache(evictionStrategy);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非运行时动态确定，在代码中指定使用哪种策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    EvictionStrategy evictionStrategy = <span class="keyword">new</span> LruEvictionStrategy();</span><br><span class="line">    UserCache userCache = <span class="keyword">new</span> UserCache(evictionStrategy);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-如何利用策略模式避免分支判断？"><a href="#4-如何利用策略模式避免分支判断？" class="headerlink" title="4.如何利用策略模式避免分支判断？"></a>4.如何利用策略模式避免分支判断？</h3><p>查表法。实际上，能够移除分支判断逻辑的模式不仅仅有策略模式，后面我们要讲的状态模式也可以。对于使用哪种模式，具体还要看应用场景来定。 策略模式适用于根据不同类型的动态，决定使用哪种策略这样一种应用场景。</p>
<p>我们先通过一个例子来看下，if-else 或 switch-case 分支判断逻辑是如何产生的。具体的代码如下所示。在这个例子中，我们没有使用策略模式，而是将策略的定义、创建、使用直接耦合在一起。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">discount</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> discount = <span class="number">0.0</span>;</span><br><span class="line">    OrderType type = order.getType();</span><br><span class="line">    <span class="keyword">if</span> (type.equals(OrderType.NORMAL)) &#123; <span class="comment">// 普通订单</span></span><br><span class="line">      <span class="comment">//...省略折扣计算算法代码</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(OrderType.GROUPON)) &#123; <span class="comment">// 团购订单</span></span><br><span class="line">      <span class="comment">//...省略折扣计算算法代码</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(OrderType.PROMOTION)) &#123; <span class="comment">// 促销订单</span></span><br><span class="line">      <span class="comment">//...省略折扣计算算法代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> discount;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用策略模式对上面的代码重构，将不同类型订单的打折策略设计成策略类，并由工厂类来负责创建策略对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 策略的定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DiscountStrategy</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">calDiscount</span><span class="params">(Order order)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 省略NormalDiscountStrategy、GrouponDiscountStrategy、PromotionDiscountStrategy类代码...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 策略的创建</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscountStrategyFactory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;OrderType, DiscountStrategy&gt; strategies = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    strategies.put(OrderType.NORMAL, <span class="keyword">new</span> NormalDiscountStrategy());</span><br><span class="line">    strategies.put(OrderType.GROUPON, <span class="keyword">new</span> GrouponDiscountStrategy());</span><br><span class="line">    strategies.put(OrderType.PROMOTION, <span class="keyword">new</span> PromotionDiscountStrategy());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DiscountStrategy <span class="title">getDiscountStrategy</span><span class="params">(OrderType type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> strategies.get(type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 策略的使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">discount</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">    OrderType type = order.getType();</span><br><span class="line">    DiscountStrategy discountStrategy = DiscountStrategyFactory.getDiscountStrategy(type);</span><br><span class="line">    <span class="keyword">return</span> discountStrategy.calDiscount(order);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h3><p><strong>策略模式用来解耦策略的定义、创建、使用。</strong>实际上，一个完整的策略模式就是由这三个部分组成的。</p>
<ul>
<li>策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。</li>
<li>策略的创建由工厂类来完成，封装策略创建的细节。</li>
<li>策略模式包含一组策略可选，客户端代码如何选择使用哪个策略，有两种确定方法：编译时静态确定和运行时动态确定。其中，“运行时动态确定”才是策略模式最典型的应用场景。</li>
</ul>
<p>除此之外，我们还可以通过策略模式来移除 if-else 分支判断。实际上，这得益于策略工厂类，更本质上点讲，是借助“查表法”，根据 type 查表替代根据 type 分支判断。</p>
<p>对于 Java 语言来说，我们可以通过反射来避免对策略工厂类的修改。具体是这么做的：我们通过一个配置文件或者自定义的 annotation 来标注都有哪些策略类；策略工厂类读取配置文件或者搜索被 annotation 标注的策略类，然后通过反射动态地加载这些策略类、创建策略对象；当我们新添加一个策略的时候，只需要将这个新添加的策略类添加到配置文件或者用 annotation 标注即可。</p>
<h2 id="6-4-职责链模式"><a href="#6-4-职责链模式" class="headerlink" title="6.4 职责链模式"></a>6.4 职责链模式</h2><p>将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止。</p>
<p><img src="/pics/image-20200523101842144.png" alt="image-20200523101842144"></p>
<h3 id="1-职责链模式的实现：链表-vs-数组"><a href="#1-职责链模式的实现：链表-vs-数组" class="headerlink" title="1.职责链模式的实现：链表 vs 数组"></a>1.职责链模式的实现：链表 vs 数组</h3><p>职责链模式有两种常用的实现。一种是使用链表来存储处理器，另一种是使用数组来存储处理器，后面一种实现方式更加简单。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Handler &#123;</span><br><span class="line">  protected Handler successor = null;</span><br><span class="line"></span><br><span class="line">  public void setSuccessor(Handler successor) &#123;</span><br><span class="line">    this.successor = successor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public final void handle() &#123;</span><br><span class="line">    boolean handled = doHandle();</span><br><span class="line">    if (successor != null &amp;&amp; !handled) &#123;</span><br><span class="line">      successor.handle();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  protected abstract boolean doHandle();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HandlerA extends Handler &#123;</span><br><span class="line">  @Override</span><br><span class="line">  protected boolean doHandle() &#123;</span><br><span class="line">    boolean handled = false;</span><br><span class="line">    //...</span><br><span class="line">    return handled;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HandlerB extends Handler &#123;</span><br><span class="line">  @Override</span><br><span class="line">  protected boolean doHandle() &#123;</span><br><span class="line">    boolean handled = false;</span><br><span class="line">    //...</span><br><span class="line">    return handled;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HandlerChain &#123;</span><br><span class="line">  private Handler head = null;</span><br><span class="line">  private Handler tail = null;</span><br><span class="line"></span><br><span class="line">  public void addHandler(Handler handler) &#123;</span><br><span class="line">    handler.setSuccessor(null);</span><br><span class="line"></span><br><span class="line">    if (head == null) &#123;</span><br><span class="line">      head = handler;</span><br><span class="line">      tail = handler;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tail.setSuccessor(handler);</span><br><span class="line">    tail = handler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void handle() &#123;</span><br><span class="line">    if (head != null) &#123;</span><br><span class="line">      head.handle();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用举例</span><br><span class="line">public class Application &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    HandlerChain chain = new HandlerChain();</span><br><span class="line">    chain.addHandler(new HandlerA());</span><br><span class="line">    chain.addHandler(new HandlerB());</span><br><span class="line">    chain.handle();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，使用链表的方式，需要每个处理器设置后继节点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public interface IHandler &#123;</span><br><span class="line">  boolean handle();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HandlerA implements IHandler &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public boolean handle() &#123;</span><br><span class="line">    boolean handled = false;</span><br><span class="line">    //...</span><br><span class="line">    return handled;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HandlerB implements IHandler &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public boolean handle() &#123;</span><br><span class="line">    boolean handled = false;</span><br><span class="line">    //...</span><br><span class="line">    return handled;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HandlerChain &#123;</span><br><span class="line">  private List&lt;IHandler&gt; handlers = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public void addHandler(IHandler handler) &#123;</span><br><span class="line">    this.handlers.add(handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void handle() &#123;</span><br><span class="line">    for (IHandler handler : handlers) &#123;</span><br><span class="line">      boolean handled = handler.handle();</span><br><span class="line">      if (handled) &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用举例</span><br><span class="line">public class Application &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    HandlerChain chain = new HandlerChain();</span><br><span class="line">    chain.addHandler(new HandlerA());</span><br><span class="line">    chain.addHandler(new HandlerB());</span><br><span class="line">    chain.handle();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-变体"><a href="#2-变体" class="headerlink" title="2.变体"></a>2.变体</h3><p>如果处理器链上的某个处理器能够处理这个请求，那就不会继续往下传递请求。实际上，职责链模式还有一种变体，那就是请求会被所有的处理器都处理一遍，不存在中途终止的情况。</p>
<h3 id="3-应用"><a href="#3-应用" class="headerlink" title="3.应用"></a>3.应用</h3><p>职责链模式常用在框架开发中，用来实现框架的<strong>过滤器、拦截器</strong>功能，让框架的使用者在不需要修改框架源码的情况下，添加新的过滤拦截功能。这也体现了之前讲到的对扩展开放、对修改关闭的设计原则。</p>
<h2 id="6-5-状态模式"><a href="#6-5-状态模式" class="headerlink" title="6.5 状态模式"></a>6.5 状态模式</h2><p>状态模式是状态机的一种实现方式即可。状态机又叫有限状态机，它有 3 个部分组成：状态、事件、动作。其中，事件也称为转移条件。事件触发状态的转移及动作的执行。不过，动作不是必须的，也可能只转移状态，不执行任何动作。</p>
<p>“超级马里奥”游戏不知道你玩过没有？在游戏中，马里奥可以变身为多种形态，比如小马里奥（Small Mario）、超级马里奥（Super Mario）、火焰马里奥（Fire Mario）、斗篷马里奥（Cape Mario）等等。在不同的游戏情节下，各个形态会互相转化，并相应的增减积分。比如，初始形态是小马里奥，吃了蘑菇之后就会变成超级马里奥，并且增加 100 积分。</p>
<p>实际上，马里奥形态的转变就是一个状态机。其中，马里奥的不同形态就是状态机中的“状态”，游戏情节（比如吃了蘑菇）就是状态机中的“事件”，加减积分就是状态机中的“动作”。比如，吃蘑菇这个事件，会触发状态的转移：从小马里奥转移到超级马里奥，以及触发动作的执行（增加 100 积分）。</p>
<p>为了方便接下来的讲解，我对游戏背景做了简化，只保留了部分状态和事件。简化之后的状态转移如下图所示：</p>
<p><img src="/pics/image-20200523110010170.png" alt="image-20200523110010170"></p>
<h3 id="1-分支逻辑法"><a href="#1-分支逻辑法" class="headerlink" title="1.分支逻辑法"></a>1.分支逻辑法</h3><p>利用 if-else 或者 switch-case 分支逻辑，参照状态转移图，将每一个状态转移原模原样地直译成代码。对于简单的状态机来说，这种实现方式最简单、最直接，是首选。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">  SMALL(<span class="number">0</span>),</span><br><span class="line">  SUPER(<span class="number">1</span>),</span><br><span class="line">  FIRE(<span class="number">2</span>),</span><br><span class="line">  CAPE(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">State</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MarioStateMachine</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line">  <span class="keyword">private</span> State currentState;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MarioStateMachine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.score = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.currentState = State.SMALL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainMushRoom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (currentState.equals(State.SMALL)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.currentState = State.SUPER;</span><br><span class="line">      <span class="keyword">this</span>.score += <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainCape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) &#123;</span><br><span class="line">      <span class="keyword">this</span>.currentState = State.CAPE;</span><br><span class="line">      <span class="keyword">this</span>.score += <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainFireFlower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) &#123;</span><br><span class="line">      <span class="keyword">this</span>.currentState = State.FIRE;</span><br><span class="line">      <span class="keyword">this</span>.score += <span class="number">300</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">meetMonster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (currentState.equals(State.SUPER)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.currentState = State.SMALL;</span><br><span class="line">      <span class="keyword">this</span>.score -= <span class="number">100</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentState.equals(State.CAPE)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.currentState = State.SMALL;</span><br><span class="line">      <span class="keyword">this</span>.score -= <span class="number">200</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentState.equals(State.FIRE)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.currentState = State.SMALL;</span><br><span class="line">      <span class="keyword">this</span>.score -= <span class="number">300</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.score;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> State <span class="title">getCurrentState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.currentState;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MarioStateMachine mario = <span class="keyword">new</span> MarioStateMachine();</span><br><span class="line">    mario.obtainMushRoom();</span><br><span class="line">    <span class="keyword">int</span> score = mario.getScore();</span><br><span class="line">    State state = mario.getCurrentState();</span><br><span class="line">    System.out.println(<span class="string">&quot;mario score: &quot;</span> + score + <span class="string">&quot;; state: &quot;</span> + state);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-查表法"><a href="#2-查表法" class="headerlink" title="2.查表法"></a>2.查表法</h3><p>对于状态很多、状态转移比较复杂的状态机来说，查表法比较合适。通过二维数组来表示状态转移图，能极大地提高代码的可读性和可维护性。</p>
<p>实际上，除了用状态转移图来表示之外，状态机还可以用二维表来表示，如下所示。在这个二维表中，第一维表示当前状态，第二维表示事件，值表示当前状态经过事件之后，转移到的新状态及其执行的动作。</p>
<p><img src="/pics/image-20200523110337991.png" alt="image-20200523110337991"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123; </span><br><span class="line">    SMALL(<span class="number">0</span>), </span><br><span class="line">    SUPER(<span class="number">1</span>), </span><br><span class="line">    FIRE(<span class="number">2</span>), </span><br><span class="line">    CAPE(<span class="number">3</span>); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">State</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.value = value; </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   		 <span class="keyword">return</span> <span class="keyword">this</span>.value; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">  GOT_MUSHROOM(<span class="number">0</span>),</span><br><span class="line">  GOT_CAPE(<span class="number">1</span>),</span><br><span class="line">  GOT_FIRE(<span class="number">2</span>),</span><br><span class="line">  MET_MONSTER(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Event</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MarioStateMachine</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line">  <span class="keyword">private</span> State currentState;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 状态转移的二维数组</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> State[][] transitionTable = &#123;</span><br><span class="line">          &#123;SUPER, CAPE, FIRE, SMALL&#125;,</span><br><span class="line">          &#123;SUPER, CAPE, FIRE, SMALL&#125;,</span><br><span class="line">          &#123;CAPE, CAPE, CAPE, SMALL&#125;,</span><br><span class="line">          &#123;FIRE, FIRE, FIRE, SMALL&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 触发事件的结果二维数组</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[][] actionTable = &#123;</span><br><span class="line">          &#123;+<span class="number">100</span>, +<span class="number">200</span>, +<span class="number">300</span>, +<span class="number">0</span>&#125;,</span><br><span class="line">          &#123;+<span class="number">0</span>, +<span class="number">200</span>, +<span class="number">300</span>, -<span class="number">100</span>&#125;,</span><br><span class="line">          &#123;+<span class="number">0</span>, +<span class="number">0</span>, +<span class="number">0</span>, -<span class="number">200</span>&#125;,</span><br><span class="line">          &#123;+<span class="number">0</span>, +<span class="number">0</span>, +<span class="number">0</span>, -<span class="number">300</span>&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MarioStateMachine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.score = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.currentState = State.SMALL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainMushRoom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    executeEvent(Event.GOT_MUSHROOM);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainCape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    executeEvent(Event.GOT_CAPE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainFireFlower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    executeEvent(Event.GOT_FIRE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">meetMonster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    executeEvent(Event.MET_MONSTER);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">executeEvent</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> stateValue = currentState.getValue();</span><br><span class="line">    <span class="keyword">int</span> eventValue = event.getValue();</span><br><span class="line">    <span class="keyword">this</span>.currentState = transitionTable[stateValue][eventValue];</span><br><span class="line">    <span class="keyword">this</span>.score += actionTable[stateValue][eventValue];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.score;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> State <span class="title">getCurrentState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.currentState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-状态模式"><a href="#3-状态模式" class="headerlink" title="3.状态模式"></a>3.状态模式</h3><p>对于状态并不多、状态转移也比较简单，<strong>但事件触发执行的动作包含的业务逻辑</strong>可能比较复杂的状态机来说，我们首选这种实现方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMario</span> </span>&#123; <span class="comment">//所有状态类的接口</span></span><br><span class="line">  <span class="function">State <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">//以下是定义的事件</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">obtainMushRoom</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">obtainCape</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">obtainFireFlower</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">meetMonster</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmallMario</span> <span class="keyword">implements</span> <span class="title">IMario</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> MarioStateMachine stateMachine;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SmallMario</span><span class="params">(MarioStateMachine stateMachine)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.stateMachine = stateMachine;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> State <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> State.SMALL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainMushRoom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stateMachine.setCurrentState(<span class="keyword">new</span> SuperMario(stateMachine));</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() + <span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainCape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stateMachine.setCurrentState(<span class="keyword">new</span> CapeMario(stateMachine));</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() + <span class="number">200</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainFireFlower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stateMachine.setCurrentState(<span class="keyword">new</span> FireMario(stateMachine));</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() + <span class="number">300</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">meetMonster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do nothing...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperMario</span> <span class="keyword">implements</span> <span class="title">IMario</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> MarioStateMachine stateMachine;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SuperMario</span><span class="params">(MarioStateMachine stateMachine)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.stateMachine = stateMachine;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> State <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> State.SUPER;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainMushRoom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do nothing...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainCape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stateMachine.setCurrentState(<span class="keyword">new</span> CapeMario(stateMachine));</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() + <span class="number">200</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainFireFlower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stateMachine.setCurrentState(<span class="keyword">new</span> FireMario(stateMachine));</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() + <span class="number">300</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">meetMonster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stateMachine.setCurrentState(<span class="keyword">new</span> SmallMario(stateMachine));</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() - <span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略CapeMario、FireMario类...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MarioStateMachine</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line">  <span class="keyword">private</span> IMario currentState; <span class="comment">// 不再使用枚举来表示状态</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MarioStateMachine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.score = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.currentState = <span class="keyword">new</span> SmallMario(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainMushRoom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.currentState.obtainMushRoom();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainCape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.currentState.obtainCape();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainFireFlower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.currentState.obtainFireFlower();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">meetMonster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.currentState.meetMonster();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.score;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> State <span class="title">getCurrentState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.currentState.getName();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.score = score;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCurrentState</span><span class="params">(IMario currentState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.currentState = currentState;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>MarioStateMachine 和各个状态类之间是双向依赖关系</strong>。MarioStateMachine 依赖各个状态类是理所当然的，但是，反过来，各个状态类为什么要依赖 MarioStateMachine 呢？这是因为，各个状态类需要更新 MarioStateMachine 中的两个变量，score 和 currentState。</p>
<h2 id="6-6-迭代器模式"><a href="#6-6-迭代器模式" class="headerlink" title="6.6 迭代器模式"></a>6.6 迭代器模式</h2><p>用来遍历集合对象。这里说的“集合对象”也可以叫“容器”“聚合对象”，实际上就是包含一组对象的对象，比如数组、链表、树、图、跳表。迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一。</p>
<p><img src="/pics/image-20200525115550212.png" alt="image-20200525115550212"></p>
<h3 id="1-迭代器来遍历有下面三个优势"><a href="#1-迭代器来遍历有下面三个优势" class="headerlink" title="1.迭代器来遍历有下面三个优势"></a>1.迭代器来遍历有下面三个优势</h3><p>遍历集合一般有三种方式：for 循环、foreach 循环、迭代器遍历。后两种本质上属于一种，都可以看作迭代器遍历。</p>
<p>相对于 for 循环遍历，利用迭代器来遍历有下面三个优势：</p>
<ul>
<li>迭代器模式封装集合内部的复杂数据结构，开发者不需要了解如何遍历，直接使用容器提供的迭代器即可；</li>
<li>迭代器模式<strong>将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一</strong>；</li>
<li>迭代器模式让<strong>添加新的遍历算法更加容易，更符合开闭原则</strong>。</li>
</ul>
<p>除此之外，因为迭代器都实现自相同的接口，在开发中，基于接口而非实现编程，替换迭代器也变得更加容易。</p>
<h3 id="2-迭代器和集合元素删除"><a href="#2-迭代器和集合元素删除" class="headerlink" title="2.迭代器和集合元素删除"></a>2.迭代器和集合元素删除</h3><p>在通过迭代器来遍历集合元素的同时，增加或者删除集合中的元素，有可能会导致某个元素被重复遍历或遍历不到。不过，并不是所有情况下都会遍历出错，有的时候也可以正常遍历，所以，这种行为称为结果不可预期行为或者未决行为。实际上，“不可预期”比直接出错更加可怕，有的时候运行正确，有的时候运行错误，一些隐藏很深、很难 debug 的 bug 就是这么产生的。</p>
<p>有两种比较干脆利索的解决方案，来避免出现这种不可预期的运行结果。一种是遍历的时候不允许增删元素，另一种是增删元素之后让遍历报错。第一种解决方案比较难实现，因为很难确定迭代器使用结束的时间点。第二种解决方案更加合理。Java 语言就是采用的这种解决方案。增删元素之后，我们选择 fail-fast 解决方式，让遍历操作直接抛出运行时异常。</p>
<p>像 Java 语言，迭代器类中除了前面提到的几个最基本的方法之外，还定义了一个 remove() 方法，能够在遍历集合的同时，安全地删除集合中的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    Itr() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      checkForComodification();</span><br><span class="line">      <span class="keyword">int</span> i = cursor;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">      Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">      cursor = i + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">      checkForComodification();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">        cursor = lastRet;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代器类新增了一个 lastRet 成员变量，用来记录游标指向的前一个元素。通过迭代器去删除这个元素的时候，我们可以更新迭代器中的cursor值为lastRet 值，来保证不会因为删除元素而导致某个元素遍历不到。</p>
<h3 id="3-“快照”迭代器"><a href="#3-“快照”迭代器" class="headerlink" title="3.“快照”迭代器"></a>3.“快照”迭代器</h3><h4 id="解决方案一："><a href="#解决方案一：" class="headerlink" title="解决方案一："></a>解决方案一：</h4><p>在迭代器类中定义一个成员变量 snapshot 来存储快照。每当创建迭代器的时候，都拷贝一份容器中的元素到快照中，后续的遍历操作都基于这个迭代器自己持有的快照来进行。具体的代码实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SnapshotArrayIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> cursor;</span><br><span class="line">  <span class="keyword">private</span> ArrayList&lt;E&gt; snapshot;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SnapshotArrayIterator</span><span class="params">(ArrayList&lt;E&gt; arrayList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cursor = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.snapshot = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">this</span>.snapshot.addAll(arrayList);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cursor &lt; snapshot.size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    E currentItem = snapshot.get(cursor);</span><br><span class="line">    cursor++;</span><br><span class="line">    <span class="keyword">return</span> currentItem;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解决方案二："><a href="#解决方案二：" class="headerlink" title="解决方案二："></a>解决方案二：</h4><p>我们可以在容器中，为每个元素保存两个时间戳，一个是添加时间戳 addTimestamp，一个是删除时间戳 delTimestamp。当元素被加入到集合中的时候，我们将 addTimestamp 设置为当前时间，将 delTimestamp 设置成最大长整型值（Long.MAX_VALUE）。当元素被删除时，我们将 delTimestamp 更新为当前时间，表示已经被删除。</p>
<p>注意，这里只是标记删除，而非真正将它从容器中删除。</p>
<p>同时，每个迭代器也保存一个迭代器创建时间戳 snapshotTimestamp，也就是迭代器对应的快照的创建时间戳。当使用迭代器来遍历容器的时候，只有满足 addTimestamp&lt; snapshotTimestamp&lt; delTimestamp的元素，才是属于这个迭代器的快照。如果元素的 addTimestamp&gt;snapshotTimestamp，说明元素在创建了迭代器之后才加入的，不属于这个迭代器的快照；如果元素的 delTimestamp&lt; snapshotTimestamp，说明元素在创建迭代器之前就被删除掉了，也不属于这个迭代器的快照。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> actualSize; <span class="comment">//不包含标记删除元素</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> totalSize; <span class="comment">//包含标记删除元素</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Object[] elements;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span>[] addTimestamps;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span>[] delTimestamps;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elements = <span class="keyword">new</span> Object[DEFAULT_CAPACITY];</span><br><span class="line">    <span class="keyword">this</span>.addTimestamps = <span class="keyword">new</span> <span class="keyword">long</span>[DEFAULT_CAPACITY];</span><br><span class="line">    <span class="keyword">this</span>.delTimestamps = <span class="keyword">new</span> <span class="keyword">long</span>[DEFAULT_CAPACITY];</span><br><span class="line">    <span class="keyword">this</span>.totalSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.actualSize = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E obj)</span> </span>&#123;</span><br><span class="line">    elements[totalSize] = obj;</span><br><span class="line">    addTimestamps[totalSize] = System.currentTimeMillis();</span><br><span class="line">    delTimestamps[totalSize] = Long.MAX_VALUE;</span><br><span class="line">    totalSize++;</span><br><span class="line">    actualSize++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalSize; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (elements[i].equals(obj)) &#123;</span><br><span class="line">        delTimestamps[i] = System.currentTimeMillis();</span><br><span class="line">        actualSize--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">actualSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.actualSize;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.totalSize;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= totalSize) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (E)elements[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getAddTimestamp</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= totalSize) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> addTimestamps[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelTimestamp</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= totalSize) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> delTimestamps[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SnapshotArrayIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> snapshotTimestamp;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> cursorInAll; <span class="comment">// 在整个容器中的下标，而非快照中的下标</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> leftCount; <span class="comment">// 快照中还有几个元素未被遍历</span></span><br><span class="line">  <span class="keyword">private</span> ArrayList&lt;E&gt; arrayList;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SnapshotArrayIterator</span><span class="params">(ArrayList&lt;E&gt; arrayList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.snapshotTimestamp = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">this</span>.cursorInAll = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.leftCount = arrayList.actualSize();;</span><br><span class="line">    <span class="keyword">this</span>.arrayList = arrayList;</span><br><span class="line"></span><br><span class="line">    justNext(); <span class="comment">// 先跳到这个迭代器快照的第一个元素</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.leftCount &gt;= <span class="number">0</span>; <span class="comment">// 注意是&gt;=, 而非&gt;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    E currentItem = arrayList.get(cursorInAll);</span><br><span class="line">    justNext();</span><br><span class="line">    <span class="keyword">return</span> currentItem;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">justNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cursorInAll &lt; arrayList.totalSize()) &#123;</span><br><span class="line">      <span class="keyword">long</span> addTimestamp = arrayList.getAddTimestamp(cursorInAll);</span><br><span class="line">      <span class="keyword">long</span> delTimestamp = arrayList.getDelTimestamp(cursorInAll);</span><br><span class="line">      <span class="keyword">if</span> (snapshotTimestamp &gt; addTimestamp &amp;&amp; snapshotTimestamp &lt; delTimestamp) &#123;</span><br><span class="line">        leftCount--;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      cursorInAll++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-7-访问者模式"><a href="#6-7-访问者模式" class="headerlink" title="6.7 访问者模式"></a>6.7 访问者模式</h2><p>允许一个或者多个操作应用到一组对象上，解耦操作和对象本身。</p>
<p><img src="/pics/image-20200528103452763.png" alt="image-20200528103452763"></p>
<h3 id="1-范例"><a href="#1-范例" class="headerlink" title="1.范例"></a>1.范例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ResourceFile &#123;</span><br><span class="line">  protected String filePath;</span><br><span class="line">  public ResourceFile(String filePath) &#123;</span><br><span class="line">    this.filePath = filePath;</span><br><span class="line">  &#125;</span><br><span class="line">  abstract public void accept(Visitor vistor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PdfFile extends ResourceFile &#123;</span><br><span class="line">  public PdfFile(String filePath) &#123;</span><br><span class="line">    super(filePath);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void accept(Visitor visitor) &#123;</span><br><span class="line">    visitor.visit(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//...PPTFile、WordFile跟PdfFile类似，这里就省略了...</span><br><span class="line">public interface Visitor &#123;</span><br><span class="line">  void visit(PdfFile pdfFile);</span><br><span class="line">  void visit(PPTFile pdfFile);</span><br><span class="line">  void visit(WordFile pdfFile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Extractor implements Visitor &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void visit(PPTFile pptFile) &#123;</span><br><span class="line">    //...</span><br><span class="line">    System.out.println(&quot;Extract PPT.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void visit(PdfFile pdfFile) &#123;</span><br><span class="line">    //...</span><br><span class="line">    System.out.println(&quot;Extract PDF.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void visit(WordFile wordFile) &#123;</span><br><span class="line">    //...</span><br><span class="line">    System.out.println(&quot;Extract WORD.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Compressor implements Visitor &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void visit(PPTFile pptFile) &#123;</span><br><span class="line">    //...</span><br><span class="line">    System.out.println(&quot;Compress PPT.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void visit(PdfFile pdfFile) &#123;</span><br><span class="line">    //...</span><br><span class="line">    System.out.println(&quot;Compress PDF.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void visit(WordFile wordFile) &#123;</span><br><span class="line">    //...</span><br><span class="line">    System.out.println(&quot;Compress WORD.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ToolApplication &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    Extractor extractor = new Extractor();</span><br><span class="line">    List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[0]);</span><br><span class="line">    for (ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class="line">      resourceFile.accept(extractor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Compressor compressor = new Compressor();</span><br><span class="line">    for(ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class="line">      resourceFile.accept(compressor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static List&lt;ResourceFile&gt; listAllResourceFiles(String resourceDirectory) &#123;</span><br><span class="line">    List&lt;ResourceFile&gt; resourceFiles = new ArrayList&lt;&gt;();</span><br><span class="line">    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)</span><br><span class="line">    resourceFiles.add(new PdfFile(&quot;a.pdf&quot;));</span><br><span class="line">    resourceFiles.add(new WordFile(&quot;b.word&quot;));</span><br><span class="line">    resourceFiles.add(new PPTFile(&quot;c.ppt&quot;));</span><br><span class="line">    return resourceFiles;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般来说，访问者模式针对的是一组类型不同的对象（PdfFile、PPTFile、WordFile）。不过，尽管这组对象的类型是不同的，但是，它们继承相同的父类（ResourceFile）或者实现相同的接口。在不同的应用场景下，我们需要对这组对象进行一系列不相关的业务操作（抽取文本、压缩等），但为了避免不断添加功能导致类（PdfFile、PPTFile、WordFile）不断膨胀，职责越来越不单一，以及避免频繁地添加功能导致的频繁代码修改，我们使用访问者模式，<strong>将对象与操作解耦，</strong>将这些业务操作抽离出来，定义在独立细分的访问者类（Extractor、Compressor）中。</p>
<h3 id="2-Single-Dispatch-和-Double-Dispatch"><a href="#2-Single-Dispatch-和-Double-Dispatch" class="headerlink" title="2.Single Dispatch 和 Double Dispatch"></a>2.Single Dispatch 和 Double Dispatch</h3><p>所谓 Single Dispatch，指的是执行<strong>哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的编译时类型来决定</strong>。所谓 Double Dispatch，指的是<strong>执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的运行时类型来决定</strong>。</p>
<p>具体到编程语言的语法机制，Single Dispatch 和 Double Dispatch 跟多态和函数重载直接相关。当前主流的面向对象编程语言（比如，Java、C++、C#）都只支持 Single Dispatch，不支持 Double Dispatch。</p>
<h3 id="3-访问者模式的替代"><a href="#3-访问者模式的替代" class="headerlink" title="3.访问者模式的替代"></a>3.访问者模式的替代</h3><p>开发这个工具有很多种代码设计和实现思路。为了讲解访问者模式，上节课我们选择了用访问者模式来实现。实际上，我们还有其他的实现方法，比如，我们还可以利用工厂模式来实现，定义一个包含 extract2txt() 接口函数的 Extractor 接口。PdfExtractor、PPTExtractor、WordExtractor 类实现 Extractor 接口，并且在各自的 extract2txt() 函数中，分别实现 Pdf、PPT、Word 格式文件的文本内容抽取。ExtractorFactory 工厂类根据不同的文件类型，返回不同的 Extractor。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ResourceFile &#123;</span><br><span class="line">  protected String filePath;</span><br><span class="line">  public ResourceFile(String filePath) &#123;</span><br><span class="line">    this.filePath = filePath;</span><br><span class="line">  &#125;</span><br><span class="line">  public abstract ResourceFileType getType();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PdfFile extends ResourceFile &#123;</span><br><span class="line">  public PdfFile(String filePath) &#123;</span><br><span class="line">    super(filePath);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public ResourceFileType getType() &#123;</span><br><span class="line">    return ResourceFileType.PDF;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//...PPTFile/WordFile跟PdfFile代码结构类似，此处省略...</span><br><span class="line"></span><br><span class="line">public interface Extractor &#123;</span><br><span class="line">  void extract2txt(ResourceFile resourceFile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PdfExtractor implements Extractor &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void extract2txt(ResourceFile resourceFile) &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//...PPTExtractor/WordExtractor跟PdfExtractor代码结构类似，此处省略...</span><br><span class="line"></span><br><span class="line">public class ExtractorFactory &#123;</span><br><span class="line">  private static final Map&lt;ResourceFileType, Extractor&gt; extractors = new HashMap&lt;&gt;();</span><br><span class="line">  static &#123;</span><br><span class="line">    extractors.put(ResourceFileType.PDF, new PdfExtractor());</span><br><span class="line">    extractors.put(ResourceFileType.PPT, new PPTExtractor());</span><br><span class="line">    extractors.put(ResourceFileType.WORD, new WordExtractor());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static Extractor getExtractor(ResourceFileType type) &#123;</span><br><span class="line">    return extractors.get(type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ToolApplication &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[0]);</span><br><span class="line">    for (ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class="line">      Extractor extractor = ExtractorFactory.getExtractor(resourceFile.getType());</span><br><span class="line">      extractor.extract2txt(resourceFile);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static List&lt;ResourceFile&gt; listAllResourceFiles(String resourceDirectory) &#123;</span><br><span class="line">    List&lt;ResourceFile&gt; resourceFiles = new ArrayList&lt;&gt;();</span><br><span class="line">    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)</span><br><span class="line">    resourceFiles.add(new PdfFile(&quot;a.pdf&quot;));</span><br><span class="line">    resourceFiles.add(new WordFile(&quot;b.word&quot;));</span><br><span class="line">    resourceFiles.add(new PPTFile(&quot;c.ppt&quot;));</span><br><span class="line">    return resourceFiles;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-8-备忘录模式"><a href="#6-8-备忘录模式" class="headerlink" title="6.8 备忘录模式"></a>6.8 备忘录模式</h2><p>在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。</p>
<p><img src="/pics/image-20200528205840204.png" alt="image-20200528205840204"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//象棋棋子类：原发器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chessman</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String label;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chessman</span><span class="params">(String label, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.label = label;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略get set</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChessmanMemento <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ChessmanMemento(<span class="keyword">this</span>.label, <span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//恢复状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restore</span><span class="params">(ChessmanMemento memento)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.label = memento.getLabel();</span><br><span class="line">        <span class="keyword">this</span>.x = memento.getX();</span><br><span class="line">        <span class="keyword">this</span>.y = memento.getY();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//象棋棋子备忘录类：备忘录</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChessmanMemento</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String label;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChessmanMemento</span><span class="params">(String label, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.label = label;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 省略get set</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//象棋棋子备忘录管理类：负责人</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MementoCaretaker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ChessmanMemento memento;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChessmanMemento <span class="title">getMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> memento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMemento</span><span class="params">(ChessmanMemento memento)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.memento = memento;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编写如下客户端测试代码：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        MementoCaretaker mc = <span class="keyword">new</span> MementoCaretaker();</span><br><span class="line">        Chessman chess = <span class="keyword">new</span> Chessman(<span class="string">&quot;车&quot;</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        display(chess);</span><br><span class="line">        mc.setMemento(chess.save()); <span class="comment">//保存状态</span></span><br><span class="line">        chess.setY(<span class="number">4</span>);</span><br><span class="line">        display(chess);</span><br><span class="line">        mc.setMemento(chess.save()); <span class="comment">//保存状态</span></span><br><span class="line">        display(chess);</span><br><span class="line">        chess.setX(<span class="number">5</span>);</span><br><span class="line">        display(chess);</span><br><span class="line">        System.out.println(<span class="string">&quot;******悔棋******&quot;</span>);</span><br><span class="line">        chess.restore(mc.getMemento()); <span class="comment">//恢复状态</span></span><br><span class="line">        display(chess);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Chessman chess)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;棋子&quot;</span> + chess.getLabel() + <span class="string">&quot;当前位置为：&quot;</span> + <span class="string">&quot;第&quot;</span> + chess.getX() + <span class="string">&quot;行&quot;</span> + <span class="string">&quot;第&quot;</span> + chess.getY() + <span class="string">&quot;列。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>备忘录模式也叫快照模式，具体来说，就是在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。这个模式的定义表达了两部分内容：一部分是，存储副本以便后期恢复；另一部分是，要在不违背封装原则的前提下，进行对象的备份和恢复。这个设计模式的核心在于将类和状态区分开，通过类去维护类状态。</p>
<h2 id="6-9-命令模式"><a href="#6-9-命令模式" class="headerlink" title="6.9 命令模式"></a>6.9 命令模式</h2><p>命令模式将请求（命令）封装为一个对象，这样可以使用不同的请求参数化其他对象（将不同请求依赖注入到其他对象），并且能够支持请求（命令）的排队执行、记录日志、撤销等（附加控制）功能。</p>
<h3 id="1-命令模式的实战讲解"><a href="#1-命令模式的实战讲解" class="headerlink" title="1.命令模式的实战讲解"></a>1.命令模式的实战讲解</h3><p>假设我们正在开发一个类似《天天酷跑》或者《QQ 卡丁车》这样的手游，整个手游后端服务器轮询获取客户端发来的请求，获取到请求之后，借助命令模式，把请求包含的数据和处理逻辑封装为命令对象，并存储在内存队列中。然后，再从队列中取出一定数量的命令来执行。执行完成之后，再重新开始新的一轮轮询。具体的示例代码如下所示，你可以结合着一块看下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public interface Command &#123;</span><br><span class="line">  void execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class GotDiamondCommand implements Command &#123;</span><br><span class="line">  // 省略成员变量</span><br><span class="line"></span><br><span class="line">  public GotDiamondCommand(/*数据*/) &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void execute() &#123;</span><br><span class="line">    // 执行相应的逻辑</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//GotStartCommand/HitObstacleCommand/ArchiveCommand类省略</span><br><span class="line"></span><br><span class="line">public class GameApplication &#123;</span><br><span class="line">  private static final int MAX_HANDLED_REQ_COUNT_PER_LOOP = 100;</span><br><span class="line">  private Queue&lt;Command&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public void mainloop() &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">      List&lt;Request&gt; requests = new ArrayList&lt;&gt;();</span><br><span class="line">      </span><br><span class="line">      //省略从epoll或者select中获取数据，并封装成Request的逻辑，</span><br><span class="line">      //注意设置超时时间，如果很长时间没有接收到请求，就继续下面的逻辑处理。</span><br><span class="line">      </span><br><span class="line">      for (Request request : requests) &#123;</span><br><span class="line">        Event event = request.getEvent();</span><br><span class="line">        Command command = null;</span><br><span class="line">        if (event.equals(Event.GOT_DIAMOND)) &#123;</span><br><span class="line">          command = new GotDiamondCommand(/*数据*/);</span><br><span class="line">        &#125; else if (event.equals(Event.GOT_STAR)) &#123;</span><br><span class="line">          command = new GotStartCommand(/*数据*/);</span><br><span class="line">        &#125; else if (event.equals(Event.HIT_OBSTACLE)) &#123;</span><br><span class="line">          command = new HitObstacleCommand(/*数据*/);</span><br><span class="line">        &#125; else if (event.equals(Event.ARCHIVE)) &#123;</span><br><span class="line">          command = new ArchiveCommand(/*数据*/);</span><br><span class="line">        &#125; // ...一堆else if...</span><br><span class="line"></span><br><span class="line">        queue.add(command);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      int handledCount = 0;</span><br><span class="line">      while (handledCount &lt; MAX_HANDLED_REQ_COUNT_PER_LOOP) &#123;</span><br><span class="line">        if (queue.isEmpty()) &#123;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        Command command = queue.poll();</span><br><span class="line">        command.execute();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-命令模式-VS-策略模式"><a href="#2-命令模式-VS-策略模式" class="headerlink" title="2.命令模式 VS 策略模式"></a>2.命令模式 VS 策略模式</h3><p>实际上，每个设计模式都应该由两部分组成：<strong>第一部分是应用场景，即这个模式可以解决哪类问题；第二部分是解决方案，即这个模式的设计思路和具体的代码实现。</strong>不过，代码实现并不是模式必须包含的。如果你单纯地只关注解决方案这一部分，甚至只关注代码实现，就会产生大部分模式看起来都很相似的错觉。实际上，设计模式之间的主要区别还是在于设计意图，也就是应用场景。单纯地看设计思路或者代码实现，有些模式确实很相似，比如策略模式和工厂模式。</p>
<p>策略模式中，不同的策略具有相同的目的、不同的实现、互相之间可以替换。比如，BubbleSort、SelectionSort 都是为了实现排序的，只不过一个是用冒泡排序算法来实现的，另一个是用选择排序算法来实现的。而在命令模式中，不同的命令具有不同的目的，对应不同的处理逻辑，并且互相之间不可替换。</p>
<h2 id="6-10-解释器模式"><a href="#6-10-解释器模式" class="headerlink" title="6.10 解释器模式"></a>6.10 解释器模式</h2><p>解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法。</p>
<p>解释器的使用有3步：</p>
<ol>
<li>明确规则</li>
<li>创建规则对应的解释器</li>
<li>将输入转化成规则</li>
</ol>
<p>假设我们定义了一个新的加减乘除计算“语言”，语法规则如下：运算符只包含加、减、乘、除，并且没有优先级的概念；表达式（也就是前面提到的“句子”）中，先书写数字，后书写运算符，空格隔开；按照先后顺序，取出两个数字和一个运算符计算结果，结果重新放入数字的最头部位置，循环上述过程，直到只剩下一个数字，这个数字就是表达式最终的计算结果。</p>
<p>我们举个例子来解释一下上面的语法规则。比如“ 8 3 2 4 - + * ”这样一个表达式，我们按照上面的语法规则来处理，取出数字“8 3”和“-”运算符，计算得到 5，于是表达式就变成了“ 5 2 4 + * ”。然后，我们再取出“ 5 2 ”和“ + ”运算符，计算得到 7，表达式就变成了“ 7 4 * ”。最后，我们取出“ 7 4”和“ * ”运算符，最终得到的结果就是 28。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">interpret</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> number;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NumberExpression</span><span class="params">(<span class="keyword">long</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.number = number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NumberExpression</span><span class="params">(String number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.number = Long.parseLong(number);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">interpret</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.number;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdditionExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Expression exp1;</span><br><span class="line">  <span class="keyword">private</span> Expression exp2;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AdditionExpression</span><span class="params">(Expression exp1, Expression exp2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.exp1 = exp1;</span><br><span class="line">    <span class="keyword">this</span>.exp2 = exp2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">interpret</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> exp1.interpret() + exp2.interpret();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SubstractionExpression/MultiplicationExpression/DivisionExpression与AdditionExpression代码结构类似，这里就省略了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpressionInterpreter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Deque&lt;Expression&gt; numbers = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">interpret</span><span class="params">(String expression)</span> </span>&#123;</span><br><span class="line">    String[] elements = expression.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> length = elements.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (length+<span class="number">1</span>)/<span class="number">2</span>; ++i) &#123;</span><br><span class="line">      numbers.addLast(<span class="keyword">new</span> NumberExpression(elements[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (length+<span class="number">1</span>)/<span class="number">2</span>; i &lt; length; ++i) &#123;</span><br><span class="line">      String operator = elements[i];</span><br><span class="line">      <span class="keyword">boolean</span> isValid = <span class="string">&quot;+&quot;</span>.equals(operator) || <span class="string">&quot;-&quot;</span>.equals(operator)</span><br><span class="line">              || <span class="string">&quot;*&quot;</span>.equals(operator) || <span class="string">&quot;/&quot;</span>.equals(operator);</span><br><span class="line">      <span class="keyword">if</span> (!isValid) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Expression is invalid: &quot;</span> + expression);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Expression exp1 = numbers.pollFirst();</span><br><span class="line">      Expression exp2 = numbers.pollFirst();</span><br><span class="line">      Expression combinedExp = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (operator.equals(<span class="string">&quot;+&quot;</span>)) &#123;</span><br><span class="line">        combinedExp = <span class="keyword">new</span> AdditionExpression(exp1, exp2);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operator.equals(<span class="string">&quot;-&quot;</span>)) &#123;</span><br><span class="line">        combinedExp = <span class="keyword">new</span> AdditionExpression(exp1, exp2);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operator.equals(<span class="string">&quot;*&quot;</span>)) &#123;</span><br><span class="line">        combinedExp = <span class="keyword">new</span> AdditionExpression(exp1, exp2);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operator.equals(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">        combinedExp = <span class="keyword">new</span> AdditionExpression(exp1, exp2);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">long</span> result = combinedExp.interpret();</span><br><span class="line">      numbers.addFirst(<span class="keyword">new</span> NumberExpression(result));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (numbers.size() != <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Expression is invalid: &quot;</span> + expression);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> numbers.pop().interpret();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-11-中介者模式"><a href="#6-11-中介者模式" class="headerlink" title="6.11 中介者模式"></a>6.11 中介者模式</h2><p>中介模式定义了一个单独的（中介）对象，来封装一组对象之间的交互。将这组对象之间的交互委派给与中介对象交互，来避免对象之间的直接交互。</p>
<p>提到中介模式，有一个比较经典的例子不得不说，那就是航空管制。为了让飞机在飞行的时候互不干扰，每架飞机都需要知道其他飞机每时每刻的位置，这就需要时刻跟其他飞机通信。飞机通信形成的通信网络就会无比复杂。这个时候，我们通过引入“塔台”这样一个中介，让每架飞机只跟塔台来通信，发送自己的位置给塔台，由塔台来负责每架飞机的航线调度。这样就大大简化了通信网络。</p>
<p><img src="/pics/image-20200528214630390.png" alt="image-20200528214630390"></p>
<p>中介模式的设计思想跟中间层很像，通过引入中介这个中间层，将一组对象之间的交互关系（或者依赖关系）从多对多（网状关系）转换为一对多（星状关系）。原来一个对象要跟 n 个对象交互，现在只需要跟一个中介对象交互，从而最小化对象之间的交互关系，降低了代码的复杂度，提高了代码的可读性和可维护性。</p>
<p>观察者模式和中介模式都是为了实现参与者之间的解耦，简化交互关系。两者的不同在于应用场景上。在观察者模式的应用场景中，参与者之间的交互比较有条理，一般都是单向的，一个参与者只有一个身份，要么是观察者，要么是被观察者。而在中介模式的应用场景中，参与者之间的交互关系错综复杂，既可以是消息的发送者、也可以同时是消息的接收者。</p>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>原型模式vs享元模式</p>
<p>原型模式关注的是如何拷贝一个对象</p>
<p>享元模式关注的是避免创建重复对象，减少内存占用，提出不可变的部分，作为享元。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/07/Notes/SoftGrowth/%E9%9D%9E%E6%9A%B4%E5%8A%9B%E6%B2%9F%E9%80%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/07/Notes/SoftGrowth/%E9%9D%9E%E6%9A%B4%E5%8A%9B%E6%B2%9F%E9%80%9A/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-07 21:52:52" itemprop="dateCreated datePublished" datetime="2020-12-07T21:52:52+08:00">2020-12-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="非暴力沟通"><a href="#非暴力沟通" class="headerlink" title="非暴力沟通"></a>非暴力沟通</h1><h2 id="一、非暴力沟通模式"><a href="#一、非暴力沟通模式" class="headerlink" title="一、非暴力沟通模式"></a>一、非暴力沟通模式</h2><h2 id="1、诚实的表达自己，而不批评指责"><a href="#1、诚实的表达自己，而不批评指责" class="headerlink" title="1、诚实的表达自己，而不批评指责"></a>1、诚实的表达自己，而不批评指责</h2><h4 id="（1）观察"><a href="#（1）观察" class="headerlink" title="（1）观察"></a>（1）观察</h4><p> 我所观察（看、听、回忆、想）到的有助于（或无助于）我的福祉的具体行为：</p>
<p>“当我看、听、回忆、想到、听到 …”  </p>
<h4 id="（2）感受"><a href="#（2）感受" class="headerlink" title="（2）感受"></a>（2）感受</h4><p>对于这些行为，我有什么感受（情感而非思想）：</p>
<p>“我感到 …”</p>
<h4 id="（3-需要"><a href="#（3-需要" class="headerlink" title="（3)  需要"></a>（3)  需要</h4><p>什么样的需要或者价值（而非偏好或某种具体的行为）导致我那样的感受：</p>
<p>“因为我需要/看重…”</p>
<h4 id="（4）请求"><a href="#（4）请求" class="headerlink" title="（4）请求"></a>（4）请求</h4><p>清楚的请求（而非命令）那些能丰富我生命的具体行为，</p>
<p>“你是否愿意 …?”</p>
<h3 id="2、关切的倾听他人、而不解读为批评或指责"><a href="#2、关切的倾听他人、而不解读为批评或指责" class="headerlink" title="2、关切的倾听他人、而不解读为批评或指责"></a>2、关切的倾听他人、而不解读为批评或指责</h3><h4 id="（1）观察-1"><a href="#（1）观察-1" class="headerlink" title="（1）观察"></a>（1）观察</h4><p>你所观察（看、听、回忆、想）到的有助于（或无助于）我的福祉的具体行为：</p>
<p>“当你看、听、回忆、想到、听到 …”  </p>
<h4 id="（2）感受-1"><a href="#（2）感受-1" class="headerlink" title="（2）感受"></a>（2）感受</h4><p>对于这些行为，你有什么感受（情感而非思想）：</p>
<p>“你感到 …吗？”</p>
<h4 id="（3）需要"><a href="#（3）需要" class="headerlink" title="（3）需要"></a>（3）需要</h4><p>什么样的需要或者价值（而非偏好或某种具体的行为）导致你那样的感受：</p>
<p>“因为你需要/看重…”</p>
<h4 id="（4）需要"><a href="#（4）需要" class="headerlink" title="（4）需要"></a>（4）需要</h4><p>关注倾听那些能丰富你生命的具体请求，而不解读为命令：</p>
<p>“所以，你想..“</p>
<h2 id="二、培育对自己的爱"><a href="#二、培育对自己的爱" class="headerlink" title="二、培育对自己的爱"></a>二、培育对自己的爱</h2><h3 id="非暴力最重要的应用在于培育对自己的爱"><a href="#非暴力最重要的应用在于培育对自己的爱" class="headerlink" title="非暴力最重要的应用在于培育对自己的爱"></a>非暴力最重要的应用在于培育对自己的爱</h3><ol>
<li>评价自己的行为时，专注于尚未满足的需要，不要依赖羞愧，内疚或沮丧的心理来寻求改变的而让爱主导我们的学习和成长。</li>
<li>根据自己的需要和价值观来选择生活。我们的行为不再是为了履行职责、获得回报、逃避惩罚或避免内心愧疚和羞愧。</li>
<li>用选择做代替不得不，我们的生活将变得充满和谐和快乐。</li>
</ol>
<h2 id="三、充分表达愤怒"><a href="#三、充分表达愤怒" class="headerlink" title="三、充分表达愤怒"></a>三、充分表达愤怒</h2><h3 id="（1）停下来，什么都不做"><a href="#（1）停下来，什么都不做" class="headerlink" title="（1）停下来，什么都不做"></a>（1）停下来，什么都不做</h3><h3 id="（2）想一想什么使我们生气了"><a href="#（2）想一想什么使我们生气了" class="headerlink" title="（2）想一想什么使我们生气了"></a>（2）想一想什么使我们生气了</h3><h3 id="（3）体会自己的需要"><a href="#（3）体会自己的需要" class="headerlink" title="（3）体会自己的需要"></a>（3）体会自己的需要</h3><h3 id="（4）表达自己的感受和需要"><a href="#（4）表达自己的感受和需要" class="headerlink" title="（4）表达自己的感受和需要"></a>（4）表达自己的感受和需要</h3><p>在第三和第四步之间，需要先倾听他人。在得到倾听和理解之后，他们就可以静下心来体会我们的感受和需要了。</p>
<h2 id="四、表达感激"><a href="#四、表达感激" class="headerlink" title="四、表达感激"></a>四、表达感激</h2><h4 id="（1）对方做了什么事情使我们的生活得到了改善"><a href="#（1）对方做了什么事情使我们的生活得到了改善" class="headerlink" title="（1）对方做了什么事情使我们的生活得到了改善;"></a>（1）对方做了什么事情使我们的生活得到了改善;</h4><h4 id="（2）我们有哪些需要得到了满足"><a href="#（2）我们有哪些需要得到了满足" class="headerlink" title="（2）我们有哪些需要得到了满足;"></a>（2）我们有哪些需要得到了满足;</h4><h4 id="（3）我们的心情怎么样？"><a href="#（3）我们的心情怎么样？" class="headerlink" title="（3）我们的心情怎么样？"></a>（3）我们的心情怎么样？</h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="sven"
      src="/images/sven.jpeg">
  <p class="site-author-name" itemprop="name">sven</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">58</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhaoxiaowen-sven" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhaoxiaowen-sven" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhaoxiaowen-sven@gmail.com" title="E-Mail → mailto:zhaoxiaowen-sven@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sven</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
