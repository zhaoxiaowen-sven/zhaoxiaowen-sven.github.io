<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Sven&#39;s blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Sven&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="sven">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Sven's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
      <a target="_blank" rel="noopener" href="https://github.com/zhaoxiaowen-sven" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Sven's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/24/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/24/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-24 17:07:24" itemprop="dateCreated datePublished" datetime="2021-10-24T17:07:24+08:00">2021-10-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/24/Notes/Java/JVM/JVM_09_JVM_GC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/24/Notes/Java/JVM/JVM_09_JVM_GC/" class="post-title-link" itemprop="url">JVM_09_JVM_GC</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-24 15:42:47" itemprop="dateCreated datePublished" datetime="2021-07-24T15:42:47+08:00">2021-07-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JVM-09-JVM-GC"><a href="#JVM-09-JVM-GC" class="headerlink" title="JVM_09_JVM_GC"></a>JVM_09_JVM_GC</h1><h2 id="哪里的内存需要回收？"><a href="#哪里的内存需要回收？" class="headerlink" title="哪里的内存需要回收？"></a>哪里的内存需要回收？</h2><p>JVM GC只回收<code>堆和方法区内的对象</code>。而栈区的数据，在超出作用域后会被JVM自动释放掉，所以其不在JVM GC的管理范围内。</p>
<h2 id="如何判断对象可以回收？"><a href="#如何判断对象可以回收？" class="headerlink" title="如何判断对象可以回收？"></a>如何判断对象可以回收？</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>给对象中添加一个<code>引用计数器</code>，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p>
<p>它的优点是简单、高效，但是缺点也是异常明显：无法解决<code>对象循环引用</code>的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象循环引用示例</span></span><br><span class="line">Object objectA = <span class="keyword">new</span> Object();</span><br><span class="line">Object objectB = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">objectA.instance = objectB;</span><br><span class="line">objectB.instance = objectA;</span><br><span class="line"></span><br><span class="line">objectA = <span class="keyword">null</span>;</span><br><span class="line">objectB = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">System.gc();</span><br></pre></td></tr></table></figure>
<p>假设我们有上面的代码。程序启动后，objectA和objectB两个对象被创建并在堆中分配内存，它们都相互持有对方的引用，但是除了它们相互持有的引用之外，再无别的引用。</p>
<p>而实际上，引用已经被置空，这两个对象不可能再被访问了，但是因为它们相互引用着对方，导致它们的引用计数都不为0，因此引用计数算法无法通知GC回收它们，造成了内存的浪费。如下图：对象之间的引用形成一个有环图。<br><img src="/pics/image-20210417183019446.png" alt="image-20210417183019446" style="zoom:50%;" /></p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>通过一系列称为<code>GC Roots</code>的对象作为起始点，从这些节点开始向下搜索，搜索所走过的引用路径称为<code>引用链（Reference Chain）</code>，当一个对象到GC Roots 没有任何的引用链相连时，则证明此对象不可用的，是可以被回收的。</p>
<img src="/pics/image-20210417184107213.png" alt="image-20210417184107213" style="zoom:30%;" />

<h4 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h4><p>在 Java 语言中，可作为 GC Root 的对象包括以下 4 种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象（static）</li>
<li>方法区中常量引用的对象（static final）</li>
<li>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象</li>
</ul>
<h4 id="Java引用"><a href="#Java引用" class="headerlink" title="Java引用"></a>Java引用</h4><p>Java 中的引用类型总共有四种：强引用，软引用，弱引用，虚引用。</p>
<ul>
<li><p>强引用就是最普通的对象引用，每当 new 一个对象的时候，都是生成一个强引用。这种引用对垃圾回收免疫，即使发生 OOM，这种对象也不会被回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure></li>
<li><p>软引用的强度相对弱一些，用来描述一些还有用但非必须的对象。在发生 OOM 之前，JVM 会尝试去回收这些对象，软引用的实现类是 SoftReference。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Object();</span><br><span class="line">SoftReference srf = <span class="keyword">new</span> SoftReference(o);</span><br></pre></td></tr></table></figure></li>
<li><p>弱引用就更弱了，用来描述一些非必需对象，碰上了垃圾回收，弱引用的对象肯定会被回收，弱引用的实现类是 WeakReference。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Object();</span><br><span class="line">WeakReference wrf = <span class="keyword">new</span> WeakReference(o);</span><br></pre></td></tr></table></figure></li>
<li><p>虚引用无法引用对象，实际只是做一些垃圾清理之后的事情, 虚引用的实现类是 PhantomReference。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object o = new Object();</span><br><span class="line">ReferenceQueue rq = new ReferenceQueue();</span><br><span class="line">PhantomReference prf = new PhantomReference(o, rq);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>上面的各种引用都继承了 Reference 类，Reference 类中有一个 get 方法，如果软引用和弱引用所指向的对象没有被回收，那么使用 get 方法就可以获取原对象的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Object();</span><br><span class="line">SoftReference srf = <span class="keyword">new</span> SoftReference(o);</span><br><span class="line">o = <span class="keyword">null</span>; <span class="comment">// 断开强引用</span></span><br><span class="line">System.out.println(srf.get()); <span class="comment">// java.lang.Object@17579e0f</span></span><br></pre></td></tr></table></figure>

<p>虚引用 PhantomReference 的 get 方法会一直返回 null，所以无法通过虚引用获取到对象。虚引用的意义在于提供了一种在对象被回收之后做某些事情的机制，在这里就需要谈到引用队列。</p>
<p>ReferenceQueue 称之为引用队列。如果我们为一个引用指定一个引用队列，那么这个引用所指向的队列在被垃圾回收后，该引用就会被加入到引用队列中。</p>
<p>我们就可以根据引用队列中的引用来判断某个对象是否被回收，或者直接清除引用队列的引用对象，具体的逻辑要看具体的业务场景。</p>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记 - 清除算法"></a>标记 - 清除算法</h3><p>“标记-清除”（Mark-Sweep）算法，如同它的名字一样，算法分为“标记”和“清除”两个阶段：</p>
<ul>
<li>首先标记出所有需要回收的对象</li>
<li>在标记完成后统一回收所有被标记的对象</li>
</ul>
<p>主要不足有两个：</p>
<ol>
<li><p>效率问题</p>
<p>标记和清除两个过程的效率都不高；</p>
</li>
<li><p>空间问题</p>
<p>标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>
</li>
</ol>
<img src="/pics/image-20210417202955925.png" alt="image-20210417202955925" style="zoom:50%;" />

<h4 id="可达性算法中的标记"><a href="#可达性算法中的标记" class="headerlink" title="可达性算法中的标记"></a>可达性算法中的标记</h4><p>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize方法。当对象没有覆盖finalize方法，或者finalize方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</p>
<p>如果这个对象被判定为有必要执行finalize方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。</p>
<p>finalize方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。</p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p>
<p>这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。</p>
<p>不足：内存缩小为了原来的一半。</p>
<img src="/pics/image-20210417204202632.png" alt="image-20210417204202632" style="zoom:50%;" />

<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记 - 整理算法"></a>标记 - 整理算法</h3><p>“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</p>
<img src="/pics/image-20210417204307864.png" alt="image-20210417204307864" style="zoom:50%;" />

<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，根据对象存活周期的不同将内存划分为几块，各再根据个年代的特点采用最适当的收集算法。</p>
<p><strong>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法</strong>，只需要付出少量存活对象的复制成本就可以完成收集。</p>
<p>老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。</p>
<h2 id="HotSpot的算法实现"><a href="#HotSpot的算法实现" class="headerlink" title="HotSpot的算法实现"></a>HotSpot的算法实现</h2><h3 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h3><p>Stop The World + OopMap(类加载完成后，特定位置记录类引用的类型数据的地址)</p>
<p>可达性分析时为<code>保证结果准确性，不可出现分析过程中对象引用关系还在不断变化的情况</code>，所以GC进行时必须停顿所有Java执行线程（称为“Stop The World”）。</p>
<p>当进入STW状态时，虚拟机需要知道哪些地方放着对象引用。在HotSpot的实现中，是使用一组称为<strong>OopMap</strong>的数据结构来达到这个目的的，在类加载完成的时候，<code>HotSpot就把对象内什么偏移量上是什么类型的数据计算出来</code>，在JIT编译过程中，也会在<strong>特定的位置</strong>记录下栈和寄存器中哪些位置是引用。这样，GC在扫描时就可以直接得知这些信息了。</p>
<h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举，但一个很现实的问题随之而来：可能导致引用关系变化（OopMap内容变化）的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本将会变得很高。</p>
<p>HotSpot也的确没有为每条指令都生成OopMap，前面已经提到，只是在“特定的位置”记录了这些信息，这些位置称为安全点（Safepoint），只有在到达安全点时才能暂停。</p>
<p>安全点的选定基本上是以程序<code>是否具有让程序长时间执行的特征</code>为标准进行选定的，“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生Safepoint。</p>
<h4 id="抢先式中断和主动式中断"><a href="#抢先式中断和主动式中断" class="headerlink" title="抢先式中断和主动式中断"></a>抢先式中断和主动式中断</h4><p>对于Sefepoint，另一个需要考虑的问题是如何在GC发生时让所有线程都“跑”到最近的安全点上再停顿下来。</p>
<ul>
<li><p>抢先式中断（Preemptive Suspension）</p>
<p>不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。</p>
</li>
<li><p>主动式中断（Voluntary Suspension）</p>
<p>当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。</p>
</li>
</ul>
<p>现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。</p>
<h3 id="安全区"><a href="#安全区" class="headerlink" title="安全区"></a>安全区</h3><p>Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”（没有分配CPU时间）的时候呢？比如线程处于Sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全的地方去中断挂起，JVM也显然不太可能等待线程重新被分配CPU时间。对于这种情况，就需要安全区域（Safe Region）来解决。</p>
<p><code>安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。</code></p>
<p>在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。</p>
<p>在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。</p>
<h2 id="HotSpot垃圾收集器"><a href="#HotSpot垃圾收集器" class="headerlink" title="HotSpot垃圾收集器"></a>HotSpot垃圾收集器</h2><img src="/pics/image-20210417210644456.png" alt="image-20210417210644456" style="zoom:33%;" />

<blockquote>
<p>说明：如果两个垃圾回收器之间存在连线说明他们之间是可以搭配使用的</p>
</blockquote>
<h3 id="Serial-和-Serial-Old-回收器"><a href="#Serial-和-Serial-Old-回收器" class="headerlink" title="Serial 和 Serial Old 回收器"></a>Serial 和 Serial Old 回收器</h3><p>Serial</p>
<ul>
<li>工作在新生代</li>
<li>复制算法</li>
<li>单线程的垃圾回收器，当垃圾回收线程开始的时候，工作（业务）线程必须暂停</li>
</ul>
<p>Serial Old</p>
<ul>
<li>工作在老年代</li>
<li>标记-整理算法<img src="/pics/image-20210417213537906.png" alt="image-20210417213537906" style="zoom:50%;" /></li>
</ul>
<h3 id="ParNew-回收器"><a href="#ParNew-回收器" class="headerlink" title="ParNew 回收器"></a>ParNew 回收器</h3><ul>
<li>ParNew可以认为是Serial的<code>多线程</code>版本</li>
<li>ParNew是<code>多线程并行</code>回收的，回收时<code>工作线程</code>必须暂停</li>
</ul>
<img src="/pics/image-20210417211623550.png" alt="image-20210417211623550" style="zoom:50%;" />

<blockquote>
<p>注意　从ParNew收集器开始，后面还会接触到几款并发和并行的收集器。并发和并行。这两个名词都是并发编程中的概念，在谈论垃圾收集器的上下文语境中，它们可以解释如下。</p>
<p>●并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于暂停（等待）状态。</p>
<p>●并发（Concurrent）：指工作（用户）线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上</p>
</blockquote>
<h3 id="Parallel-Scavenge-Parallel-Old-回收器"><a href="#Parallel-Scavenge-Parallel-Old-回收器" class="headerlink" title="Parallel Scavenge/Parallel Old 回收器"></a>Parallel Scavenge/Parallel Old 回收器</h3><p>Parallel Scavenge </p>
<ul>
<li>新生代</li>
<li>复制算法</li>
<li>使用多线程进行垃圾回收，回收时工作线程处于暂停状态</li>
</ul>
<p>Parallel Old </p>
<ul>
<li>是 Parallel Scavenge 的老年代版本，也就是说<code>Parallel Old</code>工作在<code>老年代</code></li>
<li>标记-整理</li>
<li>多线程并行</li>
</ul>
<p>JDK1.8默认采用的垃圾回收器：Parallel Scavenge、Parallel Old</p>
<img src="/pics/image-20210417212833916.png" alt="image-20210417212833916" style="zoom:50%;" />

<p>Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是<code>尽可能地缩短垃圾收集时用户线程的停顿时间</code>，而Parallel Scavenge收集器的目标则是<code>达到一个可控制的吞吐量（Throughput）</code>。</p>
<p>Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX：MaxGCPauseMillis）以及直接设置吞吐量大小的-XX：GCTimeRatio参数。</p>
<p>MaxGCPauseMillis参数允许的值是一个大于0的毫秒数，收集器将尽可能地保证内存回收花费的时间不超过设定值。不过大家不要认为如果把这个参数的值设置得稍小一点就能使得系统的垃圾收集速度变得更快，<code>GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的</code>：系统把新生代调小一些，收集300MB新生代肯定比收集500MB快吧，这也直接导致垃圾收集发生得更频繁一些，原来10秒收集一次、每次停顿100毫秒，现在变成5秒收集一次、每次停顿70毫秒。停顿时间的确在下降，但吞吐量也降下来了。</p>
<h3 id="CMS-回收器"><a href="#CMS-回收器" class="headerlink" title="CMS 回收器"></a>CMS 回收器</h3><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。</p>
<ul>
<li><p>老年代</p>
</li>
<li><p>CMS是<code>多线程并发</code>的，也就是说<code>垃圾线程</code>和<code>工作线程</code>是可以<code>一起执行</code>的</p>
</li>
<li><p>采用 <code>标记-清除</code> 算法实现</p>
</li>
<li><p>运行步骤：</p>
<ul>
<li>初始标记(CMS initial mark)：标记 GC Roots 能直接关联到的对象</li>
<li>并发标记(CMS concurrent mark)：进行 GC Roots Tracing</li>
<li>重新标记(CMS remark)：修正并发标记期间的变动部分<ul>
<li>这里要注意：重新标记就不能业务线程和垃圾线程一起执行了，也就是不能并发执行了</li>
</ul>
</li>
<li>并发清除(CMS concurrent sweep)</li>
</ul>
</li>
</ul>
<img src="/pics/image-20210417222939099.png" alt="image-20210417222939099" style="zoom:50%;" />

<h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4><ul>
<li><p>CMS收集器对CPU资源非常敏感</p>
<p>在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。</p>
</li>
<li><p>CMS收集器无法处理浮动垃圾（Floating Garbage）</p>
<p>由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”。</p>
<p>也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。</p>
</li>
<li><p>CMS是一款基于“标记—清除”算法实现的收集器。</p>
<p>收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。</p>
</li>
</ul>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><ul>
<li>Java堆，划分成一个个Region</li>
<li>标记- 整理 （整体上看）</li>
<li>运作步骤：<ul>
<li>初始标记(Initial Marking)</li>
<li>并发标记(Concurrent Marking)</li>
<li>最终标记(Final Marking)</li>
<li>筛选回收(Live Data Counting and Evacuation)</li>
</ul>
</li>
</ul>
<p><img src="/pics/image-20210417215936579.png" alt="image-20210417215936579"></p>
<p>G1优点</p>
<ol>
<li>并行与并发：多线程并行回收；工作线程和GC线程并发执行</li>
<li>分代收集：采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象</li>
<li>空间整合：G1从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的。没有CMS标记—清理的缺点。</li>
<li>可预测的停顿：这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</li>
</ol>
<h4 id="Region"><a href="#Region" class="headerlink" title="Region"></a>Region</h4><p>使用G1收集器时，Java堆的内存布局就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。</p>
<p>G1跟踪各个Region里面的垃圾堆积的价值大小<code>（回收所获得的空间大小以及回收所需时间的经验值）</code>，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</p>
<h4 id="Remembered-Set"><a href="#Remembered-Set" class="headerlink" title="Remembered Set"></a>Remembered Set</h4><p>在G1收集器中，Region之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，虚拟机都是使用Remembered Set来避免全堆扫描的。G1中每个Region都有一个与之对应的Remembered Set，虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，<code>检查Reference引用的对象是否处于不同的Region之中，如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set之中</code>。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。</p>
<h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><ol>
<li><p>对象优先在Eden分配</p>
</li>
<li><p>大对象直接进入老年代</p>
</li>
<li><p>长期存活的对象将进入老年代</p>
</li>
<li><p>动态对象年龄判定</p>
<p>为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold（默认15）才能晋升老年代。</p>
<p>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</p>
</li>
<li><p>空间分配担保</p>
<p>在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。</p>
<p>如果不成立，则虚拟机会判断是否允许<code>冒险担保失败（HandlePromotionFailure）</code>。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者不允许冒险担保，那这时也要改为进行一次Full GC。</p>
</li>
</ol>
<p>“冒险”是冒了什么风险？</p>
<blockquote>
<p>前面提到过，新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。</p>
<p>与生活中的贷款担保类似，老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象会活下来在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。</p>
</blockquote>
<p>Minor GC和Full GC有什么不一样吗？</p>
<blockquote>
<p>新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。</p>
<p>老年代GC（Major GC/Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/04/Notes/Android/NET_01_HTTP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/04/Notes/Android/NET_01_HTTP/" class="post-title-link" itemprop="url">NET_01_HTTP</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-04 18:59:33" itemprop="dateCreated datePublished" datetime="2021-07-04T18:59:33+08:00">2021-07-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="NET-01-HTTP"><a href="#NET-01-HTTP" class="headerlink" title="NET_01_HTTP"></a>NET_01_HTTP</h1><h2 id="一、HTTP协议"><a href="#一、HTTP协议" class="headerlink" title="一、HTTP协议"></a>一、HTTP协议</h2><h3 id="1-1、请求方式"><a href="#1-1、请求方式" class="headerlink" title="1.1、请求方式"></a>1.1、请求方式</h3><h3 id="1-2、请求"><a href="#1-2、请求" class="headerlink" title="1.2、请求"></a>1.2、请求</h3><img src="/pics/image-20210704204122974.png" alt="image-20210704204122974" style="zoom:50%;" />

<h3 id="1-3、响应"><a href="#1-3、响应" class="headerlink" title="1.3、响应"></a>1.3、响应</h3><h4 id="1-3-1、状态码"><a href="#1-3-1、状态码" class="headerlink" title="1.3.1、状态码"></a>1.3.1、状态码</h4><img src="/pics/image-20210704192743868.png" alt="image-20210704192743868" style="zoom:50%;" />

<h4 id="1-3-2、响应头"><a href="#1-3-2、响应头" class="headerlink" title="1.3.2、响应头"></a>1.3.2、响应头</h4><img src="/pics/image-20210704204247914.png" alt="image-20210704204247914" style="zoom:50%;" />



<img src="/pics/image-20210704220713953.png" alt="image-20210704220713953" style="zoom:50%;" />



<h2 id="二、TCP"><a href="#二、TCP" class="headerlink" title="二、TCP"></a>二、TCP</h2><h3 id="2-1、什么是连接？"><a href="#2-1、什么是连接？" class="headerlink" title="2.1、什么是连接？"></a>2.1、什么是连接？</h3><p><strong>RFC 793 传输控制协议</strong></p>
<ul>
<li>防止连接时候混乱的问题，比如过期的连接，过期是由发送方来判断。</li>
<li>弱网下，数据包丢失，顺序混乱，通过序列号，保证</li>
</ul>
<img src="/pics/image-20210704191205796.png" alt="image-20210704191205796" style="zoom:40%;" />



<img src="/pics/image-20210704191406391.png" alt="image-20210704191205796" style="zoom:40%;" />

<h3 id="2-2、TCP报文首部详解"><a href="#2-2、TCP报文首部详解" class="headerlink" title="2.2、TCP报文首部详解"></a>2.2、TCP报文首部详解</h3><img src="/pics/image-20210704224113783.png" alt="image-20210704224113783" style="zoom:50%;" />

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Source Port Number：源端口</span><br><span class="line">　　之所以占据16个bit位，是因为2的16次方正好可以标识65535个端口号</span><br><span class="line">Destination Port Number：目标端口</span><br><span class="line">Sequence Number：请求时附带的随机序列号</span><br><span class="line">Acknowledgement Number：应答时附带的序列号</span><br><span class="line">　　在对方请求时附带的序列号的基础上加1</span><br><span class="line">Header Length：报文首部的长度</span><br><span class="line">　　4个bits表示首部最长的长度为2个4次方，也就是可以标识15段，一段为4个字节，则最长长度为60个字节</span><br><span class="line">Reserved：报文的标识位，占据6bit，可表示6个flag　　URG：报文段中发送的数据是否包含紧急数据，值为1时表示有紧急数据（后面的紧急字段只有当URG值为1时才生效）</span><br><span class="line">　　ACK：表示是否前面的确认号字段是否有效，ACK=1，表示有效（TCP规定，连接建立后，ACK必须为1）</span><br><span class="line">　　PSH：告诉对方收到该报文段收是否应该立即把数据推送给上层，如果为1，则表示对方应该立即把数据提交给上层，而不是缓存起来</span><br><span class="line">　　RST：与主机的连接出现了严重错误（如主机奔溃），必须释放连接，然后再重新建立连接（或者说上次发送的数据有问题，主机拒绝响应）</span><br><span class="line">　　SYN：在建立连接时使用，用来同步序号</span><br><span class="line">　　　　当SYN为1，ACK为0时，表示这是一个请求连接的报文段</span><br><span class="line">　　　　当SYN为1，ACK为1时，表示对方同意建立连接</span><br><span class="line">　　　　SYN为1，说明这是一个请求建立连接或同意建立连接的报文，只有在前两次握手中SYN才置1</span><br><span class="line">　　FIN：标记数据是否发送完毕，如果FIN=1，将相当于告诉对方，自己的数据已经发送完毕，对方可以释放连接了</span><br><span class="line">Windows Size：滑动窗口的大小</span><br><span class="line">　　用以告知对方自己接受缓冲区的大小，以协商出一个合适的传输速率</span><br><span class="line">TCP Checksum：TCP的校验和，提供额外的可靠性</span><br><span class="line">Urgent Pointer：标记进制数据在字段中的位置</span><br><span class="line">Options：可选部分（这部分的最大长度为40Bytes）</span><br><span class="line">Data：数据部分</span><br></pre></td></tr></table></figure>

<h3 id="2-3、三次握手"><a href="#2-3、三次握手" class="headerlink" title="2.3、三次握手"></a>2.3、三次握手</h3><img src="/pics/image-20210704192333642.png" alt="image-20210704192333642" style="zoom:50%;" />

 

<img src="/pics/image-20210704190328897.png" alt="image-20210704190328897" style="zoom:30%;" />



<p><code>SEQ</code> ：序列号</p>
<p><code>ack</code> ：确认号，一般等于SEQ + 1</p>
<p><code>SYN</code> ：同步位，SYN = 1 表示进行网络请求</p>
<p><code>ACK</code>： 确认标记位</p>
<p><code>FIN</code>：结束标记位</p>
<h3 id="2-4、四次挥手"><a href="#2-4、四次挥手" class="headerlink" title="2.4、四次挥手"></a>2.4、四次挥手</h3><img src="/pics/image-20210705000512218.png" alt="image-20210705000512218" style="zoom:30%;" />

<h3 id="2-5、流量控制"><a href="#2-5、流量控制" class="headerlink" title="2.5、流量控制"></a>2.5、流量控制</h3><p>滑动窗口（接收窗口）：接受方当前可用的缓存大小。</p>
<h3 id="2-6、拥塞控制"><a href="#2-6、拥塞控制" class="headerlink" title="2.6、拥塞控制"></a>2.6、拥塞控制</h3><p>控制发送方的发送速率。</p>
<h2 id="三、DNS-过程"><a href="#三、DNS-过程" class="headerlink" title="三、DNS 过程"></a>三、DNS 过程</h2><img src="/pics/image-20210704182114232.png" alt="image-20210704190328897" style="zoom:30%;" />

<p>流量控制和</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/02/Notes/Android/Framework/FrameWork_04_%E6%8F%92%E4%BB%B6%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/02/Notes/Android/Framework/FrameWork_04_%E6%8F%92%E4%BB%B6%E5%8C%96/" class="post-title-link" itemprop="url">FrameWork_04_AMS 和 插件化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-02 00:02:25" itemprop="dateCreated datePublished" datetime="2021-07-02T00:02:25+08:00">2021-07-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="AMS-和-插件化"><a href="#AMS-和-插件化" class="headerlink" title="AMS 和 插件化"></a>AMS 和 插件化</h1><h2 id="一、插件加载"><a href="#一、插件加载" class="headerlink" title="一、插件加载"></a>一、插件加载</h2><h2 id="二、插件Activity启动"><a href="#二、插件Activity启动" class="headerlink" title="二、插件Activity启动"></a>二、插件Activity启动</h2><h2 id="三、插件资源加载"><a href="#三、插件资源加载" class="headerlink" title="三、插件资源加载"></a>三、插件资源加载</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/26/Notes/Android/Framework/FrameWork_06_View%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/26/Notes/Android/Framework/FrameWork_06_View%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/" class="post-title-link" itemprop="url">FrameWork_06_View事件分发</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-26 18:51:31" itemprop="dateCreated datePublished" datetime="2021-06-26T18:51:31+08:00">2021-06-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="FrameWork-06-View事件分发"><a href="#FrameWork-06-View事件分发" class="headerlink" title="FrameWork_06_View事件分发"></a>FrameWork_06_View事件分发</h1><h2 id="一、MoveEvent"><a href="#一、MoveEvent" class="headerlink" title="一、MoveEvent"></a>一、MoveEvent</h2><p>在手指接触屏幕后所产生的一系列事件中，典型的事件类型有如下几种：</p>
<ul>
<li>ACTION_DOWN——手指刚接触屏幕；</li>
<li>ACTION_MOVE——手指在屏幕上移动；</li>
<li>ACTION_UP——手机从屏幕上松开的一瞬间。</li>
</ul>
<p>正常情况下，一次手指触摸屏幕的行为会触发一系列点击事件，典型的事件序列有以下2种：</p>
<ul>
<li>点击屏幕后离开松开，事件序列为DOWN -&gt; UP；</li>
<li>点击屏幕滑动一会再松开，事件序列为DOWN -&gt; MOVE -&gt; … &gt; MOVE -&gt; UP。</li>
</ul>
<h2 id="二、点击事件的传递规则"><a href="#二、点击事件的传递规则" class="headerlink" title="二、点击事件的传递规则"></a>二、点击事件的传递规则</h2><p>点击事件的事件分发，其实就是对MotionEvent事件的分发过程，即当一个MotionEvent产生了以后，系统需要把这个事件传递给一个具体的View，而这个传递的过程就是分发过程。点击事件的分发过程由三个很重要的方法来共同完成：dispatchTouchEvent、onInterceptTouchEvent和onTouchEvent，下面我们先介绍一下这几个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span></span></span><br></pre></td></tr></table></figure>

<p>用来进行事件的分发。如果事件能够传递给当前View，那么此方法一定会被调用，返回结果受当前View的onTouchEvent和下级View的dispatchTouchEvent方法的影响，表示是否消耗当前事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span></span></span><br></pre></td></tr></table></figure>

<p>在上述方法内部调用，用来判断是否拦截某个事件，如果当前View拦截了某个事件，那么在同一个事件序列当中，此方法不会被再次调用，返回结果表示是否拦截当前事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span></span></span><br></pre></td></tr></table></figure>

<p>在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一个事件序列中，当前View无法再次接收到事件。<br>上述三个方法到底有什么区别呢？它们是什么关系呢？其实它们的关系可以用如下伪代码表示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> consume = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (onInterceptTouchEvent(ev)) &#123;</span><br><span class="line">        consume = onTouchEvent(ev);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        consume = child.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> consume;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于一个根ViewGroup来说，点击事件产生后，首先会传递给它，这时它的dispatchTouchEvent就会被调用，</p>
<ul>
<li>如果这个ViewGroup的onInterceptTouchEvent方法返回true就表示它要拦截当前事件，接着事件就会交给这个ViewGroup处理，即它的onTouchEvent方法就会被调用；</li>
<li>如果这个ViewGroup的onInterceptTouchEvent方法返回false就表示它不拦截当前事件，这时当前事件就会继续传递给它的子元素，接着子元素的dispatchTouchEvent方法就会被调用，如此反复直到事件被最终处理。</li>
</ul>
<h2 id="三、activity中事件的分发过程"><a href="#三、activity中事件的分发过程" class="headerlink" title="三、activity中事件的分发过程"></a>三、activity中事件的分发过程</h2><p>当一个点击事件产生后，它的传递过程遵循如下顺序：Activity -&gt; Window -&gt; View，即事件总是先传递给Activity, Activity再传递给Window，最后Window再传递给顶级View。顶级View接收到事件后，就会按照事件分发机制去分发事件。</p>
<img src="/pics/image-20210626214517837.png" alt="image-20210626214517837" style="zoom:40%;" />



<h3 id="3-1、Activity-dispatchTouchEvent"><a href="#3-1、Activity-dispatchTouchEvent" class="headerlink" title="3.1、Activity#dispatchTouchEvent"></a>3.1、Activity#dispatchTouchEvent</h3><p>首先事件开始交给Activity所附属的Window进行分发，如果返回true，整个事件循环就结束了，返回false意味着事件没人处理，所有View的onTouchEvent都返回了false，那么Activity的onTouchEvent就会被调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        onUserInteraction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> onTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2、PhoneWindow-superDispatchTouchEvent"><a href="#3-2、PhoneWindow-superDispatchTouchEvent" class="headerlink" title="3.2、PhoneWindow#superDispatchTouchEvent"></a>3.2、PhoneWindow#superDispatchTouchEvent</h3><p>PhoneWindow将事件直接传递给了DecorView</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3、DecorView-superDispatchTouchEvent"><a href="#3-3、DecorView-superDispatchTouchEvent" class="headerlink" title="3.3、DecorView#superDispatchTouchEvent"></a>3.3、DecorView#superDispatchTouchEvent</h3><p>DecorView继承自FrameLayout，事件会传递给ViewGroup</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean superDispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">    return super.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4、ViewGroup-dispatchTouchEvent"><a href="#3-4、ViewGroup-dispatchTouchEvent" class="headerlink" title="3.4、ViewGroup#dispatchTouchEvent"></a>3.4、ViewGroup#dispatchTouchEvent</h3><p>ViewGroup 的事件分发逻辑较长，可以分为三部分讲解。</p>
<h2 id="四、事件分发"><a href="#四、事件分发" class="headerlink" title="四、事件分发"></a>四、事件分发</h2><h3 id="4-1、判断是否要拦截事件"><a href="#4-1、判断是否要拦截事件" class="headerlink" title="4.1、判断是否要拦截事件"></a>4.1、判断是否要拦截事件</h3><p>ViewGroup在如下两种情况下会判断是否要拦截当前事件：</p>
<ul>
<li><p>事件类型为ACTION_DOWN</p>
</li>
<li><p>mFirstTouchTarget ! = null，当ViewGroup不拦截事件并将事件交由子元素处理时。</p>
<p>如果事件由当前ViewGroup拦截时<code>（mFirstTouchTarget == null 成立）</code>。那么当ACTION_MOVE和ACTION_UP事件到来时，由于<code>(actionMasked == MotionEvent. ACTION_DOWN || mFirstTouchTarget ! = null) 不成立</code>，将导致ViewGroup的onInterceptTouchEvent不会再被调用，同一序列中的其他事件都会由ViewGroup处理。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Check for interception.</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">        || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">        intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">        ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        intercepted = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// There are no touch targets and this action is not an initial down</span></span><br><span class="line">    <span class="comment">// so this view group continues to intercept touches.</span></span><br><span class="line">    intercepted = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>FLAG_DISALLOW_INTERCEPT</strong></p>
<p>一般用于子View中，FLAG_DISALLOW_INTERCEPT一旦设置后，<strong>ViewGroup将无法拦截除了ACTION_DOWN以外的其他点击事件</strong>。为什么说是除了ACTION_DOWN以外的其他事件呢？这是因为ViewGroup在分发事件时，如果是ACTION_DOWN就会重置FLAG_DISALLOW_INTERCEPT这个标记位，将导致子View中设置的这个标记位无效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">    <span class="comment">// Throw away all previous state when starting a new touch gesture.</span></span><br><span class="line">    <span class="comment">// The framework may have dropped the up or cancel event for the previous gesture</span></span><br><span class="line">    <span class="comment">// due to an app switch, ANR, or some other state change.</span></span><br><span class="line">    cancelAndClearTouchTargets(ev);</span><br><span class="line">    resetTouchState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结下：</p>
<img src="/pics/image-20210627235048935.png" alt="image-20210627235048935" style="zoom:50%;" />

<p>我们可以得出结论：</p>
<blockquote>
<ol>
<li><p><strong>当ViewGroup决定拦截事件后，那么后续的点击事件将会默认交给它处理并且不再调用它的<code>onInterceptTouchEvent</code>方法。</strong></p>
</li>
<li><p>当面对ACTION_DOWN事件时，ViewGroup总是会调用自己的onInterceptTouchEvent方法来询问自己是否要拦截事件，FLAG_DISALLOW_INTERCEPT影响不到<strong>ACTION_DOWN</strong></p>
</li>
</ol>
</blockquote>
<h3 id="4-2、事件分发给子view"><a href="#4-2、事件分发给子view" class="headerlink" title="4.2、事件分发给子view"></a>4.2、事件分发给子view</h3><p>遍历ViewGroup的所有子元素，然后判断子元素是否能够接收到点击事件，</p>
<ul>
<li>如果子元素的dispatchTouchEvent返回false, ViewGroup就会把事件分发给下一个子元素（如果还有下一个子元素的话）</li>
<li>如果遍历所有的子元素后事件都没有被合适地处理，ViewGroup会自己处理点击事件</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> canceled = resetCancelNextUpFlag(<span class="keyword">this</span>)</span><br><span class="line">        || actionMasked == MotionEvent.ACTION_CANCEL;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">boolean</span> alreadyDispatchedToNewTouchTarget = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">				<span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">        <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> x =</span><br><span class="line">                    isMouseEvent ? ev.getXCursorPosition() : ev.getX(actionIndex);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> y =</span><br><span class="line">                    isMouseEvent ? ev.getYCursorPosition() : ev.getY(actionIndex);</span><br><span class="line">            <span class="comment">// Find a child that can receive the event.</span></span><br><span class="line">            <span class="comment">// Scan children from front to back.</span></span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> customOrder = preorderedList == <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; isChildrenDrawingOrderEnabled();</span><br><span class="line">            <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(</span><br><span class="line">                        childrenCount, i, customOrder);</span><br><span class="line">                <span class="keyword">final</span> View child = getAndVerifyPreorderedView(</span><br><span class="line">                        preorderedList, children, childIndex);</span><br><span class="line">              	<span class="comment">// 1.判断子view 是否在播动画 或 点击事件的坐标是否落在子元素的区域内。</span></span><br><span class="line">                <span class="keyword">if</span> (!child.canReceivePointerEvents()</span><br><span class="line">                        || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                newTouchTarget = getTouchTarget(child);</span><br><span class="line">                <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Child is already receiving touch within its bounds.</span></span><br><span class="line">                    <span class="comment">// Give it the new pointer in addition to the ones it is handling.</span></span><br><span class="line">                    newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                resetCancelNextUpFlag(child);</span><br><span class="line">                <span class="comment">// 2.子view 处理事件</span></span><br><span class="line">                <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">                    <span class="comment">// Child wants to receive touch within its bounds.</span></span><br><span class="line">                    mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">                    <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// childIndex points into presorted list, find original index</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                                mLastTouchDownIndex = j;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mLastTouchDownIndex = childIndex;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mLastTouchDownX = ev.getX();</span><br><span class="line">                    mLastTouchDownY = ev.getY();</span><br><span class="line">                    <span class="comment">// 3.拦截后的处理</span></span><br><span class="line">                    newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                    alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-1、dispatchTransformedTouchEvent"><a href="#4-2-1、dispatchTransformedTouchEvent" class="headerlink" title="4.2.1、dispatchTransformedTouchEvent"></a>4.2.1、dispatchTransformedTouchEvent</h4><p>dispatchTransformedTouchEvent实际上调用的就是子元素的dispatchTouchEvent方法，上面的代码中child传递的不是null，因此它会直接调用子元素的dispatchTouchEvent方法，这样事件就交由子元素处理了，从而完成了一轮事件分发。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,</span></span></span><br><span class="line"><span class="params"><span class="function">        View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> handled;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldAction = event.getAction();</span><br><span class="line">    <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">        event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">            handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          	<span class="comment">// 传递给子view处理</span></span><br><span class="line">            handled = child.dispatchTouchEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        event.setAction(oldAction);</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果子元素的dispatchTouchEvent返回true，那么<code>mFirstTouchTarget</code>就会被赋值同时跳出for循环，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">alreadyDispatchedToNewTouchTarget = true;</span><br><span class="line">break;</span><br></pre></td></tr></table></figure>

<p>这几行代码完成了mFirstTouchTarget的赋值并终止对子元素的遍历。</p>
<h4 id="4-2-2、addTouchTarget"><a href="#4-2-2、addTouchTarget" class="headerlink" title="4.2.2、addTouchTarget"></a>4.2.2、addTouchTarget</h4><p>mFirstTouchTarget真正的赋值过程是在addTouchTarget内部完成的，mFirstTouchTarget是否被赋值，将直接影响到ViewGroup对事件的拦截策略，如果mFirstTouchTarget为null，那么ViewGroup就默认拦截接下来同一序列中所有的点击事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> TouchTarget <span class="title">addTouchTarget</span><span class="params">(View child, <span class="keyword">int</span> pointerIdBits)</span> </span>&#123;</span><br><span class="line">    TouchTarget target = TouchTarget.obtain(child, pointerIdBits);</span><br><span class="line">    target.next = mFirstTouchTarget;</span><br><span class="line">    mFirstTouchTarget = target;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果遍历所有的子元素后事件都没有被合适地处理，这包含两种情况：</p>
<ul>
<li>第一种是ViewGroup没有子元素；</li>
<li>第二种是子元素处理了点击事件，但是在dispatchTouchEvent中返回了false，这一般是因为子元素在onTouchEvent中返回了false。</li>
</ul>
<p>在这两种情况下，ViewGroup会自己处理点击事件。</p>
<h3 id="4-3、事件处理"><a href="#4-3、事件处理" class="headerlink" title="4.3、事件处理"></a>4.3、事件处理</h3><p>当mFirstTouchTarget == null，viewGroup会自己处理点击事件，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispatch to touch targets.</span></span><br><span class="line"><span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">  	<span class="comment">// viewGroup的分发</span></span><br><span class="line">    handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">            TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    TouchTarget predecessor = <span class="keyword">null</span>;</span><br><span class="line">    TouchTarget target = mFirstTouchTarget;</span><br><span class="line">    <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123; <span class="comment">// 多指的处理</span></span><br><span class="line">    		<span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会调用dispatchTransformedTouchEvent，此时child 参数为null，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">		handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		handled = child.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从前面的分析可以知道，很显然，这里就转到了View的dispatchTouchEvent方法，即点击事件开始交由View来处理，请看下面的分析。</p>
<h2 id="五、事件处理"><a href="#五、事件处理" class="headerlink" title="五、事件处理"></a>五、事件处理</h2><p>View的事件的处理是<code>dispatchTouchEvent</code>中，由于ViewGroup的重写的<code>dispatchTouchEvent</code>中主要负责的是事件分发，事件的处理也是调用了super.dispatchTouchEvent,    也就是说，调用的也是view的dispatchTouchEvent。</p>
<p>下面来分析下view的<code>dispatchTouchEvent</code>中事件的处理。</p>
<h3 id="5-1、View-dispatchTouchEvent"><a href="#5-1、View-dispatchTouchEvent" class="headerlink" title="5.1、View#dispatchTouchEvent"></a>5.1、View#dispatchTouchEvent</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//... 	</span></span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1. mOnTouchListener 处理</span></span><br><span class="line">        ListenerInfo li = mListenerInfo;</span><br><span class="line">        <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">                &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">// 2. onTouchEvent 处理</span></span><br><span class="line">        <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的源码可以看出View对点击事件的处理过程，可见OnTouchListener的优先级高于onTouchEvent。</p>
<h3 id="5-2、OnTouchListener-onTouch"><a href="#5-2、OnTouchListener-onTouch" class="headerlink" title="5.2、OnTouchListener.onTouch"></a>5.2、OnTouchListener.onTouch</h3><p>如果OnTouchListener中的onTouch方法返回true，那么onTouchEvent就不会被调用，可见OnTouchListener的优先级高于onTouchEvent。</p>
<h3 id="5-3、View-onTouchEvent"><a href="#5-3、View-onTouchEvent" class="headerlink" title="5.3、View#onTouchEvent"></a>5.3、View#onTouchEvent</h3><p>接着再分析onTouchEvent的实现。先看当View处于不可用状态下点击事件的处理过程，如下所示。很显然，不可用状态下的View照样会消耗点击事件，尽管它看起来不可用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE</span><br><span class="line">            || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</span><br><span class="line">            || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</span><br><span class="line">            setPressed(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class="line">        <span class="comment">// A disabled view that is clickable still consumes the touch</span></span><br><span class="line">        <span class="comment">// events, it just doesn&#x27;t respond to them.</span></span><br><span class="line">        <span class="keyword">return</span> clickable;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2、如果View设置有代理，那么还会执行TouchDelegate的onTouchEvent方法，这个onTouchEvent的工作机制看起来和OnTouchListener类似，这里不深入研究了。</span></span><br><span class="line">    <span class="keyword">if</span> (mTouchDelegate != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mTouchDelegate.onTouchEvent(event)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>View的enable属性不影响onTouchEvent的默认返回值。哪怕一个View是disable状态的，只要它的clickable或者longClickable有一个为true，那么它的onTouchEvent就返回true。</p>
</blockquote>
<h3 id="5-4、Click事件的处理"><a href="#5-4、Click事件的处理" class="headerlink" title="5.4、Click事件的处理"></a>5.4、Click事件的处理</h3><p>下面再看一下<code>onTouchEvent</code>中对点击事件的具体处理，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</span><br><span class="line">            (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                <span class="keyword">boolean</span> prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) ! = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) ! = <span class="number">0</span> || prepressed) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                    <span class="keyword">if</span> (! mHasPerformedLongPress) &#123;</span><br><span class="line">                        <span class="comment">// This is a tap, so remove the longpress check</span></span><br><span class="line">                        removeLongPressCallback();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//  Only  perform  take  click  actions  if  we  were  in  the</span></span><br><span class="line"><span class="function">pressed state</span></span><br><span class="line"><span class="function">                        <span class="title">if</span> <span class="params">(! focusTaken)</span> </span>&#123;</span><br><span class="line">                            <span class="comment">// Use a Runnable and post this rather than calling</span></span><br><span class="line">                            <span class="comment">// performClick directly. This lets other visual</span></span><br><span class="line">                                state</span><br><span class="line">                            <span class="comment">// of the view update before click actions start.</span></span><br><span class="line">                            <span class="keyword">if</span> (mPerformClick == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                mPerformClick = <span class="keyword">new</span> PerformClick();</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (! post(mPerformClick)) &#123;</span><br><span class="line">                                performClick();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码来看，只要View的CLICKABLE和LONG_CLICKABLE有一个为true，那么它就会消耗这个事件，即onTouchEvent方法返回true，不管它是不是DISABLE状态。</p>
<blockquote>
<p>View的onTouchEvent默认都会消耗事件（返回true），除非它是不可点击的（clickable和longClickable同时为false）。View的longClickable属性默认都为false, clickable属性要分情况，比如Button的clickable属性默认为true，而TextView的clickable属性默认为false。</p>
</blockquote>
<h4 id="performClick"><a href="#performClick" class="headerlink" title="performClick"></a>performClick</h4><p>当ACTION_UP事件发生时，会触发performClick方法，如果View设置了OnClickListener，那么performClick方法内部会调用它的onClick方法，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> result;</span><br><span class="line">    <span class="keyword">final</span> ListenerInfo li = mListenerInfo;</span><br><span class="line">    <span class="keyword">if</span> (li ! = <span class="keyword">null</span> &amp;&amp; li.mOnClickListener ! = <span class="keyword">null</span>) &#123;</span><br><span class="line">        playSoundEffect(SoundEffectConstants.CLICK);</span><br><span class="line">        li.mOnClickListener.onClick(<span class="keyword">this</span>);</span><br><span class="line">        result = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>onClick会发生的前提是当前View是可点击的，并且它收到了down和up的事件。</p>
</blockquote>
<p>总结下：</p>
<p>当一个View需要处理事件时，如果它设置了OnTouchListener，那么OnTouchListener中的<code>onTouch</code>方法会被回调。</p>
<ul>
<li><p>如果onTouch返回true，那么onTouchEvent方法将不会被调用。</p>
</li>
<li><p>如果onTouch返回false，则当前View的onTouchEvent方法会被调用，由此可见，给View设置的OnTouchListener，其优先级比onTouchEvent要高。</p>
<p>在<code>onTouchEvent</code>方法中，如果当前设置的有OnClickListener，那么它的onClick方法会被调用。可以看出，平时我们常用的OnClickListener，其优先级最低，即处于事件传递的尾端。</p>
</li>
</ul>
<h2 id="六、滑动冲突解决"><a href="#六、滑动冲突解决" class="headerlink" title="六、滑动冲突解决"></a>六、滑动冲突解决</h2><p>假设我们现在要处理的事 ViewPager 内部嵌套 ListView 的场景，此时外部是要响应横向滑动而内部要响应纵向滑动，那该如何处理呢？</p>
<p>首先可以明确的条件是，当 x 轴 滑动的距离大于 Y 轴时，需要ViewPager（父view）响应横向滑动；反之，就需要子view 响应 纵向滑动了。</p>
<h3 id="6-1、外部拦截法"><a href="#6-1、外部拦截法" class="headerlink" title="6.1、外部拦截法"></a>6.1、外部拦截法</h3><p>所谓外部拦截法是指点击事情都先经过父容器的拦截处理，如果父容器需要此事件就拦截，如果不需要此事件就不拦截，这种方法比较符合点击事件的分发机制。</p>
<p>外部拦截法需要重写父容器的<code>onInterceptTouchEvent</code>方法，在内部做相应的拦截即可，这种方法的代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> intercepted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</span><br><span class="line">    <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            intercepted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            <span class="comment">// 父容器需要当前事件</span></span><br><span class="line">            <span class="keyword">if</span> (Math.abs(x - mLastXIntercept) &gt; Math.abs(y - mLastYIntercept)) &#123;</span><br><span class="line">                intercepted = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                intercepted = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">            intercepted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mLastXIntercept = x;</span><br><span class="line">    mLastYIntercept = y;</span><br><span class="line">    <span class="keyword">return</span> intercepted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-1-1、MotionEvent-ACTION-DOWN"><a href="#6-1-1、MotionEvent-ACTION-DOWN" class="headerlink" title="6.1.1、MotionEvent.ACTION_DOWN"></a>6.1.1、MotionEvent.ACTION_DOWN</h4><p>按钮按下时，action = MotionEvent.ACTION_DOWN，父view中，初始状态为：</p>
<p><code>mFirstTouchTarget=null，onInterceptTouchEvent=false，</code></p>
<p>所以事件会分发到子view 中，由子view响应。</p>
<p>分发完毕后，父view中状态为：<code>mFirstTouchTarget = 子view</code>。</p>
<h4 id="6-1-2、第一次处理ACTION-MOVE"><a href="#6-1-2、第一次处理ACTION-MOVE" class="headerlink" title="6.1.2、第一次处理ACTION_MOVE"></a>6.1.2、第一次处理ACTION_MOVE</h4><p>父view中，初始状态为，mFirstTouchTarget = 子view，</p>
<p>当 横向滚动时，intercepted = true，最终事件会进入到 dispatchTransformedTouchEvent 中，此时有2个步骤：</p>
<ol>
<li>通过<code>dispatchTransformedTouchEvent</code>向子view中分发<code>ACTION_CANCEL</code>事件</li>
<li>将 mFirstTouchTarget 置为 null。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> TouchTarget next = target.next;</span><br><span class="line">    <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">        handled = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      	<span class="comment">// intercepted = true</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class="line">                || intercepted;</span><br><span class="line">      	<span class="comment">// step1: 分发cancelChild 到子view中</span></span><br><span class="line">        <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                target.child, target.pointerIdBits)) &#123; </span><br><span class="line">            handled = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cancelChild) &#123; <span class="comment">// true</span></span><br><span class="line">            <span class="keyword">if</span> (predecessor == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// step2：mFirstTouchTarget 被置为 null</span></span><br><span class="line">                mFirstTouchTarget = next; </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                predecessor.next = next;</span><br><span class="line">            &#125;</span><br><span class="line">            target.recycle();</span><br><span class="line">            target = next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    predecessor = target;</span><br><span class="line">    target = next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下这种情况下 <code>dispatchTransformedTouchEvent</code>中时如何分发事件的，此时<code>cancel=true</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,</span></span></span><br><span class="line"><span class="params"><span class="function">        View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> handled;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldAction = event.getAction();</span><br><span class="line">    <span class="comment">// 1.canceled = true</span></span><br><span class="line">    <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">       <span class="comment">// 事件改为 ACTION_CANCEL</span></span><br><span class="line">        event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">            handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		<span class="comment">// 2. 子view 分发 ACTION_CANCEL</span></span><br><span class="line">            handled = child.dispatchTouchEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.事件改回为 ACTION_MOVE</span></span><br><span class="line">        event.setAction(oldAction);</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>以上代码中：canceled = true 时，子view会将MOVE事件改为ACTION_CANCEL事件分发出去。</p>
<p>经过这步后，将 mFirstTouchTarget 值变为 null。</p>
<h4 id="6-1-3、第二次处理ACTION-MOVE"><a href="#6-1-3、第二次处理ACTION-MOVE" class="headerlink" title="6.1.3、第二次处理ACTION_MOVE"></a>6.1.3、第二次处理ACTION_MOVE</h4><p>当继续横向滚动时，由于mFirstTouchTarget == null &amp;&amp; onInterceptTouchEvent = true，所以会执行到如下代码，由父view 进行分发此事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// No touch targets so treat this as an ordinary view.</span></span><br><span class="line">    handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">            TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2、内部拦截法"><a href="#6-2、内部拦截法" class="headerlink" title="6.2、内部拦截法"></a>6.2、内部拦截法</h3><p>内部拦截法是指父容器不拦截任何事件，所有的事件都传递给子元素，如果子元素需要此事件就直接消耗掉，否则就交由父容器进行处理，需要配合<code>requestDisallowInterceptTouchEvent</code>才能正常工作，使用起来较外部拦截法稍显复杂。它的代码如下，我们需要重写子元素的dispatchTouchEvent方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</span><br><span class="line">    <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</span><br><span class="line">    Log.d(TAG, <span class="string">&quot;子view dispatchTouchEvent = &quot;</span> + event.getAction());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">            getParent().requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">            <span class="keyword">int</span> deltaX = x - mLastX;</span><br><span class="line">            <span class="keyword">int</span> deltaY = y - mLastY;</span><br><span class="line">            <span class="comment">// 容器需要此类点击事件</span></span><br><span class="line">            <span class="comment">// 横向交给父view 处理</span></span><br><span class="line">            <span class="keyword">if</span> (Math.abs(deltaX) &gt; Math.abs(deltaY)) &#123;</span><br><span class="line">                getParent().requestDisallowInterceptTouchEvent(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLastX = x;</span><br><span class="line">    mLastY = y;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了子元素需要做处理以外，父元素也要默认拦截除了ACTION_DOWN以外的其他事件，这样当子元素调用<code>parent.requestDisallowInterceptTouchEvent(false)</code>方法时，父元素才能继续拦截所需的事件。</p>
<p><strong>为什么父容器不能拦截ACTION_DOWN事件呢？</strong></p>
<p>那是因为ACTION_DOWN事件并不受FLAG_DISALLOW_INTERCEPT这个标记位的控制，所以一旦父容器拦截ACTION_DOWN事件，那么所有的事件都无法传递到子元素中去，这样内部拦截就无法起作用了。父元素所做的修改如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> action = event.getAction();</span><br><span class="line">		<span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> 	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面逐步分析下为何以上代码可以处理<strong>响应外部响应横向滑动，内部响应纵向滑动</strong>的情况？或者说子view中是如何处理横向滑动的呢？</p>
<h4 id="6-2-1、ACTION-DOWN处理"><a href="#6-2-1、ACTION-DOWN处理" class="headerlink" title="6.2.1、ACTION_DOWN处理"></a>6.2.1、ACTION_DOWN处理</h4><p>按钮按下时，action = MotionEvent.ACTION_DOWN，父view中，初始状态为：</p>
<p><code>mFirstTouchTarget=null，onInterceptTouchEvent=false, disallowIntercept=false</code></p>
<p>所以事件会分发到子view 中，由子view响应。分</p>
<p>发完毕后，父view中状态为：<code>mFirstTouchTarget = 子view， disallowIntercept = true</code>，</p>
<p>接下来看下ACTION_MOVE的处理。</p>
<h4 id="6-2-2、第一次处理ACTION-MOVE"><a href="#6-2-2、第一次处理ACTION-MOVE" class="headerlink" title="6.2.2、第一次处理ACTION_MOVE"></a><strong>6.2.2、第一次处理ACTION_MOVE</strong></h4><p>父view中，初始状态为：<code>mFirstTouchTarget=子view，disallowIntercept = true,onInterceptTouchEvent = true</code>，但是由于父view中<code>disallowIntercept = true</code>，所以还是由子view处理。</p>
<p>子view中识别到横向滑动后，会将</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (Math.abs(deltaX) &gt; Math.abs(deltaY)) &#123;</span><br><span class="line">		getParent().requestDisallowInterceptTouchEvent(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>父view中设置<code>disallowIntercept = false</code>。</p>
<h4 id="6-2-3、第二次处理ACTION-MOVE"><a href="#6-2-3、第二次处理ACTION-MOVE" class="headerlink" title="6.2.3、第二次处理ACTION_MOVE"></a>6.2.3、第二次处理ACTION_MOVE</h4><p>下一次MOVE事件到来之后，由于 <code>disallowIntercept = false</code>，<code>onInterceptTouchEvent=true，mFirstTouchTarget = 子view</code>，事件会由父view 进行处理。</p>
<p>分发事件时，intercepted = true，主要有2个步骤：</p>
<ol>
<li>通过<code>dispatchTransformedTouchEvent</code>向子view中分发<code>ACTION_CANCEL</code>事件</li>
<li>将 mFirstTouchTarget 置为 null。</li>
</ol>
<p>上面已经分析过<a href="#6.1.2%E3%80%81%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%A4%84%E7%90%86ACTION_MOVE">MOVE 变 取消</a></p>
<h4 id="6-2-4、第三次处理ACTION-MOVE"><a href="#6-2-4、第三次处理ACTION-MOVE" class="headerlink" title="6.2.4、第三次处理ACTION_MOVE"></a>6.2.4、第三次处理ACTION_MOVE</h4><p>下一次MOVE事件到来之后，父view中 <code>disallowIntercept = false</code>，<code>onInterceptTouchEvent=true，mFirstTouchTarget = null</code>，所以事件不会分发给子view 会由父view 进行处理。</p>
<h3 id="6-3、MotionEvent-UP"><a href="#6-3、MotionEvent-UP" class="headerlink" title="6.3、MotionEvent.UP"></a>6.3、MotionEvent.UP</h3><p>对于MotionEvent.UP事件来说，无论是内部拦截或是外部拦截方式，即MotionEvent.UP 只响应拦截</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/20/Notes/Android/Framework/FrameWork_05_View%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/20/Notes/Android/Framework/FrameWork_05_View%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">FrameWork_04_AMS 和 插件化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-20 15:48:24" itemprop="dateCreated datePublished" datetime="2021-06-20T15:48:24+08:00">2021-06-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="FrameWork-04-View绘制流程"><a href="#FrameWork-04-View绘制流程" class="headerlink" title="FrameWork_04_View绘制流程"></a>FrameWork_04_View绘制流程</h1><ul>
<li><p><strong>Activity :</strong> 对于每一个 activity 都会有拥有一个 PhoneWindow。</p>
</li>
<li><p><strong>PhoneWindow</strong> ：该类继承于 Window 类，是 Window 类的具体实现，即我们可以通过该类具体去绘制窗口。并且，该类内部包含了一个 DecorView 对象，该 DectorView 对象是所有应用窗口的根 View。</p>
</li>
<li><p><strong>DecorView</strong> 是一个应用窗口的根容器，它本质上是一个 FrameLayout。DecorView 有唯一一个子 View，它是一个垂直 LinearLayout，包含两个子元素，一个是 TitleView（ ActionBar 的容器），另一个是 ContentView（窗口内容的容器）。</p>
</li>
<li><p><strong>ContentView</strong> ：是一个 FrameLayout（android.R.id.content)，我们平常用的 setContentView 就是设置它的子 View 。</p>
</li>
<li><p><strong>WindowManager :</strong> 是一个接口，里面常用的方法有：添加View，更新View和删除View。主要是用来管理 Window 的。WindowManager 具体的实现类是WindowManagerImpl。最终，WindowManagerImpl 会将业务交给 WindowManagerGlobal 来处理。</p>
</li>
<li><p><strong>WindowManagerService (WMS)</strong> ： 负责管理各 app 窗口的创建，更新，删除， 显示顺序。运行在 system_server 进程。</p>
</li>
<li><p><strong>ViewRootImpl</strong> ：拥有 DecorView 的实例，通过该实例来控制 DecorView 绘制。ViewRootImpl 的一个内部类 W，实现了 IWindow 接口，IWindow 接口是供 WMS 使用的，WSM 通过调用 IWindow 一些方法，通过 Binder 通信的方式，最后执行到了 W 中对应的方法中。同样的，ViewRootImpl 通过 IWindowSession 来调用 WMS 的 Session 一些方法。Session 类继承自 <code>IWindowSession.Stub</code>，每一个应用进程都有一个唯一的 Session 对象与 WMS 通信。</p>
</li>
</ul>
<h2 id="一、Actvity布局加载流程"><a href="#一、Actvity布局加载流程" class="headerlink" title="一、Actvity布局加载流程"></a>一、Actvity布局加载流程</h2><h3 id="1-1、布局的层次"><a href="#1-1、布局的层次" class="headerlink" title="1.1、布局的层次"></a>1.1、布局的层次</h3><img src="/pics/image-20210620184143390.png" alt="image-20210620184143390" style="zoom:50%;" />

<h3 id="1-2、window和WMS绑定"><a href="#1-2、window和WMS绑定" class="headerlink" title="1.2、window和WMS绑定"></a>1.2、window和WMS绑定</h3><img src="/pics/image-20210704153047185.png" alt="image-20210704153047185" style="zoom:40%;" />

<h3 id="1-3、Actvity-setContentView"><a href="#1-3、Actvity-setContentView" class="headerlink" title="1.3、Actvity#setContentView"></a>1.3、Actvity#setContentView</h3><img src="/pics/image-20210620220355400.png" alt="image-20210620220355400" style="zoom:40%;" />

<h4 id="Actvity-setContentView"><a href="#Actvity-setContentView" class="headerlink" title="Actvity#setContentView"></a>Actvity#setContentView</h4><p>setContentView 调用到 PhoneWindow的<code>setContentView</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//getWindow() = PhoneWindow</span></span><br><span class="line">    getWindow().setContentView(layoutResID);</span><br><span class="line">    initWindowDecorActionBar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    attachBaseContext(context);</span><br><span class="line"></span><br><span class="line">    mFragments.attachHost(<span class="keyword">null</span> <span class="comment">/*parent*/</span>);</span><br><span class="line"></span><br><span class="line">    mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>, window, activityConfigCallback);</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="PhoneWindow-setContentView"><a href="#PhoneWindow-setContentView" class="headerlink" title="PhoneWindow#setContentView"></a>PhoneWindow#setContentView</h4><ol>
<li>创建DecorView </li>
<li>将Activity 布局添加到 mContentParent 中</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 布局顺序</span></span><br><span class="line">    setContentView(view, <span class="keyword">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// step1: 创建decorView</span></span><br><span class="line">        installDecor();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        mContentParent.removeAllViews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        <span class="keyword">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class="line">                getContext());</span><br><span class="line">        transitionTo(newScene);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// step2: 加载布局</span></span><br><span class="line">        mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParent.requestApplyInsets();</span><br><span class="line">    <span class="keyword">final</span> Callback cb = getCallback();</span><br><span class="line">    <span class="keyword">if</span> (cb != <span class="keyword">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">        cb.onContentChanged();</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParentExplicitlySet = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="PhoneWindow-installDecor"><a href="#PhoneWindow-installDecor" class="headerlink" title="PhoneWindow#installDecor"></a>PhoneWindow#installDecor</h5><ol>
<li>真正创建decorView</li>
<li>关联PhoneWindow 和 DecorView</li>
<li>生成DecorView 的 ContentParent</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mForceDecorInstall = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 1. 创建decorView</span></span><br><span class="line">        mDecor = generateDecor(-<span class="number">1</span>);</span><br><span class="line">        mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</span><br><span class="line">        mDecor.setIsRootNamespace(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != <span class="number">0</span>) &#123;</span><br><span class="line">            mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 2.关联PhoneWindow 和 DecorView</span></span><br><span class="line">        mDecor.setWindow(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 生成mContentParent 布局，</span></span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line"> 				mContentParent = generateLayout(mDecor);</span><br><span class="line">      </span><br><span class="line">    <span class="comment">//...   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>PhoneWindow#generateDecor</strong></p>
<p>创建 DecorView </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> DecorView <span class="title">generateDecor</span><span class="params">(<span class="keyword">int</span> featureId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// System process doesn&#x27;t have application context and in that case we need to directly use</span></span><br><span class="line">    <span class="comment">// the context we have. Otherwise we want the application context, so we don&#x27;t cling to the</span></span><br><span class="line">    <span class="comment">// activity.</span></span><br><span class="line">    Context context;</span><br><span class="line">    <span class="keyword">if</span> (mUseDecorContext) &#123;</span><br><span class="line">        Context applicationContext = getContext().getApplicationContext();</span><br><span class="line">        <span class="keyword">if</span> (applicationContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">            context = getContext();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            context = <span class="keyword">new</span> DecorContext(applicationContext, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (mTheme != -<span class="number">1</span>) &#123;</span><br><span class="line">                context.setTheme(mTheme);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        context = getContext();</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 创建decorView</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DecorView(context, featureId, <span class="keyword">this</span>, getAttributes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>PhoneWindow#generateLayout</strong></p>
<ol>
<li>从主题文件中获取样式信息</li>
<li>根据主题样式，加载窗口布局</li>
<li>将窗口布局添加到DecorView 中</li>
<li>初始化内容容器</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ViewGroup <span class="title">generateLayout</span><span class="params">(DecorView decor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 从主题文件中获取样式信息</span></span><br><span class="line">		TypedArray a = getWindowStyle();</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">		<span class="keyword">if</span> (a.getBoolean(R.styleable.Window_windowNoTitle, <span class="keyword">false</span>)) &#123;</span><br><span class="line">		    requestFeature(FEATURE_NO_TITLE);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.getBoolean(R.styleable.Window_windowActionBar, <span class="keyword">false</span>)) &#123;</span><br><span class="line">		    <span class="comment">// Don&#x27;t allow an action bar if there is no title.</span></span><br><span class="line">		    requestFeature(FEATURE_ACTION_BAR);</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 2.根据主题样式，加载窗口布局</span></span><br><span class="line">  	<span class="keyword">int</span> layoutResource;</span><br><span class="line">    <span class="keyword">int</span> features = getLocalFeatures();</span><br><span class="line">    <span class="comment">// System.out.println(&quot;Features: 0x&quot; + Integer.toHexString(features));</span></span><br><span class="line">    <span class="keyword">if</span> ((features &amp; ((<span class="number">1</span> &lt;&lt; FEATURE_LEFT_ICON) | (<span class="number">1</span> &lt;&lt; FEATURE_RIGHT_ICON))) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mIsFloating) &#123;</span><br><span class="line">            TypedValue res = <span class="keyword">new</span> TypedValue();</span><br><span class="line">            getContext().getTheme().resolveAttribute(</span><br><span class="line">                    R.attr.dialogTitleIconsDecorLayout, res, <span class="keyword">true</span>);</span><br><span class="line">            layoutResource = res.resourceId;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            layoutResource = R.layout.screen_title_icons;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 3.将窗口布局添加到DecorView中</span></span><br><span class="line">   	mDecor.startChanging();</span><br><span class="line">    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);</span><br><span class="line">    <span class="comment">// 4.初始化内容容器</span></span><br><span class="line">		<span class="comment">// 内容容器，ID_ANDROID_CONTENT 定义在 Window 类中，</span></span><br><span class="line">    <span class="comment">// ID_ANDROID_CONTENT = com.android.internal.R.id.content</span></span><br><span class="line">    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);</span><br><span class="line">    <span class="keyword">if</span> (contentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Window couldn&#x27;t find content container view&quot;</span>);</span><br><span class="line">    &#125;		   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DecorView # onResourcesLoaded</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onResourcesLoaded</span><span class="params">(LayoutInflater inflater, <span class="keyword">int</span> layoutResource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mBackdropFrameRenderer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        loadBackgroundDrawablesIfNeeded();</span><br><span class="line">        mBackdropFrameRenderer.onResourcesLoaded(</span><br><span class="line">                <span class="keyword">this</span>, mResizingBackgroundDrawable, mCaptionBackgroundDrawable,</span><br><span class="line">                mUserCaptionBackgroundDrawable, getCurrentColor(mStatusColorViewState),</span><br><span class="line">                getCurrentColor(mNavigationColorViewState));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDecorCaptionView = createDecorCaptionView(inflater);</span><br><span class="line">    <span class="keyword">final</span> View root = inflater.inflate(layoutResource, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (mDecorCaptionView != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mDecorCaptionView.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            addView(mDecorCaptionView,</span><br><span class="line">                    <span class="keyword">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">        &#125;</span><br><span class="line">        mDecorCaptionView.addView(root,</span><br><span class="line">                <span class="keyword">new</span> ViewGroup.MarginLayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Put it below the color views.</span></span><br><span class="line">        addView(root, <span class="number">0</span>, <span class="keyword">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">    &#125;</span><br><span class="line">    mContentRoot = (ViewGroup) root;</span><br><span class="line">    initializeElevation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>installDecor方法实质就是产生mDecor和mContentParent对象。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Actvity布局加载流程可以分为两步：</p>
<ol>
<li><p>创建<code>DecorView</code>并初始化布局</p>
<ol>
<li>创建DecorView</li>
<li>根据主题属性设置布局并将布局添加到 DecorView 中</li>
<li>初始化 mContentParent 对象</li>
<li>关联PhoneWindow 和 DecorView</li>
</ol>
</li>
<li><p>通过LayoutInflater 将activity的布局添加到 <code>mContentParent（R.id.content）</code> 中</p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/feiduclear_up/article/details/46711921">从setContentView方法分析Android加载布局流程</a></p>
<h2 id="二、xml解析流程"><a href="#二、xml解析流程" class="headerlink" title="二、xml解析流程"></a>二、xml解析流程</h2><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/feiduclear_up/article/details/46732879"><strong>从LayoutInflater分析XML布局解析成View的树形结构的过程</strong></a> </p>
<h2 id="三、view-的绘制和渲染过程"><a href="#三、view-的绘制和渲染过程" class="headerlink" title="三、view 的绘制和渲染过程"></a>三、view 的绘制和渲染过程</h2><p>DecorView是怎么添加到窗口的呢？真正的入口是在handleActivityResume 时，将DecorView和 Activity建立联系</p>
<img src="/pics/image-20210620214953160.png" alt="image-20210620214953160" style="zoom:50%;" />

<p>经过层层调用，DecorView的绘制会进入到ViewRootImpl类中的performTraversals()成员方法，这个过程可以参考上面的代码流程图。现在我们主要来分析下 ViewRootImpl类中的performTraversals方法。</p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/feiduclear_up/article/details/46772477">从ViewRootImpl类分析View绘制的流程</a></p>
<img src="/pics/image-20210620221717118.png" alt="image-20210620221717118" style="zoom:40%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="comment">//执行测量操作</span></span><br><span class="line">  performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">//执行布局操作</span></span><br><span class="line">  performLayout(lp, desiredWindowWidth, desiredWindowHeight);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//执行绘制操作</span></span><br><span class="line">	performDraw();</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1、MeasureSpec"><a href="#3-1、MeasureSpec" class="headerlink" title="3.1、MeasureSpec"></a>3.1、MeasureSpec</h3><p>MeasureSpec表示的是一个32位的整形值，<code>它的高2位表示测量模式SpecMode，低30位表示某种测量模式下的规格大小SpecSize</code>。MeasureSpec是View类的一个静态内部类，用来说明应该如何测量这个View。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_SHIFT = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_MASK = <span class="number">0x3</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNSPECIFIED = <span class="number">0</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXACTLY = <span class="number">1</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_MOST = <span class="number">2</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeMeasureSpec</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sUseBrokenMakeMeasureSpec) &#123;</span><br><span class="line">        <span class="keyword">return</span> size + mode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (size &amp; ～MODE_MASK) | (mode &amp; MODE_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMode</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (measureSpec &amp; MODE_MASK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (measureSpec &amp; ～MODE_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MeasureSpec通过将SpecMode和SpecSize打包成一个int值来避免过多的对象内存分配，为了方便操作，其提供了打包和解包方法。</p>
<p>SpecMode有三类，每一类都表示特殊的含义，如下所示。</p>
<ul>
<li><p><strong>UNSPECIFIED</strong></p>
<p>父容器不对View有任何限制，要多大给多大，这种情况一般用于系统内部，表示一种测量的状态。</p>
</li>
<li><p><strong>EXACTLY</strong></p>
<p>父容器已经检测出View所需要的精确大小，这个时候View的最终大小就是SpecSize所指定的值。它对应于LayoutParams中的match_parent和具体的数值这两种模式。</p>
</li>
<li><p><strong>AT_MOST</strong><br>父容器指定了一个可用大小即SpecSize, View的大小不能大于这个值，具体是什么值要看不同View的具体实现。它对应于LayoutParams中的wrap_content。</p>
</li>
</ul>
<h4 id="3-1-1、DecorView-的MeasureSpec"><a href="#3-1-1、DecorView-的MeasureSpec" class="headerlink" title="3.1.1、DecorView 的MeasureSpec"></a>3.1.1、DecorView 的MeasureSpec</h4><p>对于DecorView，其MeasureSpec由<code>窗口的尺寸和其自身的LayoutParams</code>来共同确定；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRootMeasureSpec</span><span class="params">(<span class="keyword">int</span> windowSize, <span class="keyword">int</span> rootDimension)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> measureSpec;</span><br><span class="line">    <span class="keyword">switch</span> (rootDimension) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT:</span><br><span class="line">        <span class="comment">// Window can&#x27;t resize. Force root view to be windowSize.</span></span><br><span class="line">        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ViewGroup.LayoutParams.WRAP_CONTENT:</span><br><span class="line">        <span class="comment">// Window can resize. Set max size for root view.</span></span><br><span class="line">        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// Window wants to be an exact size. Force root view to be that size.</span></span><br><span class="line">        measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> measureSpec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常来说，DecorView根布局宽和高都是MATCH_PARENT，因此DecorView根布局的测量模式就是MeasureSpec.EXACTLY，测量大小一般都是整个屏幕大小，所以一般我们的Activity窗口都是全屏的。</p>
<h4 id="3-1-2、普通view的MeasureSpec"><a href="#3-1-2、普通view的MeasureSpec" class="headerlink" title="3.1.2、普通view的MeasureSpec"></a>3.1.2、普通view的MeasureSpec</h4><p>对于普通View，<code>其MeasureSpec由父容器的MeasureSpec和自身的LayoutParams来共同决定</code>，MeasureSpec一旦确定后，onMeasure中就可以确定View的测量宽/高。</p>
<p>对于普通View来说，View的measure过程由ViewGroup传递而来（所有的view根布局都是DecorView，而DecorView本身是个FrameLayout），先看一下ViewGroup的measureChildWithMargins方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line">		<span class="comment">// 1.根据父view 的Measure 和 子view 的LayoutParams 确定子view的 MeasureSpec</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">            mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</span><br><span class="line">                    + widthUsed, lp.width);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">            mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</span><br><span class="line">                    + heightUsed, lp.height);</span><br><span class="line">		<span class="comment">// 2.最终调用到子view 的 measure方法</span></span><br><span class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>getChildMeasureSpec</strong></p>
<p>根据父view 的Measure 和 子view 的LayoutParams 确定子view的 MeasureSpec。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(spec);</span><br><span class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(spec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size = Math.max(<span class="number">0</span>, specSize - padding);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> resultSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> resultMode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">    <span class="comment">// Parent has imposed an exact size on us</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to be our size. So be it.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to determine its own size. It can&#x27;t be</span></span><br><span class="line">            <span class="comment">// bigger than us.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parent has imposed a maximum size on us</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Child wants a specific size... so be it</span></span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to be our size, but our size is not fixed.</span></span><br><span class="line">            <span class="comment">// Constrain child to not be bigger than us.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to determine its own size. It can&#x27;t be</span></span><br><span class="line">            <span class="comment">// bigger than us.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parent asked to see how big we want to be</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Child wants a specific size... let them have it</span></span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to be our size... find out how big it should</span></span><br><span class="line">            <span class="comment">// be</span></span><br><span class="line">            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</span><br><span class="line">            resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to determine its own size.... find out how</span></span><br><span class="line">            <span class="comment">// big it should be</span></span><br><span class="line">            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</span><br><span class="line">            resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//noinspection ResourceType</span></span><br><span class="line">    <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结下：</p>
<p>&lt;img src=””/pics/image-20210626173859241.png” alt=”image-20210626173859241” style=”zoom:50%;” /&gt;</p>
<h3 id="3-2、measure流程"><a href="#3-2、measure流程" class="headerlink" title="3.2、measure流程"></a>3.2、measure流程</h3><img src="/pics/image-20210620224045177.png" alt="image-20210620224045177" style="zoom:50%;" />



<h4 id="3-2-1、View-的绘制流程"><a href="#3-2-1、View-的绘制流程" class="headerlink" title="3.2.1、View 的绘制流程"></a>3.2.1、View 的绘制流程</h4><p>View的measure过程由其measure方法来完成，measure方法是一个final类型的方法，这意味着子类不能重写此方法，在View的measure方法中会去调用View的onMeasure方法，因此只需要看onMeasure的实现即可，View的onMeasure方法如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>getDefaultSize</strong></p>
<p>可以看出，getDefaultSize这个方法的逻辑很简单，对于我们来说，我们只需要看AT_MOST和．EXACTLY这两种情况。简单地理解，其实getDefaultSize返回的大小就是measureSpec中的specSize，而这个specSize就是View测量后的大小，这里多次提到测量后的大小，是因为View最终的大小是在layout阶段确定的，所以这里必须要加以区分，但是几乎所有情况下View的测量大小和最终大小是相等的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = size;</span><br><span class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">        result = size;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">        result = specSize;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>getSuggestedMinimumWidth</strong></p>
<p>getSuggestedMinimumWidth和getSuggestedMinimumHeight的返回值就是View在UNSPECIFIED情况下的测量宽/高。</p>
<ul>
<li>如果View没有设置背景，那么返回android:minWidth这个属性所指定的值，这个值可以为0；</li>
<li>如果View设置了背景，则返回android:minWidth和背景的最小宽度这两者中的最大值；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>wrap_content需要定义默认宽高？</strong></p>
<p>从getDefaultSize方法的实现来看，View的宽/高由specSize决定，所以我们可以得出如下结论：<code>直接继承View的自定义控件需要重写onMeasure方法并设置wrap_content时的自身大小，否则在布局中使用wrap_content就相当于使用match_parent。</code>为什么呢？</p>
<p>如果View在布局中使用wrap_content，那么它的specMode是AT_MOST模式，在这种模式下，它的宽/高等于specSize；查表4-1可知，此时specSize就是parentSize，而parentSize是父容器中目前可以使用的大小，也就是父容器当前剩余的空间大小。</p>
<p>很显然，View的宽/高就等于父容器当前剩余的空间大小，这种效果和在布局中使用match_parent完全一致。如何解决这个问题呢？也很简单，代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> heightSpecSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">    <span class="keyword">if</span> (widthSpecMode == MeasureSpec.AT_MOST &amp;&amp; heightSpecMode ==</span><br><span class="line">    MeasureSpec.AT_MOST) &#123;</span><br><span class="line">        setMeasuredDimension(mWidth, mHeight);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (widthSpecMode == MeasureSpec.AT_MOST) &#123;</span><br><span class="line">        setMeasuredDimension(mWidth, heightSpecSize);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (heightSpecMode == MeasureSpec.AT_MOST) &#123;</span><br><span class="line">        setMeasuredDimension(widthSpecSize, mHeight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，<code>我们只需要给View指定一个默认的内部宽/高（mWidth和mHeight）</code>，并在wrap_content时设置此宽/高即可。</p>
<p>对于非wrap_content情形，我们沿用系统的测量值即可，至于这个默认的内部宽/高的大小如何指定，这个没有固定的依据，根据需要灵活指定即可。如果查看TextView、ImageView等的源码就可以知道，针对wrap_content情形，它们的onMeasure方法均做了特殊处理，读者可以自行查看它们的源码。</p>
<h4 id="3-2-2、ViewGroup的绘制流程"><a href="#3-2-2、ViewGroup的绘制流程" class="headerlink" title="3.2.2、ViewGroup的绘制流程"></a>3.2.2、ViewGroup的绘制流程</h4><p>对于ViewGroup来说，除了完成自己的measure过程以外，还会遍历去调用所有子元素的measure方法，各个子元素再递归去执行这个过程。和View不同的是，ViewGroup是一个抽象类，它没有重写View的onMeasure方法，由各个具体的ViewGroup比如 FrameLayout去实现，但是它提供了一个叫measureChildren的方法，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildren</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = mChildrenCount;</span><br><span class="line">    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = children[i];</span><br><span class="line">        <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;</span><br><span class="line">            measureChild(child, widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>measureChild</strong></p>
<p>measureChild的思想就是取出子元素的LayoutParams，然后再通过getChildMeasureSpec来创建子元素的MeasureSpec，接着将MeasureSpec直接传递给View的measure方法来进行测量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> parentHeightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> LayoutParams lp = child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">            mPaddingLeft + mPaddingRight, lp.width);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">            mPaddingTop + mPaddingBottom, lp.height);</span><br><span class="line"></span><br><span class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么ViewGroup不像View一样对其onMeasure方法做统一的实现呢？</strong></p>
<p>因为不同的ViewGroup子类有不同的布局特性，这导致它们的测量细节各不相同，比如LinearLayout和RelativeLayout这两者的布局特性显然不同，因此ViewGroup无法做统一实现</p>
<h4 id="3-2-3、view-宽高获取"><a href="#3-2-3、view-宽高获取" class="headerlink" title="3.2.3、view 宽高获取?"></a>3.2.3、view 宽高获取?</h4><p>Activity生命周期<code>onCreate和onStart()，onResume</code>方法中调用<code>View.getWidth()</code>和<code>View.getMeasuredHeight()</code>返回值为0 ?</p>
<p>&lt;img src=””/pics/image-20210626162038865.png” alt=”image-20210626162038865” style=”zoom:50%;” /&gt;</p>
<p>从上面的代码片段执行顺序来看，Activity的onStart和onResume被执行的时候，其实界面还没有开始进行绘制（wm.addView(decor, l)还没执行到），这里就可以解释为什么用Handler.post在onCreate里拿不到宽高。因为Handler机制，Activity生命周期onCreate 和 onResume的都是通过主线程handler 的回调。而view 的绘制流程也是通过向主线程发送消息的方式执行的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 也就是说启动时，主线程队列中的消息执行顺序 为 onCreate -&gt; handleResumeActivity（onResume） -&gt; </p>
<p>doTraversal 。自然而然，view都没有绘制完的情况下是不可能获取到宽高的。</p>
<p><strong>解决方案：</strong></p>
<ol>
<li><p>view.post </p>
<p>本质上也是基于handler的消息机制，比如我们在onCreate 中执行 post</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 位置1</span></span><br><span class="line">    Log.i(<span class="string">&quot;view_w_&amp;_h&quot;</span>, <span class="string">&quot;onCreate &quot;</span> + mView.getWidth() + <span class="string">&quot; &quot;</span> + mView.getHeight());</span><br><span class="line">    mView.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 位置2</span></span><br><span class="line">            Log.i(<span class="string">&quot;view_w_&amp;_h&quot;</span>, <span class="string">&quot;onCreate postRun &quot;</span> + mView.getWidth() + <span class="string">&quot; &quot;</span> + mView.getHeight());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>最终这个runnable 任务会在 <code>performTraversals</code> 完成后被调用，<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/71OV_K7YJas7pLtsPY-jeQ">详见</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void performTraversals() &#123;</span><br><span class="line">    ...</span><br><span class="line">    // 这里再次添加到消息中</span><br><span class="line">    host.dispatchAttachedToWindow(mAttachInfo, 0);</span><br><span class="line">    ...</span><br><span class="line">    performMeasure();</span><br><span class="line">    ...</span><br><span class="line">    performLayout();</span><br><span class="line">    ...</span><br><span class="line">    performDraw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>ViewTreeObserver</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">view.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() &#123;  </span><br><span class="line">        @Override  </span><br><span class="line">        public void onGlobalLayout() &#123;  </span><br><span class="line">            mScrollView.post(new Runnable() &#123;  </span><br><span class="line">                public void run() &#123;  </span><br><span class="line">                    view.getHeight(); </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;);  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure></li>
<li><p>重写Activity的onWindowFocusChanged()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onWindowFocusChanged</span><span class="params">(<span class="keyword">boolean</span> hasFocus)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">super</span>.onWindowFocusChanged(hasFocus);  </span><br><span class="line">		<span class="keyword">if</span> (hasFocus) &#123;</span><br><span class="line">				getHeight();</span><br><span class="line">		&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-3、Layout流程"><a href="#3-3、Layout流程" class="headerlink" title="3.3、Layout流程"></a>3.3、Layout流程</h3><img src="/pics/image-20210620224422346.png" alt="image-20210620224422346" style="zoom:50%;" />



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//判断是否需要重新测量</span></span><br><span class="line">     <span class="keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class="number">0</span>) &#123;</span><br><span class="line">         onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</span><br><span class="line">         mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//保存上一次View的四个位置</span></span><br><span class="line">     <span class="keyword">int</span> oldL = mLeft;</span><br><span class="line">     <span class="keyword">int</span> oldT = mTop;</span><br><span class="line">     <span class="keyword">int</span> oldB = mBottom;</span><br><span class="line">     <span class="keyword">int</span> oldR = mRight;</span><br><span class="line">     <span class="comment">//设置当前视图View的左，顶，右，底的位置，并且判断布局是否有改变</span></span><br><span class="line">     <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</span><br><span class="line">             setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line">     <span class="comment">//如果布局有改变，条件成立，则视图View重新布局</span></span><br><span class="line">         <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class="line">         <span class="comment">//调用onLayout，将具体布局逻辑留给子类实现</span></span><br><span class="line">         onLayout(changed, l, t, r, b);</span><br><span class="line">         mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</span><br><span class="line"></span><br><span class="line">         ListenerInfo li = mListenerInfo;</span><br><span class="line">         <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">             ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</span><br><span class="line">                     (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</span><br><span class="line">             <span class="keyword">int</span> numListeners = listenersCopy.size();</span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</span><br><span class="line">                 listenersCopy.get(i).onLayoutChange(<span class="keyword">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</span><br><span class="line">     mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>3.3.1、<strong>setFrame</strong></p>
<p>layout 中调用<code>setFrame</code>确定当前View的布局位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">setFrame</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//当上，下，左，右四个位置有一个和上次的值不一样都会重新布局</span></span><br><span class="line">        <span class="keyword">if</span> (mLeft != left || mRight != right || mTop != top || mBottom != bottom) &#123;</span><br><span class="line">            changed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// Remember our drawn bit</span></span><br><span class="line">        <span class="keyword">int</span> drawn = mPrivateFlags &amp; PFLAG_DRAWN;</span><br><span class="line">        <span class="comment">//得到本次和上次的宽和高</span></span><br><span class="line">        <span class="keyword">int</span> oldWidth = mRight - mLeft;</span><br><span class="line">        <span class="keyword">int</span> oldHeight = mBottom - mTop;</span><br><span class="line">        <span class="keyword">int</span> newWidth = right - left;</span><br><span class="line">        <span class="keyword">int</span> newHeight = bottom - top;</span><br><span class="line">        <span class="comment">//判断本次View的宽高和上次View的宽高是否相等</span></span><br><span class="line">        <span class="keyword">boolean</span> sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Invalidate our old position</span></span><br><span class="line">        <span class="comment">//清楚上次布局的位置</span></span><br><span class="line">        invalidate(sizeChanged);</span><br><span class="line">        <span class="comment">//保存当前View的最新位置</span></span><br><span class="line">        mLeft = left;</span><br><span class="line">        mTop = top;</span><br><span class="line">        mRight = right;</span><br><span class="line">        mBottom = bottom;</span><br><span class="line">        mRenderNode.setLeftTopRightBottom(mLeft, mTop, mRight, mBottom);</span><br><span class="line"></span><br><span class="line">        mPrivateFlags |= PFLAG_HAS_BOUNDS;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果当前View的尺寸有所变化</span></span><br><span class="line">        <span class="keyword">if</span> (sizeChanged) &#123;</span><br><span class="line">            sizeChange(newWidth, newHeight, oldWidth, oldHeight);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...............</span><br><span class="line">    <span class="keyword">return</span> changed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-2、onLayout"><a href="#3-3-2、onLayout" class="headerlink" title="3.3.2、onLayout"></a>3.3.2、onLayout</h4><p>对于View来说，经过setFrame，view的位置就已经确定了，onLayout是一个空方法。</p>
<p>对于ViewGroup来说，位置通过setFrame已经实现，onLayout是个抽象的方法，所有继承自ViewGroup的对象都必须实现，确定子view的位置。以FrameLayout 为例，真正的实现在中<code>layoutChildren</code>。</p>
<p>不像View视图的measure测量，通过子类实现onMeasure方法来实现测量逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">    layoutChildren(left, top, right, bottom, <span class="keyword">false</span> <span class="comment">/* no force left gravity */</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutChildren</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom, <span class="keyword">boolean</span> forceLeftGravity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = getChildCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> parentLeft = getPaddingLeftWithForeground();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> parentRight = right - left - getPaddingRightWithForeground();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> parentTop = getPaddingTopWithForeground();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> parentBottom = bottom - top - getPaddingBottomWithForeground();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = getChildAt(i);</span><br><span class="line">        <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">            <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> width = child.getMeasuredWidth();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> height = child.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> childLeft;</span><br><span class="line">            <span class="keyword">int</span> childTop;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> gravity = lp.gravity;</span><br><span class="line">            <span class="keyword">if</span> (gravity == -<span class="number">1</span>) &#123;</span><br><span class="line">                gravity = DEFAULT_CHILD_GRAVITY;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = getLayoutDirection();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> verticalGravity = gravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</span><br><span class="line">                <span class="keyword">case</span> Gravity.CENTER_HORIZONTAL:</span><br><span class="line">                    childLeft = parentLeft + (parentRight - parentLeft - width) / <span class="number">2</span> +</span><br><span class="line">                    lp.leftMargin - lp.rightMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Gravity.RIGHT:</span><br><span class="line">                    <span class="keyword">if</span> (!forceLeftGravity) &#123;</span><br><span class="line">                        childLeft = parentRight - width - lp.rightMargin;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">case</span> Gravity.LEFT:</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    childLeft = parentLeft + lp.leftMargin;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (verticalGravity) &#123;</span><br><span class="line">                <span class="keyword">case</span> Gravity.TOP:</span><br><span class="line">                    childTop = parentTop + lp.topMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Gravity.CENTER_VERTICAL:</span><br><span class="line">                    childTop = parentTop + (parentBottom - parentTop - height) / <span class="number">2</span> +</span><br><span class="line">                    lp.topMargin - lp.bottomMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Gravity.BOTTOM:</span><br><span class="line">                    childTop = parentBottom - height - lp.bottomMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    childTop = parentTop + lp.topMargin;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            child.layout(childLeft, childTop, childLeft + width, childTop + height);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4、draw流程"><a href="#3-4、draw流程" class="headerlink" title="3.4、draw流程"></a>3.4、draw流程</h3><p>View视图绘制流程中的最后一步绘制draw是由ViewRootImpl中的performDraw成员方法开始的，跟踪代码，最后会在<code>ViewRootImpl.drawSoftware</code>方法绘制View：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">drawSoftware</span><span class="params">(Surface surface, AttachInfo attachInfo, <span class="keyword">int</span> xoff, <span class="keyword">int</span> yoff,</span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="keyword">boolean</span> scalingRequired, Rect dirty)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Draw with software renderer.</span></span><br><span class="line">      <span class="keyword">final</span> Canvas canvas;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//从surface对象中获得canvas变量</span></span><br><span class="line">          canvas = mSurface.lockCanvas(dirty);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// If this bitmap&#x27;s format includes an alpha channel, we</span></span><br><span class="line">          <span class="comment">// need to clear it before drawing so that the child will</span></span><br><span class="line">          <span class="comment">// properly re-composite its drawing on a transparent</span></span><br><span class="line">          <span class="comment">// background. This automatically respects the clip/dirty region</span></span><br><span class="line">          <span class="comment">// or</span></span><br><span class="line">          <span class="comment">// If we are applying an offset, we need to clear the area</span></span><br><span class="line">          <span class="comment">// where the offset doesn&#x27;t appear to avoid having garbage</span></span><br><span class="line">          <span class="comment">// left in the blank areas.</span></span><br><span class="line">          <span class="keyword">if</span> (!canvas.isOpaque() || yoff != <span class="number">0</span> || xoff != <span class="number">0</span>) &#123;</span><br><span class="line">              canvas.drawColor(<span class="number">0</span>, PorterDuff.Mode.CLEAR);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">         ......................</span><br><span class="line"></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">//调整画布的位置</span></span><br><span class="line">              canvas.translate(-xoff, -yoff);</span><br><span class="line">              <span class="keyword">if</span> (mTranslator != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  mTranslator.translateCanvas(canvas);</span><br><span class="line">              &#125;</span><br><span class="line">              canvas.setScreenDensity(scalingRequired ? mNoncompatDensity : <span class="number">0</span>);</span><br><span class="line">              attachInfo.mSetIgnoreDirtyState = <span class="keyword">false</span>;</span><br><span class="line">              <span class="comment">//调用View类中的成员方法draw开始绘制View视图</span></span><br><span class="line">              mView.draw(canvas);</span><br><span class="line">          &#125; </span><br><span class="line"></span><br><span class="line">      .....................</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可知，我们的视图View最终是绘制到Surface中去的，关于Surface相关的知识，可以参考这篇大神的博客：</p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/luoshengyang/article/details/8303098">Android应用程序窗口（Activity）的绘图表面（Surface）的创建过程分析</a></p>
<p>跟踪代码，进入View的draw方法分析源码：</p>
<h4 id="3-4-1、Draw"><a href="#3-4-1、Draw" class="headerlink" title="3.4.1、Draw"></a>3.4.1、Draw</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public void draw(Canvas canvas) &#123;</span><br><span class="line">      final int privateFlags = mPrivateFlags;</span><br><span class="line">      final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) ==</span><br><span class="line">      PFLAG_DIRTY_OPAQUE &amp;&amp;</span><br><span class="line">              (mAttachInfo == null || ! mAttachInfo.mIgnoreDirtyState);</span><br><span class="line">      mPrivateFlags = (privateFlags &amp; ～PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">      /＊</span><br><span class="line">      ＊ Draw traversal performs several drawing steps which must be executed</span><br><span class="line">      ＊ in the appropriate order:</span><br><span class="line">      ＊ in the appropriate order:</span><br><span class="line">    ＊</span><br><span class="line">    ＊       1. Draw the background</span><br><span class="line">    ＊       2. If necessary, save the canvas&#x27; layers to prepare for fading</span><br><span class="line">    ＊       3. Draw view&#x27;s content</span><br><span class="line">    ＊       4. Draw children</span><br><span class="line">    ＊       5. If necessary, draw the fading edges and restore layers</span><br><span class="line">    ＊       6. Draw decorations (scrollbars for instance)</span><br><span class="line">    ＊/</span><br><span class="line"></span><br><span class="line">   // Step 1, draw the background, if needed</span><br><span class="line">   int saveCount;</span><br><span class="line"></span><br><span class="line">   if (! dirtyOpaque) &#123;</span><br><span class="line">        drawBackground(canvas);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // skip step 2 &amp; 5 if possible (common case)</span><br><span class="line">   final int viewFlags = mViewFlags;</span><br><span class="line">   boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) ! = 0;</span><br><span class="line">   boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) ! = 0;</span><br><span class="line">   if (! verticalEdges &amp;&amp; ! horizontalEdges) &#123;</span><br><span class="line">        // Step 3, draw the content</span><br><span class="line">        if (! dirtyOpaque) onDraw(canvas);</span><br><span class="line"></span><br><span class="line">        // Step 4, draw the children</span><br><span class="line">        dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">        // Step 6, draw decorations (scrollbars)</span><br><span class="line">        onDrawScrollBars(canvas);</span><br><span class="line"></span><br><span class="line">        if (mOverlay ! = null &amp;&amp; ! mOverlay.isEmpty()) &#123;</span><br><span class="line">            mOverlay.getOverlayView().dispatchDraw(canvas);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // we&#x27;re done...</span><br><span class="line">        return;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下：</p>
<ol>
<li>绘制当前视图的背景。</li>
<li>保存canvas的图层，为fading做准备</li>
<li>绘制View的内容</li>
<li>绘制View的子View</li>
<li>绘制当前视图在滑动时的边框渐变效果。</li>
<li>绘制View的装饰(例如滚动条等等)</li>
</ol>
<img src="/pics/image-20210620231436212.png" alt="image-20210620231436212" style="zoom:50%;" />



<h4 id="3-4-2、View-的树形结构绘制流程"><a href="#3-4-2、View-的树形结构绘制流程" class="headerlink" title="3.4.2、View 的树形结构绘制流程"></a>3.4.2、View 的树形结构绘制流程</h4><p>View绘制过程的传递是通过dispatchDraw来实现的，dispatchDraw会遍历调用所有子元素的draw方法，如此draw事件就一层层地传递了下去。View有一个特殊的方法setWillNotDraw，先看一下它的源码，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/＊＊</span><br><span class="line"> ＊ If <span class="keyword">this</span> view doesn<span class="string">&#x27;t do any drawing on its own, set this flag to</span></span><br><span class="line"><span class="string"> ＊ allow further optimizations. By default, this flag is not set on</span></span><br><span class="line"><span class="string"> ＊ View, but could be set on some View subclasses such as ViewGroup.</span></span><br><span class="line"><span class="string"> ＊</span></span><br><span class="line"><span class="string"> ＊ Typically, if you override &#123;@link #onDraw(android.graphics.Canvas)&#125;</span></span><br><span class="line"><span class="string"> ＊ you should clear this flag.</span></span><br><span class="line"><span class="string"> ＊</span></span><br><span class="line"><span class="string"> ＊ @param willNotDraw whether or not this View draw on its own</span></span><br><span class="line"><span class="string"> ＊/</span></span><br><span class="line"><span class="string">public void setWillNotDraw(boolean willNotDraw) &#123;</span></span><br><span class="line"><span class="string">    setFlags(willNotDraw ? WILL_NOT_DRAW : 0, DRAW_MASK);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>从setWillNotDraw这个方法的注释中可以看出，如果一个View不需要绘制任何内容，那么设置这个标记位为true以后，系统会进行相应的优化。默认情况下，View没有启用这个优化标记位，但是ViewGroup会默认启用这个优化标记位。</p>
<p>这个标记位对实际开发的意义是：<code>当我们的自定义控件继承于ViewGroup并且本身不具备绘制功能时，就可以开启这个标记位从而便于系统进行后续的优化。</code>当然，当明确知道一个ViewGroup需要通过onDraw来绘制内容时，我们需要显式地关闭WILL_NOT_DRAW这个标记位。</p>
<img src="/pics/image-20210620232417701.png" alt="image-20210620232417701" style="zoom:50%;" />

<h2 id="四、Question"><a href="#四、Question" class="headerlink" title="四、Question"></a>四、Question</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904131136618510">https://juejin.cn/post/6844904131136618510</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ITRenj/article/details/53819583">invalidate()和requestLayout()方法调用过程</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/baiqiantao/p/2a3fccd829120089d24547929175ae29.html">invalidate和requestLayout方法源码分析</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/06/Notes/Android/Framework/FrameWork_03_AMS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/06/Notes/Android/Framework/FrameWork_03_AMS/" class="post-title-link" itemprop="url">FrameWork_02_Binder</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-06 16:44:58" itemprop="dateCreated datePublished" datetime="2021-06-06T16:44:58+08:00">2021-06-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="FrameWork-03-Activity-启动流程"><a href="#FrameWork-03-Activity-启动流程" class="headerlink" title="FrameWork_03_Activity 启动流程"></a>FrameWork_03_Activity 启动流程</h1><h2 id="Launcher-启动App过程"><a href="#Launcher-启动App过程" class="headerlink" title="Launcher 启动App过程"></a>Launcher 启动App过程</h2><p>以桌面（Launcher）启动Activity为例，Activity启动过程可以分为如下步骤：</p>
<p><img src="/pics/image-20210613151222905.png" alt="image-20210613151222905"></p>
<p>图解：</p>
<ol>
<li><p>Launcher 通知 AMS</p>
<p>通过<code> AMN （ActivityManagerNative）/ AMP（ActivityManagerProxy）</code>调用到<code>sytem_server</code>进程的<code>AMS</code>，使用的是Binder通信。</p>
</li>
<li><p>AMS 处理 Launcher 传递过来的信息，有3步:</p>
<ul>
<li>通过 <code>PMS(PackageManagerService)</code> 校验intent是否有效</li>
<li>通知<code>Launcher</code> pause，这里也涉及一次Binder通信，使用的是<code>ATN（ApplicationThreadNative）ATP（ApplicationThreadProxy）</code>，此时的client是AMS，server端 是Launcher。</li>
<li>启动Activity，在Activity 所在进程没启动的情况下，需要先启动activity进程。</li>
</ul>
</li>
<li><p>AMS启动新的进程</p>
<p>AMS 通过 <code>startProcessLocked </code>调用到 <code>zygote</code> 进程，通过<code>fork</code> 方式创建一个新App进程。这个过程使用的是 socket 通信</p>
<img src="/pics/image-20210613151425352.png" alt="image-20210613151425352" style="zoom:30%;" />

<p>(<a target="_blank" rel="noopener" href="http://gityuan.com/2016/10/09/app-process-create-2/">Android四大组件与进程启动的关系</a>)</p>
</li>
<li><p>新进程启动，绑定AMS</p>
<p>App启动后，首先进入<code>ActivityThread</code>的main 方法中：</p>
<ol>
<li>创建主线程Looper </li>
<li>创建 Application</li>
<li>最后通过Binder IPC向<code>sytem_server</code>进程<code>AMS</code>发起attachApplication请求；</li>
</ol>
</li>
<li><p>AMS中确定要启动的Activity</p>
<p>AMS 中保存的 第一个阶段 获取到要启动的Activity信息，经过多次调用，最后会通过ATP，使用Binder IPC向App进程发送scheduleLaunchActivity请求；</p>
</li>
<li><p>启动相应的Activtity</p>
<p>主线程在收到Message后，通过反射机制创建目标Activity，并回调Activity.onCreate()等方法</p>
</li>
</ol>
<h2 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h2><h3 id="ActivityThread"><a href="#ActivityThread" class="headerlink" title="ActivityThread"></a>ActivityThread</h3><h3 id="ApplicationThread"><a href="#ApplicationThread" class="headerlink" title="ApplicationThread"></a>ApplicationThread</h3><h4 id="ApplicationThreadProxy"><a href="#ApplicationThreadProxy" class="headerlink" title="ApplicationThreadProxy"></a>ApplicationThreadProxy</h4><h4 id="ApplicationThreadNative"><a href="#ApplicationThreadNative" class="headerlink" title="ApplicationThreadNative"></a>ApplicationThreadNative</h4><h3 id="ActivityMangerService"><a href="#ActivityMangerService" class="headerlink" title="ActivityMangerService"></a>ActivityMangerService</h3><h4 id="ActivityMangerProxy"><a href="#ActivityMangerProxy" class="headerlink" title="ActivityMangerProxy"></a>ActivityMangerProxy</h4><h4 id="ActivityManagerNative"><a href="#ActivityManagerNative" class="headerlink" title="ActivityManagerNative"></a>ActivityManagerNative</h4><h3 id="ActivityStackSupervisor"><a href="#ActivityStackSupervisor" class="headerlink" title="ActivityStackSupervisor"></a>ActivityStackSupervisor</h3><h3 id="ActivityStack"><a href="#ActivityStack" class="headerlink" title="ActivityStack"></a>ActivityStack</h3><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>上述的过程是基于 Android 6.0，Andorid 11 上 AMN/AMP 的 实现变为了<code>ActivityTaskManagerService</code>,但核心的流程并未发生变化。</p>
<p><a target="_blank" rel="noopener" href="http://gityuan.com/2016/03/12/start-activity/">Android6.0 startActivity启动过程分析</a></p>
<p><a target="_blank" rel="noopener" href="https://calmcenter.club/2020/android-framework-activity">Android 11 Activity 启动分析</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/06/Notes/Android/Framework/FrameWork_02_Binder%20%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/06/Notes/Android/Framework/FrameWork_02_Binder%20%E6%9E%B6%E6%9E%84/" class="post-title-link" itemprop="url">FrameWork_02_Binder</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-06 16:44:03" itemprop="dateCreated datePublished" datetime="2021-06-06T16:44:03+08:00">2021-06-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="FrameWork-02-Binder-架构"><a href="#FrameWork-02-Binder-架构" class="headerlink" title="FrameWork_02_Binder 架构"></a>FrameWork_02_Binder 架构</h1><p>Binder通信采用C/S架构，从组件视角来说，包含Client、Server、ServiceManager以及Binder驱动，其中ServiceManager用于管理系统中的各种服务。架构图如下所示：</p>
<img src="/pics/image-20210606151407737.png" alt="image-20210606151407737" style="zoom:50%;" />

<p>可以看出无论是注册服务和获取服务的过程都需要ServiceManager，需要注意的是此处的Service Manager是指Native层的ServiceManager（C++），并非指framework层的ServiceManager(Java)。ServiceManager是整个Binder通信机制的大管家，是Android进程间通信机制Binder的守护进程，要掌握Binder机制，首先需要了解系统是如何首次<a target="_blank" rel="noopener" href="http://gityuan.com/2015/11/07/binder-start-sm/">启动Service Manager</a>。当Service Manager启动之后，Client端和Server端通信时都需要先<a target="_blank" rel="noopener" href="http://gityuan.com/2015/11/08/binder-get-sm/">获取Service Manager</a>接口，才能开始通信服务。</p>
<p>图中Client/Server/ServiceManage之间的相互通信都是基于Binder机制。既然基于Binder机制通信，那么同样也是C/S架构，则图中的3大步骤都有相应的Client端与Server端。</p>
<ol>
<li>**<a target="_blank" rel="noopener" href="http://gityuan.com/2015/11/14/binder-add-service/">注册服务(addService)</a>**：Server进程要先注册Service到ServiceManager。该过程：Server是客户端，ServiceManager是服务端。</li>
<li>**<a target="_blank" rel="noopener" href="http://gityuan.com/2015/11/15/binder-get-service/">获取服务(getService)</a>**：Client进程使用某个Service前，须先向ServiceManager中获取相应的Service。该过程：Client是客户端，ServiceManager是服务端。</li>
<li><strong>使用服务</strong>：Client根据得到的Service信息建立与Service所在的Server进程通信的通路，然后就可以直接与Service交互。该过程：client是客户端，server是服务端。</li>
</ol>
<p>图中的Client,Server,Service Manager之间交互都是虚线表示，是由于它们彼此之间不是直接交互的，而是都通过与<a target="_blank" rel="noopener" href="http://gityuan.com/2015/11/01/binder-driver/">Binder驱动</a>进行交互的，从而实现IPC通信方式。其中Binder驱动位于内核空间，Client,Server,Service Manager位于用户空间。Binder驱动和Service Manager可以看做是Android平台的基础架构，而Client和Server是Android的应用层，开发人员只需自定义实现client、Server端，借助Android的基本平台架构便可以直接进行IPC通信。</p>
<p>下面我们先来了解下Android 中binder驱动的核心方法。</p>
<h3 id="Binder驱动"><a href="#Binder驱动" class="headerlink" title="Binder驱动"></a>Binder驱动</h3><p>Client进程通过RPC(Remote Procedure Call Protocol)与Server通信，可以简单地划分为三层，驱动层、IPC层、业务层。<code>demo()</code>便是Client端和Server共同协商好的统一方法；handle、RPC数据、代码、协议这4项组成了IPC层的数据，通过IPC层进行数据传输；而真正在Client和Server两端建立通信的基础设施便是Binder Driver。</p>
<img src="/pics/image-20210606153003357.png" alt="image-20210606153003357" style="zoom:40%;" />

<p>Binder驱动是Android专用的，但底层的驱动架构与Linux驱动一样。binder驱动在以misc设备进行注册，作为虚拟字符设备，没有直接操作硬件，只是对设备内存的处理。主要是驱动设备的初始化(binder_init)，打开 (binder_open)，映射(binder_mmap)，数据操作(binder_ioctl)。</p>
<img src="/pics/image-20210606152124763.png" alt="image-20210606152124763" style="zoom:50%;" />

<ul>
<li>binder_init：初始化字符设备</li>
<li>binder_open：打开驱动设备</li>
<li>binder_mmap：首先在内核虚拟地址空间，申请一块与用户虚拟内存相同大小的内存；然后再申请1个page大小的物理内存，再将<strong>同一块物理内存分别映射到内核虚拟地址空间和用户虚拟内存空间</strong>，从而实现了用户空间的Buffer和内核空间的Buffer同步操作的功能。</li>
<li>binder_ioctl：binder_ioctl()函数负责在两个进程间收发IPC数据和IPC reply数据。</li>
</ul>
<p><strong>系统调用</strong></p>
<p>用户态的程序调用Kernel层驱动是需要陷入内核态，进行系统调用(<code>syscall</code>)，比如打开Binder驱动方法的调用链为： open-&gt; __open() -&gt; binder_open()。 open()为用户空间的方法，__open()便是系统调用中相应的处理方法，通过查找，对应调用到内核binder驱动的binder_open()方法，至于其他的从用户态陷入内核态的流程也基本一致。</p>
<img src="/pics/image-20210606152245305.png" alt="image-20210606152245305" style="zoom:40%;" />

<p>简单说，当用户空间调用open()方法，最终会调用binder驱动的binder_open()方法；mmap()/ioctl()方法也是同理，在BInder系列的后续文章从用户态进入内核态，都依赖于系统调用过程。</p>
<h3 id="ServiceManager"><a href="#ServiceManager" class="headerlink" title="ServiceManager"></a>ServiceManager</h3><p>ServiceManger集中管理系统内的所有服务，通过权限控制进程是否有权注册服务,通过字符串名称来查找对应的Service; 由于ServiceManger进程建立跟所有向其注册服务的死亡通知, 那么当服务所在进程死亡后, 会只需告知ServiceManager. 每个Client通过查询ServiceManager可获取Server进程的情况，降低所有Client进程直接检测会导致负载过重。</p>
<h4 id="ServiceManager启动过程"><a href="#ServiceManager启动过程" class="headerlink" title="ServiceManager启动过程"></a>ServiceManager启动过程</h4><p>ServiceManager是Binder IPC通信过程中的守护进程，本身也是一个Binder服务，但并没有采用libbinder中的多线程模型来与Binder驱动通信，而是自行编写了binder.c直接和Binder驱动来通信，并且只有一个循环binder_loop来进行读取和处理事务，这样的好处是简单而高效。</p>
<p><strong>ServiceManager启动流程：</strong></p>
<ol>
<li>打开binder驱动，并调用mmap()方法分配128k的内存映射空间：binder_open();</li>
<li>通知binder驱动使其成为守护进程：binder_become_context_manager()；</li>
<li>验证selinux权限，判断进程是否有权注册或查看指定服务；</li>
<li>进入循环状态，等待Client端的请求：binder_loop()。</li>
<li>注册服务的过程，根据服务名称，但同一个服务已注册，重新注册前会先移除之前的注册信息；</li>
<li>死亡通知: 当binder所在进程死亡后,会调用binder_release方法,然后调用binder_node_release.这个过程便会发出死亡通知的回调.</li>
</ol>
<p>ServiceManager最核心的两个功能为查询和注册服务：</p>
<ul>
<li>注册服务：记录服务名和handle信息，保存到svclist列表；</li>
<li>查询服务：根据服务名查询相应的的handle信息。</li>
</ul>
<h4 id="获取ServiceManager"><a href="#获取ServiceManager" class="headerlink" title="获取ServiceManager"></a>获取ServiceManager</h4><p>获取Service Manager是通过<code>defaultServiceManager()</code>方法来完成，当进程<a target="_blank" rel="noopener" href="http://gityuan.com/2015/11/14/binder-add-service/">注册服务(addService)</a>或 <a target="_blank" rel="noopener" href="http://gityuan.com/2015/11/15/binder-get-service/">获取服务(getService)</a>的过程之前，都需要先调用defaultServiceManager()方法来获取<code>gDefaultServiceManager</code>对象。对于gDefaultServiceManager对象，如果存在则直接返回；如果不存在则创建该对象，创建过程包括调用open()打开binder驱动设备，利用mmap()映射内核的地址空间。</p>
<h3 id="注册服务"><a href="#注册服务" class="headerlink" title="注册服务"></a>注册服务</h3><p>Media服务注册的过程涉及到MediaPlayerService(作为Client进程)和Service Manager(作为Service进程)，通信流程图如下所示</p>
<img src="/pics/image-20210606155146718.png" alt="image-20210606155146718" style="zoom:50%;" />

<ol>
<li><code>BINDER_COMMAND_PROTOCOL</code>：binder请求码，以”BC_“开头，简称BC码，用于从IPC层传递到Binder Driver层；</li>
<li><code>BINDER_RETURN_PROTOCOL</code> ：binder响应码，以”BR_“开头，简称BR码，用于从Binder Driver层传递到IPC层；</li>
</ol>
<h3 id="获取服务"><a href="#获取服务" class="headerlink" title="获取服务"></a>获取服务</h3><p>BpBinder(客户端)和BBinder(服务端)都是Android中Binder通信相关的代表，它们都从IBinder类中派生而来，关系图如下：</p>
<img src="/pics/image-20210606161156966.png" alt="image-20210606161156966" style="zoom:50%;" />

<ul>
<li>client端：BpBinder.transact()来发送事务请求；</li>
<li>server端：BBinder.onTransact()会接收到相应事务。</li>
</ul>
<p>请求服务(getService)过程，就是向servicemanager进程查询指定服务，当执行binder_transaction()时，会区分请求服务所属进程情况。</p>
<ol>
<li>当请求服务的进程与服务属于不同进程，则为请求服务所在进程创建binder_ref对象，指向服务进程中的binder_node;<ul>
<li>最终readStrongBinder()，返回的是BpBinder对象；</li>
</ul>
</li>
<li>当请求服务的进程与服务属于同一进程，则不再创建新对象，只是引用计数加1，并且修改type为BINDER_TYPE_BINDER或BINDER_TYPE_WEAK_BINDER。<ul>
<li>最终readStrongBinder()，返回的是BBinder对象的真实子类；</li>
</ul>
</li>
</ol>
<h3 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h3><p>binder在framework层，采用JNI技术来调用native(C/C++)层的binder架构，从而为上层应用程序提供服务。 看过binder系列之前的文章，我们知道native层中，binder是C/S架构，分为Bn端(Server)和Bp端(Client)。对于java层在命名与架构上非常相近，同样实现了一套IPC通信架构。</p>
<img src="/pics/image-20210606161741080.png" alt="image-20210606161741080" style="zoom:40%;" />

<ul>
<li>图中红色代表整个framework层 binder架构相关组件；<ul>
<li>Binder类代表Server端，BinderProxy类代码Client端；</li>
</ul>
</li>
<li>图中蓝色代表Native层Binder架构相关组件；</li>
<li>上层framework层的Binder逻辑是建立在Native层架构基础之上的，核心逻辑都是交予Native层方法来处理。</li>
<li>framework层的ServiceManager类与Native层的功能并不完全对应，framework层的ServiceManager类的实现最终是通过BinderProxy传递给Native层来完成的，后面会详细说明。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/30/Notes/Android/Framework/FrameWork_01_Binder/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/30/Notes/Android/Framework/FrameWork_01_Binder/" class="post-title-link" itemprop="url">FrameWork_01_Binder</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-30 16:22:00" itemprop="dateCreated datePublished" datetime="2021-05-30T16:22:00+08:00">2021-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="FrameWork-01-Binder"><a href="#FrameWork-01-Binder" class="headerlink" title="FrameWork_01_Binder"></a>FrameWork_01_Binder</h1><h2 id="什么是Binder？"><a href="#什么是Binder？" class="headerlink" title="什么是Binder？"></a>什么是Binder？</h2><p>对于<code>Binder</code>的定义，在不同场景下其定义不同。</p>
<ol>
<li>从IPC角度来说：<strong>Binder是Android中的一种跨进程通信方式，该通信方式在linux中没有，是Android独有</strong>；</li>
<li>从Android Driver层：<strong>Binder还可以理解为一种虚拟的物理设备，它的设备驱动是/dev/binder</strong>；</li>
<li>从Android Native层：Binder是创建Service Manager以及BpBinder/BBinder模型，搭建与binder驱动的桥梁；</li>
<li>从Android Framework层：Binder是各种Manager（ActivityManager、WindowManager等）和相应xxxManagerService的桥梁；</li>
<li>从Android APP层：Binder是客户端和服务端进行通信的媒介，当bindService的时候，服务端会返回一个包含了服务端业务调用的 Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或者数据，这里的服务包括普通服务和基于AIDL的服务。</li>
</ol>
<h2 id="IPC-基本概念"><a href="#IPC-基本概念" class="headerlink" title="IPC 基本概念"></a>IPC 基本概念</h2><p><img src="/pics/image-20210530173422907.png" alt="image-20210530173422907" style="zoom:35%;" />..</p>
<p>上图展示了传统进程通信的基本概念：</p>
<ul>
<li>进程隔离</li>
<li>进程空间划分</li>
<li>系统调用</li>
</ul>
<h3 id="进程隔离"><a href="#进程隔离" class="headerlink" title="进程隔离"></a>进程隔离</h3><p>为了保证 安全性 &amp; 独立性，一个进程 不能直接操作或者访问另一个进程，即<code>Android</code>的进程是<strong>相互独立、隔离的</strong>。2个进程之间内存可以随意访问的话，那基本上程序之间就没有任何安全性可言，若可以随意修改其他程序的数据，那计算机世界将陷入混乱。</p>
<p>基于进程之间不可互相访问数据的基础上，为了实现进程间数据共享，这里就必须采用特殊的通信机制：<strong>进程间通信（IPC）</strong></p>
<h3 id="进程空间划分"><a href="#进程空间划分" class="headerlink" title="进程空间划分"></a>进程空间划分</h3><p>一个进程空间分为 **用户空间 和内核空间（Kernel)**，二者区别：</p>
<ul>
<li>进程间，用户空间的数据不可共享</li>
<li>进程间，内核空间的数据可共享</li>
</ul>
<blockquote>
<p>所有进程共用1个内核空间</p>
</blockquote>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>虽然从逻辑上进行了用户空间和内核空间的划分，但是不可避免的用户空间需要访问内核资源，比如文件操作、访问网络等等。为了突破隔离限制，就需要借助系统调用来实现。系统调用是用户空间访问内核空间的唯一方式，保证了所有的内核资源访问都是在内核的控制下进行的，避免了用户程序对系统资源的越权访问，提升系统安全性和稳定性。</p>
<p>进程内 用户空间 &amp; 内核空间 进行交互 需通过 系统调用，主要通过函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">copy_from_user（）：将用户空间的数据拷贝到内核空间</span><br><span class="line">copy_to_user（）：将内核空间的数据拷贝到用户空间</span><br></pre></td></tr></table></figure>

<h3 id="传统IPC通信的缺点"><a href="#传统IPC通信的缺点" class="headerlink" title="传统IPC通信的缺点"></a>传统IPC通信的缺点</h3><ol>
<li>性能低下。一次数据传递需要经历：内存缓存区 –&gt; 内核缓存区 –&gt; 内存缓存区，需要 2 次数据拷贝；</li>
<li>接收数据的缓存区由数据接收进程提供，但是接收进程并不知道需要多大的空间来存放将要传递过来的数据，因此只能开辟尽可能大的内存空间或者先调用 API 接收消息头来获取消息体的大小，这两种做法<strong>不是浪费空间就是浪费时间</strong>。</li>
</ol>
<h2 id="为什么选择Binder通信？"><a href="#为什么选择Binder通信？" class="headerlink" title="为什么选择Binder通信？"></a>为什么选择Binder通信？</h2><img src="/pics/image-20210606161417803.png" alt="image-20210606161417803" style="zoom:50%;" />

<ul>
<li><p>从性能的角度</p>
<p>Binder数据拷贝只需要一次，而管道、消息队列、Socket都需要2次，但共享内存方式一次内存拷贝都不需要；从性能角度看，Binder性能仅次于共享内存。但共享内存控制复杂，难以使用。</p>
<img src="/pics/image-20210606161436142.png" alt="image-20210606161436142" style="zoom:50%;" /></li>
<li><p>从稳定性的角度<br>Binder 基于 C/S 架构，客户端（Client）有什么需求就丢给服务端（Server）去完成，架构清晰、职责明确又相互独立，自然稳定性更好。共享内存虽然无需拷贝，但是控制负责，难以使用。从稳定性的角度讲，Binder 机制是优于内存共享的。</p>
</li>
<li><p>从安全的角度<br>传统Linux IPC的接收方无法获得对方进程可靠的UID/PID，从而无法鉴别对方身份；传统Linux IPC无任何保护措施，完全由上层协议来确保。</p>
<p>Android为每个安装好的应用程序分配了自己的UID，故进程的UID是鉴别进程身份的重要标志，前面提到C/S架构，Android系统中对外只暴露Client端，Client端将任务发送给Server端，Server端会根据权限控制策略，判断UID/PID是否满足访问权限，目前权限控制很多时候是通过弹出权限询问对话框，让用户选择是否运行。</p>
<blockquote>
<p>传统IPC只能由用户在数据包里填入UID/PID；另外，可靠的身份标记只有由IPC机制本身在内核中添加。其次传统IPC访问接入点是开放的，无法建立私有通道。从安全角度，Binder的安全性更高。</p>
</blockquote>
</li>
</ul>
<h2 id="Binder-IPC原理"><a href="#Binder-IPC原理" class="headerlink" title="Binder IPC原理"></a>Binder IPC原理</h2><h3 id="动态内核可加载模块"><a href="#动态内核可加载模块" class="headerlink" title="动态内核可加载模块"></a>动态内核可加载模块</h3><p>跨进程通信是需要内核空间做支持的。传统的 IPC 机制如管道、Socket 都是内核的一部分，因此通过内核支持来实现进程间通信自然是没问题的。但是 Binder 并不是 Linux 系统内核的一部分，那怎么办呢？</p>
<p>这就得益于 Li<strong>nux 的动态内核可加载模块（Loadable Kernel Module，LKM）的机制</strong>；模块是具有独立功能的程序，它可以被单独编译，但是不能独立运行（可以简单类比成一个功能库）。模块在运行时被链接到内核作为内核的一部分运行。这样，Android 系统就可以通过动态添加一个内核模块运行在内核空间，用户进程之间通过这个内核模块作为桥梁来实现通信。</p>
<p>在 Android 系统中，这个运行在内核空间，<strong>负责各个用户进程通过 Binder 实现通信的内核模块就叫 Binder 驱动（Binder Dirver）。</strong></p>
<p>那么在 Android 系统中用户进程之间是如何通过这个内核模块（Binder 驱动）来实现通信的呢？这就不得不通道 Linux 下的另一个概念：内存映射。</p>
<h3 id="内存映射（mmap）"><a href="#内存映射（mmap）" class="headerlink" title="内存映射（mmap）"></a>内存映射（mmap）</h3><p>Binder IPC 机制中涉及到的内存映射通过 mmap() 来实现，mmap() 是操作系统中一种内存映射的方法。</p>
<p>内存映射简单的讲就是将<strong>用户空间的一块内存区域映射到内核空间</strong>。<strong>映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间</strong>。</p>
<p>内存映射能减少数据拷贝次数，实现用户空间和内核空间的高效互动。两个空间各自的修改能直接反映在映射的内存区域，从而被对方空间及时感知。也正因为如此，内存映射能够提供对进程间通信的支持。</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/719fc4758813">操作系统：图文详解 内存映射</a></p>
<h3 id="Binder-IPC实现原理"><a href="#Binder-IPC实现原理" class="headerlink" title="Binder IPC实现原理"></a>Binder IPC实现原理</h3><img src="/pics/image-20210606153721575.png" alt="image-20210606153721575" style="zoom:40%;" />

<p>一次完整的 Binder IPC 通信过程通常是这样：</p>
<ol>
<li>首先 Binder 驱动在内核空间创建一个<strong>数据接收缓存区</strong>；</li>
<li>接着在内核空间开辟一块内核缓存区，建立<ol>
<li><strong>内核缓存区 和 内核中数据接收缓存区之间</strong>的映射，</li>
<li><strong>数据接收缓存区 和 接收进程用户空间地址</strong> 的映射关系；</li>
</ol>
</li>
<li>发送方进程通过系统调用 copyfromuser() 将数据 copy 到内核中的内核缓存区，<strong>由于内核缓存区和接收进程的用户空间存在内存映射</strong>，因此也就<strong>相当于把数据发送到了接收进程的用户空间</strong>，这样便完成了一次进程间的通信。</li>
</ol>
<h2 id="Binder-通信模型"><a href="#Binder-通信模型" class="headerlink" title="Binder 通信模型"></a><strong>Binder 通信模型</strong></h2><p>一次完整的进程间通信必然至少包含两个进程，通常我们称通信的双方分别为客户端进程（Client）和服务端进程（Server），由于进程隔离机制的存在，通信双方必然需要借助 Binder 来实现。</p>
<h3 id="Client-Server-ServiceManager-驱动"><a href="#Client-Server-ServiceManager-驱动" class="headerlink" title="Client/Server/ServiceManager/驱动"></a>Client/Server/ServiceManager/驱动</h3><p>前面我们介绍过，Binder 是基于 C/S 架构的。由一系列的组件组成，包括 Client、Server、ServiceManager、Binder 驱动。其中 Client、Server、Service Manager 运行在用户空间，Binder 驱动运行在内核空间。其中 Service Manager 和 Binder 驱动由系统提供，而 Client、Server 由应用程序来实现。Client、Server 和 ServiceManager 均是通过系统调用 open、mmap 和 ioctl 来访问设备文件 /dev/binder，从而实现与 Binder 驱动的交互来间接的实现跨进程通信。</p>
<p><img src="https://pic3.zhimg.com/80/v2-729b3444cd784d882215a24067893d0e_1440w.jpg" alt="img"></p>
<p>Client、Server、ServiceManager、Binder 驱动这几个组件在通信过程中扮演的角色就如同互联网中服务器（Server）、客户端（Client）、DNS域名服务器（ServiceManager）以及路由器（Binder 驱动）之前的关系。</p>
<p><a href="https://link.zhihu.com/?target=http://blog.csdn.net/universus/article/details/6211589">Android Binder 设计与实现</a><em>一文中对 Client、Server、ServiceManager、Binder 驱动有很详细的描述，以下是部分摘录：</em></p>
<blockquote>
<p><strong>Binder 驱动</strong><br>Binder 驱动就如同路由器一样，是整个通信的核心；驱动负责进程之间 Binder 通信的建立，Binder 在进程之间的传递，Binder 引用计数管理，数据包在进程之间的传递和交互等一系列底层支持。</p>
<p><strong>ServiceManager 与实名 Binder</strong><br>ServiceManager 和 DNS 类似，作用是将字符形式的 Binder 名字转化成 Client 中对该 Binder 的引用，使得 Client 能够通过 Binder 的名字获得对 Binder 实体的引用。注册了名字的 Binder 叫实名 Binder，就像网站一样除了除了有 IP 地址意外还有自己的网址。Server 创建了 Binder，并为它起一个字符形式，可读易记得名字，将这个 Binder 实体连同名字一起以数据包的形式通过 Binder 驱动发送给 ServiceManager ，通知 ServiceManager 注册一个名为“张三”的 Binder，它位于某个 Server 中。驱动为这个穿越进程边界的 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager。ServiceManger 收到数据后从中取出名字和引用填入查找表。</p>
<p>细心的读者可能会发现，ServierManager 是一个进程，Server 是另一个进程，Server 向 ServiceManager 中注册 Binder 必然涉及到进程间通信。当前实现进程间通信又要用到进程间通信，这就好像蛋可以孵出鸡的前提却是要先找只鸡下蛋！Binder 的实现比较巧妙，就是预先创造一只鸡来下蛋。ServiceManager 和其他进程同样采用 Bidner 通信，ServiceManager 是 Server 端，有自己的 Binder 实体，其他进程都是 Client，需要通过这个 Binder 的引用来实现 Binder 的注册，查询和获取。ServiceManager 提供的 Binder 比较特殊，它没有名字也不需要注册。当一个进程使用 BINDER<em>SET</em>CONTEXT_MGR 命令将自己注册成 ServiceManager 时 Binder 驱动会自动为它创建 Binder 实体（<strong>这就是那只预先造好的那只鸡</strong>）。其次这个 Binder 实体的引用在所有 Client 中都固定为 0 而无需通过其它手段获得。也就是说，一个 Server 想要向 ServiceManager 注册自己的 Binder 就必须通过这个 0 号引用和 ServiceManager 的 Binder 通信。类比互联网，0 号引用就好比是域名服务器的地址，你必须预先动态或者手工配置好。要注意的是，这里说的 Client 是相对于 ServiceManager 而言的，一个进程或者应用程序可能是提供服务的 Server，但对于 ServiceManager 来说它仍然是个 Client。</p>
<p><strong>Client 获得实名 Binder 的引用</strong><br>Server 向 ServiceManager 中注册了 Binder 以后， Client 就能通过名字获得 Binder 的引用了。Client 也利用保留的 0 号引用向 ServiceManager 请求访问某个 Binder: 我申请访问名字叫张三的 Binder 引用。ServiceManager 收到这个请求后从请求数据包中取出 Binder 名称，在查找表里找到对应的条目，取出对应的 Binder 引用作为回复发送给发起请求的 Client。从面向对象的角度看，Server 中的 Binder 实体现在有两个引用：一个位于 ServiceManager 中，一个位于发起请求的 Client 中。如果接下来有更多的 Client 请求该 Binder，系统中就会有更多的引用指向该 Binder ，就像 Java 中一个对象有多个引用一样。</p>
</blockquote>
<h3 id="Binder-通信过程"><a href="#Binder-通信过程" class="headerlink" title="Binder 通信过程"></a>Binder 通信过程</h3><p>至此，我们大致能总结出 Binder 通信过程：</p>
<ol>
<li>首先，一个进程使用 BINDER<em>SET</em>CONTEXT_MGR 命令通过 Binder 驱动将自己注册成为 ServiceManager；</li>
<li>Server 通过驱动向 ServiceManager 中注册 Binder（Server 中的 Binder 实体），表明可以对外提供服务。驱动为这个 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager，ServiceManger 将其填入查找表。</li>
<li>Client 通过名字，在 Binder 驱动的帮助下从 ServiceManager 中获取到对 Binder 实体的引用，通过这个引用就能实现和 Server 进程的通信。</li>
</ol>
<p>我们看到整个通信过程都需要 Binder 驱动的接入。下图能更加直观的展现整个通信过程(为了进一步抽象通信过程以及呈现上的方便，下图我们忽略了 Binder 实体及其引用的概念)：</p>
<img src="https://pic4.zhimg.com/80/v2-67854cdf14d07a6a4acf9d675354e1ff_1440w.jpg" alt="img" style="zoom:50%;" />

<h3 id="详细过程"><a href="#详细过程" class="headerlink" title="详细过程"></a>详细过程</h3><ol>
<li>**<a target="_blank" rel="noopener" href="http://gityuan.com/2015/11/14/binder-add-service/">注册服务(addService)</a>**：Server进程要先注册Service到ServiceManager。该过程：Server是客户端，ServiceManager是服务端。</li>
<li>**<a target="_blank" rel="noopener" href="http://gityuan.com/2015/11/15/binder-get-service/">获取服务(getService)</a>**：Client进程使用某个Service前，须先向ServiceManager中获取相应的Service。该过程：Client是客户端，ServiceManager是服务端。</li>
<li><strong>使用服务</strong>：Client根据得到的Service信息建立与Service所在的Server进程通信的通路，然后就可以直接与Service交互。该过程：client是客户端，server是服务端。</li>
</ol>
<img src="/pics/image-20210530205550500.png" alt="image-20210530205550500" style="zoom:48%;" />

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/carson_ho/article/details/73560642">https://blog.csdn.net/carson_ho/article/details/73560642</a></p>
<h2 id="Binder通信过程的代理模式"><a href="#Binder通信过程的代理模式" class="headerlink" title="Binder通信过程的代理模式"></a>Binder通信过程的代理模式</h2><p>跨进程通信的过程都有 Binder 驱动的参与，因此在数据流经 Binder 驱动的时候驱动会对数据做一层转换。当 A 进程想要获取 B 进程中的 object 时，驱动并不会真的把 object 返回给 A，<strong>而是返回了一个跟 object 看起来一模一样的代理对象 objectProxy</strong>，这个 objectProxy 具有和 object 一摸一样的方法，但是这些方法并没有 B 进程中 object 对象那些方法的能力，<strong>这些方法只需要把把请求参数交给驱动即可</strong>。对于 A 进程来说和直接调用 object 中的方法是一样的。</p>
<p>当 Binder 驱动接收到 A 进程的消息后，发现这是个 objectProxy 就去查询自己维护的表单，一查发现这是 B 进程 object 的代理对象。<code>于是就会去通知</code> B 进程调用 object 的方法，并要求 B 进程把返回结果发给自己。当驱动拿到 B 进程的返回结果后就会转发给 A 进程，一次通信就完成了。</p>
<img src="/pics/image-20210606150728973.png" alt="image-20210606150728973" style="zoom:40%;" />

<h2 id="Binder进程与线程"><a href="#Binder进程与线程" class="headerlink" title="Binder进程与线程"></a>Binder进程与线程</h2><p>每个Server进程在启动时会创建一个binder线程池，用来处理Binder请求；Binder的线程管理由Binder驱动自身进行管理，<strong>而不是由Server进程来管理</strong>。</p>
<p>对于一个Server进程有一个最大Binder线程数限制，默认为16个binder线程，例如Android的system_server进程就存在16个线程，超过的请求会被阻塞等待空闲的Binder线程。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/35519585">https://zhuanlan.zhihu.com/p/35519585</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/carson_ho/article/details/73560642">https://blog.csdn.net/carson_ho/article/details/73560642</a></p>
<p><a target="_blank" rel="noopener" href="http://gityuan.com/2015/11/28/binder-summary/">http://gityuan.com/2015/11/28/binder-summary/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/14/Notes/Algorithm/ALG_01_%E7%90%86%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/14/Notes/Algorithm/ALG_01_%E7%90%86%E8%AE%BA/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-14 19:54:57" itemprop="dateCreated datePublished" datetime="2021-05-14T19:54:57+08:00">2021-05-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ALG-01-理论"><a href="#ALG-01-理论" class="headerlink" title="ALG_01_理论"></a>ALG_01_理论</h1><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h2 id="LeetCode顺序"><a href="#LeetCode顺序" class="headerlink" title="LeetCode顺序"></a>LeetCode顺序</h2><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ol>
<li><p>移除元素是虚节点的用处</p>
</li>
<li><p>链表操作</p>
</li>
<li><p>反转列表</p>
</li>
<li><p>删除链表倒数的第n个节点:</p>
</li>
</ol>
<p>​         主要走的次数</p>
<ol start="5">
<li>142</li>
</ol>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="sven"
      src="/images/sven.jpeg">
  <p class="site-author-name" itemprop="name">sven</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhaoxiaowen-sven" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhaoxiaowen-sven" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhaoxiaowen-sven@gmail.com" title="E-Mail → mailto:zhaoxiaowen-sven@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sven</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
