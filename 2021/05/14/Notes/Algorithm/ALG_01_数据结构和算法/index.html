<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zhaoxiaowen-sven.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="ALG_01_数据结构和算法之美">
<meta property="og:type" content="article">
<meta property="og:title" content="ALG_01_数据结构和算法之美">
<meta property="og:url" content="https://zhaoxiaowen-sven.github.io/2021/05/14/Notes/Algorithm/ALG_01_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="Sven&#39;s blog">
<meta property="og:description" content="ALG_01_数据结构和算法之美">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/913e0ababe43a2d57267df5c5f0832a7-1591080554105.jpg">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200805160547310.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics%5Cimage-20200601212047477-1591080559983.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics%5Cimage-20200601213410715.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics%5Cimage-20200601213945204.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200810164157017.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200810154021103.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200810162534670.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200810163501739.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200810171434090.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200810172138477.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200810201914105.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200810201950148.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200810203502825.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200811111219333.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200811113630996.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200811111908528.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200811112239043.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200811113137622.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200811112653905.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200811112721747.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200817143455781.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200817143508642.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200817205422048.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200817205459425.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200817202922035.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200817210302264.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200911102322716.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200911102306980.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200911102529207.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200911103306293.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200911110241749.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200911111109174.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200911111135840.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200911111219114.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200911111935159.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200911111827044.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200911112757396.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200911113232315.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200911113315231.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200911113748626.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200911114327205.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200911114940272.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200911115025993.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200911115238390.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200911115323265.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200911115353816.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200911115428376.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200911180457956.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200911180244241.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200911180407556.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200911180606089.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200911180638659.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200915105022777.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200915105500416.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200915105606224.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200915105626442.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200915105706437.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200915105805034.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200915110356072.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200915110411756.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200915143617330.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200915143641884.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200915143942044.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200915144216413.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200915145504103.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200917111916805.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200920162912673.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200920154441523.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200920154502413.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200920163617146.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200920163704632.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200920164156582.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200920164246852.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200920171450218.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200920171619096.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200920172528702.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200920175143682.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200928174611685.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200928174622275.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20201008101806029.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20201009103249878.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20201010113610142.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20201010165702505.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20201010150846225.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20201010151620998.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20201010151527119.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20201012102804659.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20201012110343653.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20201012112015612.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20201012112142672.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20201012112100954.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200812175129105.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200812210611764.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200812175024173.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200812210524669.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200812210531732.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200812210309877.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200825194744273.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200824174735736.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200824174835386.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200825194433665.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200910203208775.png">
<meta property="og:image" content="https://zhaoxiaowen-sven.github.io/pics/image-20200910203220494.png">
<meta property="article:published_time" content="2021-05-14T11:54:57.150Z">
<meta property="article:modified_time" content="2022-03-03T15:53:57.668Z">
<meta property="article:author" content="sven">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhaoxiaowen-sven.github.io/pics/913e0ababe43a2d57267df5c5f0832a7-1591080554105.jpg">

<link rel="canonical" href="https://zhaoxiaowen-sven.github.io/2021/05/14/Notes/Algorithm/ALG_01_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>ALG_01_数据结构和算法之美 | Sven's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
      <a target="_blank" rel="noopener" href="https://github.com/zhaoxiaowen-sven" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Sven's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhaoxiaowen-sven.github.io/2021/05/14/Notes/Algorithm/ALG_01_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ALG_01_数据结构和算法之美
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-14 19:54:57" itemprop="dateCreated datePublished" datetime="2021-05-14T19:54:57+08:00">2021-05-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="ALG-01-数据结构和算法之美"><a href="#ALG-01-数据结构和算法之美" class="headerlink" title="ALG_01_数据结构和算法之美"></a>ALG_01_数据结构和算法之美</h1><span id="more"></span>

<h1 id="一、入门"><a href="#一、入门" class="headerlink" title="一、入门"></a>一、入门</h1><h2 id="1-1-核心数据结构和算法"><a href="#1-1-核心数据结构和算法" class="headerlink" title="1.1 核心数据结构和算法"></a>1.1 核心数据结构和算法</h2><p>10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；</p>
<p>10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。<img src="/pics/913e0ababe43a2d57267df5c5f0832a7-1591080554105.jpg" alt="913e0ababe43a2d57267df5c5f0832a7"></p>
<h2 id="1-2-复杂度分析"><a href="#1-2-复杂度分析" class="headerlink" title="1.2 复杂度分析"></a>1.2 复杂度分析</h2><h3 id="1、时间复杂度"><a href="#1、时间复杂度" class="headerlink" title="1、时间复杂度"></a>1、时间复杂度</h3><p>大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。</p>
<ol>
<li><p>只关注循环执行次数最多的一段代码</p>
</li>
<li><p>加法法则：总复杂度等于量级最大的那段代码的复杂度</p>
</li>
<li><p>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</p>
</li>
</ol>
<h3 id="2、几种常见时间复杂度实例分析"><a href="#2、几种常见时间复杂度实例分析" class="headerlink" title="2、几种常见时间复杂度实例分析"></a>2、几种常见时间复杂度实例分析</h3><p><img src="/pics/image-20200805160547310.png" alt="image-20200805160547310"></p>
<p>对于刚罗列的复杂度量级，我们可以粗略地分为两类，多项式量级和非多项式量级。其中，非多项式量级只有两个：O(2n) 和 O(n!)。</p>
<p>我们把时间复杂度为非多项式量级的算法问题叫作 NP（Non-Deterministic Polynomial，非确定多项式）问题。</p>
<p>当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。因此，关于 NP 时间复杂度我就不展开讲了。我们主要来看几种常见的多项式时间复杂度。</p>
<h4 id="1-O-1"><a href="#1-O-1" class="headerlink" title="1. O(1)"></a>1. O(1)</h4><p>首先你必须明确一个概念，O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。比如这段代码，即便有 3 行，它的时间复杂度也是 O(1），而不是 O(3)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i = 8;</span><br><span class="line">int j = 6;</span><br><span class="line">int sum = i + j;</span><br></pre></td></tr></table></figure>

<p>我稍微总结一下，只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)。或者说，一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。</p>
<h4 id="2-O-logn-、O-nlogn"><a href="#2-O-logn-、O-nlogn" class="headerlink" title="2. O(logn)、O(nlogn)"></a>2. O(logn)、O(nlogn)</h4><p>对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i=1;</span><br><span class="line">while (i &lt;= n)  &#123;</span><br><span class="line">  i = i * 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量 i 的取值就是一个等比数列，<br>$$<br>2^x = n<br>$$<br>所以，这段代码的时间复杂度就是<br>$$<br>O(log_2n）<br>$$<br>如果你理解了我前面讲的 O(logn)，那 O(nlogn) 就很容易理解了。还记得我们刚讲的乘法法则吗？<strong>如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。</strong>而且，O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn)。</p>
<h4 id="3-O-m-n-、O-m-n"><a href="#3-O-m-n-、O-m-n" class="headerlink" title="3. O(m+n)、O(m*n)"></a>3. O(m+n)、O(m*n)</h4><p>我们再来讲一种跟前面都不一样的时间复杂度，代码的复杂度由两个数据的规模来决定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum_1 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; m; ++i) &#123;</span><br><span class="line">    sum_1 = sum_1 + i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> sum_2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; j &lt; n; ++j) &#123;</span><br><span class="line">    sum_2 = sum_2 + j;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum_1 + sum_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、空间复杂度分析"><a href="#3、空间复杂度分析" class="headerlink" title="3、空间复杂度分析"></a>3、空间复杂度分析</h3><p>空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void print(int n) &#123;</span><br><span class="line">  int i = 0;</span><br><span class="line">  int[] a = new int[n];</span><br><span class="line">  for (i; i &lt;n; ++i) &#123;</span><br><span class="line">    a[i] = i * i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for (i = n-1; i &gt;= 0; --i) &#123;</span><br><span class="line">    print out a[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟时间复杂度分析一样，我们可以看到，第 2 行代码中，我们申请了一个空间存储变量 i，但是它是常量阶的，跟数据规模 n 没有关系，所以我们可以忽略。第 3 行申请了一个大小为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)。</p>
<p>我们常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多。所以，对于空间复杂度，掌握刚我说的这些内容已经足够了。</p>
<p><img src="/pics%5Cimage-20200601212047477-1591080559983.png" alt="image-20200601212047477"></p>
<h3 id="4-最好、最坏、平均、均摊时间复杂度"><a href="#4-最好、最坏、平均、均摊时间复杂度" class="headerlink" title="4.最好、最坏、平均、均摊时间复杂度"></a>4.最好、最坏、平均、均摊时间复杂度</h3><h4 id="1-最好、最坏情况时间复杂度"><a href="#1-最好、最坏情况时间复杂度" class="headerlink" title="1.最好、最坏情况时间复杂度"></a>1.最好、最坏情况时间复杂度</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// n表示数组array的长度</span><br><span class="line">int find(int[] array, int n, int x) &#123;</span><br><span class="line">  int i = 0;</span><br><span class="line">  int pos = -1;</span><br><span class="line">  for (; i &lt; n; ++i) &#123;</span><br><span class="line">    if (array[i] == x) pos = i;</span><br><span class="line">  &#125;</span><br><span class="line">  return pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该可以看出来，这段代码要实现的功能是，在一个无序的数组（array）中，查找变量 x 出现的位置。如果没有找到，就返回 -1。按照上节课讲的分析方法，这段代码的复杂度是 O(n)，其中，n 代表数组的长度。</p>
<p>我们在数组中查找一个数据，并不需要每次都把整个数组都遍历一遍，因为有可能中途找到就可以提前结束循环了。但是，这段代码写得不够高效。我们可以这样优化一下这段查找代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// n表示数组array的长度</span><br><span class="line">int find(int[] array, int n, int x) &#123;</span><br><span class="line">  int i = 0;</span><br><span class="line">  int pos = -1;</span><br><span class="line">  for (; i &lt; n; ++i) &#123;</span><br><span class="line">    if (array[i] == x) &#123;</span><br><span class="line">       pos = i;</span><br><span class="line">       break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候，问题就来了。我们优化完之后，这段代码的时间复杂度还是 O(n) 吗？如果数组中第一个元素正好是要查找的变量 x，那就不需要继续遍历剩下的 n-1 个数据了，那时间复杂度就是 O(1)。但如果数组中不存在变量 x，那我们就需要把整个数组都遍历一遍，时间复杂度就成了 O(n)。所以，不同的情况下，这段代码的时间复杂度是不一样的。</p>
<p>为了表示代码在不同情况下的不同时间复杂度，我们需要引入三个概念：<strong>最好情况时间复杂度、最坏情况时间复杂度和平均情况时间复杂度</strong>。顾名思义，最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度。就像我们刚刚讲到的，在最理想的情况下，要查找的变量 x 正好是数组的第一个元素，这个时候对应的时间复杂度就是最好情况时间复杂度。同理，最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度。就像刚举的那个例子，如果数组中没有要查找的变量 x，我们需要把整个数组都遍历一遍才行，所以这种最糟糕情况下对应的时间复杂度就是最坏情况时间复杂度。</p>
<h4 id="2-平均情况时间复杂度-amp-期望时间复杂度"><a href="#2-平均情况时间复杂度-amp-期望时间复杂度" class="headerlink" title="2. 平均情况时间复杂度 &amp;  期望时间复杂度"></a>2. 平均情况时间复杂度 &amp;  期望时间复杂度</h4><p>平均时间复杂度又该怎么分析呢？我还是借助刚才查找变量 x 的例子来给你解释。要查找的变量 x 在数组中的位置，有 n+1 种情况：在数组的 0～n-1 位置中和不在数组中。我们把每种情况下，查找需要遍历的元素个数累加起来，然后再除以 n+1，就可以得到需要遍历的元素个数的平均值，即：<br>$$<br>\frac{1+2+3+n+n}{n+1} =\frac{n(n+3)/2}{(n+1)}<br>$$<br>我们知道，时间复杂度的大 O 标记法中，可以省略掉系数、低阶、常量，所以，咱们把刚刚这个公式简化之后，得到的平均时间复杂度就是 O(n)。</p>
<p>这个结论虽然是正确的，但是计算过程稍微有点儿问题。究竟是什么问题呢？我们刚讲的这 n+1 种情况，出现的概率并不是一样的。我带你具体分析一下。</p>
<p>我们知道，要查找的变量 x，要么在数组里，要么就不在数组里。这两种情况对应的概率统计起来很麻烦，为了方便你理解，我们假设在数组中与不在数组中的概率都为 1/2。另外，要查找的数据出现在 0～n-1 这 n 个位置的概率也是一样的，为 1/n。所以，根据概率乘法法则，要查找的数据出现在 0～n-1 中任意位置的概率就是 1/(2n)。</p>
<p>因此，前面的推导过程中存在的最大问题就是，没有将各种情况发生的概率考虑进去。如果我们把每种情况发生的概率也考虑进去，那平均时间复杂度的计算过程就变成了这样：</p>
<p><img src="/pics%5Cimage-20200601213410715.png" alt="image-20200601213410715"></p>
<p><strong>这个值就是概率论中的加权平均值，也叫作期望值，所以平均时间复杂度的全称应该叫加权平均时间复杂度或者期望时间复杂度。</strong></p>
<p>在大多数情况下，我们并不需要区分最好、最坏、平均情况时间复杂度三种情况。像我们上一节课举的那些例子那样，很多时候，我们使用一个复杂度就可以满足需求了。只有同一块代码在不同的情况下，时间复杂度有量级的差距，我们才会使用这三种复杂度表示法来区分。</p>
<h4 id="3-均摊时间复杂度"><a href="#3-均摊时间复杂度" class="headerlink" title="3. 均摊时间复杂度"></a>3. 均摊时间复杂度</h4><p>均摊时间复杂度，听起来跟平均时间复杂度有点儿像。对于初学者来说，这两个概念确实非常容易弄混。我前面说了，大部分情况下，我们并不需要区分最好、最坏、平均三种复杂度。平均复杂度只在某些特殊情况下才会用到，而均摊时间复杂度应用的场景比它更加特殊、更加有限。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array表示一个长度为n的数组</span></span><br><span class="line"><span class="comment">// 代码中的array.length就等于n</span></span><br><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (count == array.length) &#123;</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; ++i) &#123;</span><br><span class="line">         sum = sum + array[i];</span><br><span class="line">      &#125;</span><br><span class="line">      array[<span class="number">0</span>] = sum;</span><br><span class="line">      count = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   array[count] = val;</span><br><span class="line">   ++count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>码实现了一个往数组中插入数据的功能。当数组满了之后，也就是代码中的 count == array.length 时，我们用 for 循环遍历数组求和，并清空数组，将求和之后的 sum 值放到数组的第一个位置，然后再将新的数据插入。但如果数组一开始就有空闲空间，则直接将数据插入数组。</p>
<p>那这段代码的时间复杂度是多少呢？你可以先用我们刚讲到的三种时间复杂度的分析方法来分析一下。最理想的情况下，数组中有空闲空间，我们只需要将数据插入到数组下标为 count 的位置就可以了，所以最好情况时间复杂度为 O(1)。最坏的情况下，数组中没有空闲空间了，我们需要先做一次数组的遍历求和，然后再将数据插入，所以最坏情况时间复杂度为 O(n)。那平均时间复杂度是多少呢？答案是 O(1)。我们还是可以通过前面讲的概率论的方法来分析。</p>
<p>假设数组的长度是 n，根据数据插入的位置的不同，我们可以分为 n 种情况，每种情况的时间复杂度是 O(1)。除此之外，还有一种“额外”的情况，就是在数组没有空闲空间时插入一个数据，这个时候的时间复杂度是 O(n)。而且，这 n+1 种情况发生的概率一样，都是 1/(n+1)。所以，根据加权平均的计算方法，我们求得的平均时间复杂度就是：</p>
<p><img src="/pics%5Cimage-20200601213945204.png" alt="image-20200601213945204"></p>
<p>至此为止，前面的最好、最坏、平均时间复杂度的计算，理解起来应该都没有问题。但是这个例子里的平均复杂度分析其实并不需要这么复杂，不需要引入概率论的知识。这是为什么呢？我们先来对比一下这个 insert() 的例子和前面那个 find() 的例子，你就会发现这两者有很大差别。</p>
<p>首先，find() 函数在极端情况下，复杂度才为 O(1)。但 insert() 在大部分情况下，时间复杂度都为 O(1)。只有个别情况下，复杂度才比较高，为 O(n)。这是 insert()第一个区别于 find() 的地方。</p>
<p>我们再来看第二个不同的地方。对于 insert() 函数来说，O(1) 时间复杂度的插入和 O(n) 时间复杂度的插入，出现的频率是非常有规律的，而且有一定的前后时序关系，一般都是一个 O(n) 插入之后，紧跟着 n-1 个 O(1) 的插入操作，循环往复。</p>
<p>所以，针对这样一种特殊场景的复杂度分析，我们并不需要像之前讲平均复杂度分析方法那样，找出所有的输入情况及相应的发生概率，然后再计算加权平均值。针对这种特殊的场景，我们引入了一种更加简单的分析方法：摊还分析法，通过摊还分析得到的时间复杂度我们起了一个名字，叫均摊时间复杂度。</p>
<p>究竟如何使用摊还分析法来分析算法的均摊时间复杂度呢？我们还是继续看在数组中插入数据的这个例子。每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1)。这就是均摊分析的大致思路。你都理解了吗？</p>
<p>均摊时间复杂度和摊还分析应用场景比较特殊，所以我们并不会经常用到。为了方便你理解、记忆，我这里简单总结一下它们的应用场景。如果你遇到了，知道是怎么回事儿就行了。对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。</p>
<p>尽管很多数据结构和算法书籍都花了很大力气来区分平均时间复杂度和均摊时间复杂度，但其实我个人认为，<strong>均摊时间复杂度就是一种特殊的平均时间复杂度</strong>，我们没必要花太多精力去区分它们。你最应该掌握的是它的分析方法，摊还分析。至于分析出来的结果是叫平均还是叫均摊，这只是个说法，并不重要。</p>
<h1 id="二、线性表"><a href="#二、线性表" class="headerlink" title="二、线性表"></a>二、线性表</h1><h2 id="2-1-数组"><a href="#2-1-数组" class="headerlink" title="2.1 数组"></a>2.1 数组</h2><p>数组是一种线性表，存储时是<strong>连续的</strong>内存空间和相同类型的数据。</p>
<h3 id="1、插入和删除"><a href="#1、插入和删除" class="headerlink" title="1、插入和删除"></a>1、插入和删除</h3><p>数组插入和删除过程中均需要搬移数据。</p>
<p><img src="/pics/image-20200810164157017.png" alt="image-20200810164157017"></p>
<p>平均的搬移次数为 :<br>$$<br>（n-i）/2<br>$$<br>i 表示插入的位置。</p>
<h3 id="2、容器vs数组"><a href="#2、容器vs数组" class="headerlink" title="2、容器vs数组"></a>2、容器vs数组</h3><ul>
<li>ArrayList 的优势：就是可以将很多数组操作的细节封装起来。比如前面提到的数组插入、删除数据时需要搬移其他数据等。另外，它还有一个优势，就是支持动态扩容。</li>
<li>数组的优势：1.Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。2.如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。3.要表示多维数组时，用数组往往会更加直观。比如 Object[][] array；而用容器的话则需要这样定义：ArrayList &lt;ArrayList<Object>&gt;</li>
</ul>
<h2 id="2-2-链表"><a href="#2-2-链表" class="headerlink" title="2.2 链表"></a>2.2 链表</h2><p>线性表，具有非连续的存储空间。存储单元除了存储元素信息外，还需存储后继节点的地址。</p>
<h3 id="1、类型"><a href="#1、类型" class="headerlink" title="1、类型"></a>1、类型</h3><ul>
<li><p>单链表： 每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址，尾结点的指针指向null。</p>
</li>
<li><p>双向链表：支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。</p>
</li>
<li><p>循环链表：能通过任何一个节点找到其他所有的节点，将两种(双向/单向)链表的最后一个结点指向第一个结点从而实现循环。</p>
</li>
</ul>
<h3 id="2、插入和删除"><a href="#2、插入和删除" class="headerlink" title="2、插入和删除"></a>2、插入和删除</h3><h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p><img src="/pics/image-20200810154021103.png" alt="image-20200810154021103"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;next = x;  <span class="comment">// 将p的next指针指向x结点；</span></span><br><span class="line">x-&gt;next = p-&gt;next;  <span class="comment">// 将x的结点的next指针指向b结点；</span></span><br></pre></td></tr></table></figure>

<p>插入时这两句话的顺序不可交换，否则第二行代码的 x-&gt;next = p-&gt;next（x）；x-&gt;next 指向了自己，整个列表断裂开来。</p>
<p>对于删除：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p -&gt; next = p-&gt;next -&gt;next;</span><br></pre></td></tr></table></figure>

<h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><p>插入时：</p>
<p><img src="/pics/image-20200810162534670.png" alt="image-20200810162534670"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s-&gt;pre = p; // s的前驱</span><br><span class="line">s-&gt;next = p-&gt;next; // s的后继</span><br><span class="line">p-&gt;next-&gt;pre = s; // p的后继的前驱 = s</span><br><span class="line">p-&gt;next = s; // p的后继 = s</span><br></pre></td></tr></table></figure>

<p>删除时：</p>
<p><img src="/pics/image-20200810163501739.png" alt="image-20200810163501739"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;next-&gt;pre = p-&gt;pre; // p的后继的前驱 = p的前驱</span><br><span class="line">p-&gt;pre-&gt;next = p-&gt;next; // p的前驱的后继 = p的后继</span><br></pre></td></tr></table></figure>

<p><strong>指针的理解：</strong>将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针**，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。</p>
<h3 id="3、头结点vs头指针"><a href="#3、头结点vs头指针" class="headerlink" title="3、头结点vs头指针"></a>3、头结点vs头指针</h3><p>头指针：链表的第一个节点称为头指针。</p>
<p>头结点：为方便对单链表进行操作，通常会在单链表第一个节点前附设一个节点称为头结点。头节点的数据域可以不存储任何元素也可以存储链表的大小。<strong>使用头结点可以简化插入第一个节点以及删除最后一个节点时的操作。</strong></p>
<p><img src="/pics/image-20200810171434090.png" alt="image-20200810171434090"></p>
<h3 id="4、链表vs数组性能"><a href="#4、链表vs数组性能" class="headerlink" title="4、链表vs数组性能"></a>4、链表vs数组性能</h3><p><img src="/pics/image-20200810172138477.png" alt="image-20200810172138477"></p>
<h1 id="三、栈与队列"><a href="#三、栈与队列" class="headerlink" title="三、栈与队列"></a>三、栈与队列</h1><h2 id="3-1-栈"><a href="#3-1-栈" class="headerlink" title="3.1  栈"></a>3.1  栈</h2><p>限定仅在表尾进行插入和删除操作的线性表，元素具有后进先出（LIFO）的特性。</p>
<p>那栈可以用来解决哪些问题呢？</p>
<h3 id="1、递归"><a href="#1、递归" class="headerlink" title="1、递归"></a>1、递归</h3><p>我们先看一个经典的递归例子，斐波那契数列数列。兔子出生2个月后，就有繁殖能力，一对兔子每个月能生一对小兔子，不考虑死亡的情况下，一年能有多少对对兔子？</p>
<p><img src="/pics/image-20200810201914105.png" alt="image-20200810201914105"></p>
<p>转换成数学公式就是：</p>
<p><img src="/pics/image-20200810201950148.png" alt="image-20200810201950148"></p>
<p>使用递归实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; </span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>) </span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>) </span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">	<span class="keyword">return</span> f(n-<span class="number">1</span>) + f(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、四则运算"><a href="#2、四则运算" class="headerlink" title="2、四则运算"></a>2、四则运算</h3><p>平时我们所用的四则表达式又称为中辍表达式，除了加减乘除等符号外还有括号等等，能够改变运算符执行优先级，导致很难转换成合适的计算指令。如果要通过机器计算，常见的方法是将中缀表达式转化为后缀表达式（逆波兰），去除原来表达式中的括号，因为括号只指示运算顺序，不是实际参与计算的元素。同时使得运算顺序有规律可寻，计算机能编写出代码完成计算。比如 9 + (3 - 1) * 2 + 10 / 2 转换成后缀表达式就是 9 3 1 - 3 * + 10 2 / +。</p>
<ul>
<li>中缀表达式转化后缀表达式规则：从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号（乘除优先加减）则栈顶元素依次出栈并输出（右括号匹配到左括号），并将当前符号进栈，一直到最终输出后缀表达式为止。</li>
<li>后缀表达式计算法：从左到右遍历表达式的每个数字和符号，遇到数字就进栈，遇到符号就将处于栈顶的两个数字出栈，一直到最终获得结果。</li>
</ul>
<p>将以上2步结合起来的规则如下：</p>
<p>先建立两个栈，一个保存操作数的栈，另一个是保存运算符的栈。从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；</p>
<p>当遇到运算符，就与运算符栈的栈顶元素进行比较；如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。</p>
<p><img src="/pics/image-20200810203502825.png" alt="image-20200810203502825"></p>
<h2 id="3-2-队列"><a href="#3-2-队列" class="headerlink" title="3.2 队列"></a>3.2 队列</h2><p>限定在一端进行插入，而在另一端进行删除操作的线性表，具有FIFO特性。</p>
<h3 id="1、顺序队列"><a href="#1、顺序队列" class="headerlink" title="1、顺序队列"></a>1、顺序队列</h3><p>使用数组实现的队列，队头和队尾分别用2个指针表示，font指队头的第一个元素，rear指队尾的下一个元素。在入队和出队的过程中通过指针移动来查找元素。</p>
<p><img src="/pics/image-20200811111219333.png" alt="image-20200811111219333"></p>
<p>此种方式存在的问题：1.队满时，rear指针数组越界；2.队满时，队列存在空闲元素，假溢出情况。</p>
<p><img src="/pics/image-20200811113630996.png" alt="image-20200811113630996"></p>
<p>对于这个问题其中的一种解决方案是在队满时进行整体搬移。</p>
<p><img src="/pics/image-20200811111908528.png" alt="image-20200811111908528"></p>
<p>这种方案会导致入队的最坏时间复杂度变成O(n)，更好的解决方案是采用循环队列。</p>
<h3 id="2、循环队列"><a href="#2、循环队列" class="headerlink" title="2、循环队列"></a>2、循环队列</h3><p>将队列的头尾相接。</p>
<p><img src="/pics/image-20200811112239043.png" alt="image-20200811112239043"></p>
<p>对于循环队列，队空的条件是：rear == front；<strong>队满条件为：(rear +1)%n=front。</strong>对应的入队和出队操作如下：</p>
<p><img src="/pics/image-20200811113137622.png" alt="image-20200811113137622"></p>
<h3 id="3、链式队列"><a href="#3、链式队列" class="headerlink" title="3、链式队列"></a>3、链式队列</h3><h4 id="1、入队"><a href="#1、入队" class="headerlink" title="1、入队"></a>1、入队</h4><p><img src="/pics/image-20200811112653905.png" alt="image-20200811112653905"></p>
<h4 id="2、出队"><a href="#2、出队" class="headerlink" title="2、出队"></a>2、出队</h4><p><img src="/pics/image-20200811112721747.png" alt="image-20200811112721747"></p>
<h1 id="四、串"><a href="#四、串" class="headerlink" title="四、串"></a>四、串</h1><p>由0个或多个字符组成的有限序列，又称为字符串。</p>
<p>下面主要讲下串的匹配算法。</p>
<h3 id="1、朴素模式"><a href="#1、朴素模式" class="headerlink" title="1、朴素模式"></a>1、朴素模式</h3><h4 id="1、原理"><a href="#1、原理" class="headerlink" title="1、原理"></a>1、原理</h4><p><strong>对主串的每一个字符作为开头，与要匹配的字符串进行匹配。对主串做大循环，每个字符开头做T长度的小循环，直到匹配成功或者全部遍历完成为止。</strong></p>
<p><img src="/pics/image-20200817143455781.png" alt="image-20200817143455781"></p>
<p><img src="/pics/image-20200817143508642.png" alt="image-20200817143508642"></p>
<h4 id="2、实现"><a href="#2、实现" class="headerlink" title="2、实现"></a>2、实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">match</span><span class="params">(String source, String match)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] sourceArr = source.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] matchArr = match.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sourceArr.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果第一位相等了，就迭代里面循环</span></span><br><span class="line">            <span class="keyword">if</span> (sourceArr[i] == matchArr[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="comment">// 开始比较第二位到最后一位</span></span><br><span class="line">                <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; matchArr.length) &#123;</span><br><span class="line">                    <span class="comment">// 当出现不相当的情况时，提前终止循环</span></span><br><span class="line">                    <span class="keyword">if</span> (sourceArr[i + j] != matchArr[j]) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 若子串比较到最后，没有提前退出循环，说明匹配成功</span></span><br><span class="line">                <span class="keyword">if</span> (j ==  matchArr.length) &#123;</span><br><span class="line">                    index = i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;matched, from source index &quot;</span> + index);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;not matched &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、KMP匹配-再理解一下"><a href="#2、KMP匹配-再理解一下" class="headerlink" title="2、KMP匹配(再理解一下)"></a>2、KMP匹配(再理解一下)</h3><p><img src="/pics/image-20200817205422048.png" alt="image-20200817205422048"></p>
<p><img src="/pics/image-20200817205459425.png" alt="image-20200817205459425"></p>
<h4 id="1、原理-1"><a href="#1、原理-1" class="headerlink" title="1、原理"></a>1、原理</h4><p>KMP算法通过寻找子串字符的规律，与主串匹配过程中，若发现失配，将子串回溯到合适位置，重新适配，直至匹配到主串结束或者匹配到子串。 </p>
<p><a target="_blank" rel="noopener" href="https://wiki.jikexueyuan.com/project/kmp-algorithm/define.html">https://wiki.jikexueyuan.com/project/kmp-algorithm/define.html</a></p>
<h4 id="2、部分匹配表（pmt）-amp-next数组"><a href="#2、部分匹配表（pmt）-amp-next数组" class="headerlink" title="2、部分匹配表（pmt） &amp; next数组"></a>2、部分匹配表（pmt） &amp; next数组</h4><p><img src="/pics/image-20200817202922035.png" alt="image-20200817202922035"></p>
<p><img src="/pics/image-20200817210302264.png" alt="image-20200817210302264"></p>
<p>总结下：</p>
<ul>
<li>失配时，模式串向右移动的距离 = 失配字符所在位置 - 失配字符对应的next值，也就是说jj回溯的距离 = j - next[j]；相当于索引从 j 变为了 next[j]。</li>
<li>next表 = 部分匹配表整体右移一位；</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Yintianhao/p/9996524.html">KMP算法理解及java实现</a></p>
<h4 id="3、next数组实现"><a href="#3、next数组实现" class="headerlink" title="3、next数组实现"></a>3、next数组实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getNext(<span class="keyword">char</span>[] match) &#123;</span><br><span class="line">       <span class="keyword">int</span> size = match == <span class="keyword">null</span> ? <span class="number">0</span> : match.length;</span><br><span class="line">       <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">       next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> k = -<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (i &lt; size - <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (k == -<span class="number">1</span> || next[i] == next[k]) &#123;</span><br><span class="line">               i++;</span><br><span class="line">               k++;</span><br><span class="line">               next[i] = k;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               k = next[k];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、next数组优化"><a href="#4、next数组优化" class="headerlink" title="4、next数组优化"></a>4、next数组优化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getNextMore(<span class="keyword">char</span>[] match) &#123;</span><br><span class="line">    <span class="keyword">int</span> size = match == <span class="keyword">null</span> ? <span class="number">0</span> : match.length;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = -<span class="number">1</span>; <span class="comment">// k代表前缀</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">// j代表后缀</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; size - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == -<span class="number">1</span> || match[k] == match[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">            k++;</span><br><span class="line">            <span class="keyword">if</span> (match[k] != match[j]) &#123;</span><br><span class="line">                next[j] = k;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 前缀和后缀相同情况下，那么当前后缀的回溯==前缀的回溯</span></span><br><span class="line">                next[j] = next[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5、KMP实现"><a href="#5、KMP实现" class="headerlink" title="5、KMP实现"></a>5、KMP实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] next = getNext(matchArr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; sourceArr.length &amp;&amp; j &lt; matchArr.length) &#123;</span><br><span class="line">    <span class="comment">// j == -1 表示的是第一个字符</span></span><br><span class="line">    <span class="comment">// 当字符串相同时，继续遍历</span></span><br><span class="line">    <span class="keyword">if</span> (j == -<span class="number">1</span> || sourceArr[i] == matchArr[j]) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        j++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 字符串不同时子串索引j开始回溯</span></span><br><span class="line">        j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若子串迭代结束到最后，说明匹配到了</span></span><br><span class="line"><span class="keyword">if</span> (j == matchArr.length) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;matched, from source index&quot;</span> + (i - j));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;not matched&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6、性能"><a href="#6、性能" class="headerlink" title="6、性能"></a>6、性能</h4><p>所以，如果文本串的长度为 n，模式串的长度为 m，那么匹配过程的时间复杂度为 O(n)，算上计算 next 的 O(m) 时间，KMP 的整体时间复杂度为 O(m + n)。</p>
<h3 id="3、BM算法"><a href="#3、BM算法" class="headerlink" title="3、BM算法"></a>3、BM算法</h3><h1 id="五、树"><a href="#五、树" class="headerlink" title="五、树"></a>五、树</h1><h2 id="5-1-树的定义"><a href="#5-1-树的定义" class="headerlink" title="5.1 树的定义"></a>5.1 树的定义</h2><p><img src="/pics/image-20200911102322716.png" alt="image-20200911102322716"></p>
<h3 id="1、度"><a href="#1、度" class="headerlink" title="1、度"></a>1、度</h3><p><img src="/pics/image-20200911102306980.png" alt="image-20200911102306980"></p>
<h3 id="2、深度和层次"><a href="#2、深度和层次" class="headerlink" title="2、深度和层次"></a>2、深度和层次</h3><p><img src="/pics/image-20200911102529207.png" alt="image-20200911102529207"></p>
<h2 id="5-2-二叉树"><a href="#5-2-二叉树" class="headerlink" title="5.2 二叉树"></a>5.2 二叉树</h2><p>二叉树，顾名思义，每个节点最多有两个“叉”，也就是两个子节点，分别是左子节点和右子节点。不过，二叉树并不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点。</p>
<h3 id="1、二叉树的类型"><a href="#1、二叉树的类型" class="headerlink" title="1、二叉树的类型"></a>1、二叉树的类型</h3><h4 id="1、满二叉树"><a href="#1、满二叉树" class="headerlink" title="1、满二叉树"></a>1、满二叉树</h4><p>除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫做满二叉树。</p>
<h4 id="2、完全二叉树"><a href="#2、完全二叉树" class="headerlink" title="2、完全二叉树"></a>2、完全二叉树</h4><p>最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫做完全二叉树。</p>
<p><img src="/pics/image-20200911103306293.png" alt="image-20200911103306293"></p>
<h4 id="3、斜树"><a href="#3、斜树" class="headerlink" title="3、斜树"></a>3、斜树</h4><p>所有节点都只有左子树或者右子树。所有节点都只有左子树的二叉树叫左斜树，所有节点只有右子树二叉树叫斜树。</p>
<p><img src="/pics/image-20200911110241749.png" alt="image-20200911110300815"></p>
<h3 id="2、二叉树的性质"><a href="#2、二叉树的性质" class="headerlink" title="2、二叉树的性质"></a>2、二叉树的性质</h3><p><img src="/pics/image-20200911111109174.png" alt="image-20200911111109174"></p>
<p><img src="/pics/image-20200911111135840.png" alt="image-20200911111135840"></p>
<p><img src="/pics/image-20200911111219114.png" alt="image-20200911111219114"></p>
<h3 id="3、二叉树的存储"><a href="#3、二叉树的存储" class="headerlink" title="3、二叉树的存储"></a>3、二叉树的存储</h3><p>存储一棵二叉树，有两种方法，一种是基于指针或者引用的二叉链式存储法，一种是基于数组的顺序存储法。</p>
<h4 id="1、链式存储"><a href="#1、链式存储" class="headerlink" title="1、链式存储"></a>1、链式存储</h4><p>我们只要拎住根节点，就可以通过左右子节点的指针，把整棵树都串起来。这种存储方式我们比较常用。大部分二叉树代码都是通过这种结构来实现的。</p>
<p><img src="/pics/image-20200911111935159.png" alt="image-20200911111935159"></p>
<h4 id="2、顺序存储"><a href="#2、顺序存储" class="headerlink" title="2、顺序存储"></a>2、顺序存储</h4><p>基于数组的顺序存储法。我们把根节点存储在下标 i = 1 的位置，<strong>那左子节点存储在下标 2 * i = 2 的位置，右子节点存储在 2 * i + 1</strong> = 3 的位置。以此类推，B 节点的左子节点存储在 2 * i = 2 * 2 = 4 的位置，右子节点存储在 2 * i + 1 = 2 * 2 + 1 = 5 的位置。</p>
<p><img src="/pics/image-20200911111827044.png" alt="image-20200911111827044"></p>
<p>如果某棵二叉树是一棵完全二叉树，那用数组存储无疑是最节省内存的一种方式。因为数组的存储方式并不需要像链式存储法那样，要存储额外的左右子节点的指针。</p>
<h3 id="4、二叉树的遍历"><a href="#4、二叉树的遍历" class="headerlink" title="4、二叉树的遍历"></a>4、二叉树的遍历</h3><p>如何将所有节点都遍历打印出来呢？经典的方法有三种，前序遍历、中序遍历和后序遍历。其中，前、中、后序，表示的是节点与它的左右子树节点遍历打印的先后顺序。</p>
<ul>
<li><p>前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。</p>
<p>ABDGHCEIF</p>
<p><img src="/pics/image-20200911112757396.png" alt="image-20200911112757396"></p>
</li>
<li><p>中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。</p>
<p>GDHBAEICF</p>
<p><img src="/pics/image-20200911113232315.png" alt="image-20200911113232315"></p>
</li>
<li><p>后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。GHDBIEFCA</p>
</li>
</ul>
<p><img src="/pics/image-20200911113315231.png" alt="image-20200911113315231"></p>
<p>此外还有一种遍历方式叫层序遍历，顾名思义，从上至下，一层一层遍历。ABCDEFGHI</p>
<p><img src="/pics/image-20200911113748626.png" alt="image-20200911113748626"></p>
<h3 id="5、遍历顺序复原二叉树"><a href="#5、遍历顺序复原二叉树" class="headerlink" title="5、遍历顺序复原二叉树"></a>5、遍历顺序复原二叉树</h3><p><img src="/pics/image-20200911114327205.png" alt="image-20200911114327205"></p>
<h2 id="5-3-树、森林与二叉树的转换"><a href="#5-3-树、森林与二叉树的转换" class="headerlink" title="5.3 树、森林与二叉树的转换"></a>5.3 树、森林与二叉树的转换</h2><h3 id="1、树转换为二叉树"><a href="#1、树转换为二叉树" class="headerlink" title="1、树转换为二叉树"></a>1、树转换为二叉树</h3><p><img src="/pics/image-20200911114940272.png" alt="image-20200911114940272"></p>
<h3 id="2、森林转换为二叉树"><a href="#2、森林转换为二叉树" class="headerlink" title="2、森林转换为二叉树"></a>2、森林转换为二叉树</h3><p><img src="/pics/image-20200911115025993.png" alt="image-20200911115025993"></p>
<h3 id="3、二叉树转换为树"><a href="#3、二叉树转换为树" class="headerlink" title="3、二叉树转换为树"></a>3、二叉树转换为树</h3><p><img src="/pics/image-20200911115238390.png" alt="image-20200911115238390"></p>
<p><img src="/pics/image-20200911115323265.png" alt="image-20200911115323265"></p>
<h3 id="4、二叉树转化为森林"><a href="#4、二叉树转化为森林" class="headerlink" title="4、二叉树转化为森林"></a>4、二叉树转化为森林</h3><p><img src="/pics/image-20200911115353816.png" alt="image-20200911115353816"></p>
<p><img src="/pics/image-20200911115428376.png" alt="image-20200911115428376"></p>
<h2 id="5-5-赫夫曼树"><a href="#5-5-赫夫曼树" class="headerlink" title="5.5 赫夫曼树"></a>5.5 赫夫曼树</h2><p>带权路径和最短的树，提升排序和查找的效率。</p>
<p><img src="/pics/image-20200911180457956.png" alt="image-20200911180457956"></p>
<h3 id="1、哈夫曼树的构造"><a href="#1、哈夫曼树的构造" class="headerlink" title="1、哈夫曼树的构造"></a>1、哈夫曼树的构造</h3><p><img src="/pics/image-20200911180244241.png" alt="image-20200911180244241"></p>
<p><img src="/pics/image-20200911180407556.png" alt="image-20200911180407556"></p>
<h3 id="2、哈夫曼编码"><a href="#2、哈夫曼编码" class="headerlink" title="2、哈夫曼编码"></a>2、哈夫曼编码</h3><p>哈夫曼树的应用很广，哈夫曼编码就是其在电讯通信中的应用之一。广泛地用于数据文件压缩的十分有效的编码方法。其压缩率通常在20%～90%之间。在电讯通信业务中，通常用二进制编码来表示字母或其他字符，并用这样的编码来表示字符序列。 </p>
<p><img src="/pics/image-20200911180606089.png" alt="image-20200911180606089"></p>
<p><img src="/pics/image-20200911180638659.png" alt="image-20200911180638659"></p>
<h1 id="六、图"><a href="#六、图" class="headerlink" title="六、图"></a>六、图</h1><h2 id="6-1-图"><a href="#6-1-图" class="headerlink" title="6.1 图"></a>6.1 图</h2><h3 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h3><p><img src="/pics/image-20200915105022777.png" alt="image-20200915105022777"></p>
<h4 id="1、无向图和有向图"><a href="#1、无向图和有向图" class="headerlink" title="1、无向图和有向图"></a>1、无向图和有向图</h4><p><img src="/pics/image-20200915105500416.png" alt="image-20200915105500416"></p>
<p><img src="/pics/image-20200915105606224.png" alt="image-20200915105606224"></p>
<p><img src="/pics/image-20200915105626442.png" alt="image-20200915105626442"></p>
<p><img src="/pics/image-20200915105706437.png" alt="image-20200915105706437"></p>
<h4 id="2、网"><a href="#2、网" class="headerlink" title="2、网"></a>2、网</h4><p><img src="/pics/image-20200915105805034.png" alt="image-20200915105805034"></p>
<h4 id="3、环"><a href="#3、环" class="headerlink" title="3、环"></a>3、环</h4><p><img src="/pics/image-20200915110356072.png" alt="image-20200915110356072"></p>
<p><img src="/pics/image-20200915110411756.png" alt="image-20200915110411756"></p>
<h3 id="2、存储结构"><a href="#2、存储结构" class="headerlink" title="2、存储结构"></a>2、存储结构</h3><h4 id="1、邻接矩阵"><a href="#1、邻接矩阵" class="headerlink" title="1、邻接矩阵"></a>1、邻接矩阵</h4><p><img src="/pics/image-20200915143617330.png" alt="image-20200915143617330"></p>
<p><img src="/pics/image-20200915143641884.png" alt="image-20200915143641884"></p>
<p><img src="/pics/image-20200915143942044.png" alt="image-20200915143942044"></p>
<p>邻接矩阵在边数相对较少的情况下，存在存储空间浪费的情况。</p>
<h4 id="2、邻接表"><a href="#2、邻接表" class="headerlink" title="2、邻接表"></a>2、邻接表</h4><p><img src="/pics/image-20200915144216413.png" alt="image-20200915144216413"></p>
<p>对于有向图，邻接表是顶点作为弧尾来存储边表，这样可以很容易的确定顶点的出度；有时为了更方便的确定顶点的入度，会采用逆领接表的方式存储数据。</p>
<p><img src="/pics/image-20200915145504103.png" alt="image-20200915145504103"></p>
<h3 id="3-、遍历"><a href="#3-、遍历" class="headerlink" title="3 、遍历"></a>3 、遍历</h3><p>从图的某一个顶点出发访遍图中的其余顶点，且使每一个顶点仅被访问一次，这一过程就叫做图的遍历。</p>
<h4 id="1、深度优先遍历DFS"><a href="#1、深度优先遍历DFS" class="headerlink" title="1、深度优先遍历DFS"></a>1、深度优先遍历DFS</h4><p>每次遍历当前访问顶点的临界点，一直到访问的顶点没有未被访问过的临界点为止。然后采用依次回退的方式，查看来的路上每一个顶点是否有其它未被访问的临界点。访问完成后，判断图中的顶点是否已经全部遍历完成，如果没有，以未访问的顶点为起始点，重复上述过程。</p>
<h4 id="2、广度优先遍历BFS"><a href="#2、广度优先遍历BFS" class="headerlink" title="2、广度优先遍历BFS"></a>2、广度优先遍历BFS</h4><p>广度优先搜索类似于树的层次遍历。从图中的某一顶点出发，遍历每一个顶点时，依次遍历其所有的邻接点，然后再从这些邻接点出发，同样依次访问它们的邻接点。按照此过程，直到图中所有被访问过的顶点的邻接点都被访问到。</p>
<h2 id="6-2-最小生成树"><a href="#6-2-最小生成树" class="headerlink" title="6.2 最小生成树"></a>6.2 最小生成树</h2><p><img src="/pics/image-20200917111916805.png" alt="image-20200917111916805"></p>
<p>构造连通网的最小代价生成树称为最小生成树。找到连通网的最小树，通常有2种做法分别是：</p>
<ol>
<li>Prim算法是以点为对象，挑选与点相连的最短边来构成最小生成树。</li>
<li>Kruskal算法是以边为对象，不断地加入新的不构成环路的最短边来构成最小生成树。</li>
</ol>
<h3 id="1、Prim算法"><a href="#1、Prim算法" class="headerlink" title="1、Prim算法"></a>1、Prim算法</h3><p>基本原理：</p>
<ol>
<li>从某个点开始，查找当前点可以访问的所有边；</li>
<li>找到离当前顶点权值最小的边，并且将该顶点加入到集合V[]。</li>
<li>寻找当前集合可以访问的所有边，重复2过程，直到没有新的点可以加入。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INF = <span class="number">65535</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">miniTree</span><span class="params">(<span class="keyword">int</span>[][] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    <span class="comment">// 边的集合,访问过的顶点标记为0</span></span><br><span class="line">    <span class="comment">// 初始化为第0行的数组</span></span><br><span class="line">    <span class="keyword">int</span>[] lowCost = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 记录访问的节点顺序</span></span><br><span class="line">    <span class="keyword">int</span>[] path = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="comment">// 路径长度</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 默认从第一个顶点开始查找</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 记录查找到的顶点</span></span><br><span class="line">    lowCost[k] = <span class="number">0</span>;</span><br><span class="line">    path[k] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = INF;</span><br><span class="line">        <span class="comment">// 查找当前lowest中的最小值即最短边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lowCost[j] != <span class="number">0</span> &amp;&amp; lowCost[j] &lt; min) &#123;</span><br><span class="line">                min = lowCost[j];</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//标记节点为已访问</span></span><br><span class="line">        lowCost[k] = <span class="number">0</span>;</span><br><span class="line">        path[i] = k;</span><br><span class="line">        <span class="comment">// 节点路径权值和</span></span><br><span class="line">        sum += min;</span><br><span class="line">        <span class="comment">// 更新最短路径的边，[k,j] 新加入的节点到其余未访问节点的权值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lowCost[j] != <span class="number">0</span> &amp;&amp; arr[k][j] &lt; lowCost[j]) &#123;</span><br><span class="line">                lowCost[j] = arr[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : path) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、Kruskal-算法"><a href="#2、Kruskal-算法" class="headerlink" title="2、Kruskal 算法"></a>2、Kruskal 算法</h3><p>将最短路径的顶点连接成树，在连接过程中要注意判断是不是形成了环，如果形成了环则调过这个顶点。环的判断方法为：<strong>当某边的2个顶点的根节点相同时，此时就形成了环。</strong></p>
<p><strong>步骤：</strong></p>
<ol>
<li>将边的权值从小到大排序</li>
<li>选择最小权重的边，判断是否其在当前的生成树中形成了一个环路。如果环路没有形成，则将该边加入树中，否则放弃。</li>
<li>重复步骤2，直到有n-1条边（n表示顶点数）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">miniTree</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = graph.length;</span><br><span class="line">    <span class="comment">//1.生成边的列表</span></span><br><span class="line">    ArrayList&lt;Edge&gt; edgeList = getEdges(graph, len);</span><br><span class="line">    <span class="comment">//2.对边进行排序</span></span><br><span class="line">    sortEdge(edgeList);</span><br><span class="line">    <span class="comment">//3.初始化的parent数组值都为0，理解为顶点都是根节点</span></span><br><span class="line">    <span class="comment">// parent 数组用来查找节点的根节点</span></span><br><span class="line">    <span class="keyword">int</span>[] parent = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.对边进行遍历，权值从低到高</span></span><br><span class="line">    <span class="keyword">int</span> edgeCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Edge edge : edgeList) &#123;</span><br><span class="line">        <span class="keyword">int</span> root1 = findRoot(parent, edge.from);</span><br><span class="line">        <span class="keyword">int</span> root2 = findRoot(parent, edge.to);</span><br><span class="line">        <span class="keyword">if</span> (root1 != root2) &#123; <span class="comment">// 判断是否形成了环，如果不同就可以合并2个节点或者树，让他们有相同的根</span></span><br><span class="line">            parent[root2] = root1; <span class="comment">// 两个顶点组成树</span></span><br><span class="line">            System.out.println(<span class="string">&quot;edge from = &quot;</span> + edge.from + <span class="string">&quot;, to = &quot;</span> + edge.to + <span class="string">&quot;, weight = &quot;</span> + edge.weight);</span><br><span class="line">            edgeCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (edgeCount == len - <span class="number">1</span>) &#123;<span class="comment">// 当边的个数 = 顶点数 - 1时，构造完成</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span>[] parent, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (parent[n] &gt; <span class="number">0</span>) &#123; <span class="comment">// 查找根节点的过程</span></span><br><span class="line">        n = parent[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;Edge&gt; <span class="title">getEdges</span><span class="params">(<span class="keyword">int</span>[][] arr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Edge&gt; edgeList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i][j] != INF) &#123;</span><br><span class="line">                edgeList.add(<span class="keyword">new</span> Edge(i, j, arr[i][j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> edgeList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortEdge</span><span class="params">(ArrayList&lt;Edge&gt; edgeList)</span> </span>&#123;</span><br><span class="line">    edgeList.sort(<span class="keyword">new</span> Comparator&lt;Edge&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Edge o1, Edge o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o1.weight - o2.weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//for (Edge edge : edgeList) &#123;</span></span><br><span class="line"><span class="comment">//      System.out.println(edge);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> from;</span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line">        <span class="keyword">this</span>.to = to;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Edge&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;from=&quot;</span> + from +</span><br><span class="line">                <span class="string">&quot;, to=&quot;</span> + to +</span><br><span class="line">                <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、对比"><a href="#3、对比" class="headerlink" title="3、对比"></a>3、对比</h3><p>Prim算法的时间复杂度为O（n^2）；Kruskal  的算法复杂度为O（ElogE）E表示边数。</p>
<p>Kruskal主要是针对边来展开，边数少时效率会非常高，对于稀疏图效率非常高；</p>
<p>Prim算法更适用于稠密图，即边数较多的情况。</p>
<h2 id="6-3-最短路径"><a href="#6-3-最短路径" class="headerlink" title="6.3 最短路径"></a>6.3 最短路径</h2><p><img src="/pics/image-20200920162912673.png" alt="image-20200920162912673"></p>
<h3 id="1、Dijkstra算法"><a href="#1、Dijkstra算法" class="headerlink" title="1、Dijkstra算法"></a>1、Dijkstra算法</h3><p><img src="/pics/image-20200920154441523.png" alt="image-20200920154441523"></p>
<p><img src="/pics/image-20200920154502413.png" alt="image-20200920154502413"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">minPath</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = graph.length;</span><br><span class="line">    <span class="comment">// 算法从0节点开始</span></span><br><span class="line">    <span class="comment">// vex 表示访问过的顶点</span></span><br><span class="line">    <span class="keyword">int</span>[] vex = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="comment">// path 表示访问这个顶点需要经过的顶点</span></span><br><span class="line">    <span class="keyword">int</span>[] path = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="comment">// dist 表示访问到顶点最小权值</span></span><br><span class="line">    <span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        dist[i] = graph[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vex[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vex[i] == <span class="number">0</span> &amp;&amp; dist[i] &lt; min) &#123;</span><br><span class="line">                min = dist[i];</span><br><span class="line">                k = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vex[k] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 选中k位后，比较【0-&gt;剩余顶点】及【0-&gt;k + k-&gt;剩余顶点】的距离，</span></span><br><span class="line">            <span class="comment">// 更新到【0-&gt;剩余顶点】的最小距离</span></span><br><span class="line">            <span class="keyword">if</span> (vex[i] == <span class="number">0</span> &amp;&amp; (min + graph[k][i] &lt; dist[i])) &#123;</span><br><span class="line">                dist[i] = min + graph[k][i];</span><br><span class="line">                path[i] = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [0,0,0,2] 表示的含义为，最短路径中从0节点开始到这个节点的前驱节点</span></span><br><span class="line">    System.out.println(<span class="string">&quot;路径访问的前驱, 默认索引是 0, 1, 2..&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> value : path) &#123;</span><br><span class="line">        System.out.print(value + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;权值，从0到这个节点的最大权值&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> value : dist) &#123;</span><br><span class="line">        System.out.print(value + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Prim和Dijkstra算法具体原理非常相似，区别是：</p>
<ul>
<li>Prim更新的是<strong>未标记集合到已标记集合之间的距离</strong>。</li>
<li>Dijkstra更新的是<strong>源点到未标记集合之间的距离。</strong></li>
</ul>
<h3 id="2、Floyd算法"><a href="#2、Floyd算法" class="headerlink" title="2、Floyd算法"></a>2、Floyd算法</h3><p>Floyd算法能够计算图中<strong>任意两点间的最短路径</strong>。核心原理是：i,j 是目标2点，若i,j中点为v，那么i，j直接的最短距离为：<br>$$<br>D[i][j] = min( D[i][j], (D[i][v] + D[v][j]) )（i!=j,v!=i,v!=j）<br>$$</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public static void minPath(int[][] graph) &#123;</span><br><span class="line">    int len = graph.length;</span><br><span class="line"></span><br><span class="line">    int[][] path = new int[len][len];</span><br><span class="line">    // path 表示i，j直接的最短距离的中点。</span><br><span class="line">    // 初始化</span><br><span class="line">    for (int i = 0; i &lt;len; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; len; j++) &#123;</span><br><span class="line">            // 有2种方式</span><br><span class="line">            // 1.&quot;顶点i&quot;到&quot;顶点j&quot;的最短路径是经过顶点j</span><br><span class="line">            // 2.-1 表示直接连接</span><br><span class="line">            path[i][j] = -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // u 表示i,j中间顶点的索引</span><br><span class="line">    for (int u = 0; u &lt; len; u++) &#123;</span><br><span class="line">        for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; len; j++) &#123;</span><br><span class="line">                // 顶点不能首尾相接 &amp;&amp; 中间点不能和头尾相同，比如 i=1,j=2,u=2，此时</span><br><span class="line">                // graph [1][2] &gt; graph[1][2] + graph[2][2]</span><br><span class="line">                if (i == j || u == j || u == i) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                //比较时若后面出现无穷值时，前后是不能比较的，取最大值为INF</span><br><span class="line">                int tmp = (graph[i][u] == INF || graph[u][j] == INF) ? INF : graph[i][u] + graph[u][j];</span><br><span class="line">                if (graph[i][j] &gt; tmp) &#123;</span><br><span class="line">                    // i j 间的最小距离</span><br><span class="line">                    graph[i][j] = tmp;</span><br><span class="line">                    // i j要经过的点</span><br><span class="line">                    path[i][j] = u;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;=== graph ======&quot;);</span><br><span class="line">    printGraph(graph);</span><br><span class="line">    System.out.println(&quot;=== path ======&quot;);</span><br><span class="line">    printGraph(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、比较"><a href="#3、比较" class="headerlink" title="3、比较"></a>3、比较</h3><p>Dijkstra算法主要用于计算单源最短路径，时间复杂度为O（n^2)；若要计算任意2点间的最短距离，那么时间复杂度为 n * n^2 = O(n^3);</p>
<p>Floyd算法可以计算任意2点间的最短距离，时间复杂度为O(n^2)；所以说在求任意2点间最短距离时，这2种算法的时间复杂度基本相当。</p>
<h2 id="6-4-拓补排序（算法待补充）"><a href="#6-4-拓补排序（算法待补充）" class="headerlink" title="6.4 拓补排序（算法待补充）"></a>6.4 拓补排序（算法待补充）</h2><p><img src="/pics/image-20200920163617146.png" alt="image-20200920163617146"></p>
<p><img src="/pics/image-20200920163704632.png" alt="image-20200920163704632"></p>
<h3 id="1、拓补排序算法"><a href="#1、拓补排序算法" class="headerlink" title="1、拓补排序算法"></a>1、拓补排序算法</h3><p><img src="/pics/image-20200920164156582.png" alt="image-20200920164156582"></p>
<p><img src="/pics/image-20200920164246852.png" alt="image-20200920164246852"></p>
<h3 id="2、关键路径"><a href="#2、关键路径" class="headerlink" title="2、关键路径"></a>2、关键路径</h3><p><img src="/pics/image-20200920171450218.png" alt="image-20200920171450218"></p>
<p><img src="/pics/image-20200920171619096.png" alt="image-20200920171619096"></p>
<p><img src="/pics/image-20200920172528702.png" alt="image-20200920172528702"></p>
<p>关键路径步骤：</p>
<ol>
<li>从源点开始到汇点求所有事件的最早开始时间Ve</li>
<li>从汇点到源点求所有事件的最晚开始时间Le</li>
<li>通过Le和Ve求活动的最早、最晚开始时间ete、lte</li>
<li>若ete == lte，说明此活动为关键路径</li>
</ol>
<p><img src="/pics/image-20200920175143682.png" alt="image-20200920175143682"></p>
<h4 id="1、事件的最早-最晚发生时间"><a href="#1、事件的最早-最晚发生时间" class="headerlink" title="1、事件的最早/最晚发生时间"></a>1、事件的最早/最晚发生时间</h4><table>
<thead>
<tr>
<th></th>
<th>V0</th>
<th>V1</th>
<th>V2</th>
<th>V3</th>
<th>V4</th>
<th>V5</th>
<th>V6</th>
<th>V7</th>
<th>V8</th>
<th>V9</th>
</tr>
</thead>
<tbody><tr>
<td>etv(最早发生时间<strong>，多个入度取最大</strong>)</td>
<td>0</td>
<td>3</td>
<td>4</td>
<td>12</td>
<td>15</td>
<td>11</td>
<td>24</td>
<td>19</td>
<td>24</td>
<td>27</td>
</tr>
<tr>
<td>Ltv（最晚发生时间，<strong>多个入度取最小</strong>）</td>
<td>0</td>
<td>7</td>
<td>4</td>
<td>12</td>
<td>15</td>
<td>13</td>
<td>25</td>
<td>19</td>
<td>24</td>
<td>27</td>
</tr>
</tbody></table>
<h4 id="2、活动的最早、最晚开始时间"><a href="#2、活动的最早、最晚开始时间" class="headerlink" title="2、活动的最早、最晚开始时间"></a>2、活动的最早、最晚开始时间</h4><table>
<thead>
<tr>
<th></th>
<th>a0</th>
<th>a1</th>
<th>a2</th>
<th>a3</th>
<th>a4</th>
<th>a5</th>
<th>a6</th>
<th>a7</th>
<th>a8</th>
<th>a9</th>
<th>a10</th>
<th>a11</th>
<th>a12</th>
</tr>
</thead>
<tbody><tr>
<td>ete(etv(k),弧尾节点的最早发生时间）</td>
<td>0</td>
<td>0</td>
<td>3</td>
<td>3</td>
<td>4</td>
<td>4</td>
<td>12</td>
<td>15</td>
<td>15</td>
<td>11</td>
<td>24</td>
<td>19</td>
<td>24</td>
</tr>
<tr>
<td>lte</td>
<td>4</td>
<td>0</td>
<td>7</td>
<td>9</td>
<td>4</td>
<td>8</td>
<td>12</td>
<td>16</td>
<td>15</td>
<td>13</td>
<td>25</td>
<td>19</td>
<td>24</td>
</tr>
</tbody></table>
<p>lte[4] = Ltv[j] - w[j,k]，lte = 弧头节点的Ltv - 路径权值；比如Lte（a4） = Ltv[3] - wa4  = 12 - 8 = 4</p>
<h4 id="3、ete-lte为关键路径"><a href="#3、ete-lte为关键路径" class="headerlink" title="3、ete == lte为关键路径"></a>3、ete == lte为关键路径</h4><p>也就是说a1,a4,a6,a8,a11,a12为关键路径，缩短关键路径的时间能够提高整个工程的周期，当然如果缩短太多，关键路径可能发生变化；关键路径可能不止一条。</p>
<h1 id="七、查找"><a href="#七、查找" class="headerlink" title="七、查找"></a>七、查找</h1><h2 id="7-1-有序表的查找"><a href="#7-1-有序表的查找" class="headerlink" title="7.1 有序表的查找"></a>7.1 有序表的查找</h2><h3 id="1、二分查找"><a href="#1、二分查找" class="headerlink" title="1、二分查找"></a>1、二分查找</h3><p>又称为折半查找法，取中间的记录进行比较；若给定值小于中间值，则向记录的左半区继续查找；若给定值大于中间值，则向记录的右半区查找。不断重复上述步骤，知道查找成功。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> find = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = arr.length;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; arr[mid]) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; arr[mid]) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            find = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (find != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;find &quot;</span> + find);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;not find &quot;</span> + find);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> find;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、插值查找"><a href="#2、插值查找" class="headerlink" title="2、插值查找"></a>2、插值查找</h3><p>二分查找的改善算法，适用于记录较多，关键字分布比较均匀的表，只需要更改下mid的算法<br>$$<br>mid = low + （high - low）* (key - a[low]) / (a[high] - a[low])<br>$$</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] sortedList, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> find = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = sortedList.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + (high - low) * (key - sortedList[low]) / (sortedList[high] - sortedList[low]);</span><br><span class="line">        <span class="keyword">if</span> (key &lt; sortedList[mid]) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; sortedList[mid]) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            find = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (find != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;find &quot;</span> + find);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;not find &quot;</span> + find);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> find;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、斐波那契查找"><a href="#3、斐波那契查找" class="headerlink" title="3、斐波那契查找"></a>3、斐波那契查找</h3><p>斐波那契查找是利用斐波那契数列对查找区间进行分割。<br>$$<br>F[k] = F[k-1] + F[ k-2]<br>$$<br>F[k]表示的是数组总长度，F[k-1],F[k-2]分别表示分割后，前后数组的长度。</p>
<p><img src="/pics/image-20200928174611685.png" alt="image-20200928174611685"></p>
<p><img src="/pics/image-20200928174622275.png" alt="image-20200928174622275"></p>
<p>$$<br>mid = low + F[k-1] - 1<br>$$</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] F = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> find = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 计算n位于斐波那契数列的位置</span></span><br><span class="line">        <span class="keyword">while</span> (arr.length &gt; F[k]) &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[F[k]];</span><br><span class="line">        <span class="comment">// 将数列补充为斐波那契的长度F[k]，不足的位数取值为数组最后一位的值。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; F[k]; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; arr.length) &#123;</span><br><span class="line">                temp[i] = arr[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[i] = arr[high];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// F[k] = F[k-1] + F[k-2]</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            mid = low + F[k - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (key &lt; temp[mid]) &#123;</span><br><span class="line">                <span class="comment">// 当关键字小于中间值时，取前边的序列，high从mid -1开始，长度为F[k-1]，所以k-=1 </span></span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">                k -= <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; temp[mid]) &#123;</span><br><span class="line">                <span class="comment">// 当关键字大于中间值时，取后边的序列，low要从mid+1开始，长度为F[k-2]，所以k-=2 </span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">                k -= <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                find = mid;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (find &lt; arr.length) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;find = &quot;</span> + find + <span class="string">&quot; , k = &quot;</span> + k);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;find out of arr &quot;</span> + find + <span class="string">&quot; , k = &quot;</span> + k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> find;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-2-线性索引查询"><a href="#7-2-线性索引查询" class="headerlink" title="7.2 线性索引查询"></a>7.2 线性索引查询</h2><p>常见的线性索引主要有三种：稠密索引、分块索引、倒排索引</p>
<p>稠密索引：数据集中每一个记录对应一个索引项。对于稠密索引的的索引表来说，索引项是按照关键码有序的排列。也就是说查找索引关键字时可以运用二分查找等算法。</p>
<p>分块索引：分块有序，把数据集的记录分成若干块，并且这些块需要满足2个条件：</p>
<ul>
<li>块内无序，即每一块内的记录不要求有序</li>
<li>块间有序，例如，要求第二块的所有记录关键字大于第一块，依次类推。</li>
</ul>
<p><img src="/pics/image-20201008101806029.png" alt="image-20201008101806029"></p>
<p>倒排索引：记录好存储具有相同次关键字的所有的记录的记录号，主要用于搜索引擎</p>
<h2 id="7-3-二叉排序树"><a href="#7-3-二叉排序树" class="headerlink" title="7.3 二叉排序树"></a>7.3 二叉排序树</h2><p>又称为二叉查找树，可以是空树，非空树具有如下的性质：</p>
<ul>
<li><p>若它的左子树不为空，则左子树上所有节点的值均小于根节点的值</p>
</li>
<li><p>若右子树不为空，则右子树所有节点值均大于等于根节点值</p>
</li>
<li><p>左右子树也分别为二叉树</p>
</li>
<li><p>中序遍历二叉排序树会得到一个有序序列</p>
</li>
</ul>
<h3 id="1、查找"><a href="#1、查找" class="headerlink" title="1、查找"></a>1、查找</h3><p>从根节点开始查找，若小于key则从继续查找左子树，否则查找右子树，直到查找到或者节点没有子节点。</p>
<h3 id="2、插入"><a href="#2、插入" class="headerlink" title="2、插入"></a>2、插入</h3><p>从根节点开始查找，若小于key则从继续查找左子树，否则查找右子树，直到查找的节点缺少左或右节点，则再此位置插入。</p>
<h3 id="3、删除"><a href="#3、删除" class="headerlink" title="3、删除"></a>3、删除</h3><p>删除时有以下几种情况：</p>
<p>1、删除节点时叶子节点，直接删除即可</p>
<p>2、节点只有左子树或者右子树，将节点删除后，将左子树或者右子树移动到删除节点的位置</p>
<p>3、删除节点有左右子树，找到要删除节点的p的直接前驱（或直接后继）s，用s来替换p，然后再删除s节点。</p>
<h3 id="4、实现"><a href="#4、实现" class="headerlink" title="4、实现"></a>4、实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BstTree tree = <span class="keyword">new</span> BstTree();</span><br><span class="line"></span><br><span class="line">        tree.insert(<span class="number">62</span>);</span><br><span class="line">        tree.insert(<span class="number">88</span>);</span><br><span class="line">        tree.insert(<span class="number">58</span>);</span><br><span class="line">        tree.insert(<span class="number">47</span>);</span><br><span class="line">        tree.insert(<span class="number">35</span>);</span><br><span class="line">        tree.insert(<span class="number">73</span>);</span><br><span class="line">        tree.insert(<span class="number">51</span>);</span><br><span class="line">        tree.insert(<span class="number">99</span>);</span><br><span class="line">        tree.insert(<span class="number">37</span>);</span><br><span class="line">        tree.insert(<span class="number">93</span>);</span><br><span class="line">        <span class="comment">//        62</span></span><br><span class="line">        <span class="comment">//      /    \</span></span><br><span class="line">        <span class="comment">//     58    88</span></span><br><span class="line">        <span class="comment">//     / \   / \</span></span><br><span class="line">        <span class="comment">//    47     73 99</span></span><br><span class="line">        <span class="comment">//    / \      /</span></span><br><span class="line">        <span class="comment">//   35  51   93</span></span><br><span class="line">        <span class="comment">//    \</span></span><br><span class="line">        <span class="comment">//     37</span></span><br><span class="line"></span><br><span class="line">        System.out.println(tree.search(<span class="number">47</span>));</span><br><span class="line">        System.out.println(tree.search(<span class="number">52</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(&quot;\n前序遍历结果&quot;);</span></span><br><span class="line"><span class="comment">//        tree.preOrder(tree.root);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n中序遍历结果&quot;</span>);</span><br><span class="line">        tree.midOrder(tree.root);</span><br><span class="line"><span class="comment">//        System.out.println(&quot;\n后序遍历结果&quot;);</span></span><br><span class="line"><span class="comment">//        tree.postOrder(tree.root);</span></span><br><span class="line"></span><br><span class="line">        tree.delete(tree.root, <span class="number">58</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;\n中序遍历结果&quot;</span>);</span><br><span class="line">        tree.midOrder(tree.root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> data;</span><br><span class="line">        <span class="keyword">public</span> TreeNode left;</span><br><span class="line">        <span class="keyword">public</span> TreeNode right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;TreeNode&#123;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;data=&quot;</span> + data +</span><br><span class="line">                    <span class="string">&quot;, left=&quot;</span> + left +</span><br><span class="line">                    <span class="string">&quot;, right=&quot;</span> + right +</span><br><span class="line">                    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BstTree</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> TreeNode root;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TreeNode <span class="title">search</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> search(root, data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> TreeNode <span class="title">search</span><span class="params">(TreeNode currentNode, <span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (currentNode == <span class="keyword">null</span> || currentNode.data == data) &#123;</span><br><span class="line">                <span class="keyword">return</span> currentNode;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data &lt; currentNode.data) &#123;</span><br><span class="line">                <span class="keyword">return</span> search(currentNode.left, data);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> search(currentNode.right, data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            root = insert(root, data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> TreeNode <span class="title">insert</span><span class="params">(TreeNode rootNode, <span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == rootNode) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(data);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (data &lt; rootNode.data) &#123;</span><br><span class="line">                rootNode.left = insert(rootNode.left, data);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (data &gt; rootNode.data) &#123;</span><br><span class="line">                rootNode.right = insert(rootNode.right, data);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> rootNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> TreeNode <span class="title">delete</span><span class="params">(TreeNode treeNode, <span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (treeNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (data &lt; treeNode.data) &#123;</span><br><span class="line">                <span class="comment">// 递归赋值的过程</span></span><br><span class="line">                treeNode.left = delete(treeNode.left, data);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data &gt; treeNode.data) &#123;</span><br><span class="line">                treeNode.right = delete(treeNode.right, data);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (treeNode.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> treeNode.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (treeNode.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> treeNode.left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 找到节点右子树的最小值，后继节点</span></span><br><span class="line">                TreeNode minNode = minRightNode(treeNode.right);</span><br><span class="line">                <span class="comment">// 用后继节点替换删除节点</span></span><br><span class="line">                treeNode.data = minNode.data;</span><br><span class="line">                <span class="comment">// 将后继节点删除</span></span><br><span class="line">                treeNode.right = delete(minNode, minNode.data);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 第二种方式</span></span><br><span class="line"><span class="comment">//                TreeNode maxNode = maxLeftNode(treeNode.left);</span></span><br><span class="line"><span class="comment">//                treeNode.data = maxNode.data;</span></span><br><span class="line"><span class="comment">//                treeNode.left = delete(maxNode, maxNode.data);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> treeNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左子树的最大值</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> TreeNode <span class="title">maxLeftNode</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右子树的最小值</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> TreeNode <span class="title">minRightNode</span><span class="params">(TreeNode targetNode)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (targetNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                targetNode = targetNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> targetNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != treeNode) &#123;</span><br><span class="line">                System.out.print(treeNode.data + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">                preOrder(treeNode.left);</span><br><span class="line">                preOrder(treeNode.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">midOrder</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != treeNode) &#123;</span><br><span class="line">                midOrder(treeNode.left);</span><br><span class="line">                System.out.print(treeNode.data + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">                midOrder(treeNode.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != treeNode) &#123;</span><br><span class="line">                postOrder(treeNode.left);</span><br><span class="line">                postOrder(treeNode.right);</span><br><span class="line">                System.out.print(treeNode.data + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、效率"><a href="#5、效率" class="headerlink" title="5、效率"></a>5、效率</h3><p><img src="/pics/image-20201009103249878.png" alt="image-20201009103249878"></p>
<h2 id="7-4-平衡二叉树（AVL树）"><a href="#7-4-平衡二叉树（AVL树）" class="headerlink" title="7.4 平衡二叉树（AVL树）"></a>7.4 平衡二叉树（AVL树）</h2><p>是一种二叉排序树，具有二叉排序树的所有特性，除此外新的特性有：</p>
<ul>
<li>每一个节点的左子树和右子树的高度差至多为1。将二叉树节点的左子树深度减去右子树深度的值称为平衡因子BF，那么二叉树所有节点的平衡因子只可能是0/1/-1。只要二叉树上有一个节点的BF绝对值大于1，那么这棵树就是不平衡的。</li>
<li>距离插入节点最近的，且BF绝对值大于1的节点做为根的子树，称为<strong>最小不平衡子树</strong>。</li>
</ul>
<h3 id="1、失衡调整"><a href="#1、失衡调整" class="headerlink" title="1、失衡调整"></a>1、失衡调整</h3><p>插入节点不平衡时，取最小不平衡树，进行调整，失衡的情况及调整策略有4种：</p>
<p><img src="/pics/image-20201010113610142.png" alt="image-20201010113610142"></p>
<h3 id="2、实现-1"><a href="#2、实现-1" class="headerlink" title="2、实现"></a>2、实现</h3><h2 id="7-5-红黑树"><a href="#7-5-红黑树" class="headerlink" title="7.5 红黑树"></a>7.5 红黑树</h2><p>红黑树是每个节点都带有<em>颜色</em>属性的，颜色为<em>红色</em>或<em>黑色</em>。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：</p>
<ol>
<li>节点是红色或黑色。</li>
<li>根是黑色。</li>
<li>所有叶子都是黑色（叶子是NIL节点）。</li>
<li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</li>
<li>从任一节点到其每个叶子的所有<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%81%93%E8%B7%AF_(%E5%9B%BE%E8%AE%BA)">简单路径</a>都包含相同数目的黑色节点。</li>
</ol>
<p>下面是一个具体的红黑树的图例：</p>
<p><img src="/pics/image-20201010165702505.png" alt="image-20201010165702505"></p>
<p>红黑树相对于AVL树来说，牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树。</p>
<h3 id="1、红黑树的调整："><a href="#1、红黑树的调整：" class="headerlink" title="1、红黑树的调整："></a>1、红黑树的调整：</h3><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91">https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91</a></p>
<p><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/68976">https://time.geekbang.org/column/article/68976</a></p>
<h2 id="7-6-B树和B-树"><a href="#7-6-B树和B-树" class="headerlink" title="7.6 B树和B+树"></a>7.6 B树和B+树</h2><h3 id="1、多路查找树"><a href="#1、多路查找树" class="headerlink" title="1、多路查找树"></a>1、多路查找树</h3><p>每一个节点的孩子可以多于2个，且每一个节点可以存储多个元素。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wtyvhreal/article/details/46442091">https://blog.csdn.net/wtyvhreal/article/details/46442091</a></p>
<h3 id="2、B树"><a href="#2、B树" class="headerlink" title="2、B树"></a>2、B树</h3><p>B/B+树是为了磁盘或其它存储设备而设计的一种平衡多路查找树，与AVL树相比，在相同的的节点的情况下，一颗B/B+树的高度远远小于AVL树的高度(<strong>在下面B/B+树的性能分析中会提到</strong>)。B/B+树上操作的时间通常由存取磁盘的时间和CPU计算时间这两部分构成，而CPU的速度非常快，所以B树的操作效率取决于访问磁盘的次数，关键字总数相同的情况下B树的高度越小，磁盘I/O所花的时间越少。</p>
<p><img src="/pics/image-20201010150846225.png" alt="image-20201010150846225"></p>
<h3 id="3、B-树"><a href="#3、B-树" class="headerlink" title="3、B+树"></a>3、B+树</h3><p><img src="/pics/image-20201010151620998.png" alt="image-20201010151620998"></p>
<p><img src="/pics/image-20201010151527119.png" alt="image-20201010151527119"></p>
<h2 id="7-7-散列表"><a href="#7-7-散列表" class="headerlink" title="7.7 散列表"></a>7.7 散列表</h2><p><img src="/pics/image-20201012102804659.png" alt="image-20201012102804659"></p>
<h3 id="1、散列函数"><a href="#1、散列函数" class="headerlink" title="1、散列函数"></a>1、散列函数</h3><p>散列函数构造有2个原则：1、计算简单 2、散列地址分布均匀</p>
<h4 id="1、直接定址法"><a href="#1、直接定址法" class="headerlink" title="1、直接定址法"></a>1、直接定址法</h4><p>适合查找表较小且连续的情况，实际中应用较少。<br>$$<br>F(key) = a * key + b<br>$$</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(key) = a * key + b</span><br></pre></td></tr></table></figure>

<h4 id="2、除留余数法"><a href="#2、除留余数法" class="headerlink" title="2、除留余数法"></a>2、除留余数法</h4><p>最常用的构造散列函数的方法，方法的关键在于选择合适的p，对于散列表长为m的散列函数公式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(key) = key mod p (p &lt;= m)</span><br></pre></td></tr></table></figure>

<h2 id="2、散列冲突处理"><a href="#2、散列冲突处理" class="headerlink" title="2、散列冲突处理"></a>2、散列冲突处理</h2><p>不同关键字经过散列函数计算得到相同的散列地址。</p>
<h4 id="1、-线性探测法"><a href="#1、-线性探测法" class="headerlink" title="1、 线性探测法"></a>1、 线性探测法</h4><p><img src="/pics/image-20201012110343653.png" alt="image-20201012110343653"></p>
<h4 id="2、二次探测法-随机数法"><a href="#2、二次探测法-随机数法" class="headerlink" title="2、二次探测法 +随机数法"></a>2、二次探测法 +随机数法</h4><p><img src="/pics/image-20201012112015612.png" alt="image-20201012112015612"></p>
<h4 id="3、链地址法"><a href="#3、链地址法" class="headerlink" title="3、链地址法"></a>3、链地址法</h4><p><img src="/pics/image-20201012112142672.png" alt="image-20201012112142672"></p>
<p><img src="/pics/image-20201012112100954.png" alt="image-20201012112100954"></p>
<h3 id="3、实现"><a href="#3、实现" class="headerlink" title="3、实现"></a>3、实现</h3><h1 id="八、排序"><a href="#八、排序" class="headerlink" title="八、排序"></a>八、排序</h1><ol>
<li><p>算法的执行效率：</p>
<p>算法的时间复杂度。排序时主要关注的是比较和移动的次数。</p>
</li>
<li><p>算法的稳定性：</p>
<p>如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。我通过一个例子来解释一下。比如我们有一组数据 2，9，3，4，8，3，按照大小排序之后就是 2，3，3，4，8，9。这组数据里有两个 3。经过某种排序算法排序之后，如果两个 3 的前后顺序没有改变，那我们就把这种排序算法叫作稳定的排序算法；如果前后顺序发生变化，那对应的排序算法就叫作不稳定的排序算法。当存在多个排序因子时，比如订单要根据金额和下单时间排序，稳定和不稳定的结果差异很大。</p>
</li>
<li><p>算法的内存消耗：</p>
<p>算法的空间复杂度，即进行排序时所需要的的辅助存储空间。</p>
</li>
</ol>
<h2 id="8-1-冒泡排序"><a href="#8-1-冒泡排序" class="headerlink" title="8.1 冒泡排序"></a>8.1 冒泡排序</h2><p><strong>两两比较相邻记录的顺序</strong>，如果反序则交换，直到没有反序记录为止，从小到大排。</p>
<p><img src="/pics/image-20200812175129105.png" alt="image-20200812175129105"></p>
<h3 id="1、冒泡的三种实现"><a href="#1、冒泡的三种实现" class="headerlink" title="1、冒泡的三种实现"></a>1、冒泡的三种实现</h3><p>冒泡初级版，严格意义上非冒泡排序，只是将最小值放到这一轮的第一位，更准确的描述应该是交换排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort0</span><span class="params">(<span class="keyword">int</span>[] source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = source == <span class="keyword">null</span> ? <span class="number">0</span> : source.length;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span> || len == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;element less 1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="comment">// 当前元素大于后续的元素，则进行交换，</span></span><br><span class="line">            <span class="comment">// 这样的结果就是每轮结束时，会找到当前轮最小的元素放到当前轮的第一位</span></span><br><span class="line">            <span class="keyword">if</span> (source[i] &gt; source[j]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = source[i];</span><br><span class="line">                source[i] = source[j];</span><br><span class="line">                source[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dump(source);</span><br><span class="line">    &#125;</span><br><span class="line">    dump(source);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dump</span><span class="params">(<span class="keyword">int</span>[] source)</span> </span>&#123;</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> element : source) &#123;</span><br><span class="line">        builder.append(element).append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(builder.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>改进版1，标准冒泡排序：第一种方式严格来讲并不是冒泡排序，不是两两相邻进行比较，每次只是比较这一轮的“第一位”和其余位置，若是逆序则交换<strong>。两两比较过程中，会将其余位置较小的元素也往前移动。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序，两两相邻比较并交换</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort1</span><span class="params">(<span class="keyword">int</span>[] source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = source == <span class="keyword">null</span> ? <span class="number">0</span> : source.length;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span> || len == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;element less 1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = len - <span class="number">1</span>; j &gt; i; j--) &#123; <span class="comment">// 从后往前遍历</span></span><br><span class="line">            <span class="comment">// 前 &gt; 后时，交换元素</span></span><br><span class="line">            <span class="keyword">if</span> (source[j - <span class="number">1</span>] &gt; source[j]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = source[j];</span><br><span class="line">                source[j] = source[j - <span class="number">1</span>];</span><br><span class="line">                source[j - <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dump(source);</span><br><span class="line">    &#125;</span><br><span class="line">    dump(source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>试想一下，冒泡排序过程中，某一轮如果没有发生任何交换，那么就说明此时序列已经是有序的，就不需要再进行比较了，也就是说可以再进一步优化下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort2</span><span class="params">(<span class="keyword">int</span>[] source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = source == <span class="keyword">null</span> ? <span class="number">0</span> : source.length;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span> || len == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;element less 1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = len - <span class="number">1</span>; j &gt; i; j--) &#123; <span class="comment">// 从后往前遍历</span></span><br><span class="line">            <span class="comment">// 前 &gt; 后时，交换元素</span></span><br><span class="line">            <span class="keyword">if</span> (source[j - <span class="number">1</span>] &gt; source[j]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = source[j];</span><br><span class="line">                source[j] = source[j - <span class="number">1</span>];</span><br><span class="line">                source[j - <span class="number">1</span>] = temp;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果某一轮没有发生元素交换，说明已经排好序了</span></span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dump(source);</span><br><span class="line">    &#125;</span><br><span class="line">    dump(source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、性能分析"><a href="#2、性能分析" class="headerlink" title="2、性能分析"></a>2、性能分析</h3><ul>
<li><p>时间复杂度</p>
<p><img src="/pics/image-20200812210611764.png" alt="image-20200812210611764"></p>
</li>
<li><p>稳定性</p>
<p>在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。</p>
</li>
<li><p>空间复杂度</p>
<p>冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)。</p>
</li>
</ul>
<h2 id="8-2-选择排序"><a href="#8-2-选择排序" class="headerlink" title="8.2 选择排序"></a>8.2 选择排序</h2><p>数组中的数据分为两个区间，已排序区间和未排序区间，通过n-1次遍历，每次找到未排序区间的最小元素，将其放到已排序区间末尾。</p>
<p><img src="/pics/image-20200812175024173.png" alt="image-20200812175024173"></p>
<h3 id="1、实现"><a href="#1、实现" class="headerlink" title="1、实现"></a>1、实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort0</span><span class="params">(<span class="keyword">int</span>[] source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = source == <span class="keyword">null</span> ? <span class="number">0</span> : source.length;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span> || len == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;element less 1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (source[minIndex] &gt; source[j]) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = source[minIndex];</span><br><span class="line">            source[minIndex] = source[i];</span><br><span class="line">            source[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        SortHelper.dump(source);</span><br><span class="line">    &#125;</span><br><span class="line">    SortHelper.dump(source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、性能"><a href="#2、性能" class="headerlink" title="2、性能"></a>2、性能</h3><ul>
<li><p>时间复杂度：</p>
<p><img src="/pics/image-20200812210524669.png" alt="image-20200812210524669"></p>
<p><img src="/pics/image-20200812210531732.png" alt="image-20200812210531732"></p>
</li>
<li><p>稳定性：</p>
<p>选择排序是一种不稳定的排序算法。从前面画的那张图中可以看出来，选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。</p>
</li>
<li><p>空间复杂度：O(1)</p>
</li>
</ul>
<p>​       相比于冒泡排序，选择排序的性能略好，因为元素交换的次数较少，但是不具备稳定性。</p>
<h2 id="8-3-插入排序"><a href="#8-3-插入排序" class="headerlink" title="8.3 插入排序"></a>8.3 插入排序</h2><p>数组中的数据分为两个区间，<strong>已排序区间和未排序区间</strong>，初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。</p>
<h3 id="1、实现-1"><a href="#1、实现-1" class="headerlink" title="1、实现"></a>1、实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort0</span><span class="params">(<span class="keyword">int</span>[] source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = source == <span class="keyword">null</span> ? <span class="number">0</span> : source.length;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span> || len == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;element less 1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123; <span class="comment">// 从第二位开始</span></span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">int</span> temp = source[j]; <span class="comment">//记录当前位置，若移位，当前位置会被覆盖</span></span><br><span class="line">        <span class="keyword">for</span> (; j &gt; <span class="number">0</span> &amp;&amp; source[j - <span class="number">1</span>] &gt; temp; j--) &#123; <span class="comment">// 从后往前遍历，查找插入的位置</span></span><br><span class="line">            <span class="comment">//若前一位值大于当前位置，前一位向后移动一位</span></span><br><span class="line">            source[j] = source[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        source[j] = temp; <span class="comment">// 将值插入到合适的位置</span></span><br><span class="line">        SortHelper.dump(source);</span><br><span class="line">    &#125;</span><br><span class="line">    SortHelper.dump(source);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移位判断使用while循环，更好理解一点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort1</span><span class="params">(<span class="keyword">int</span>[] source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = source == <span class="keyword">null</span> ? <span class="number">0</span> : source.length;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span> || len == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;element less 1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123; <span class="comment">// 从第二位开始</span></span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">int</span> temp = source[j];</span><br><span class="line">        <span class="comment">// 查找并移位置</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; source[j - <span class="number">1</span>] &gt; temp) &#123;</span><br><span class="line">            source[j] = source[j - <span class="number">1</span>];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果j！=i ，说明移动过了位置</span></span><br><span class="line">        <span class="keyword">if</span> (j != i) &#123;</span><br><span class="line">            source[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        SortHelper.dump(source);</span><br><span class="line">    &#125;</span><br><span class="line">    SortHelper.dump(source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、性能-1"><a href="#2、性能-1" class="headerlink" title="2、性能"></a>2、性能</h3><ul>
<li><p>时间复杂度</p>
<p><img src="/pics/image-20200812210309877.png" alt="image-20200812210309877"></p>
</li>
<li><p>稳定性</p>
<p>在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。</p>
</li>
<li><p>空间复杂度：O(1)</p>
</li>
</ul>
<h2 id="8-4-希尔排序"><a href="#8-4-希尔排序" class="headerlink" title="8.4 希尔排序"></a>8.4 希尔排序</h2><p>希尔排序是将待排序的数组元素 按下标的一定增量分组 ，分成多个子序列，然后对各个子序列进行直接插入排序算法排序；然后依次缩减增量再进行排序，直到增量为1时，进行最后一次直接插入排序，排序结束。</p>
<p><img src="/pics/image-20200825194744273.png" alt="image-20200825194744273"></p>
<h3 id="1、实现-2"><a href="#1、实现-2" class="headerlink" title="1、实现"></a>1、实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort0</span><span class="params">(<span class="keyword">int</span>[] source)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> len = source.length;</span><br><span class="line">      <span class="comment">// 步长循环直到1</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> step = len / <span class="number">2</span>; step &gt;= <span class="number">1</span>; step /= <span class="number">2</span>) &#123;</span><br><span class="line">          <span class="comment">// 间隔为step的插入排序</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = step; i &lt; len; i++) &#123;</span><br><span class="line">              <span class="keyword">int</span> temp = source[i];</span><br><span class="line">              <span class="comment">// j表示向前间隔多少位</span></span><br><span class="line">              <span class="keyword">int</span> j = i - step;</span><br><span class="line">              <span class="comment">// 从小到大排序，前面的数 &gt; 后面的数，向后移动</span></span><br><span class="line">              <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; source[j] &gt; temp) &#123;</span><br><span class="line">                  source[j + step] = source[j];</span><br><span class="line">                  j -= step;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//  优化，没有发生移动时，尾部不需要再赋值</span></span><br><span class="line">              <span class="keyword">if</span> ( j != i - step) &#123;</span><br><span class="line">                  source[j + step] = temp;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          SortHelper.dump(source);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、性能-2"><a href="#2、性能-2" class="headerlink" title="2、性能"></a>2、性能</h3><p><img src="/pics/image-20200824174735736.png" alt="image-20200824174735736"></p>
<p><img src="/pics/image-20200824174835386.png" alt="image-20200824174835386"></p>
<p>由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，<strong>所以希尔排序是不稳定的</strong>。</p>
<h2 id="8-5-堆排序"><a href="#8-5-堆排序" class="headerlink" title="8.5 堆排序"></a>8.5 堆排序</h2><p>将待排序的序列构造成一个大顶堆，整个序列的最大值就是堆顶的根节点。将其移动到队尾，然后继续对剩余的元素进行构造，保证剩余元素也具有大顶堆的特性。</p>
<h3 id="1、实现-3"><a href="#1、实现-3" class="headerlink" title="1、实现"></a>1、实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort0</span><span class="params">(<span class="keyword">int</span>[] source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = source.length;</span><br><span class="line">    <span class="comment">// 建堆，从中间节点开始，中间节点必有子节点</span></span><br><span class="line">    <span class="comment">// 建堆的过程先自下而上，在自上而下（递归）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapify(source, n, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 排序，最大值在堆顶（索引为0）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">        <span class="comment">// 将最大值放到末尾</span></span><br><span class="line">        swap(source, j, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 对剩余元素继续维护堆的性质</span></span><br><span class="line">        heapify(source, j, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    SortHelper.dump(source);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 维护堆的算法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> source</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n      数组长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target      待维护节点下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] source, <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// large 表示当前最大值索引</span></span><br><span class="line">    <span class="keyword">int</span> large = target;</span><br><span class="line">    <span class="keyword">int</span> leftSon = target * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> rightSon = target * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (leftSon &lt; n &amp;&amp; source[leftSon] &gt; source[large]) &#123;</span><br><span class="line">        large = leftSon;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rightSon &lt; n &amp;&amp; source[rightSon] &gt; source[large]) &#123;</span><br><span class="line">        large = rightSon;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若父节点小于左节点或者小于右节点，那么就要交换父子节点的值，</span></span><br><span class="line">    <span class="comment">// 交换完毕后，还需要对新的子节点进行维护</span></span><br><span class="line">    <span class="keyword">if</span> (large != target) &#123;</span><br><span class="line">        swap(source, target, large);</span><br><span class="line">        <span class="comment">// large 指向的是被交换子节点的索引，交换后索引位置的值发生了变化，需要重新维护有序性</span></span><br><span class="line">        heapify(source, n, large);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] source, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = source[left];</span><br><span class="line">    source[left] = source[right];</span><br><span class="line">    source[right] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、性能-3"><a href="#2、性能-3" class="headerlink" title="2、性能"></a>2、性能</h3><p>第1步，把无序数组构建成二叉堆，这一步的时间复杂度是O(n) 。<br>第2步，需要进行n-1次循环。每次循环调用一次heapify方法，所以 第2步的计算规模是 (n-1)×logn ，时间复杂度为O(nlogn) 。 两个步骤是并列关系，所以整体的时间复杂度是O(nlogn) 。</p>
<h2 id="8-6-归并排序"><a href="#8-6-归并排序" class="headerlink" title="8.6 归并排序"></a>8.6 归并排序</h2><p>如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。</p>
<p><img src="/pics/image-20200825194433665.png" alt="image-20200825194433665"></p>
<h3 id="1、递归实现"><a href="#1、递归实现" class="headerlink" title="1、递归实现"></a>1、递归实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public static void sort0(int[] source) &#123;</span><br><span class="line">    sort(source, 0, source.length - 1);</span><br><span class="line">    SortHelper.dump(source);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void sort(int[] source, int left, int right) &#123;</span><br><span class="line">    if (left &gt;= right) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int center = (left + right) / 2;</span><br><span class="line">    sort(source, left, center);</span><br><span class="line">    sort(source, center + 1, right);</span><br><span class="line">    merge(source, left, center, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void merge(int[] source, int left, int center, int right) &#123;</span><br><span class="line">    int[] tmp = new int[right - left + 1];</span><br><span class="line">    int k = 0;</span><br><span class="line">    int i = left;</span><br><span class="line">    int j = center + 1;</span><br><span class="line">    // 从小到大排，取较小值放到tmp数组里</span><br><span class="line">    while (i &lt;= center &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">        if (source[i] &lt; source[j]) &#123;</span><br><span class="line">            tmp[k++] = source[i++];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            tmp[k++] = source[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 多的元素放到末尾</span><br><span class="line">    while (i &lt;= center) &#123;</span><br><span class="line">        tmp[k++] = source[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    // 多的元素放到末尾</span><br><span class="line">    while (j &lt;= right) &#123;</span><br><span class="line">        tmp[k++] = source[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    // 将排序好的数组替换原数组相同位置</span><br><span class="line">    for (int i1 = 0; i1 &lt; tmp.length; i1++) &#123;</span><br><span class="line">        source[left + i1] = tmp[i1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、迭代实现"><a href="#2、迭代实现" class="headerlink" title="2、迭代实现"></a>2、迭代实现</h3><h3 id="3、性能"><a href="#3、性能" class="headerlink" title="3、性能"></a>3、性能</h3><p>时间复杂度是 O(nlogn)，稳定的排序算法</p>
<h2 id="8-7-快速排序"><a href="#8-7-快速排序" class="headerlink" title="8.7 快速排序"></a>8.7 快速排序</h2><p>通过一趟排序将待排记录分割成独立的两部分，其中一部分的记录的关键字均比另一个部分关键字小，则可对这两部分记录进行排序，以达到整个序列有序的目的。</p>
<h3 id="1、实现-4"><a href="#1、实现-4" class="headerlink" title="1、实现"></a>1、实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] source, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pivot = partition(source, left, right);</span><br><span class="line">    SortHelper.dump(source);</span><br><span class="line">    sort(source, left, pivot - <span class="number">1</span>);</span><br><span class="line">    sort(source, pivot + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] source, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = source[left];</span><br><span class="line">    <span class="comment">// 从两端同时向中间遍历，将较小的数放到左边，较大的数放到右边</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (source[left] &lt; pivot) &#123;</span><br><span class="line">            left ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (source[right] &gt; pivot) &#123;</span><br><span class="line">            right --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左右查找到不合规则的数据时，进行交换</span></span><br><span class="line">        swap(source,left, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当left &gt;= right时说明，左右的数均已划分好了</span></span><br><span class="line">    source[left] = pivot;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] source, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = source[left];</span><br><span class="line">    source[left] = source[right];</span><br><span class="line">    source[right] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、优化"><a href="#2、优化" class="headerlink" title="2、优化"></a>2、优化</h3><ol>
<li>选取合适的基准点</li>
<li>小数组时使用插入排序</li>
<li>尾递归优化</li>
</ol>
<h2 id="8-8-小结"><a href="#8-8-小结" class="headerlink" title="8.8 小结"></a>8.8 小结</h2><p><img src="/pics/image-20200910203208775.png" alt="image-20200910203208775"></p>
<p><img src="/pics/image-20200910203220494.png" alt="image-20200910203220494"></p>

    </div>

    
    
    
      

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>sven
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://zhaoxiaowen-sven.github.io/2021/05/14/Notes/Algorithm/ALG_01_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" title="ALG_01_数据结构和算法之美">https://zhaoxiaowen-sven.github.io/2021/05/14/Notes/Algorithm/ALG_01_数据结构和算法/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/04/21/Notes/Java/03Collections/Java%E9%9B%86%E5%90%88_07_ConcurrentHashMap_JDK7/" rel="prev" title="Java集合_07_ConcurrentHashMap_JDK7">
      <i class="fa fa-chevron-left"></i> Java集合_07_ConcurrentHashMap_JDK7
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/05/14/Notes/Algorithm/ALG_06_%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" rel="next" title="ALG_06_贪心算法">
      ALG_06_贪心算法 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#ALG-01-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E"><span class="nav-text">ALG_01_数据结构和算法之美</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%85%A5%E9%97%A8"><span class="nav-text">一、入门</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95"><span class="nav-text">1.1 核心数据结构和算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="nav-text">1.2 复杂度分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-text">1、时间复杂度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90"><span class="nav-text">2、几种常见时间复杂度实例分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-O-1"><span class="nav-text">1. O(1)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-O-logn-%E3%80%81O-nlogn"><span class="nav-text">2. O(logn)、O(nlogn)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-O-m-n-%E3%80%81O-m-n"><span class="nav-text">3. O(m+n)、O(m*n)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="nav-text">3、空间复杂度分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%9C%80%E5%A5%BD%E3%80%81%E6%9C%80%E5%9D%8F%E3%80%81%E5%B9%B3%E5%9D%87%E3%80%81%E5%9D%87%E6%91%8A%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-text">4.最好、最坏、平均、均摊时间复杂度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%9C%80%E5%A5%BD%E3%80%81%E6%9C%80%E5%9D%8F%E6%83%85%E5%86%B5%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-text">1.最好、最坏情况时间复杂度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%B9%B3%E5%9D%87%E6%83%85%E5%86%B5%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-amp-%E6%9C%9F%E6%9C%9B%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-text">2. 平均情况时间复杂度 &amp;  期望时间复杂度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%9D%87%E6%91%8A%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-text">3. 均摊时间复杂度</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="nav-text">二、线性表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E6%95%B0%E7%BB%84"><span class="nav-text">2.1 数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="nav-text">1、插入和删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%AE%B9%E5%99%A8vs%E6%95%B0%E7%BB%84"><span class="nav-text">2、容器vs数组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E9%93%BE%E8%A1%A8"><span class="nav-text">2.2 链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%B1%BB%E5%9E%8B"><span class="nav-text">1、类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="nav-text">2、插入和删除</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="nav-text">单链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="nav-text">双向链表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E5%A4%B4%E7%BB%93%E7%82%B9vs%E5%A4%B4%E6%8C%87%E9%92%88"><span class="nav-text">3、头结点vs头指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E9%93%BE%E8%A1%A8vs%E6%95%B0%E7%BB%84%E6%80%A7%E8%83%BD"><span class="nav-text">4、链表vs数组性能</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97"><span class="nav-text">三、栈与队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E6%A0%88"><span class="nav-text">3.1  栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E9%80%92%E5%BD%92"><span class="nav-text">1、递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97"><span class="nav-text">2、四则运算</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E9%98%9F%E5%88%97"><span class="nav-text">3.2 队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97"><span class="nav-text">1、顺序队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="nav-text">2、循环队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97"><span class="nav-text">3、链式队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%85%A5%E9%98%9F"><span class="nav-text">1、入队</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%87%BA%E9%98%9F"><span class="nav-text">2、出队</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E4%B8%B2"><span class="nav-text">四、串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E6%9C%B4%E7%B4%A0%E6%A8%A1%E5%BC%8F"><span class="nav-text">1、朴素模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%8E%9F%E7%90%86"><span class="nav-text">1、原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%AE%9E%E7%8E%B0"><span class="nav-text">2、实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81KMP%E5%8C%B9%E9%85%8D-%E5%86%8D%E7%90%86%E8%A7%A3%E4%B8%80%E4%B8%8B"><span class="nav-text">2、KMP匹配(再理解一下)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%8E%9F%E7%90%86-1"><span class="nav-text">1、原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E9%83%A8%E5%88%86%E5%8C%B9%E9%85%8D%E8%A1%A8%EF%BC%88pmt%EF%BC%89-amp-next%E6%95%B0%E7%BB%84"><span class="nav-text">2、部分匹配表（pmt） &amp; next数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81next%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">3、next数组实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81next%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96"><span class="nav-text">4、next数组优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81KMP%E5%AE%9E%E7%8E%B0"><span class="nav-text">5、KMP实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81%E6%80%A7%E8%83%BD"><span class="nav-text">6、性能</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81BM%E7%AE%97%E6%B3%95"><span class="nav-text">3、BM算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E6%A0%91"><span class="nav-text">五、树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">5.1 树的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%BA%A6"><span class="nav-text">1、度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E6%B7%B1%E5%BA%A6%E5%92%8C%E5%B1%82%E6%AC%A1"><span class="nav-text">2、深度和层次</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">5.2 二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-text">1、二叉树的类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">1、满二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">2、完全二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E6%96%9C%E6%A0%91"><span class="nav-text">3、斜树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="nav-text">2、二叉树的性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8"><span class="nav-text">3、二叉树的存储</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="nav-text">1、链式存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="nav-text">2、顺序存储</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-text">4、二叉树的遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E9%81%8D%E5%8E%86%E9%A1%BA%E5%BA%8F%E5%A4%8D%E5%8E%9F%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">5、遍历顺序复原二叉树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-text">5.3 树、森林与二叉树的转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">1、树转换为二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E6%A3%AE%E6%9E%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">2、森林转换为二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%A0%91"><span class="nav-text">3、二叉树转换为树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%A3%AE%E6%9E%97"><span class="nav-text">4、二叉树转化为森林</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-5-%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="nav-text">5.5 赫夫曼树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0"><span class="nav-text">1、哈夫曼树的构造</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="nav-text">2、哈夫曼编码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E5%9B%BE"><span class="nav-text">六、图</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-%E5%9B%BE"><span class="nav-text">6.1 图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%AE%9A%E4%B9%89"><span class="nav-text">1、定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E6%97%A0%E5%90%91%E5%9B%BE%E5%92%8C%E6%9C%89%E5%90%91%E5%9B%BE"><span class="nav-text">1、无向图和有向图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E7%BD%91"><span class="nav-text">2、网</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E7%8E%AF"><span class="nav-text">3、环</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">2、存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="nav-text">1、邻接矩阵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="nav-text">2、邻接表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E3%80%81%E9%81%8D%E5%8E%86"><span class="nav-text">3 、遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86DFS"><span class="nav-text">1、深度优先遍历DFS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86BFS"><span class="nav-text">2、广度优先遍历BFS</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-text">6.2 最小生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81Prim%E7%AE%97%E6%B3%95"><span class="nav-text">1、Prim算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81Kruskal-%E7%AE%97%E6%B3%95"><span class="nav-text">2、Kruskal 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E5%AF%B9%E6%AF%94"><span class="nav-text">3、对比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-text">6.3 最短路径</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81Dijkstra%E7%AE%97%E6%B3%95"><span class="nav-text">1、Dijkstra算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81Floyd%E7%AE%97%E6%B3%95"><span class="nav-text">2、Floyd算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E6%AF%94%E8%BE%83"><span class="nav-text">3、比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4-%E6%8B%93%E8%A1%A5%E6%8E%92%E5%BA%8F%EF%BC%88%E7%AE%97%E6%B3%95%E5%BE%85%E8%A1%A5%E5%85%85%EF%BC%89"><span class="nav-text">6.4 拓补排序（算法待补充）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E6%8B%93%E8%A1%A5%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-text">1、拓补排序算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="nav-text">2、关键路径</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%9C%80%E6%97%A9-%E6%9C%80%E6%99%9A%E5%8F%91%E7%94%9F%E6%97%B6%E9%97%B4"><span class="nav-text">1、事件的最早&#x2F;最晚发生时间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E6%B4%BB%E5%8A%A8%E7%9A%84%E6%9C%80%E6%97%A9%E3%80%81%E6%9C%80%E6%99%9A%E5%BC%80%E5%A7%8B%E6%97%B6%E9%97%B4"><span class="nav-text">2、活动的最早、最晚开始时间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81ete-lte%E4%B8%BA%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="nav-text">3、ete &#x3D;&#x3D; lte为关键路径</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E6%9F%A5%E6%89%BE"><span class="nav-text">七、查找</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-%E6%9C%89%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="nav-text">7.1 有序表的查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-text">1、二分查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE"><span class="nav-text">2、插值查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE"><span class="nav-text">3、斐波那契查找</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-%E7%BA%BF%E6%80%A7%E7%B4%A2%E5%BC%95%E6%9F%A5%E8%AF%A2"><span class="nav-text">7.2 线性索引查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91"><span class="nav-text">7.3 二叉排序树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E6%9F%A5%E6%89%BE"><span class="nav-text">1、查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E6%8F%92%E5%85%A5"><span class="nav-text">2、插入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E5%88%A0%E9%99%A4"><span class="nav-text">3、删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E5%AE%9E%E7%8E%B0"><span class="nav-text">4、实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E6%95%88%E7%8E%87"><span class="nav-text">5、效率</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-4-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88AVL%E6%A0%91%EF%BC%89"><span class="nav-text">7.4 平衡二叉树（AVL树）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%A4%B1%E8%A1%A1%E8%B0%83%E6%95%B4"><span class="nav-text">1、失衡调整</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%AE%9E%E7%8E%B0-1"><span class="nav-text">2、实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-5-%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-text">7.5 红黑树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E8%B0%83%E6%95%B4%EF%BC%9A"><span class="nav-text">1、红黑树的调整：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-6-B%E6%A0%91%E5%92%8CB-%E6%A0%91"><span class="nav-text">7.6 B树和B+树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="nav-text">1、多路查找树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81B%E6%A0%91"><span class="nav-text">2、B树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81B-%E6%A0%91"><span class="nav-text">3、B+树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-7-%E6%95%A3%E5%88%97%E8%A1%A8"><span class="nav-text">7.7 散列表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0"><span class="nav-text">1、散列函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E7%9B%B4%E6%8E%A5%E5%AE%9A%E5%9D%80%E6%B3%95"><span class="nav-text">1、直接定址法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E9%99%A4%E7%95%99%E4%BD%99%E6%95%B0%E6%B3%95"><span class="nav-text">2、除留余数法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E6%95%A3%E5%88%97%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86"><span class="nav-text">2、散列冲突处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81-%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95"><span class="nav-text">1、 线性探测法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E4%BA%8C%E6%AC%A1%E6%8E%A2%E6%B5%8B%E6%B3%95-%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%B3%95"><span class="nav-text">2、二次探测法 +随机数法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95"><span class="nav-text">3、链地址法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E5%AE%9E%E7%8E%B0"><span class="nav-text">3、实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AB%E3%80%81%E6%8E%92%E5%BA%8F"><span class="nav-text">八、排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-text">8.1 冒泡排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%86%92%E6%B3%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0"><span class="nav-text">1、冒泡的三种实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="nav-text">2、性能分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-text">8.2 选择排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%AE%9E%E7%8E%B0"><span class="nav-text">1、实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E6%80%A7%E8%83%BD"><span class="nav-text">2、性能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-3-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-text">8.3 插入排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%AE%9E%E7%8E%B0-1"><span class="nav-text">1、实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E6%80%A7%E8%83%BD-1"><span class="nav-text">2、性能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-4-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="nav-text">8.4 希尔排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%AE%9E%E7%8E%B0-2"><span class="nav-text">1、实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E6%80%A7%E8%83%BD-2"><span class="nav-text">2、性能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-5-%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-text">8.5 堆排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%AE%9E%E7%8E%B0-3"><span class="nav-text">1、实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E6%80%A7%E8%83%BD-3"><span class="nav-text">2、性能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-6-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-text">8.6 归并排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0"><span class="nav-text">1、递归实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E8%BF%AD%E4%BB%A3%E5%AE%9E%E7%8E%B0"><span class="nav-text">2、迭代实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E6%80%A7%E8%83%BD"><span class="nav-text">3、性能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-7-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-text">8.7 快速排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%AE%9E%E7%8E%B0-4"><span class="nav-text">1、实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E4%BC%98%E5%8C%96"><span class="nav-text">2、优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-8-%E5%B0%8F%E7%BB%93"><span class="nav-text">8.8 小结</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="sven"
      src="/images/sven.jpeg">
  <p class="site-author-name" itemprop="name">sven</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">78</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhaoxiaowen-sven" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhaoxiaowen-sven" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhaoxiaowen-sven@gmail.com" title="E-Mail → mailto:zhaoxiaowen-sven@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sven</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
