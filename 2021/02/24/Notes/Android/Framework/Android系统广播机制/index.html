<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="http:&#x2F;&#x2F;gityuan.com&#x2F;2016&#x2F;06&#x2F;04&#x2F;broadcast-receiver&#x2F;https:&#x2F;&#x2F;rawgit.com&#x2F;prife&#x2F;VirtualAppDoc&#x2F;master&#x2F;pngs&#x2F;Broadcast.svg 一、概述广播(Broadcast)机制用于进程&#x2F;线程间通信，广播分为广播发送和广播接收两个过程，其中广播接收者BroadcastReceiver便是Android四大组件之">
<meta property="og:type" content="article">
<meta property="og:title" content="Sven&#39;s blog">
<meta property="og:url" content="http://example.com/2021/02/24/Notes/Android/Framework/Android%E7%B3%BB%E7%BB%9F%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6/index.html">
<meta property="og:site_name" content="Sven&#39;s blog">
<meta property="og:description" content="http:&#x2F;&#x2F;gityuan.com&#x2F;2016&#x2F;06&#x2F;04&#x2F;broadcast-receiver&#x2F;https:&#x2F;&#x2F;rawgit.com&#x2F;prife&#x2F;VirtualAppDoc&#x2F;master&#x2F;pngs&#x2F;Broadcast.svg 一、概述广播(Broadcast)机制用于进程&#x2F;线程间通信，广播分为广播发送和广播接收两个过程，其中广播接收者BroadcastReceiver便是Android四大组件之">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-02-24T15:08:49.506Z">
<meta property="article:modified_time" content="2021-02-24T15:08:49.507Z">
<meta property="article:author" content="sven">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2021/02/24/Notes/Android/Framework/Android%E7%B3%BB%E7%BB%9F%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title> | Sven's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
      <a target="_blank" rel="noopener" href="https://github.com/zhaoxiaowen-sven" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Sven's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/24/Notes/Android/Framework/Android%E7%B3%BB%E7%BB%9F%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sven.jpeg">
      <meta itemprop="name" content="sven">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sven's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-24 23:08:49" itemprop="dateCreated datePublished" datetime="2021-02-24T23:08:49+08:00">2021-02-24</time>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><a target="_blank" rel="noopener" href="http://参考博客/">http://gityuan.com/2016/06/04/broadcast-receiver/</a><br><a target="_blank" rel="noopener" href="http://流程图/">https://rawgit.com/prife/VirtualAppDoc/master/pngs/Broadcast.svg</a></p>
<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>广播(Broadcast)机制用于进程/线程间通信，广播分为广播发送和广播接收两个过程，其中广播接收者BroadcastReceiver便是Android四大组件之一。</p>
<p>BroadcastReceiver分为两类：</p>
<pre><code>静态广播接收者：通过AndroidManifest.xml的标签来申明的BroadcastReceiver。
动态广播接收者：通过AMS.registerReceiver()方式注册的BroadcastReceiver，动态注册更为灵活，可在不需要时通过unregisterReceiver()取消注册。
</code></pre>
<p>从广播发送方式可分为三类：</p>
<pre><code>普通广播：通过Context.sendBroadcast()发送，可并行处理
有序广播：通过Context.sendOrderedBroadcast()发送，串行处理
Sticky广播：通过Context.sendStickyBroadcast()发送
</code></pre>
<h1 id="二、广播的注册过程"><a href="#二、广播的注册过程" class="headerlink" title="二、广播的注册过程"></a>二、广播的注册过程</h1><h1 id="2-1-registerReceiver-BroadcastReceiver-receiver-IntentFilter-filter"><a href="#2-1-registerReceiver-BroadcastReceiver-receiver-IntentFilter-filter" class="headerlink" title="2.1 registerReceiver(BroadcastReceiver receiver, IntentFilter filter)"></a>2.1 registerReceiver(BroadcastReceiver receiver, IntentFilter filter)</h1><h1 id="2-2-ContextWrapper-registerReceiver-receiver-filter"><a href="#2-2-ContextWrapper-registerReceiver-receiver-filter" class="headerlink" title="2.2 ContextWrapper.registerReceiver(receiver,filter)"></a>2.2 ContextWrapper.registerReceiver(receiver,filter)</h1><h1 id="2-3-ContextImpl-registerReceiver-receiver-filter"><a href="#2-3-ContextImpl-registerReceiver-receiver-filter" class="headerlink" title="2.3 ContextImpl.registerReceiver(receiver,filter)"></a>2.3 ContextImpl.registerReceiver(receiver,filter)</h1><pre><code>public Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter,
        String broadcastPermission, Handler scheduler) &#123;
    return registerReceiverInternal(receiver, getUserId(),
            filter, broadcastPermission, scheduler, getOuterContext());
&#125;

private Intent registerReceiverInternal(BroadcastReceiver receiver, int userId,
        IntentFilter filter, String broadcastPermission,
        Handler scheduler, Context context) &#123;
    //rd 的类型是LoadApk.ReceiverDispatcher.InnerReceiver的一个对象
    IIntentReceiver rd = null;
    if (receiver != null) &#123;
        if (mPackageInfo != null &amp;&amp; context != null) &#123;
            if (scheduler == null) &#123;
                scheduler = mMainThread.getHandler();
            &#125;
            rd = mPackageInfo.getReceiverDispatcher(
                receiver, context, scheduler,
                mMainThread.getInstrumentation(), true);
        &#125; else &#123;
            if (scheduler == null) &#123;
                scheduler = mMainThread.getHandler();
            &#125;
            rd = new LoadedApk.ReceiverDispatcher(
                    receiver, context, scheduler, null, true).getIIntentReceiver();
        &#125;
    &#125;
    try &#123;
        //调用到AMS的registerReceiver方法
        return ActivityManagerNative.getDefault().registerReceiver(
                mMainThread.getApplicationThread(), mBasePackageName,
                rd, filter, broadcastPermission, userId);
    &#125; catch (RemoteException e) &#123;
        return null;
    &#125;
&#125;
</code></pre>
<h1 id="step1：-rd-的创建过程"><a href="#step1：-rd-的创建过程" class="headerlink" title="step1： rd 的创建过程"></a>step1： rd 的创建过程</h1><p>ReceiverDispatcher(广播分发者)有一个内部类InnerReceiver，该类继承于IIntentReceiver.Stub。显然，这是一个Binder服务端，广播分发者通过rd.getIIntentReceiver()可获取该Binder服务端对象InnerReceiver，用于Binder IPC通信。</p>
<pre><code>frameworks/base/core/java/android/app/LoadedApk.java

static final class ReceiverDispatcher &#123;

    final static class InnerReceiver extends IIntentReceiver.Stub &#123;
        final WeakReference&lt;LoadedApk.ReceiverDispatcher&gt; mDispatcher;
        final LoadedApk.ReceiverDispatcher mStrongRef;

        InnerReceiver(LoadedApk.ReceiverDispatcher rd, boolean strong) &#123;
            mDispatcher = new WeakReference&lt;LoadedApk.ReceiverDispatcher&gt;(rd);
            mStrongRef = strong ? rd : null;
        &#125;
       ...
    &#125;

    final IIntentReceiver.Stub mIIntentReceiver;
    final BroadcastReceiver mReceiver;
    ...

     ReceiverDispatcher(BroadcastReceiver receiver, Context context,
            Handler activityThread, Instrumentation instrumentation,
            boolean registered) &#123;
        if (activityThread == null) &#123;
            throw new NullPointerException(&quot;Handler must not be null&quot;);
        &#125;

        mIIntentReceiver = new InnerReceiver(this, !registered);
        mReceiver = receiver;
        mContext = context;
        mActivityThread = activityThread;
        mInstrumentation = instrumentation;
        mRegistered = registered;
        mLocation = new IntentReceiverLeaked(null);
        mLocation.fillInStackTrace();
    &#125;
    ...
    IIntentReceiver getIIntentReceiver() &#123;
        return mIIntentReceiver;
    &#125;
</code></pre>
<h1 id="2-4-在AMS中注册"><a href="#2-4-在AMS中注册" class="headerlink" title="2.4 在AMS中注册"></a>2.4 在AMS中注册</h1><p>其中mRegisteredReceivers记录着所有已注册的广播，以receiver IBinder为key, ReceiverList为value为HashMap。另外，这个过程涉及对象ReceiverList，BroadcastFilter，BroadcastRecord的创建。</p>
<p>在BroadcastQueue中有两个广播队列mParallelBroadcasts,mOrderedBroadcasts，数据类型都为ArrayList：</p>
<pre><code>mParallelBroadcasts:并行广播队列，可以立刻执行，而无需等待另一个广播运行完成，该队列只允许动态已注册的广播，从而避免发生同时拉起大量进程来执行广播，前台的和后台的广播分别位于独立的队列。
mOrderedBroadcasts：有序广播队列，同一时间只允许执行一个广播，该队列顶部的广播便是活动广播，其他广播必须等待该广播结束才能运行，也是独立区别前台的和后台的广播。

public Intent registerReceiver(IApplicationThread caller, String callerPackage,
            IIntentReceiver receiver, IntentFilter filter, String permission, int userId) &#123;
        synchronized (this) &#123;
            if (callerApp != null &amp;&amp; (callerApp.thread == null
                    || callerApp.thread.asBinder() != caller.asBinder())) &#123;
                return null;
            &#125;
            //ReceiverList rl保存了相同InnerReceiver注册的广播接收者BroadcastFilter
            //mRegisteredReceivers的 final HashMap&lt;IBinder, ReceiverList&gt; mRegisteredReceivers
            //通过不同的InnerReceiver来区分不同的广播
            ReceiverList rl = mRegisteredReceivers.get(receiver.asBinder());
            if (rl == null) &#123;
                rl = new ReceiverList(this, callerApp, callingPid, callingUid,
                        userId, receiver);
                if (rl.app != null) &#123;
                    rl.app.receivers.add(rl);
                &#125; else &#123;
                    try &#123;
                        receiver.asBinder().linkToDeath(rl, 0);
                    &#125; catch (RemoteException e) &#123;
                        return sticky;
                    &#125;
                    rl.linkedToDeath = true;
                &#125;
                mRegisteredReceivers.put(receiver.asBinder(), rl);
            &#125; 
            //描述正在注册的广播接收者
            BroadcastFilter bf = new BroadcastFilter(filter, rl, callerPackage,
                    permission, callingUid, userId);
            //将注册的广播接收者BroadcastFilter 加入到ReceiverList中
            rl.add(bf);
            if (!bf.debugCheck()) &#123;
                Slog.w(TAG, &quot;==&gt; For Dynamic broadcast&quot;);
            &#125;
            //将广播接收者保存到内部的类成员变量mReceiverResolver中，所以BroadcastReceiver和InnerReceiver是成对存在的
            //final IntentResolver&lt;BroadcastFilter, BroadcastFilter&gt; mReceiverResolver
            mReceiverResolver.addFilter(bf);

            if (allSticky != null) &#123;
                ArrayList receivers = new ArrayList();
                receivers.add(bf);

                final int stickyCount = allSticky.size();
                for (int i = 0; i &lt; stickyCount; i++) &#123;
                    Intent intent = allSticky.get(i);
                    BroadcastQueue queue = broadcastQueueForIntent(intent);
                    BroadcastRecord r = new BroadcastRecord(queue, intent, null,
                            null, -1, -1, null, null, AppOpsManager.OP_NONE, null, receivers,
                            null, 0, null, null, false, true, true, -1);
                    queue.enqueueParallelBroadcastLocked(r);
                    queue.scheduleBroadcastsLocked();
                &#125;
            &#125;

            return sticky;
        &#125;
    &#125;
</code></pre>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>注册广播的过程，主要功能：<br>创建ReceiverList(接收者队列)，并添加到AMS.mRegisteredReceivers(已注册广播队列)；<br>创建BroadcastFilter(广播过滤者)，并添加到AMS.mReceiverResolver(接收者的解析人)；<br>当注册的是Sticky广播，则创建BroadcastRecord，并添加到BroadcastQueue的mParallelBroadcasts(并行广播队列)，注册后调用AMS来尽快处理该广播。</p>
<p>三、广播的发送过程</p>
<h1 id="3-1-sendBroadcast-intent"><a href="#3-1-sendBroadcast-intent" class="headerlink" title="3.1 sendBroadcast(intent)"></a>3.1 sendBroadcast(intent)</h1><h1 id="3-2-ContextWrapper-sendBroadcast-intent"><a href="#3-2-ContextWrapper-sendBroadcast-intent" class="headerlink" title="3.2 ContextWrapper.sendBroadcast(intent)"></a>3.2 ContextWrapper.sendBroadcast(intent)</h1><pre><code>frameworks/base/core/java/android/content/ContextWrapper.java

public void sendBroadcast(Intent intent) &#123;
        mBase.sendBroadcast(intent);
&#125;
</code></pre>
<h1 id="3-3-ContextImpl-sendBroadcast"><a href="#3-3-ContextImpl-sendBroadcast" class="headerlink" title="3.3 ContextImpl.sendBroadcast"></a>3.3 ContextImpl.sendBroadcast</h1><pre><code>frameworks/base/core/java/android/app/ContextImpl.java

public void sendBroadcast(Intent intent) &#123;
        warnIfCallingFromSystemProcess();
        String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
        try &#123;
            intent.prepareToLeaveProcess();
            ActivityManagerNative.getDefault().broadcastIntent(
                    mMainThread.getApplicationThread(), intent, resolvedType, null,
                    Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false,
                    getUserId());
        &#125; catch (RemoteException e) &#123;
            throw new RuntimeException(&quot;Failure from system&quot;, e);
        &#125;
    &#125;
</code></pre>
<h1 id="3-4-ActivityManagerProxy-broadcastIntent"><a href="#3-4-ActivityManagerProxy-broadcastIntent" class="headerlink" title="3.4 ActivityManagerProxy.broadcastIntent"></a>3.4 ActivityManagerProxy.broadcastIntent</h1><pre><code>frameworks/base/core/java/android/app/ActivityManagerNative.java

    public int broadcastIntent(IApplicationThread caller,
        Intent intent, String resolvedType, IIntentReceiver resultTo,
        int resultCode, String resultData, Bundle map,
        String[] requiredPermissions, int appOp, Bundle options, boolean serialized,
        boolean sticky, int userId) throws RemoteException
&#123;
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IActivityManager.descriptor);
    data.writeStrongBinder(caller != null ? caller.asBinder() : null);
    intent.writeToParcel(data, 0);
    data.writeString(resolvedType);
    data.writeStrongBinder(resultTo != null ? resultTo.asBinder() : null);
    data.writeInt(resultCode);
    data.writeString(resultData);
    data.writeBundle(map);
    data.writeStringArray(requiredPermissions);
    data.writeInt(appOp);
    data.writeBundle(options);
    data.writeInt(serialized ? 1 : 0);
    data.writeInt(sticky ? 1 : 0);
    data.writeInt(userId);
    mRemote.transact(BROADCAST_INTENT_TRANSACTION, data, reply, 0);
    reply.readException();
    int res = reply.readInt();
    reply.recycle();
    data.recycle();
    return res;
&#125;
</code></pre>
<h1 id="3-5-ActivityManagerService-broadcastIntent"><a href="#3-5-ActivityManagerService-broadcastIntent" class="headerlink" title="3.5 ActivityManagerService.broadcastIntent"></a>3.5 ActivityManagerService.broadcastIntent</h1><pre><code>frameworks/base/services/java/com/android/server/am/ActivityManagerService.java

public final int broadcastIntent(IApplicationThread caller,
        Intent intent, String resolvedType, IIntentReceiver resultTo,
        int resultCode, String resultData, Bundle resultExtras,
        String[] requiredPermissions, int appOp, Bundle options,
        boolean serialized, boolean sticky, int userId) &#123;
    enforceNotIsolatedCaller(&quot;broadcastIntent&quot;);
    synchronized(this) &#123;
        intent = verifyBroadcastLocked(intent);

        final ProcessRecord callerApp = getRecordForAppLocked(caller);
        final int callingPid = Binder.getCallingPid();
        final int callingUid = Binder.getCallingUid();
        final long origId = Binder.clearCallingIdentity();
        int res = broadcastIntentLocked(callerApp,
                callerApp != null ? callerApp.info.packageName : null,
                intent, resolvedType, resultTo, resultCode, resultData, resultExtras,
                requiredPermissions, appOp, null, serialized, sticky,
                callingPid, callingUid, userId);
        Binder.restoreCallingIdentity(origId);
        return res;
    &#125;
</code></pre>
<h1 id="3-6-ActivityManagerService-broadcastIntentLocked-分解为8个步骤解析"><a href="#3-6-ActivityManagerService-broadcastIntentLocked-分解为8个步骤解析" class="headerlink" title="3.6 ActivityManagerService.broadcastIntentLocked 分解为8个步骤解析"></a>3.6 ActivityManagerService.broadcastIntentLocked 分解为8个步骤解析</h1><h1 id="step1-设置广播flag"><a href="#step1-设置广播flag" class="headerlink" title="step1: 设置广播flag"></a>step1: 设置广播flag</h1><pre><code>添加flag=FLAG_EXCLUDE_STOPPED_PACKAGES，保证已停止app不会收到该广播；
当系统还没有启动完成，则不允许启动新进程，，即只有动态注册receiver才能接受广播
当非USER_ALL广播且当前用户并没有处于Running的情况下，除非是系统升级广播或者关机广播，否则直接返回。

BroadcastReceiver还有其他flag，位于Intent.java常量:
    FLAG_RECEIVER_REGISTERED_ONLY //只允许已注册receiver接收广播
    FLAG_RECEIVER_REPLACE_PENDING //新广播会替代相同广播
    FLAG_RECEIVER_FOREGROUND //只允许前台receiver接收广播
    FLAG_RECEIVER_NO_ABORT //对于有序广播，先接收到的receiver无权抛弃广播
    FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT //Boot完成之前，只允许已注册receiver接收广播
    FLAG_RECEIVER_BOOT_UPGRADE //升级模式下，允许系统准备就绪前可以发送广播

private final int broadcastIntentLocked(ProcessRecord callerApp,
        String callerPackage, Intent intent, String resolvedType,
        IIntentReceiver resultTo, int resultCode, String resultData,
        Bundle resultExtras, String[] requiredPermissions, int appOp, Bundle options,
        boolean ordered, boolean sticky, int callingPid, int callingUid, int userId) &#123;
    intent = new Intent(intent);

    // By default broadcasts do not go to stopped apps.
    intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
    
    // If we have not finished booting, don&#39;t allow this to launch new processes.
    if (!mProcessesReady &amp;&amp; (intent.getFlags()&amp;Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) &#123;
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
    &#125;
    
     // Make sure that the user who is receiving this broadcast is running.
    // If not, we will just skip it. Make an exception for shutdown broadcasts
    // and upgrade steps.

    if (userId != UserHandle.USER_ALL &amp;&amp; !isUserRunningLocked(userId, false)) &#123;
        if ((callingUid != Process.SYSTEM_UID
                || (intent.getFlags() &amp; Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0)
                &amp;&amp; !Intent.ACTION_SHUTDOWN.equals(intent.getAction())) &#123;
            Slog.w(TAG, &quot;Skipping broadcast of &quot; + intent
                    + &quot;: user &quot; + userId + &quot; is stopped&quot;);
            return ActivityManager.BROADCAST_FAILED_USER_STOPPED;
        &#125;
    &#125;
</code></pre>
<h1 id="step2-广播权限验证"><a href="#step2-广播权限验证" class="headerlink" title="step2: 广播权限验证"></a>step2: 广播权限验证</h1><p>对于callingAppId为SYSTEM_UID，PHONE_UID，SHELL_UID，BLUETOOTH_UID，NFC_UID之一或者callingUid == 0时都畅通无阻；<br>否则对于调用者进程为空并且不是persistent进程的情况下：<br>    1.当发送的是受保护广播mProtectedBroadcasts(只允许系统使用)，则抛出异常；<br>    2.当action为ACTION_APPWIDGET_CONFIGURE时，虽然不希望该应用发送这种广播，处于兼容性考虑，限制该广播只允许发送给自己，否则抛出异常。</p>
<pre><code>/*
     * Prevent non-system code (defined here to be non-persistent
     * processes) from sending protected broadcasts.
     */
    int callingAppId = UserHandle.getAppId(callingUid);
    if (callingAppId == Process.SYSTEM_UID || callingAppId == Process.PHONE_UID
        || callingAppId == Process.SHELL_UID || callingAppId == Process.BLUETOOTH_UID
        || callingAppId == Process.NFC_UID || callingUid == 0) &#123;
        // Always okay.
    &#125; else if (callerApp == null || !callerApp.persistent) &#123;
        try &#123;
            if (AppGlobals.getPackageManager().isProtectedBroadcast(
                    intent.getAction())) &#123;
                String msg = &quot;Permission Denial: not allowed to send broadcast &quot;
                        + intent.getAction() + &quot; from pid=&quot;
                        + callingPid + &quot;, uid=&quot; + callingUid;
                Slog.w(TAG, msg);
                throw new SecurityException(msg);
            &#125; else if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(intent.getAction())) &#123;
                // Special case for compatibility: we don&#39;t want apps to send this,
                // but historically it has not been protected and apps may be using it
                // to poke their own app widget.  So, instead of making it protected,
                // just limit it to the caller.
                if (callerApp == null) &#123;
                    String msg = &quot;Permission Denial: not allowed to send broadcast &quot;
                            + intent.getAction() + &quot; from unknown caller.&quot;;
                    Slog.w(TAG, msg);
                    throw new SecurityException(msg);
                &#125; else if (intent.getComponent() != null) &#123;
                    // They are good enough to send to an explicit component...  verify
                    // it is being sent to the calling app.
                    if (!intent.getComponent().getPackageName().equals(
                            callerApp.info.packageName)) &#123;
                        String msg = &quot;Permission Denial: not allowed to send broadcast &quot;
                                + intent.getAction() + &quot; to &quot;
                                + intent.getComponent().getPackageName() + &quot; from &quot;
                                + callerApp.info.packageName;
                        Slog.w(TAG, msg);
                        throw new SecurityException(msg);
                    &#125;
                &#125; else &#123;
                    // Limit broadcast to their own package.
                    intent.setPackage(callerApp.info.packageName);
                &#125;
            &#125;
        &#125; catch (RemoteException e) &#123;
            Slog.w(TAG, &quot;Remote exception&quot;, e);
            return ActivityManager.BROADCAST_SUCCESS;
        &#125;
    &#125;
</code></pre>
<h1 id="step3-处理系统相关广播"><a href="#step3-处理系统相关广播" class="headerlink" title="step3: 处理系统相关广播"></a>step3: 处理系统相关广播</h1><pre><code>这个过程代码较长，主要处于系统相关的广播，如下10个case：
case Intent.ACTION_UID_REMOVED: //uid移除
case Intent.ACTION_PACKAGE_REMOVED: //package移除，
case Intent.ACTION_PACKAGE_CHANGED: //package改变
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE: //外部设备不可用时，强制停止所有波及的应用并清空cache数据
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE: //外部设备可用
case Intent.ACTION_PACKAGE_ADDED: //增加package，处于兼容考虑

case Intent.ACTION_TIMEZONE_CHANGED: //时区改变，通知所有运行中的进程
case Intent.ACTION_TIME_CHANGED: //时间改变，通知所有运行中的进程
case Intent.ACTION_CLEAR_DNS_CACHE: //dns缓存清空
case Proxy.PROXY_CHANGE_ACTION: //网络代理改变

final String action = intent.getAction();
if (action != null) &#123;
    switch (action) &#123;
        case Intent.ACTION_UID_REMOVED:
            mBatteryStatsService.removeUid(uid);
            mAppOpsService.uidRemoved(uid);
            break;
        case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
            String list[] = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
            if (list != null &amp;&amp; list.length &gt; 0) &#123;
                for (int i = 0; i &lt; list.length; i++) &#123;
                    forceStopPackageLocked(list[i], -1, false, true, true,
                            false, false, userId, &quot;storage unmount&quot;);
                &#125;
                mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
                sendPackageBroadcastLocked(
                    IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE, list,userId);
            &#125;
            break;
        case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE
            mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
            break;
        case Intent.ACTION_PACKAGE_REMOVED:
        case Intent.ACTION_PACKAGE_CHANGED:
            Uri data = intent.getData();
            boolean removed = Intent.ACTION_PACKAGE_REMOVED.equals(action);
            boolean fullUninstall = removed &amp;&amp; !intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
            final boolean killProcess = !intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP, false);
            if (killProcess) &#123;
                forceStopPackageLocked(ssp, UserHandle.getAppId(
                        intent.getIntExtra(Intent.EXTRA_UID, -1)),
                        false, true, true, false, fullUninstall, userId,
                        removed ? &quot;pkg removed&quot; : &quot;pkg changed&quot;);
            &#125;
            if (removed) &#123;
                sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REMOVED,new String[] &#123;ssp&#125;, userId);
                if (fullUninstall) &#123;
                    mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID, -1), ssp);
                    removeUriPermissionsForPackageLocked(ssp, userId, true);
                    removeTasksByPackageNameLocked(ssp, userId);
                    mBatteryStatsService.notePackageUninstalled(ssp);
                &#125;
            &#125; else &#123;
                cleanupDisabledPackageComponentsLocked(ssp, userId, killProcess,
                        intent.getStringArrayExtra(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST));
            &#125;
            break;

        case Intent.ACTION_PACKAGE_ADDED:
            Uri data = intent.getData();
            final boolean replacing =intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
            mCompatModePackages.handlePackageAddedLocked(ssp, replacing);
            ApplicationInfo ai = AppGlobals.getPackageManager().getApplicationInfo(ssp, 0, 0);
            break;
        case Intent.ACTION_TIMEZONE_CHANGED:
            mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
            break;
        case Intent.ACTION_TIME_CHANGED:
            final int is24Hour = intent.getBooleanExtra(Intent.EXTRA_TIME_PREF_24_HOUR_FORMAT, false) ? 1: 0;
            mHandler.sendMessage(mHandler.obtainMessage(UPDATE_TIME, is24Hour, 0));
            BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();
            synchronized (stats) &#123;
                stats.noteCurrentTimeChangedLocked();
            &#125;
            break;
        case Intent.ACTION_CLEAR_DNS_CACHE:
            mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
            break;
        case Proxy.PROXY_CHANGE_ACTION:
            ProxyInfo proxy = intent.getParcelableExtra(Proxy.EXTRA_PROXY_INFO);
            mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG, proxy));
            break;
    &#125;
&#125;
</code></pre>
<h1 id="step4：增加sticky广播"><a href="#step4：增加sticky广播" class="headerlink" title="step4：增加sticky广播"></a>step4：增加sticky广播</h1><pre><code>这个过程主要是将sticky广播增加到list，并放入mStickyBroadcasts里面。

if (sticky) &#123;
    if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,
            callingPid, callingUid)
            != PackageManager.PERMISSION_GRANTED) &#123;
        throw new SecurityException(&quot;&quot;);
    &#125;
    if (requiredPermissions != null &amp;&amp; requiredPermissions.length &gt; 0) &#123;
        return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
    &#125;

    if (intent.getComponent() != null) &#123;
       //当sticky广播发送给指定组件，则throw Exception
    &#125;
    if (userId != UserHandle.USER_ALL) &#123;
       //当非USER_ALL广播跟USER_ALL广播出现冲突,则throw Exception
    &#125;

    ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt; stickies = mStickyBroadcasts.get(userId);
    if (stickies == null) &#123;
        stickies = new ArrayMap&lt;&gt;();
        mStickyBroadcasts.put(userId, stickies);
    &#125;
    ArrayList&lt;Intent&gt; list = stickies.get(intent.getAction());
    if (list == null) &#123;
        list = new ArrayList&lt;&gt;();
        stickies.put(intent.getAction(), list);
    &#125;
    final int stickiesCount = list.size();
    int i;
    for (i = 0; i &lt; stickiesCount; i++) &#123;
        if (intent.filterEquals(list.get(i))) &#123;
            //替换已存在的sticky intent
            list.set(i, new Intent(intent));
            break;
        &#125;
    &#125;
    //新的intent追加到list
    if (i &gt;= stickiesCount) &#123;
        list.add(new Intent(intent));
    &#125;
&#125;
</code></pre>
<h1 id="step5：查询receivers和registeredReceivers"><a href="#step5：查询receivers和registeredReceivers" class="headerlink" title="step5：查询receivers和registeredReceivers"></a>step5：查询receivers和registeredReceivers</h1><p>receivers：记录着匹配当前intent的所有静态注册广播接收者；<br>registeredReceivers：记录着匹配当前的所有动态注册的广播接收者。<br>其中，mReceiverResolver是AMS的成员变量，记录着已注册的广播接收者的resolver.</p>
<pre><code>int[] users;
if (userId == UserHandle.USER_ALL) &#123;
    users = mStartedUserArray; //广播给所有已启动用户
&#125; else &#123;
    users = new int[] &#123;userId&#125;; //广播给指定用户
&#125;

List receivers = null;
List&lt;BroadcastFilter&gt; registeredReceivers = null;
//找出所有能接收该广播的receivers
if ((intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) &#123;
    //根据intent查找相应的receivers,查询静态注册的广播
    receivers = collectReceiverComponents(intent, resolvedType, callingUid, users);
&#125;
if (intent.getComponent() == null) &#123;
    if (userId == UserHandle.USER_ALL &amp;&amp; callingUid == Process.SHELL_UID) &#123;
        UserManagerService ums = getUserManagerLocked();
        for (int i = 0; i &lt; users.length; i++) &#123;
            //shell用户是否开启允许debug功能
            if (ums.hasUserRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES, users[i])) &#123;
                continue;
            &#125;
            // 查询动态注册的广播
            List&lt;BroadcastFilter&gt; registeredReceiversForUser =
                    mReceiverResolver.queryIntent(intent,
                            resolvedType, false, users[i]);
            if (registeredReceivers == null) &#123;
                registeredReceivers = registeredReceiversForUser;
            &#125; else if (registeredReceiversForUser != null) &#123;
                registeredReceivers.addAll(registeredReceiversForUser);
            &#125;
        &#125;
    &#125; else &#123;
        // 查询动态注册的广播
        registeredReceivers = mReceiverResolver.queryIntent(intent,
                resolvedType, false, userId);
    &#125;
&#125;

AMS.collectReceiverComponents：

private List&lt;ResolveInfo&gt; collectReceiverComponents(Intent intent, String resolvedType,
    int callingUid, int[] users) &#123;
List&lt;ResolveInfo&gt; receivers = null;
for (int user : users) &#123;
    //调用PKMS.queryIntentReceivers，可获取AndroidManifest.xml声明的接收者信息
    List&lt;ResolveInfo&gt; newReceivers = AppGlobals.getPackageManager()
            .queryIntentReceivers(intent, resolvedType, STOCK_PM_FLAGS, user);
    if (receivers == null) &#123;
        receivers = newReceivers;
    &#125; else if (newReceivers != null) &#123;
        ...
        //将所用户的receiver整合到receivers
    &#125;
 &#125;
return receivers;
&#125;
</code></pre>
<h1 id="step6：处理并行广播"><a href="#step6：处理并行广播" class="headerlink" title="step6：处理并行广播"></a>step6：处理并行广播</h1><p>广播队列中有一个成员变量mParallelBroadcasts，类型为ArrayList，记录着所有的并行广播。</p>
<pre><code>//用于标识是否需要用新intent替换旧的intent。
final boolean replacePending = (intent.getFlags()&amp;Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
//处理并行广播
int NR = registeredReceivers != null ? registeredReceivers.size() : 0;
if (!ordered &amp;&amp; NR &gt; 0) &#123;
    final BroadcastQueue queue = broadcastQueueForIntent(intent);
    //创建BroadcastRecord对象
    BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp,
            callerPackage, callingPid, callingUid, resolvedType, requiredPermissions,
            appOp, brOptions, registeredReceivers, resultTo, resultCode, resultData,
            resultExtras, ordered, sticky, false, userId);

    final boolean replaced = replacePending &amp;&amp; queue.replaceParallelBroadcastLocked(r);
    if (!replaced) &#123;
        //将BroadcastRecord加入到并行广播队列
        queue.enqueueParallelBroadcastLocked(r);
        //处理广播【见小节4.1】
        queue.scheduleBroadcastsLocked();
    &#125;
    registeredReceivers = null;
    NR = 0;
&#125;
</code></pre>
<h1 id="step7：合并registeredReceivers到receivers"><a href="#step7：合并registeredReceivers到receivers" class="headerlink" title="step7：合并registeredReceivers到receivers"></a>step7：合并registeredReceivers到receivers</h1><pre><code>int ir = 0;
if (receivers != null) &#123;
    //防止应用监听该广播，在安装时直接运行。
    String skipPackages[] = null;
    if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction())
            || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction())
            || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) &#123;
        Uri data = intent.getData();
        if (data != null) &#123;
            String pkgName = data.getSchemeSpecificPart();
            if (pkgName != null) &#123;
                skipPackages = new String[] &#123; pkgName &#125;;
            &#125;
        &#125;
    &#125; else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) &#123;
        skipPackages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
    &#125;

    //将skipPackages相关的广播接收者从receivers列表中移除
    if (skipPackages != null &amp;&amp; (skipPackages.length &gt; 0)) &#123;
        for (String skipPackage : skipPackages) &#123;
            if (skipPackage != null) &#123;
                int NT = receivers.size();
                for (int it=0; it&lt;NT; it++) &#123; ResolveInfo curt = (ResolveInfo)receivers.get(it); if (curt.activityInfo.packageName.equals(skipPackage)) &#123; receivers.remove(it); it--; NT--; &#125; &#125; &#125; &#125; &#125; //前面part6有一个处理动态广播的过程，处理完后再执行将动态注册的registeredReceivers合并到receivers int NT = receivers != null ? receivers.size() : 0; int it = 0; ResolveInfo curt = null; BroadcastFilter curr = null; while (it &lt; NT &amp;&amp; ir &lt; NR) &#123; if (curt == null) &#123; curt = (ResolveInfo)receivers.get(it); &#125; if (curr == null) &#123; curr = registeredReceivers.get(ir); &#125; if (curr.getPriority()&gt;= curt.priority) &#123;
            receivers.add(it, curr);
            ir++;
            curr = null;
            it++;
            NT++;
        &#125; else &#123;
            it++;
            curt = null;
        &#125;
    &#125;
&#125;
while (ir &lt; NR) &#123;
    if (receivers == null) &#123;
        receivers = new ArrayList();
    &#125;
    receivers.add(registeredReceivers.get(ir));
    ir++;
&#125;
</code></pre>
<h1 id="step8-处理串行广播"><a href="#step8-处理串行广播" class="headerlink" title="step8: 处理串行广播"></a>step8: 处理串行广播</h1><p>广播队列中有一个成员变量mOrderedBroadcasts，类型为ArrayList，记录着所有的有序广播。</p>
<pre><code>    if ((receivers != null &amp;&amp; receivers.size() &gt; 0)
        || resultTo != null) &#123;
    BroadcastQueue queue = broadcastQueueForIntent(intent);
    //创建BroadcastRecord
    BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp,
            callerPackage, callingPid, callingUid, resolvedType,
            requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode,
            resultData, resultExtras, ordered, sticky, false, userId);

    boolean replaced = replacePending &amp;&amp; queue.replaceOrderedBroadcastLocked(r);
    if (!replaced) &#123;
        //将BroadcastRecord加入到有序广播队列
        queue.enqueueOrderedBroadcastLocked(r);
        //处理广播【见小节4.1】
        queue.scheduleBroadcastsLocked();
    &#125;
&#125;
</code></pre>
<h1 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h1><pre><code>注册广播的小节[2.4]阶段, 会处理Sticky广播;
发送广播的[step 6]阶段, 会处理并行广播;
发送广播的[step 8]阶段, 会处理串行广播;
</code></pre>
<p>上述3个处理过程都是通过调用scheduleBroadcastsLocked()方法来完成的,接下来再来看看这个方法.</p>
<h1 id="四、-处理广播"><a href="#四、-处理广播" class="headerlink" title="四、 处理广播"></a>四、 处理广播</h1><p>在发送广播过程中会执行scheduleBroadcastsLocked方法来处理相关的广播</p>
<pre><code>base/services/core/java/com/android/server/am/BroadcastQueue
</code></pre>
<h1 id="4-1-scheduleBroadcastsLocked"><a href="#4-1-scheduleBroadcastsLocked" class="headerlink" title="4.1 scheduleBroadcastsLocked"></a>4.1 scheduleBroadcastsLocked</h1><pre><code>public void scheduleBroadcastsLocked() &#123;
        if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, &quot;Schedule broadcasts [&quot;
                + mQueueName + &quot;]: current=&quot;
                + mBroadcastsScheduled);

        if (mBroadcastsScheduled) &#123;
            return;
        &#125;
        mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this));
        mBroadcastsScheduled = true;
    &#125;
</code></pre>
<h1 id="4-2-handleMessage"><a href="#4-2-handleMessage" class="headerlink" title="4.2 handleMessage"></a>4.2 handleMessage</h1><p>调用到processNextBroadcast</p>
<pre><code>private final class BroadcastHandler extends Handler &#123;
    public BroadcastHandler(Looper looper) &#123;
        super(looper, null, true);
    &#125;

    @Override
    public void handleMessage(Message msg) &#123;
        switch (msg.what) &#123;
            case BROADCAST_INTENT_MSG: &#123;
                if (DEBUG_BROADCAST) Slog.v(
                        TAG_BROADCAST, &quot;Received BROADCAST_INTENT_MSG&quot;);
                processNextBroadcast(true);
            &#125; break;
            ...
            &#125;
</code></pre>
<h1 id="4-3-processNextBroadcast"><a href="#4-3-processNextBroadcast" class="headerlink" title="4.3 processNextBroadcast"></a>4.3 processNextBroadcast</h1><p>此处mService为AMS，整个流程还是比较长的，全程持有AMS锁，所以广播效率低的情况下，直接会严重影响这个手机的性能与流畅度，这里应该考虑细化同步锁的粒度。</p>
<pre><code>final void processNextBroadcast(boolean fromMsg) &#123;
synchronized(mService) &#123;
    //step1: 处理并行广播
    //step2: 处理当前有序广播
    //step3: 获取下条有序广播
    //step4: 处理下条有序广播
    &#125;
&#125;
</code></pre>
<h1 id="step1-处理并行广播"><a href="#step1-处理并行广播" class="headerlink" title="step1: 处理并行广播"></a>step1: 处理并行广播</h1><pre><code>BroadcastRecord r;
mService.updateCpuStats(); //更新CPU统计信息
if (fromMsg)  mBroadcastsScheduled = false;

while (mParallelBroadcasts.size() &gt; 0) &#123;
    r = mParallelBroadcasts.remove(0);
    r.dispatchTime = SystemClock.uptimeMillis();
    r.dispatchClockTime = System.currentTimeMillis();
    final int N = r.receivers.size();
    for (int i=0; i&lt;N; i++) &#123; Object target = r.receivers.get(i); //分发广播给已注册的receiver 【见小节4.3】 deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, false); &#125; addBroadcastToHistoryLocked(r);//将广播添加历史统计 &#125; # step2: 处理当前有序广播 if (mPendingBroadcast != null) &#123; boolean isDead; synchronized (mService.mPidsSelfLocked) &#123; //从mPidsSelfLocked获取正在处理该广播进程，判断该进程是否死亡 ProcessRecord proc = mService.mPidsSelfLocked.get(mPendingBroadcast.curApp.pid); isDead = proc == null || proc.crashing; &#125; if (!isDead) &#123; //正在处理广播的进程保持活跃状态，则继续等待其执行完成 return; &#125; else &#123; mPendingBroadcast.state = BroadcastRecord.IDLE; mPendingBroadcast.nextReceiver = mPendingBroadcastRecvIndex; mPendingBroadcast = null; &#125; &#125; boolean looped = false; do &#123; if (mOrderedBroadcasts.size() == 0) &#123; //所有串行广播处理完成，则调度执行gc mService.scheduleAppGcsLocked(); if (looped) &#123; mService.updateOomAdjLocked(); &#125; return; &#125; r = mOrderedBroadcasts.get(0); boolean forceReceive = false; //获取所有该广播所有的接收者 int numReceivers = (r.receivers != null) ? r.receivers.size() : 0; if (mService.mProcessesReady &amp;&amp; r.dispatchTime&gt; 0) &#123;
        long now = SystemClock.uptimeMillis();
        if ((numReceivers &gt; 0) &amp;&amp;
                (now &gt; r.dispatchTime + (2*mTimeoutPeriod*numReceivers))) &#123;
            //当广播处理时间超时，则强制结束这条广播
            broadcastTimeoutLocked(false);
            forceReceive = true;
            r.state = BroadcastRecord.IDLE;
        &#125;
    &#125;

    if (r.state != BroadcastRecord.IDLE) &#123;
        return;
    &#125;

    if (r.receivers == null || r.nextReceiver &gt;= numReceivers
            || r.resultAbort || forceReceive) &#123;
        if (r.resultTo != null) &#123;
            //处理广播消息消息，调用到onReceive()
            performReceiveLocked(r.callerApp, r.resultTo,
                new Intent(r.intent), r.resultCode,
                r.resultData, r.resultExtras, false, false, r.userId);
            r.resultTo = null;
        &#125;
        //取消BROADCAST_TIMEOUT_MSG消息
        cancelBroadcastTimeoutLocked();

        addBroadcastToHistoryLocked(r);
        mOrderedBroadcasts.remove(0);
        r = null;
        looped = true;
        continue;
    &#125;
&#125; while (r == null);
</code></pre>
<h1 id="step3-获取下条有序广播"><a href="#step3-获取下条有序广播" class="headerlink" title="step3: 获取下条有序广播"></a>step3: 获取下条有序广播</h1><p>mTimeoutPeriod，对于前台广播则为10s，对于后台广播则为60s。广播超时为2<em>mTimeoutPeriod</em>numReceivers，接收者个数numReceivers越多则广播超时总时长越大。</p>
<pre><code>//获取下一个receiver的index
int recIdx = r.nextReceiver++;

r.receiverTime = SystemClock.uptimeMillis();
if (recIdx == 0) &#123;
    r.dispatchTime = r.receiverTime;
    r.dispatchClockTime = System.currentTimeMillis();
&#125;
if (!mPendingBroadcastTimeoutMessage) &#123;
    long timeoutTime = r.receiverTime + mTimeoutPeriod;
    //设置广播超时时间，发送BROADCAST_TIMEOUT_MSG
    setBroadcastTimeoutLocked(timeoutTime);
&#125;

final BroadcastOptions brOptions = r.options;
//获取下一个广播接收者
final Object nextReceiver = r.receivers.get(recIdx);

if (nextReceiver instanceof BroadcastFilter) &#123;
    //对于动态注册的广播接收者，deliverToRegisteredReceiverLocked处理广播
    BroadcastFilter filter = (BroadcastFilter)nextReceiver;
    deliverToRegisteredReceiverLocked(r, filter, r.ordered);
    if (r.receiver == null || !r.ordered) &#123;
        r.state = BroadcastRecord.IDLE;
        scheduleBroadcastsLocked();
    &#125; else &#123;
        ...
    &#125;
    return;
&#125;

//对于静态注册的广播接收者
ResolveInfo info = (ResolveInfo)nextReceiver;
ComponentName component = new ComponentName(
        info.activityInfo.applicationInfo.packageName,
        info.activityInfo.name);
...
//执行各种权限检测，此处省略，当权限不满足时skip=true

if (skip) &#123;
    r.receiver = null;
    r.curFilter = null;
    r.state = BroadcastRecord.IDLE;
    scheduleBroadcastsLocked();
    return;
&#125;

r.state = BroadcastRecord.APP_RECEIVE;
String targetProcess = info.activityInfo.processName;
r.curComponent = component;
final int receiverUid = info.activityInfo.applicationInfo.uid;
if (r.callingUid != Process.SYSTEM_UID &amp;&amp; isSingleton
        &amp;&amp; mService.isValidSingletonCall(r.callingUid, receiverUid)) &#123;
    info.activityInfo = mService.getActivityInfoForUser(info.activityInfo, 0);
&#125;
r.curReceiver = info.activityInfo;
...

//Broadcast正在执行中，stopped状态设置成false
AppGlobals.getPackageManager().setPackageStoppedState(
        r.curComponent.getPackageName(), false, UserHandle.getUserId(r.callingUid));
</code></pre>
<h1 id="step4-处理下条有序广播"><a href="#step4-处理下条有序广播" class="headerlink" title="step4: 处理下条有序广播"></a>step4: 处理下条有序广播</h1><p>如果是动态广播接收者，则调用deliverToRegisteredReceiverLocked处理；<br>如果是静态广播接收者，且对应进程已经创建，则调用processCurBroadcastLocked处理；<br>如果是静态广播接收者，且对应进程尚未创建，则调用startProcessLocked创建进程。</p>
<pre><code>//该receiver所对应的进程已经运行，则直接处理
    ProcessRecord app = mService.getProcessRecordLocked(targetProcess,
            info.activityInfo.applicationInfo.uid, false);
    if (app != null &amp;&amp; app.thread != null) &#123;
        try &#123;
            app.addPackage(info.activityInfo.packageName,
                    info.activityInfo.applicationInfo.versionCode, mService.mProcessStats);
            processCurBroadcastLocked(r, app);
            return;
        &#125; catch (RemoteException e) &#123;
        &#125; catch (RuntimeException e) &#123;
            finishReceiverLocked(r, r.resultCode, r.resultData, r.resultExtras, r.resultAbort, false);
            scheduleBroadcastsLocked();
            r.state = BroadcastRecord.IDLE; //启动receiver失败则重置状态
            return;
        &#125;
    &#125;
    
    //该receiver所对应的进程尚未启动，则创建该进程
    if ((r.curApp=mService.startProcessLocked(targetProcess,
            info.activityInfo.applicationInfo, true,
            r.intent.getFlags() | Intent.FLAG_FROM_BACKGROUND,
            &quot;broadcast&quot;, r.curComponent,
            (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_BOOT_UPGRADE) != 0, false, false))
                    == null) &#123;
        //创建失败，则结束该receiver
        finishReceiverLocked(r, r.resultCode, r.resultData,
                r.resultExtras, r.resultAbort, false);
        scheduleBroadcastsLocked();
        r.state = BroadcastRecord.IDLE;
        return;
    &#125;
    mPendingBroadcast = r;
    mPendingBroadcastRecvIndex = recIdx;
</code></pre>
<h1 id="4-3-deliverToRegisteredReceiverLocked"><a href="#4-3-deliverToRegisteredReceiverLocked" class="headerlink" title="4.3 deliverToRegisteredReceiverLocked"></a>4.3 deliverToRegisteredReceiverLocked</h1><pre><code>private void deliverToRegisteredReceiverLocked(BroadcastRecord r,
        BroadcastFilter filter, boolean ordered) &#123;
        ...
        //检查发送者是否有BroadcastFilter所需权限
        //以及接收者是否有发送者所需的权限等等
        //当权限不满足要求，则skip=true。
    
        if (!skip) &#123;
            //并行广播ordered = false，只有串行广播才进入该分支
            if (ordered) &#123;
                r.receiver = filter.receiverList.receiver.asBinder();
                r.curFilter = filter;
                filter.receiverList.curBroadcast = r;
                r.state = BroadcastRecord.CALL_IN_RECEIVE;
                if (filter.receiverList.app != null) &#123;
                    r.curApp = filter.receiverList.app;
                    filter.receiverList.app.curReceiver = r;
                    mService.updateOomAdjLocked(r.curApp);
                &#125;
            &#125;
            // 处理广播【见小节4.4】
            performReceiveLocked(filter.receiverList.app, filter.receiverList.receiver,
                    new Intent(r.intent), r.resultCode, r.resultData,
                    r.resultExtras, r.ordered, r.initialSticky, r.userId);
            if (ordered) &#123;
                r.state = BroadcastRecord.CALL_DONE_RECEIVE;
            &#125;
            ...
        &#125;
    &#125;
</code></pre>
<h1 id="4-4-performReceiveLocked"><a href="#4-4-performReceiveLocked" class="headerlink" title="4.4 performReceiveLocked"></a>4.4 performReceiveLocked</h1><pre><code>private static void performReceiveLocked(ProcessRecord app, IIntentReceiver receiver,
    Intent intent, int resultCode, String data, Bundle extras,
    boolean ordered, boolean sticky, int sendingUser) throws RemoteException &#123;
//通过binder异步机制，向receiver发送intent
if (app != null) &#123;
    if (app.thread != null) &#123;
        //调用ApplicationThreadProxy类对应的方法 【4.5】
        app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode,
                data, extras, ordered, sticky, sendingUser, app.repProcState);
    &#125; else &#123;
        //应用进程死亡，则Recevier并不存在
        throw new RemoteException(&quot;app.thread must not be null&quot;);
    &#125;
&#125; else &#123;
    //调用者进程为空，则执行该分支
    receiver.performReceive(intent, resultCode, data, extras, ordered,
            sticky, sendingUser);
&#125;
</code></pre>
<p>}</p>
<h1 id="4-5-ATP-scheduleRegisteredReceiver"><a href="#4-5-ATP-scheduleRegisteredReceiver" class="headerlink" title="4.5 ATP.scheduleRegisteredReceiver"></a>4.5 ATP.scheduleRegisteredReceiver</h1><p>ATP位于system_server进程，是Binder Bp端通过Binder驱动向Binder Bn端发送消息, ATP所对应的Bn端位于发送广播调用端所在进程的ApplicationThread，即进入AT.scheduleRegisteredReceiver， 接下来说明该方</p>
<pre><code>public void scheduleRegisteredReceiver(IIntentReceiver receiver, Intent intent,
        int resultCode, String dataStr, Bundle extras, boolean ordered,
        boolean sticky, int sendingUser, int processState) throws RemoteException &#123;
    Parcel data = Parcel.obtain();
    data.writeInterfaceToken(IApplicationThread.descriptor);
    data.writeStrongBinder(receiver.asBinder());
    intent.writeToParcel(data, 0);
    data.writeInt(resultCode);
    data.writeString(dataStr);
    data.writeBundle(extras);
    data.writeInt(ordered ? 1 : 0);
    data.writeInt(sticky ? 1 : 0);
    data.writeInt(sendingUser);
    data.writeInt(processState);

    //command=SCHEDULE_REGISTERED_RECEIVER_TRANSACTION
    mRemote.transact(SCHEDULE_REGISTERED_RECEIVER_TRANSACTION, data, null,
            IBinder.FLAG_ONEWAY);
    data.recycle();
&#125;
</code></pre>
<h1 id="4-6-scheduleRegisteredReceiver"><a href="#4-6-scheduleRegisteredReceiver" class="headerlink" title="4.6 scheduleRegisteredReceiver"></a>4.6 scheduleRegisteredReceiver</h1><p>IPC过程 最终调用到ActivityThread.scheduleRegisteredReceiver,此处receiver是注册广播时创建的，见小节[2.3]，可知该receiver=LoadedApk.ReceiverDispatcher.InnerReceiver。</p>
<pre><code>public void scheduleRegisteredReceiver(IIntentReceiver receiver, Intent intent,
        int resultCode, String dataStr, Bundle extras, boolean ordered,
        boolean sticky, int sendingUser, int processState) throws RemoteException &#123;
    //更新虚拟机进程状态
    updateProcessState(processState, false);
    //【见小节4.7】
    receiver.performReceive(intent, resultCode, dataStr, extras, ordered,
            sticky, sendingUser);
&#125;
</code></pre>
<h1 id="4-7-InnerReceiver-performReceive"><a href="#4-7-InnerReceiver-performReceive" class="headerlink" title="4.7 InnerReceiver.performReceive"></a>4.7 InnerReceiver.performReceive</h1><pre><code>base/core/java/android/app/LoadedApk.java
public void performReceive(Intent intent, int resultCode, String data,
        Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123;
    LoadedApk.ReceiverDispatcher rd = mDispatcher.get();
    if (rd != null) &#123;
        //【4.8】
        rd.performReceive(intent, resultCode, data, extras, ordered, sticky, sendingUser);
    &#125; else &#123;
       ...
    &#125;
&#125;
</code></pre>
<h1 id="4-8-ReceiverDispatcher-performReceive"><a href="#4-8-ReceiverDispatcher-performReceive" class="headerlink" title="4.8 ReceiverDispatcher.performReceive"></a>4.8 ReceiverDispatcher.performReceive</h1><p>其中Args继承于BroadcastReceiver.PendingResult，实现了接口Runnable。这里mActivityThread.post(args) 消息机制，关于Handler消息机制，见Android消息机制1-Handler(Java层)，把消息放入MessageQueue，再调用Args的run()方法。</p>
<pre><code>public void performReceive(Intent intent, int resultCode, String data,
        Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123;
    Args args = new Args(intent, resultCode, data, extras, ordered,
            sticky, sendingUser);
    //通过handler消息机制发送args.
    if (!mActivityThread.post(args)) &#123;
        if (mRegistered &amp;&amp; ordered) &#123;
            IActivityManager mgr = ActivityManagerNative.getDefault();
            args.sendFinished(mgr);
        &#125;
    &#125;
&#125;
</code></pre>
<h1 id="4-9-Args-run"><a href="#4-9-Args-run" class="headerlink" title="4.9 Args.run"></a>4.9 Args.run</h1><p>最终调用BroadcastReceiver具体实现类的onReceive()方法，至此广播的处理过程结束,后续是AMS的一些处理过程</p>
<pre><code>public final class LoadedApk &#123;
  static final class ReceiverDispatcher &#123;
    final class Args extends BroadcastReceiver.PendingResult implements Runnable &#123;
        public void run() &#123;
            final BroadcastReceiver receiver = mReceiver;
            final boolean ordered = mOrdered;

            final IActivityManager mgr = ActivityManagerNative.getDefault();
            final Intent intent = mCurIntent;
            mCurIntent = null;

            if (receiver == null || mForgotten) &#123;
                if (mRegistered &amp;&amp; ordered) &#123;
                    sendFinished(mgr);
                &#125;
                return;
            &#125;

            try &#123;
                //获取mReceiver的类加载器
                ClassLoader cl =  mReceiver.getClass().getClassLoader();
                intent.setExtrasClassLoader(cl);
                setExtrasClassLoader(cl);
                receiver.setPendingResult(this);
                //回调广播onReceive方法
                receiver.onReceive(mContext, intent);
            &#125; catch (Exception e) &#123;
                ...
            &#125;
            //调用到BroadcastReceiver.finishReceiver
            if (receiver.getPendingResult() != null) &#123;
                finish();
            &#125;
        &#125;
      &#125;
    &#125;
</code></pre>
<p>​        </p>
<h1 id="4-10-PendingResult-finish"><a href="#4-10-PendingResult-finish" class="headerlink" title="4.10 PendingResult.finish"></a>4.10 PendingResult.finish</h1><p>此处AMP.finishReceiver，经过binder调用，进入AMS.finishReceiver方法,</p>
<pre><code>base/core/java/android/content/BroadcastReceiver.java

public final void finish() &#123;
    final IActivityManager mgr = ActivityManagerNative.getDefault();
    sendFinished(mgr);
    ...
&#125;

public void sendFinished(IActivityManager am) &#123;
    synchronized (this) &#123;
        try &#123;
            if (mResultExtras != null) &#123;
                mResultExtras.setAllowFds(false);
            &#125;
            if (mOrderedHint) &#123;
                //串行广播
                am.finishReceiver(mToken, mResultCode, mResultData, mResultExtras,
                        mAbortBroadcast, mFlags);
            &#125; else &#123;
                //并行广播
                am.finishReceiver(mToken, 0, null, null, false, mFlags);
            &#125;
        &#125; catch (RemoteException ex) &#123;
        &#125;
    &#125;
&#125;
</code></pre>
<h1 id="4-11-AMS-finishReceiver"><a href="#4-11-AMS-finishReceiver" class="headerlink" title="4.11 AMS.finishReceiver"></a>4.11 AMS.finishReceiver</h1><pre><code>public void finishReceiver(IBinder who, int resultCode, String resultData,
        Bundle resultExtras, boolean resultAbort, int flags) &#123;
    ...
    final long origId = Binder.clearCallingIdentity();
    try &#123;
        boolean doNext = false;
        BroadcastRecord r;

        synchronized(this) &#123;
            BroadcastQueue queue = (flags &amp; Intent.FLAG_RECEIVER_FOREGROUND) != 0
                    ? mFgBroadcastQueue : mBgBroadcastQueue;
            r = queue.getMatchingOrderedReceiver(who);
            if (r != null) &#123;
                doNext = r.queue.finishReceiverLocked(r, resultCode,
                    resultData, resultExtras, resultAbort, true);
            &#125;
        &#125;

        if (doNext) &#123;
            //处理下一条广播
            r.queue.processNextBroadcast(false);
        &#125;
        trimApplications();
    &#125; finally &#123;
        Binder.restoreCallingIdentity(origId);
    &#125;
&#125;
</code></pre>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/02/24/Notes/Android/IPC/2.%20IPC%E7%9A%84%E6%96%B9%E5%BC%8F/" rel="prev" title="">
      <i class="fa fa-chevron-left"></i> 
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/02/24/Notes/Android/Framework/FrameWork_07_SharePreference%20%E6%80%BB%E7%BB%93/" rel="next" title="FrameWork_08_SharedPreferences">
      FrameWork_08_SharedPreferences <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">一、概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%B9%BF%E6%92%AD%E7%9A%84%E6%B3%A8%E5%86%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">二、广播的注册过程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-1-registerReceiver-BroadcastReceiver-receiver-IntentFilter-filter"><span class="nav-number">3.</span> <span class="nav-text">2.1 registerReceiver(BroadcastReceiver receiver, IntentFilter filter)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-2-ContextWrapper-registerReceiver-receiver-filter"><span class="nav-number">4.</span> <span class="nav-text">2.2 ContextWrapper.registerReceiver(receiver,filter)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-3-ContextImpl-registerReceiver-receiver-filter"><span class="nav-number">5.</span> <span class="nav-text">2.3 ContextImpl.registerReceiver(receiver,filter)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#step1%EF%BC%9A-rd-%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="nav-number">6.</span> <span class="nav-text">step1： rd 的创建过程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-4-%E5%9C%A8AMS%E4%B8%AD%E6%B3%A8%E5%86%8C"><span class="nav-number">7.</span> <span class="nav-text">2.4 在AMS中注册</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">8.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-1-sendBroadcast-intent"><span class="nav-number">9.</span> <span class="nav-text">3.1 sendBroadcast(intent)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-2-ContextWrapper-sendBroadcast-intent"><span class="nav-number">10.</span> <span class="nav-text">3.2 ContextWrapper.sendBroadcast(intent)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-3-ContextImpl-sendBroadcast"><span class="nav-number">11.</span> <span class="nav-text">3.3 ContextImpl.sendBroadcast</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-4-ActivityManagerProxy-broadcastIntent"><span class="nav-number">12.</span> <span class="nav-text">3.4 ActivityManagerProxy.broadcastIntent</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-5-ActivityManagerService-broadcastIntent"><span class="nav-number">13.</span> <span class="nav-text">3.5 ActivityManagerService.broadcastIntent</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-6-ActivityManagerService-broadcastIntentLocked-%E5%88%86%E8%A7%A3%E4%B8%BA8%E4%B8%AA%E6%AD%A5%E9%AA%A4%E8%A7%A3%E6%9E%90"><span class="nav-number">14.</span> <span class="nav-text">3.6 ActivityManagerService.broadcastIntentLocked 分解为8个步骤解析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#step1-%E8%AE%BE%E7%BD%AE%E5%B9%BF%E6%92%ADflag"><span class="nav-number">15.</span> <span class="nav-text">step1: 设置广播flag</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#step2-%E5%B9%BF%E6%92%AD%E6%9D%83%E9%99%90%E9%AA%8C%E8%AF%81"><span class="nav-number">16.</span> <span class="nav-text">step2: 广播权限验证</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#step3-%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E5%B9%BF%E6%92%AD"><span class="nav-number">17.</span> <span class="nav-text">step3: 处理系统相关广播</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#step4%EF%BC%9A%E5%A2%9E%E5%8A%A0sticky%E5%B9%BF%E6%92%AD"><span class="nav-number">18.</span> <span class="nav-text">step4：增加sticky广播</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#step5%EF%BC%9A%E6%9F%A5%E8%AF%A2receivers%E5%92%8CregisteredReceivers"><span class="nav-number">19.</span> <span class="nav-text">step5：查询receivers和registeredReceivers</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#step6%EF%BC%9A%E5%A4%84%E7%90%86%E5%B9%B6%E8%A1%8C%E5%B9%BF%E6%92%AD"><span class="nav-number">20.</span> <span class="nav-text">step6：处理并行广播</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#step7%EF%BC%9A%E5%90%88%E5%B9%B6registeredReceivers%E5%88%B0receivers"><span class="nav-number">21.</span> <span class="nav-text">step7：合并registeredReceivers到receivers</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#step8-%E5%A4%84%E7%90%86%E4%B8%B2%E8%A1%8C%E5%B9%BF%E6%92%AD"><span class="nav-number">22.</span> <span class="nav-text">step8: 处理串行广播</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93%EF%BC%9A"><span class="nav-number">23.</span> <span class="nav-text">小结：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81-%E5%A4%84%E7%90%86%E5%B9%BF%E6%92%AD"><span class="nav-number">24.</span> <span class="nav-text">四、 处理广播</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-1-scheduleBroadcastsLocked"><span class="nav-number">25.</span> <span class="nav-text">4.1 scheduleBroadcastsLocked</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-2-handleMessage"><span class="nav-number">26.</span> <span class="nav-text">4.2 handleMessage</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-3-processNextBroadcast"><span class="nav-number">27.</span> <span class="nav-text">4.3 processNextBroadcast</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#step1-%E5%A4%84%E7%90%86%E5%B9%B6%E8%A1%8C%E5%B9%BF%E6%92%AD"><span class="nav-number">28.</span> <span class="nav-text">step1: 处理并行广播</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#step3-%E8%8E%B7%E5%8F%96%E4%B8%8B%E6%9D%A1%E6%9C%89%E5%BA%8F%E5%B9%BF%E6%92%AD"><span class="nav-number">29.</span> <span class="nav-text">step3: 获取下条有序广播</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#step4-%E5%A4%84%E7%90%86%E4%B8%8B%E6%9D%A1%E6%9C%89%E5%BA%8F%E5%B9%BF%E6%92%AD"><span class="nav-number">30.</span> <span class="nav-text">step4: 处理下条有序广播</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-3-deliverToRegisteredReceiverLocked"><span class="nav-number">31.</span> <span class="nav-text">4.3 deliverToRegisteredReceiverLocked</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-4-performReceiveLocked"><span class="nav-number">32.</span> <span class="nav-text">4.4 performReceiveLocked</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-5-ATP-scheduleRegisteredReceiver"><span class="nav-number">33.</span> <span class="nav-text">4.5 ATP.scheduleRegisteredReceiver</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-6-scheduleRegisteredReceiver"><span class="nav-number">34.</span> <span class="nav-text">4.6 scheduleRegisteredReceiver</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-7-InnerReceiver-performReceive"><span class="nav-number">35.</span> <span class="nav-text">4.7 InnerReceiver.performReceive</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-8-ReceiverDispatcher-performReceive"><span class="nav-number">36.</span> <span class="nav-text">4.8 ReceiverDispatcher.performReceive</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-9-Args-run"><span class="nav-number">37.</span> <span class="nav-text">4.9 Args.run</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-10-PendingResult-finish"><span class="nav-number">38.</span> <span class="nav-text">4.10 PendingResult.finish</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-11-AMS-finishReceiver"><span class="nav-number">39.</span> <span class="nav-text">4.11 AMS.finishReceiver</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="sven"
      src="/images/sven.jpeg">
  <p class="site-author-name" itemprop="name">sven</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhaoxiaowen-sven" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhaoxiaowen-sven" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhaoxiaowen-sven@gmail.com" title="E-Mail → mailto:zhaoxiaowen-sven@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sven</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
